<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c72{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Courier New";font-style:normal}.c11{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Arial";font-style:normal}.c39{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.8pt;font-family:"Arial";font-style:italic}.c61{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:16.6pt;font-family:"Arial";font-style:normal}.c88{margin-left:-28.1pt;padding-top:6pt;text-indent:37.9pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-14pt}.c48{margin-left:-28.1pt;padding-top:3.8pt;text-indent:37pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-14pt}.c47{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:19.9pt;font-family:"Arial";font-style:normal}.c143{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Courier New";font-style:normal}.c26{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5pt;font-family:"Courier New";font-style:normal}.c10{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Courier New";font-style:normal}.c34{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:6.5pt;font-family:"Arial";font-style:normal}.c55{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:9.6pt;font-family:"Arial";font-style:italic}.c106{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:5.8pt;font-family:"Arial";font-style:italic}.c7{margin-left:-19pt;padding-top:5.8pt;text-indent:28.9pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-24pt}.c24{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.3pt;font-family:"Arial";font-style:normal}.c75{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Courier New";font-style:normal}.c43{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c92{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.2pt;font-family:"Arial";font-style:normal}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Arial";font-style:normal}.c15{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:7pt;font-family:"Arial";font-style:normal}.c83{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:9.6pt;font-family:"Arial";font-style:italic}.c124{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:17.9pt;font-family:"Arial";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Arial";font-style:normal}.c104{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:9.8pt;font-family:"Courier New";font-style:normal}.c91{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.9pt;font-family:"Courier New";font-style:normal}.c19{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.9pt;font-family:"Courier New";font-style:normal}.c81{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10.1pt;font-family:"Courier New";font-style:normal}.c40{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11.5pt;font-family:"Arial";font-style:normal}.c101{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.9pt;font-family:"Arial";font-style:normal}.c25{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10pt;font-family:"Arial";font-style:normal}.c9{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:11.5pt;font-family:"Arial";font-style:normal}.c27{margin-left:-28.1pt;padding-top:1.4pt;text-indent:37pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-14pt}.c8{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.9pt;font-family:"Arial";font-style:normal}.c90{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.2pt;font-family:"Arial";font-style:normal}.c150{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:9.8pt;font-family:"Courier New";font-style:normal}.c17{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Courier New";font-style:normal}.c60{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Arial";font-style:normal}.c111{margin-left:-28.1pt;padding-top:8.4pt;text-indent:37.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.6pt}.c74{color:#000000;font-weight:700;text-decoration:none;vertical-align:sub;font-size:9.6pt;font-family:"Arial";font-style:italic}.c68{margin-left:-28.1pt;padding-top:9.4pt;text-indent:37.9pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-14pt}.c44{margin-left:-28.1pt;padding-top:6.2pt;text-indent:37pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-14pt}.c42{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10.5pt;font-family:"Arial";font-style:normal}.c87{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10.1pt;font-family:"Courier New";font-style:normal}.c59{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10pt;font-family:"Arial";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:7.5pt;font-family:"Arial";font-style:normal}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Arial";font-style:normal}.c57{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:6.9pt;font-family:"Arial";font-style:normal}.c45{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c144{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10.1pt;font-family:"Arial";font-style:normal}.c100{margin-left:-19pt;padding-top:6.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-23pt}.c58{margin-left:218.2pt;padding-top:574.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-36.1pt}.c30{margin-left:-14.9pt;padding-top:7.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-14pt}.c65{margin-left:-14.9pt;padding-top:6.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-14pt}.c54{margin-left:-19pt;padding-top:3.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-23pt}.c53{margin-left:-23.5pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-14pt}.c154{margin-left:-19pt;padding-top:7.9pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-23.5pt}.c114{margin-left:218.2pt;padding-top:35pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-36.1pt}.c137{margin-left:-28.1pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-7.3pt}.c133{margin-left:-23.5pt;padding-top:16.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-6.1pt}.c41{margin-left:-16.4pt;padding-top:7.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:23.8pt}.c94{margin-left:-15pt;padding-top:19.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-18.7pt}.c135{margin-left:218.2pt;padding-top:31.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-36.1pt}.c116{margin-left:-19pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-21.8pt}.c82{margin-left:-28.1pt;padding-top:11.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:80.1pt}.c77{margin-left:-14.9pt;padding-top:7.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-14pt}.c36{margin-left:-215.6pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:354.7pt}.c46{margin-left:-19pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-22.1pt}.c37{margin-left:-14.9pt;padding-top:7.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-14pt}.c113{margin-left:-27.6pt;padding-top:4.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:9.5pt}.c33{margin-left:-19pt;padding-top:13pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-23pt}.c105{margin-left:-19pt;padding-top:94.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:64.8pt}.c142{margin-left:-19pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-22.6pt}.c31{margin-left:-19pt;padding-top:0.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-22.8pt}.c16{margin-left:-215.6pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:294pt}.c128{margin-left:-16.4pt;padding-top:7.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:136.1pt}.c96{margin-left:-19pt;padding-top:8.9pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-23pt}.c102{margin-left:-19pt;padding-top:12pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-23pt}.c62{margin-left:6.2pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:174.4pt}.c51{margin-left:-28.1pt;padding-top:16.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-13.8pt}.c38{margin-left:-0.3pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-21.8pt}.c56{margin-left:7.6pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:150.7pt}.c132{margin-left:-28.1pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-8.7pt}.c3{margin-left:7.6pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:151.9pt}.c93{margin-left:218.2pt;padding-top:29.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-36.1pt}.c155{margin-left:-28.1pt;padding-top:9.4pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-18.1pt}.c50{margin-left:-28.1pt;padding-top:175.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-24.1pt}.c76{margin-left:-19pt;padding-top:5.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-23pt}.c18{margin-left:-19pt;padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-23pt}.c141{padding-top:5pt;text-indent:37.9pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c148{padding-top:3.4pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c134{padding-top:3.8pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c127{padding-top:4.1pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c146{padding-top:16.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c139{padding-top:22.3pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c110{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c118{padding-top:11pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c63{padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c20{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c147{padding-top:7.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c123{padding-top:10.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c79{padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c112{padding-top:10.8pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c21{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c152{padding-top:11.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c103{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c64{margin-left:-28.1pt;text-indent:37pt;margin-right:-14pt}.c49{margin-left:-19pt;margin-right:-29.3pt}.c23{margin-left:7.6pt;margin-right:157.9pt}.c149{margin-left:7.6pt;margin-right:162.7pt}.c145{margin-left:57pt;margin-right:116.6pt}.c120{margin-left:-23.5pt;margin-right:1.1pt}.c97{margin-left:68.3pt;margin-right:116.6pt}.c109{margin-left:-19pt;margin-right:-19.7pt}.c71{margin-left:179.9pt;margin-right:3.6pt}.c66{margin-left:-23.5pt;margin-right:-9.2pt}.c121{margin-left:-215.6pt;margin-right:334.6pt}.c98{margin-left:-19pt;margin-right:-25.4pt}.c95{margin-left:-19pt;margin-right:-12pt}.c151{margin-left:-21.4pt;margin-right:-7pt}.c108{margin-left:-19pt;margin-right:-23pt}.c131{margin-left:7.6pt;margin-right:155pt}.c67{margin-left:-19pt;margin-right:-20.6pt}.c70{margin-left:-19pt;margin-right:-22.3pt}.c122{margin-left:-23.5pt;margin-right:-12.6pt}.c29{margin-left:169.8pt;margin-right:3.8pt}.c153{margin-left:-19pt;margin-right:-19.2pt}.c107{margin-left:-215.6pt;margin-right:374.9pt}.c73{margin-left:-215.6pt;margin-right:354.7pt}.c156{margin-left:-23.5pt;margin-right:-13.8pt}.c138{margin-left:-23.5pt;margin-right:-1.8pt}.c69{margin-left:4.1pt;margin-right:172.2pt}.c86{margin-left:-215.6pt;margin-right:269.8pt}.c12{margin-left:165.8pt;margin-right:3.8pt}.c117{margin-left:-215.6pt;margin-right:382.3pt}.c126{margin-left:-19pt;margin-right:-19pt}.c129{margin-left:4.3pt;margin-right:169.6pt}.c99{margin-left:-28.1pt;margin-right:-14pt}.c125{margin-left:-9.4pt;margin-right:-12.1pt}.c136{margin-left:-215.6pt;margin-right:395.3pt}.c80{margin-left:-19pt;margin-right:-28.1pt}.c115{margin-left:-215.6pt;margin-right:314.4pt}.c14{margin-left:61.4pt;margin-right:116.6pt}.c140{margin-left:7.6pt;margin-right:156pt}.c52{margin-left:7.6pt;margin-right:156.7pt}.c13{margin-left:95.4pt;margin-right:78.2pt}.c119{margin-left:-19pt;margin-right:-22.8pt}.c78{margin-left:135.8pt;margin-right:42.2pt}.c89{margin-left:6.2pt;margin-right:174.4pt}.c84{margin-left:-19pt;margin-right:-24pt}.c35{margin-left:91.4pt;margin-right:78.2pt}.c130{margin-left:-28.1pt;margin-right:116.6pt}.c28{margin-left:129.8pt;margin-right:42.2pt}.c85{margin-left:107.9pt;margin-right:78pt}.c32{text-indent:28.9pt}.c22{text-indent:27.9pt}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:24pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:14pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c103"><p class="c110"><span class="c124">SIEF: Efficiently Answering Distance Queries for Failure Prone Graphs </span></p><p class="c0"><span class="c43">Yongrui Qin </span><span class="c61">School of Computer Science The University of Adelaide Adelaide, </span><span class="c47">yongrui.qin@adelaide. </span><span class="c61">SA 5005, Australia </span><span class="c47">edu.au </span></p><p class="c0"><span class="c43">Quan Z. Sheng </span><span class="c61">School of Computer Science The University of Adelaide </span><span class="c47">michael.sheng@adelaide. </span><span class="c61">Adelaide, SA 5005, Australia </span><span class="c47">edu.au </span></p><p class="c0"><span class="c43">Wei Emma Zhang </span><span class="c61">School of Computer Science The University of Adelaide </span><span class="c47">wei.zhang01@adelaide. </span><span class="c61">Adelaide, SA 5005, Australia </span><span class="c47">edu.au </span></p><p class="c0"><span class="c43">ABSTRACT </span><span class="c6">Shortest path computation is one of the most fundamental operations for managing and analyzing graphs. A number of methods have been proposed to answer shortest path dis- tance queries on static graphs. Unfortunately, there is lit- tle work on answering distance queries on dynamic graphs, particularly graphs with edge failures. Today&rsquo;s real-world graphs, such as the social network graphs and web graphs, are evolving all the time and link failures occur due to var- ious factors, such as people stopping following others on Twitter or web links becoming invalid. Therefore, it is of great importance to handle distance queries on these failure- prone graphs. This is not only a problem far more difficult than that of static graphs but also important for processing distance queries on evolving or unstable networks. In this paper, we focus on the problem of computing the shortest path distance on graphs subject to edge failures. We pro- pose SIEF, a S </span></p><p class="c21"><span class="c6">ailures on a graph, which is based on distance labeling. Together with the original index created for the original graph, SIEF can support distance queries with edge failures efficiently. By exploiting properties of distance labeling on static graphs, we are able to compute very compact distance labeling for all singe-edge failure cases on dynamic graphs. We exten- sively evaluate our algorithms using six real-world graphs and confirm the effectiveness and efficiency of our approach. </span></p><p class="c0"><span class="c43">Categories and Subject Descriptors </span><span class="c6">E.1 [Data]: Data Structures&mdash;Graphs and networks; H.2.8 [Database management]: Database Applications&mdash;Graph Indexing and Querying </span><span class="c43">General Terms </span><span class="c6">Algorithms, Experimentation, Performance </span><span class="c43">Keywords </span><span class="c6">Shortest paths, distance query, 2-hop labeling, edge failure </span></p><p class="c21"><span class="c6">c&#8413;</span><span class="c4">2015, Copyright is with the authors. Published in Proc. 18th Inter- national Conference on Extending Database Technology (EDBT), March 23-27, 2015, Brussels, Belgium: ISBN 978-3-89318-067-7, on OpenPro- ceedings.org. Distribution of this paper is permitted under the terms of the Creative Commons license CC-by-nc-nd 4.0 </span></p><p class="c0"><span class="c6">upplemental I </span></p><p class="c0"><span class="c6">ndex for E </span></p><p class="c0"><span class="c6">dge F </span></p><p class="c0"><span class="c59">145 10.5441/002/edbt.2015.14 </span></p><p class="c0"><span class="c43">1. INTRODUCTION </span></p><p class="c21"><span class="c6">Recent years have witnessed the fast emergence of massive graph data in many application domains, such as the World Wide Web, linked data technology, online social networks, and Web of Things [21, 19, 22, 25]. In a graph, one of the most fundamental challenges centers on the efficient compu- tation of the shortest path or distance between any given pair of vertices. For instance, distances or the numbers of links between web pages on a web graph can be considered a robust measure of web page relevancy, especially in rele- vance feedback analysis in web search [21]. In RDF graphs of linked data, the shortest path distance from one entity to another is important for ranking entity relationships and keyword querying [19, 14]. For online social networks, the shortest path distance can be used to measure the closeness centrality between users [22]. </span></p><p class="c21"><span class="c6">A large body of indexing techniques have been recently proposed to process exact shortest path distance queries on graphs [10, 23, 9, 8, 2, 26, 15]. Among them, a signifi- cant portion of indexes are based on 2-hop distance label- ing, which is originally proposed by Cohen et al. [12]. The 2-hop distance labeling techniques pre-compute a label for each vertex so that the shortest path distance between any two vertices can be computed by giving their labels only. These labeling indexes, such as [10, 8, 2, 15], have been proved to be efficient, i.e., being able to answer a distance query within microseconds. </span></p><p class="c21"><span class="c6">Motivation. The above mentioned approaches generally make the assumption that graphs are static. However, in reality, many graphs are subject to edge failures. In this pa- per, we refer to graphs that are not subject to edge failures as stable graphs, i.e., static graphs. Similarly, we refer to graphs that are subject to edge failures as unstable graphs. For example, the emerging social Web of Things calls for graph data management with edge failures because smart things are normally moving and their connectivity could be intermittent, leading to frequent and unpredictable changes in the corresponding graph models [11, 25]. Another exam- ple is web graphs. It is not uncommon that some web links become invalid as the web evolves. All these are examples of unstable graphs, which are common in the real-world, calling for efficient graph computations by considering link failures. We believe that it is imperative to design novel algorithms that can compute shortest path indexes for fast response on distance queries avoiding any failed edge. Some real-world applications/scenarios that require the computa- </span></p><p class="c0"><span class="c6">tion of shortest path distance avoiding a failed edge are de- scribed in the following. </span></p><p class="c21"><span class="c6">SCEnARio 1. The most vital arc problem [17, 6] aims to identify the edge on a given shortest path and the removal of this edge results in the longest replacement path. Here, a replacement path means a shortest path from a source vertex to a destination vertex in a graph that avoids a specified edge. To find the most vital arc in a graph, we need to compute the shortest path distances efficiently when we are given an arc (i.e., an edge) to avoid. </span></p><p class="c21"><span class="c6">SCEnARio 2. In the sensitivity analysis and in many analytical applications of transportation networks, govern- ment agencies need to evaluate different road segments (i.e., to find how much a road segment is worth) through Vickrey pricing [16], such that maintenance budget can be allocated accordingly, or the amount of tolls can be adjusted reason- ably [24]. For example, if tolls are not charged appropriately and avoiding an expensive toll point causes only a small de- tour, then it is more likely that most drivers would take the detour, rather than pay for the toll. </span></p><p class="c21"><span class="c6">SCEnARio 3. In order to develop game-theoretic and price-based mechanisms to share bandwidth and other network resources, a natural economic question is [16]: how much is an edge in a network worth to a user who wants to send data between two nodes along a shortest path? Or in other words, what is the penalty of avoiding an edge in the given network? </span></p><p class="c21"><span class="c6">These application scenarios reveal an urge for handling shortest path computations in a graph with single-edge fail- ures. Here, single-edge failure refers to graph failures with only one failed edge at a time [5]. Note that, other types of edge failure, such as dual-failure in [13], may allow multiple failed edges at a time. But they are considered much harder than single-failure [13]. To shed light on these challenging issues, we focus on single-edge failures in this paper. </span></p><p class="c21"><span class="c6">Contributions. Since 2-hop labeling has shown its power to support instant responses to shortest path distance queries on stable graphs, our work aims at extending this technique to support unstable graphs. Existing shortest path index- ing techniques based on 2-hop labeling can be used to pre- compute the whole shortest path index for a graph. The resulted indexes can normally answer distance queries fast using moderate storage space [2, 15]. However, applying in- dexing techniques designed for static/stable graphs directly to evolving/unstable graphs may lead to inefficiency. When considering every single-edge failure case and constructing a corresponding index for each case, the size of all these indexes will become too big to manage. For instance, a snapshot of the Gnutella peer-to-peer (P2P) file sharing net- work in August 2002 contains more than 6,000 vertices</span><span class="c25">1 </span><span class="c6">and 20,000 edges. Using state-of-the-art method, Pruned Land- mark Labeling (PLL) [2], the index size is slightly more than 5 MB. However, suppose we want to construct such index for each single-edge failure case, the total index size would be more than 5 &times; 20,000 = 10</span><span class="c25">5 </span><span class="c6">MB. </span></p><p class="c21"><span class="c6">To address the deficiency of existing shortest path in- dexing techniques, this paper proposes a generic framework named SIEF, a S </span></p><p class="c0"><span class="c5">1</span><span class="c11">http://snap.stanford.edu/ </span></p><p class="c0"><span class="c6">upplemental I </span></p><p class="c0"><span class="c6">ndex for E </span></p><p class="c0"><span class="c6">dge F </span></p><p class="c0"><span class="c6">ailures on a </span></p><p class="c21"><span class="c6">graph, to construct compact shortest path indexes efficiently for unstable graphs where single-edge failures may exist. As an initial attempt on this challenging issue, we focus on un- weighted, undirected graphs. Similar to other distance la- beling based indexing methods [2, 15], our method can be extended to weighted and/or directed graphs. We highlight our main contributions in the following. </span></p><p class="c21"><span class="c6">&bull; We present the concept of well-ordering 2-hop distance labeling and identify its important properties that can be utilized to design algorithms for shortest path in- dexes on graphs with edge failures. </span></p><p class="c21"><span class="c6">&bull; We analyze shortest path index constructions on graphs with edge failures theoretically. We develop the corre- sponding theorems as well as novel algorithms to en- able constructions of compact indexes for all the single- edge failure cases of the entire graph. By applying our approach to the aforementioned Gnutella P2P dataset, the size of the generated SIEF index together with the original index created for the original graph is merely 14 MB, which is much more compact than 10</span><span class="c25">5 </span><span class="c6">MB by directly using PLL method [2] to construct indexes for each single-edge failure case. </span></p><p class="c21"><span class="c6">&bull; We conduct extensive experiments on six real-world graphs to verify the efficiency and effectiveness of our method. The results show that our method can effi- ciently answer shortest path distance queries avoiding a failed edge with very compact labeling indexes. </span></p><p class="c21"><span class="c6">The rest of this paper is organized as follows. In Section 2, we review the related work. In Section 3, we present some preliminaries on 2-hop distance labeling. We then present the framework and the details of our approach in Section 4. In Section 5, we report the results of an extensive experi- mental study using six graphs from real-world. Finally, we present some concluding remarks in Section 6. </span></p><p class="c0"><span class="c43">2. RELATED WORK </span></p><p class="c0"><span class="c6">In this section, we review the major techniques that are most closely related to our work. </span></p><p class="c0"><span class="c6">Distance labeling has been an active research area in re- cent years. In [10], Cheng and Yu exploit the strongly con- nected components property and graph partitioning to pre- compute 2-hop distance cover. However, the graph parti- tioning process introduces high cost because it has to find vertex separators recursively. Hierarchical hub labeling (HHL) proposed by Abraham et al. [1] is based on the partial order of vertices. Smaller labeling results can be obtained by com- puting labeling for different partial order of vertices. In [18], Jin et al. propose a highway-centric labeling (HCL) that uses a spanning tree as a highway. Based on the highway, a 2-hop labeling is generated for fast distance computation. </span></p><p class="c21"><span class="c6">Very recently, the pruned landmark labeling (PLL) [2] is proposed by Akiba et al. to pre-compute 2-hop distance la- bels for vertices by performing a breadth-first search from every vertex. The key idea is to prune vertices that have obtained correct distance information during breadth-first searches, which helps reduce the search space and sizes of labels. Further, query performance is also improved as the number of label entries per vertex is reduced. IS-Label (or ISL) is developed by Fu et al. in [15] to pre-compute 2-hop </span></p><p class="c0"><span class="c59">146 </span></p><p class="c21"><span class="c6">distance label for large graphs in memory constrained en- vironments. ISL is based on the idea of independent set of vertices in a large graph. By recursively removing an in- dependent set of vertices from the original graph, and by augmenting edges that preserve distance information after the removal of vertices in the independent set, the remaining graph keeps the distance information for all remaining ver- tices in the graph. Apart from the 2-hop distance labeling technique, a multi-hop distance labeling approach [8] is also studied, which can reduce the overall size of labels at the cost of increased distance querying time. </span></p><p class="c21"><span class="c6">Tree decomposition approach has been recently investi- gated [23, 4] for answering distance queries on graphs. Wei proposes TEDI [23], which first decomposes a graph into a tree and then constructs a tree decomposition for the graph. A tree decomposition of a graph is a tree with each vertex associated with a set of vertices in the graph, which is also called a bag. The shortest paths among vertices in the same bag are pre-computed and stored in bags. For any given source and target vertices, a bottom-up operation along the tree can be executed to find the shortest path. An improved TEDI index is proposed by Akiba et al. in [4] that exploits a core-fringe structure to improve index performance. How- ever, due to the large size of some bags in the decomposed tree, the construction time for a large graph is costly and thus such indexing approaches cannot scale well. </span></p><p class="c21"><span class="c6">Maintenance of 2-hop reachability labeling is also stud- ied. For example, HOPI (2-HOP-cover-based Index) intro- duces some maintenance techniques for the constructed in- dex. HOPI is developed by Schenkel et al. in [20] and is de- signed to speed up connection or reachability tests in XML documents based on the idea of 2-hop cover. HOPI is able to update indexes for insertions and deletions of nodes, edges or even XML documents. To the best of our knowledge, HOPI is the first work on maintenance of 2-hop labeling. Recently, maintenance of 2-hop labeling for large graphs has also been studied by Bramandia et al. in [7]. However, all these studies focus on reachability queries and are based on 2-hop labeling but not on 2-hop distance labeling. </span></p><p class="c21"><span class="c6">Incremental maintenance of 2-hop distance labeling is also studied very recently by Akiba et al. in [3]. In that work, in- cremental updates (i.e., edge insertions) of 2-hop labeling in- dexes are investigated. To support fast incremental updates, outdated distance labels are kept, which will not affect the distance computation on the updated graphs in the incre- mental case. However, for the decremental case (i.e., edge deletions), this approach will not work, as outdated distance labels must be removed first and then some necessary labels of the 2-hop labeling index need to be recomputed. Hence, their update algorithms cannot be applied on edge deletions (i.e., edge failures), which will be discussed in this paper. </span></p><p class="c0"><span class="c43">3. PRELIMINARIES </span></p><p class="c0"><span class="c43">3.1 2-Hop Distance Labeling </span></p><p class="c21"><span class="c6">The technique of 2-hop cover can be used to solve reacha- bility problems (using reachability labels) and shortest path distance querying problems (using distance labels) on graphs [12]. Since our work focuses on the shortest path distance querying problems, we adopt distance labels with the 2-hop cover technique. We specifically refer to it as 2-hop distance labeling or 2-hop distance cover. </span></p><p class="c21"><span class="c6">Assume a graph G = (V,E), where V is a set of vertices and E is a set of edges. For each vertex v &isin; V , there is a pre- computed label L(v), which is a set of vertex and distance pairs (u,&delta;</span><span class="c5">uv</span><span class="c6">). Here u is a vertex and &delta;</span><span class="c5">uv </span><span class="c6">is the shortest path distance between u and v. Given such a labeling for all vertices in G, denoted by L, for any pair of vertices s and t in G, we have </span></p><p class="c0"><span class="c6">dist(s, t, L) =min{&delta;</span><span class="c5">vs </span><span class="c6">+ &delta;</span><span class="c5">vt</span><span class="c6">|(v,&delta;</span><span class="c5">vs</span><span class="c6">) &isin; L(s) </span></p><p class="c0"><span class="c6">and (v,&delta;</span><span class="c5">vt</span><span class="c6">) &isin; L(t)} </span><span class="c60">(1) </span></p><p class="c0"><span class="c6">If L(s) and L(t) do not share any vertices, we have dist(s, t, L) =&infin;. The distance between any given vertices s and t in G is denoted by d</span><span class="c2">G</span><span class="c11">(s, t). If we have d</span><span class="c2">G</span><span class="c11">(s, t) = dist(s, t, L) for all </span><span class="c6">s and t in G, we call the labeling result L a 2-hop distance cover. </span><span class="c43">3.2 Well-Ordering 2-Hop Distance Labeling </span></p><p class="c21"><span class="c6">For a connected graph G, there exists a sequence of ver- tices &sigma; =&lt; v</span><span class="c5">0</span><span class="c6">,v</span><span class="c5">1</span><span class="c6">,v</span><span class="c5">2</span><span class="c6">,...,v</span><span class="c5">n&minus;1 </span><span class="c6">&gt;. We denote the order of any vertex v</span><span class="c2">i </span><span class="c11">as &sigma;[v</span><span class="c2">i</span><span class="c11">] and we have &sigma;[v</span><span class="c2">i</span><span class="c11">] = i for the above </span><span class="c6">given vertex sequence. Based on this, we can define Well- Ordering 2-Hop Distance Labeling in the following. </span></p><p class="c21"><span class="c6">Definition 1 (Well-Ordering 2-Hop Distance Label- ing). Suppose that (1) each vertex v</span><span class="c2">i </span><span class="c11">has a distance labeling </span><span class="c6">L(v</span><span class="c5">i</span><span class="c6">), and the labeling result L of all vertices forms a 2-hop distance cover of G; (2) for any pair of vertices v</span><span class="c2">i </span><span class="c11">and v</span><span class="c2">j</span><span class="c11">, </span><span class="c6">given that &sigma;[v</span><span class="c2">i</span><span class="c11">] &lt; &sigma;[v</span><span class="c2">j</span><span class="c11">], then v</span><span class="c2">j </span><span class="c11">is not in L(v</span><span class="c2">i</span><span class="c11">) and v</span><span class="c2">i </span><span class="c11">may </span><span class="c6">be in L(v</span><span class="c5">j</span><span class="c6">). We call such a 2-hop distance cover a well- ordering 2-hop distance labeling. Alternatively we say that a 2-hop distance cover has well-ordering property. </span></p><p class="c21"><span class="c6">Similar concepts of well-ordering 2-hop distance labeling also appear in recent research efforts such as HHL [1], PLL [2], and ISL [15]. This confirms that well-ordering 2-hop distance labeling is important in the related research area. More importantly, we will show in this paper that the well- ordering property is also a basic concept in the design of index construction algorithms for distance labeling compu- tation on unstable graphs where edges may fail. </span></p><p class="c0"><span class="c19">25 </span><span class="c104">1</span><span class="c19">7</span><span class="c150">10 </span><span class="c19">6 9</span><span class="c104">8</span><span class="c6">Figure 1: A graph example </span></p><p class="c21"><span class="c6">In a graph containing multiple connected components, suppose its 2-hop labeling is L. For any pair of vertices u and v in different connected components, we can assert that L(u) and L(v) do not share any vertex according to the definition of 2-hop cover. Each connected component has its own vertex orders. For such a graph, we will have separate vertex orders for each connected component. We denote a connected component containing vertex u as C(u). If u and v belong to the same connected component, we have C(u) = C(v). </span></p><p class="c21"><span class="c6">Figure 1 shows an example graph with 11 vertices and Table 1 shows a well-ordering 2-hop distance labeling result L for the graph (L can be constructed by PLL [2] using the same vertex ordering as that specified in the table). In the </span></p><p class="c0"><span class="c59">147 </span></p><p class="c0"><span class="c19">30 </span></p><p class="c0"><span class="c104">4</span></p><p class="c50"><span class="c6">table, the order of vertices is &lt; 0, 1,2,3,4, 5,6,7,8, 9,10 &gt;. Take L(5) as an example to further explain the idea of well- ordering 2-hop distance labeling. L(5) is the label of vertex 5. By the well-ordering property, label entries in L(5) can only contain vertices 0,1, 2,3,4 and 5. Since label entries containing vertices 3 and 4 are redundant in L(5) (this will be explained in more details later in this section), label en- tries in L(5) only contain vertices 0, 1,2 and 5. </span><span class="c43">3.3 Properties of Well-Ordering 2-Hop Distance </span><span class="c47">Labeling </span><span class="c6">Technically speaking, if we index shortest paths for all pairs using a labeling method, we will obtain an index that occupies O(n</span><span class="c25">2</span><span class="c6">) disk space. This index can be considered as a special 2-hop distance labeling. Obviously, the space complexity of this is too high for large graphs. Constructing a minimal 2-hop distance labeling has been proven to be NP- hard [12]. Therefore, an alternative way to obtain labeling results with reduced sizes is by using heuristic methods [10, 8, 2, 15]. Well-ordering 2-hop distance labeling is one of the techniques that can help to design efficient algorithms for constructing shortest path distance labeling indexes and for index maintenance. We identify its useful properties in the following. </span></p><p class="c68"><span class="c6">Lemma 1. Given a well-ordering 2-hop distance labeling L of a connected graph G, suppose u &isin; G and &sigma;[u] is a minimum among all vertices in G, then for any vertex v &isin; G, we must have (u,&delta;</span><span class="c5">uv</span><span class="c6">) &isin; L(v). </span></p><p class="c99 c141"><span class="c6">Proof. It is trivial to prove this when v = u since (u,0) &isin; L(u). We prove the case when v = u by contradiction. Sup- pose there exists a vertex v &isin; G, (u, &delta;</span><span class="c2">uv</span><span class="c11">) /&isin; L(v). By the </span><span class="c6">definition of L, since &sigma;[u] is minimum, L(u) will contain only one label entry (u, 0). Then it is obvious that L(u) and L(v) do not share any vertex, which leads to dist(u, v, L) = &infin;. This implies that u and v belong to different connected com- ponents, which is false. Therefore, the lemma is proved. </span></p><p class="c68"><span class="c6">Lemma 2. Given a well-ordering 2-hop distance labeling L of a connected graph G, suppose s, t, u &isin; G and dist(s, t, L) = dist(s, u, L)+dist(u, t, L), then u must be an internal ver- tex of a certain shortest path between s and t. </span></p><p class="c88"><span class="c6">Proof. Since dist(s, t, L) = dist(s, u, L) + dist(u, t, L), there must exist some shortest path that starts from s, passes u, and ends at t. Hence the lemma is proved. </span></p><p class="c155"><span class="c6">Take vertices 5, 6 and 2 in Figure 1 as an example. From Table 1, we have dist(5,6,L)=3 and dist(5,2,L)+dist(2,6,L) </span></p><p class="c18 c32"><span class="c6">Proof. We prove this by contradiction. Without loss of generality, suppose (u,&delta;</span><span class="c2">us</span><span class="c11">) /&isin; L(s). In order to calculate </span><span class="c6">dist(s, u, L), there must exist some vertex v other than u, where (v,&delta;</span><span class="c2">vs</span><span class="c11">) &isin; L(s), (v,&delta;</span><span class="c2">vu</span><span class="c11">) &isin; L(u) and dist(s, u, L) = </span><span class="c6">&delta;</span><span class="c5">vs </span><span class="c6">+ &delta;</span><span class="c5">vu</span><span class="c6">. According to Lemma 2, v must be an internal vertex of some shortest path between s and u. Hence v must also be an internal vertex of some shortest path be- tween s and t. Meanwhile, by definition, we must have &sigma;[v] &lt; &sigma;[u]. This contradicts our assumption that u has the minimum vertex order among all shortest paths between s and t. Hence, we must have (u,&delta;</span><span class="c2">us</span><span class="c11">) &isin; L(s). Furthermore, u </span><span class="c6">is an internal vertex of some shortest path between s and t, thus dist(s, t, L) = &delta;</span><span class="c2">us</span><span class="c11">+&delta;</span><span class="c2">ut</span><span class="c11">. Hence the lemma is proved. </span></p><p class="c22 c102"><span class="c6">Take vertices 1 and 6 in Figure 1 as an example. Paths p</span><span class="c2">1 </span><span class="c11">=&lt; 1, 0,8,6 &gt;, p</span><span class="c2">2 </span><span class="c11">=&lt; 1,0, 3,6 &gt; and p</span><span class="c2">3 </span><span class="c11">=&lt; 1,4, 8,6 &gt; </span><span class="c6">are all the shortest paths between vertices 1 and 6. Vertex 0 is the one with minimum order along all these paths. From Table 1 we can see that both vertices 1 and 6 contain a label entry (0,&delta;). We can also easily check that dist(1,6,L) = &delta;</span><span class="c2">0,1 </span><span class="c11">+ &delta;</span><span class="c2">0,6 </span><span class="c11">=1+2=3. </span></p><p class="c108 c32 c152"><span class="c6">Lemma 4. Given a well-ordering 2-hop distance labeling L of a connected graph G, suppose &sigma;[u] &lt; &sigma;[v]. If there is a label entry (u, &delta;</span><span class="c2">uv</span><span class="c11">) &isin; L(v), we must have for any label </span><span class="c6">entry (r,&delta;</span><span class="c5">rv</span><span class="c6">) &isin; L(v), (1) &delta;</span><span class="c5">uv </span><span class="c6">&le; &delta;</span><span class="c5">rv </span><span class="c6">+ dist(r, u, L); (2) if &sigma;[r] &lt; &sigma;[u] and &delta;</span><span class="c2">uv </span><span class="c11">= &delta;</span><span class="c2">rv </span><span class="c11">+dist(r, u, L) then (u,&delta;</span><span class="c2">uv</span><span class="c11">) &isin; L(v) </span><span class="c6">is a redundant label entry. </span></p><p class="c154"><span class="c6">Proof. We first prove the first claim that &delta;</span><span class="c5">uv </span><span class="c6">&le; &delta;</span><span class="c5">rv </span><span class="c6">+ dist(r, u, L). By definition and the triangle inequalities we must have &delta;</span><span class="c2">uv </span><span class="c11">= d</span><span class="c2">G</span><span class="c11">(u, v) = dist(u, v, L) &le; &delta;</span><span class="c2">rv</span><span class="c11">+dist(r, u, L). </span><span class="c6">We then prove the second claim. We need to prove that if &delta;</span><span class="c2">uv </span><span class="c11">= &delta;</span><span class="c2">rv </span><span class="c11">+ dist(r, u, L), then for any vertex t, when we </span><span class="c6">calculate dist(v,t,L), (u, &delta;</span><span class="c5">uv</span><span class="c6">) in L(v) is not required. For t, there are three cases: (1) (u,&delta;</span><span class="c2">ut</span><span class="c11">) /&isin; L(t); (2) (u,&delta;</span><span class="c2">ut</span><span class="c11">) &isin; L(t) </span><span class="c6">but &delta;</span><span class="c2">uv </span><span class="c11">+ &delta;</span><span class="c2">ut </span><span class="c11">&gt; dist(v, t, L); (3) (u,&delta;</span><span class="c2">ut</span><span class="c11">) &isin; L(t) and &delta;</span><span class="c2">uv </span><span class="c11">+ </span><span class="c6">&delta;</span><span class="c5">ut </span><span class="c6">= dist(v, t, L). For Case (1) and Case (2), it is trivial since (u, &delta;</span><span class="c2">uv</span><span class="c11">) in L(v) is not required to calculate dist(v,t,L). </span><span class="c6">For Case (3), according to Lemma 2, u is an internal vertex of some shortest paths between v and t. Similarly, since &delta;</span><span class="c2">uv </span><span class="c11">= &delta;</span><span class="c2">rv </span><span class="c11">+ dist(r, u, L), r is an internal vertex of some </span><span class="c6">shortest paths between u and v, which means r is also an internal vertex of some shortest paths between v and t. In such case, we prove in the following that there must exist a vertex s other than u and we have (s,&delta;</span><span class="c2">sv</span><span class="c11">) &isin; L(v), (s,&delta;</span><span class="c2">st</span><span class="c11">) &isin; </span><span class="c6">L(t) where &delta;</span><span class="c5">st </span><span class="c6">+ &delta;</span><span class="c5">sv </span><span class="c6">= dist(v,t,L). </span></p><p class="c22 c31"><span class="c6">Suppose s is the vertex with minimum vertex order among all shortest paths between v and t. According to Lemma 3, we must have (s,&delta;</span><span class="c5">sv</span><span class="c6">) &isin; L(v), (s,&delta;</span><span class="c5">st</span><span class="c6">) &isin; L(t) and &delta;</span><span class="c5">st </span><span class="c6">+ &delta;</span><span class="c2">sv </span><span class="c11">= dist(v, t, L). Since &sigma;[s] &le; &sigma;[r] &lt; &sigma;[u], s is not the </span><span class="c6">same vertex of u. Therefore, (u,&delta;</span><span class="c5">uv</span><span class="c6">) in L(v) is not required to calculate dist(v, t, L). Hence, the second claim is also proved. </span></p><p class="c0 c69"><span class="c4">L(10) </span></p><p class="c0 c86"><span class="c4">(0,4) (2,4) (3,3) (4,4) (6,2) (9,1) (10,0) </span></p><p class="c18 c32"><span class="c6">Proof. We prove this by contradiction. Without loss of generality, suppose (u,&delta;</span><span class="c2">us</span><span class="c11">) /&isin; L(s). In order to calculate </span><span class="c6">dist(s, u, L), there must exist some vertex v other than u, where (v,&delta;</span><span class="c2">vs</span><span class="c11">) &isin; L(s), (v,&delta;</span><span class="c2">vu</span><span class="c11">) &isin; L(u) and dist(s, u, L) = </span><span class="c6">&delta;</span><span class="c5">vs </span><span class="c6">+ &delta;</span><span class="c5">vu</span><span class="c6">. According to Lemma 2, v must be an internal vertex of some shortest path between s and u. Hence v must also be an internal vertex of some shortest path be- tween s and t. Meanwhile, by definition, we must have &sigma;[v] &lt; &sigma;[u]. This contradicts our assumption that u has the minimum vertex order among all shortest paths between s and t. Hence, we must have (u,&delta;</span><span class="c2">us</span><span class="c11">) &isin; L(s). Furthermore, u </span><span class="c6">is an internal vertex of some shortest path between s and t, thus dist(s, t, L) = &delta;</span><span class="c2">us</span><span class="c11">+&delta;</span><span class="c2">ut</span><span class="c11">. Hence the lemma is proved. </span></p><p class="c18 c32"><span class="c6">Proof. We prove this by contradiction. Without loss of generality, suppose (u,&delta;</span><span class="c2">us</span><span class="c11">) /&isin; L(s). In order to calculate </span><span class="c6">dist(s, u, L), there must exist some vertex v other than u, where (v,&delta;</span><span class="c2">vs</span><span class="c11">) &isin; L(s), (v,&delta;</span><span class="c2">vu</span><span class="c11">) &isin; L(u) and dist(s, u, L) = </span><span class="c6">&delta;</span><span class="c5">vs </span><span class="c6">+ &delta;</span><span class="c5">vu</span><span class="c6">. According to Lemma 2, v must be an internal vertex of some shortest path between s and u. Hence v must also be an internal vertex of some shortest path be- tween s and t. Meanwhile, by definition, we must have &sigma;[v] &lt; &sigma;[u]. This contradicts our assumption that u has the minimum vertex order among all shortest paths between s and t. Hence, we must have (u,&delta;</span><span class="c2">us</span><span class="c11">) &isin; L(s). Furthermore, u </span><span class="c6">is an internal vertex of some shortest path between s and t, thus dist(s, t, L) = &delta;</span><span class="c2">us</span><span class="c11">+&delta;</span><span class="c2">ut</span><span class="c11">. Hence the lemma is proved. </span></p><p class="c0 c151"><span class="c6">Table 1: 2-Hop Distance Labeling L for Figure 1 </span></p><p class="c18"><span class="c6">=1+2=3. From Figure 1, we can see that vertex 2 is an in- ternal vertex on some shortest path, denoted as p, between vertex 5 and vertex 6. In this case, we have p =&lt; 5,2,3, 6 &gt;. </span></p><p class="c0 c129"><span class="c4">Label </span></p><p class="c62"><span class="c4">L(0) </span></p><p class="c63 c89"><span class="c4">L(1) </span></p><p class="c62"><span class="c4">L(2) </span></p><p class="c63 c89"><span class="c4">L(3) </span></p><p class="c62"><span class="c4">L(4) </span></p><p class="c62"><span class="c4">L(5) </span></p><p class="c63 c89"><span class="c4">L(6) </span></p><p class="c62"><span class="c4">L(7) </span></p><p class="c63 c89"><span class="c4">L(8) </span></p><p class="c62"><span class="c4">L(9) </span></p><p class="c0 c117"><span class="c4">Entries </span></p><p class="c79 c136"><span class="c4">(0,0) </span></p><p class="c63 c107"><span class="c4">(0,1) (1,0) </span></p><p class="c79 c107"><span class="c4">(0,1) (2,0) </span></p><p class="c63 c73"><span class="c4">(0,1) (2,1) (3,0) </span></p><p class="c36"><span class="c4">(0,1) (1,1) (4,0) </span></p><p class="c79 c121"><span class="c4">(0,2) (1,1) (2,1) (5,0) </span></p><p class="c63 c115"><span class="c4">(0,2) (2,2) (3,1) (4,2) (6,0) </span></p><p class="c79 c115"><span class="c4">(0,2) (2,2) (3,1) (6,1) (7,0) </span></p><p class="c63 c121"><span class="c4">(0,1) (4,1) (6,1) (8,0) </span></p><p class="c16"><span class="c4">(0,3) (2,3) (3,2) (4,3) (6,1) (9,0) </span></p><p class="c58"><span class="c59">148 </span></p><p class="c18"><span class="c6">=1+2=3. From Figure 1, we can see that vertex 2 is an in- ternal vertex on some shortest path, denoted as p, between vertex 5 and vertex 6. In this case, we have p =&lt; 5,2,3, 6 &gt;. </span></p><p class="c18"><span class="c6">=1+2=3. From Figure 1, we can see that vertex 2 is an in- ternal vertex on some shortest path, denoted as p, between vertex 5 and vertex 6. In this case, we have p =&lt; 5,2,3, 6 &gt;. </span></p><p class="c18"><span class="c6">=1+2=3. From Figure 1, we can see that vertex 2 is an in- ternal vertex on some shortest path, denoted as p, between vertex 5 and vertex 6. In this case, we have p =&lt; 5,2,3, 6 &gt;. </span></p><p class="c18"><span class="c6">=1+2=3. From Figure 1, we can see that vertex 2 is an in- ternal vertex on some shortest path, denoted as p, between vertex 5 and vertex 6. In this case, we have p =&lt; 5,2,3, 6 &gt;. </span></p><p class="c32 c33"><span class="c6">Lemma 3. Given a well-ordering 2-hop distance labeling L of a connected graph G, suppose s, t, u &isin; G and u has minimum vertex order &sigma;[u] among all shortest paths between s and t. Then we must have (u,&delta;</span><span class="c5">us</span><span class="c6">) &isin; L(s) and (u,&delta;</span><span class="c5">ut</span><span class="c6">) &isin; L(t) and dist(s, t, L) = &delta;</span><span class="c2">us </span><span class="c11">+ &delta;</span><span class="c2">ut</span><span class="c11">. </span></p><p class="c18 c32"><span class="c6">Lemma 3. Given a well-ordering 2-hop distance labeling L of a connected graph G, suppose s, t, u &isin; G and u has minimum vertex order &sigma;[u] among all shortest paths between s and t. Then we must have (u,&delta;</span><span class="c5">us</span><span class="c6">) &isin; L(s) and (u,&delta;</span><span class="c5">ut</span><span class="c6">) &isin; L(t) and dist(s, t, L) = &delta;</span><span class="c2">us </span><span class="c11">+ &delta;</span><span class="c2">ut</span><span class="c11">. </span></p><p class="c18 c32"><span class="c6">Lemma 3. Given a well-ordering 2-hop distance labeling L of a connected graph G, suppose s, t, u &isin; G and u has minimum vertex order &sigma;[u] among all shortest paths between s and t. Then we must have (u,&delta;</span><span class="c5">us</span><span class="c6">) &isin; L(s) and (u,&delta;</span><span class="c5">ut</span><span class="c6">) &isin; L(t) and dist(s, t, L) = &delta;</span><span class="c2">us </span><span class="c11">+ &delta;</span><span class="c2">ut</span><span class="c11">. </span></p><p class="c18 c32"><span class="c6">Lemma 3. Given a well-ordering 2-hop distance labeling L of a connected graph G, suppose s, t, u &isin; G and u has minimum vertex order &sigma;[u] among all shortest paths between s and t. Then we must have (u,&delta;</span><span class="c5">us</span><span class="c6">) &isin; L(s) and (u,&delta;</span><span class="c5">ut</span><span class="c6">) &isin; L(t) and dist(s, t, L) = &delta;</span><span class="c2">us </span><span class="c11">+ &delta;</span><span class="c2">ut</span><span class="c11">. </span></p><p class="c18 c32"><span class="c6">Lemma 3. Given a well-ordering 2-hop distance labeling L of a connected graph G, suppose s, t, u &isin; G and u has minimum vertex order &sigma;[u] among all shortest paths between s and t. Then we must have (u,&delta;</span><span class="c5">us</span><span class="c6">) &isin; L(s) and (u,&delta;</span><span class="c5">ut</span><span class="c6">) &isin; L(t) and dist(s, t, L) = &delta;</span><span class="c2">us </span><span class="c11">+ &delta;</span><span class="c2">ut</span><span class="c11">. </span></p><p class="c18 c32"><span class="c6">Lemma 3. Given a well-ordering 2-hop distance labeling L of a connected graph G, suppose s, t, u &isin; G and u has minimum vertex order &sigma;[u] among all shortest paths between s and t. Then we must have (u,&delta;</span><span class="c5">us</span><span class="c6">) &isin; L(s) and (u,&delta;</span><span class="c5">ut</span><span class="c6">) &isin; L(t) and dist(s, t, L) = &delta;</span><span class="c2">us </span><span class="c11">+ &delta;</span><span class="c2">ut</span><span class="c11">. </span></p><p class="c18 c32"><span class="c6">Lemma 3. Given a well-ordering 2-hop distance labeling L of a connected graph G, suppose s, t, u &isin; G and u has minimum vertex order &sigma;[u] among all shortest paths between s and t. Then we must have (u,&delta;</span><span class="c5">us</span><span class="c6">) &isin; L(s) and (u,&delta;</span><span class="c5">ut</span><span class="c6">) &isin; L(t) and dist(s, t, L) = &delta;</span><span class="c2">us </span><span class="c11">+ &delta;</span><span class="c2">ut</span><span class="c11">. </span></p><p class="c18 c32"><span class="c6">Lemma 3. Given a well-ordering 2-hop distance labeling L of a connected graph G, suppose s, t, u &isin; G and u has minimum vertex order &sigma;[u] among all shortest paths between s and t. Then we must have (u,&delta;</span><span class="c5">us</span><span class="c6">) &isin; L(s) and (u,&delta;</span><span class="c5">ut</span><span class="c6">) &isin; L(t) and dist(s, t, L) = &delta;</span><span class="c2">us </span><span class="c11">+ &delta;</span><span class="c2">ut</span><span class="c11">. </span></p><p class="c18 c32"><span class="c6">Lemma 3. Given a well-ordering 2-hop distance labeling L of a connected graph G, suppose s, t, u &isin; G and u has minimum vertex order &sigma;[u] among all shortest paths between s and t. Then we must have (u,&delta;</span><span class="c5">us</span><span class="c6">) &isin; L(s) and (u,&delta;</span><span class="c5">ut</span><span class="c6">) &isin; L(t) and dist(s, t, L) = &delta;</span><span class="c2">us </span><span class="c11">+ &delta;</span><span class="c2">ut</span><span class="c11">. </span></p><p class="c18 c32"><span class="c6">Lemma 3. Given a well-ordering 2-hop distance labeling L of a connected graph G, suppose s, t, u &isin; G and u has minimum vertex order &sigma;[u] among all shortest paths between s and t. Then we must have (u,&delta;</span><span class="c5">us</span><span class="c6">) &isin; L(s) and (u,&delta;</span><span class="c5">ut</span><span class="c6">) &isin; L(t) and dist(s, t, L) = &delta;</span><span class="c2">us </span><span class="c11">+ &delta;</span><span class="c2">ut</span><span class="c11">. </span></p><p class="c18 c32"><span class="c6">Lemma 3. Given a well-ordering 2-hop distance labeling L of a connected graph G, suppose s, t, u &isin; G and u has minimum vertex order &sigma;[u] among all shortest paths between s and t. Then we must have (u,&delta;</span><span class="c5">us</span><span class="c6">) &isin; L(s) and (u,&delta;</span><span class="c5">ut</span><span class="c6">) &isin; L(t) and dist(s, t, L) = &delta;</span><span class="c2">us </span><span class="c11">+ &delta;</span><span class="c2">ut</span><span class="c11">. </span></p><p class="c18 c32"><span class="c6">Lemma 3. Given a well-ordering 2-hop distance labeling L of a connected graph G, suppose s, t, u &isin; G and u has minimum vertex order &sigma;[u] among all shortest paths between s and t. Then we must have (u,&delta;</span><span class="c5">us</span><span class="c6">) &isin; L(s) and (u,&delta;</span><span class="c5">ut</span><span class="c6">) &isin; L(t) and dist(s, t, L) = &delta;</span><span class="c2">us </span><span class="c11">+ &delta;</span><span class="c2">ut</span><span class="c11">. </span></p><p class="c18 c32"><span class="c6">Lemma 3. Given a well-ordering 2-hop distance labeling L of a connected graph G, suppose s, t, u &isin; G and u has minimum vertex order &sigma;[u] among all shortest paths between s and t. Then we must have (u,&delta;</span><span class="c5">us</span><span class="c6">) &isin; L(s) and (u,&delta;</span><span class="c5">ut</span><span class="c6">) &isin; L(t) and dist(s, t, L) = &delta;</span><span class="c2">us </span><span class="c11">+ &delta;</span><span class="c2">ut</span><span class="c11">. </span></p><p class="c18 c32"><span class="c6">Lemma 3. Given a well-ordering 2-hop distance labeling L of a connected graph G, suppose s, t, u &isin; G and u has minimum vertex order &sigma;[u] among all shortest paths between s and t. Then we must have (u,&delta;</span><span class="c5">us</span><span class="c6">) &isin; L(s) and (u,&delta;</span><span class="c5">ut</span><span class="c6">) &isin; L(t) and dist(s, t, L) = &delta;</span><span class="c2">us </span><span class="c11">+ &delta;</span><span class="c2">ut</span><span class="c11">. </span></p><p class="c32 c100"><span class="c6">Proof. We prove this by contradiction. Without loss of generality, suppose (u,&delta;</span><span class="c2">us</span><span class="c11">) /&isin; L(s). In order to calculate </span><span class="c6">dist(s, u, L), there must exist some vertex v other than u, where (v,&delta;</span><span class="c2">vs</span><span class="c11">) &isin; L(s), (v,&delta;</span><span class="c2">vu</span><span class="c11">) &isin; L(u) and dist(s, u, L) = </span><span class="c6">&delta;</span><span class="c5">vs </span><span class="c6">+ &delta;</span><span class="c5">vu</span><span class="c6">. According to Lemma 2, v must be an internal vertex of some shortest path between s and u. Hence v must also be an internal vertex of some shortest path be- tween s and t. Meanwhile, by definition, we must have &sigma;[v] &lt; &sigma;[u]. This contradicts our assumption that u has the minimum vertex order among all shortest paths between s and t. Hence, we must have (u,&delta;</span><span class="c2">us</span><span class="c11">) &isin; L(s). Furthermore, u </span><span class="c6">is an internal vertex of some shortest path between s and t, thus dist(s, t, L) = &delta;</span><span class="c2">us</span><span class="c11">+&delta;</span><span class="c2">ut</span><span class="c11">. Hence the lemma is proved. </span></p><p class="c18 c32"><span class="c6">Proof. We prove this by contradiction. Without loss of generality, suppose (u,&delta;</span><span class="c2">us</span><span class="c11">) /&isin; L(s). In order to calculate </span><span class="c6">dist(s, u, L), there must exist some vertex v other than u, where (v,&delta;</span><span class="c2">vs</span><span class="c11">) &isin; L(s), (v,&delta;</span><span class="c2">vu</span><span class="c11">) &isin; L(u) and dist(s, u, L) = </span><span class="c6">&delta;</span><span class="c5">vs </span><span class="c6">+ &delta;</span><span class="c5">vu</span><span class="c6">. According to Lemma 2, v must be an internal vertex of some shortest path between s and u. Hence v must also be an internal vertex of some shortest path be- tween s and t. Meanwhile, by definition, we must have &sigma;[v] &lt; &sigma;[u]. This contradicts our assumption that u has the minimum vertex order among all shortest paths between s and t. Hence, we must have (u,&delta;</span><span class="c2">us</span><span class="c11">) &isin; L(s). Furthermore, u </span><span class="c6">is an internal vertex of some shortest path between s and t, thus dist(s, t, L) = &delta;</span><span class="c2">us</span><span class="c11">+&delta;</span><span class="c2">ut</span><span class="c11">. Hence the lemma is proved. </span></p><p class="c18 c32"><span class="c6">Proof. We prove this by contradiction. Without loss of generality, suppose (u,&delta;</span><span class="c2">us</span><span class="c11">) /&isin; L(s). In order to calculate </span><span class="c6">dist(s, u, L), there must exist some vertex v other than u, where (v,&delta;</span><span class="c2">vs</span><span class="c11">) &isin; L(s), (v,&delta;</span><span class="c2">vu</span><span class="c11">) &isin; L(u) and dist(s, u, L) = </span><span class="c6">&delta;</span><span class="c5">vs </span><span class="c6">+ &delta;</span><span class="c5">vu</span><span class="c6">. According to Lemma 2, v must be an internal vertex of some shortest path between s and u. Hence v must also be an internal vertex of some shortest path be- tween s and t. Meanwhile, by definition, we must have &sigma;[v] &lt; &sigma;[u]. This contradicts our assumption that u has the minimum vertex order among all shortest paths between s and t. Hence, we must have (u,&delta;</span><span class="c2">us</span><span class="c11">) &isin; L(s). Furthermore, u </span><span class="c6">is an internal vertex of some shortest path between s and t, thus dist(s, t, L) = &delta;</span><span class="c2">us</span><span class="c11">+&delta;</span><span class="c2">ut</span><span class="c11">. Hence the lemma is proved. </span></p><p class="c18 c32"><span class="c6">Proof. We prove this by contradiction. Without loss of generality, suppose (u,&delta;</span><span class="c2">us</span><span class="c11">) /&isin; L(s). In order to calculate </span><span class="c6">dist(s, u, L), there must exist some vertex v other than u, where (v,&delta;</span><span class="c2">vs</span><span class="c11">) &isin; L(s), (v,&delta;</span><span class="c2">vu</span><span class="c11">) &isin; L(u) and dist(s, u, L) = </span><span class="c6">&delta;</span><span class="c5">vs </span><span class="c6">+ &delta;</span><span class="c5">vu</span><span class="c6">. According to Lemma 2, v must be an internal vertex of some shortest path between s and u. Hence v must also be an internal vertex of some shortest path be- tween s and t. Meanwhile, by definition, we must have &sigma;[v] &lt; &sigma;[u]. This contradicts our assumption that u has the minimum vertex order among all shortest paths between s and t. Hence, we must have (u,&delta;</span><span class="c2">us</span><span class="c11">) &isin; L(s). Furthermore, u </span><span class="c6">is an internal vertex of some shortest path between s and t, thus dist(s, t, L) = &delta;</span><span class="c2">us</span><span class="c11">+&delta;</span><span class="c2">ut</span><span class="c11">. Hence the lemma is proved. </span></p><p class="c64 c146"><span class="c6">Take label entries of vertex 5 in Table 1 as an example. We have &sigma;(3) &lt; &sigma;(5) and &sigma;(2) &lt; &sigma;(3). We also have &delta;</span><span class="c5">3,5 </span><span class="c6">= 2 = &delta;</span><span class="c2">2,5 </span><span class="c11">+ &delta;</span><span class="c2">2,3</span><span class="c11">. Therefore (3, 2) is a redundant label entry </span><span class="c6">in L(5), which can be removed from L(5). </span></p><p class="c82"><span class="c43">4. THE SIEF APPROACH </span></p><p class="c134 c64"><span class="c6">In this section, we first provide an overview of our SIEF approach. We then analyze the 2-hop distance labeling com- putation on graphs with single-edge failures and introduce a set of algorithms to achieve fast and compact index con- structions. </span><span class="c43">4.1 SIEF Overview </span></p><p class="c64 c127"><span class="c6">After an edge fails on a graph, we observe that distances of a considerable proportion of shortest paths between any pair of vertices remain unchanged. Therefore, to construct a new index for each single-edge failure case, we only need to compute new labels for those vertices with changed shortest path distances due to the edge failure. Overall, our index construction approach can be divided into two main stages. In the first stage, IDENTIFY, we identify affected vertices after an edge fails. In the second stage, RELABEL, we re- label all affected vertices with necessary additional label en- tries for the single-edge failed graph. These new label entries form a new part of the index, which is called a supplemental index. </span></p><p class="c27"><span class="c6">Before the detailed discussions of our algorithms, suppose that the failed edge is (u, v) in G, and the new graph is G</span><span class="c25">&prime;</span><span class="c6">, we introduce a concept for the supplemental index construction: </span></p><p class="c99 c147"><span class="c6">Definition 2 (A</span><span class="c72">ff</span><span class="c6">ected vertices AV</span><span class="c2">(u,v)</span><span class="c11">). For any vertices </span><span class="c6">s and t, if d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(s, t) = d</span><span class="c2">G</span><span class="c11">(s, t), then s &isin; AV</span><span class="c2">(u,v) </span><span class="c6">and t &isin; AV</span><span class="c2">(u,v)</span><span class="c11">. </span></p><p class="c0 c64"><span class="c6">To be specific, AV</span><span class="c2">(u,v) </span><span class="c6">contains all vertices whose distance to some other vertex must have been changed due to the failed edge (u, v). It is quite clear that supplemental indexes should be constructed to maintain all new distances for each single-edge failure case. In other words, supplemental in- dexes are constructed based on all the vertices in AV</span><span class="c2">(u,v)</span><span class="c6">. Further, in order to be compact, the supplemental indexes should only answer distances that cannot be answered by the original index. </span><span class="c43">4.2 Identification of Affected Vertices </span></p><p class="c48"><span class="c6">Before we can start to construct supplemental indexes, we need to identify all the affected vertices in AV</span><span class="c2">(u,v) </span><span class="c11">first. A </span><span class="c6">naive method would be to compare distances for any possible pair of affected vertices in the original graph G and the new graph G</span><span class="c25">&prime; </span><span class="c6">with a failed edge (u, v), but that would be very time consuming as it will need to test distances of O(n</span><span class="c25">2</span><span class="c6">) pairs of vertices. In the following, we will try to identify some important properties for vertices in AV</span><span class="c2">(u,v) </span><span class="c6">for us to identify AV</span><span class="c2">(u,v) </span><span class="c6">more efficiently and accurately. </span></p><p class="c111"><span class="c6">Lemma 5. After removing the failed edge (u, v) from graph G, for any vertex s, t in G</span><span class="c25">&prime;</span><span class="c6">, we must have d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(s, t) &ge; dist(s, t, L).</span><span class="c11">Proof. In the old graph G, there are only two types of </span><span class="c6">shortest paths: (1) shortest paths containing edge (u, v); and (2) shortest paths not containing edge (u, v). For the former, we have d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(s, t) &ge; d</span><span class="c5">G</span><span class="c6">(s, t) = dist(s, t, L). For the latter, we have d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(s, t) = d</span><span class="c2">G</span><span class="c11">(s, t) = dist(s, t, L). Thus the </span><span class="c6">lemma is proved. </span></p><p class="c0 c32 c80"><span class="c6">Lemma 8. After removing the failed edge (u, v), suppose w in G</span><span class="c25">&prime; </span><span class="c6">is an affected vertex, i.e. w &isin; AV</span><span class="c2">(u,v)</span><span class="c6">(u) or w &isin; AV</span><span class="c2">(u,v)</span><span class="c11">(v). Without loss of generality, we assume w &isin; AV</span><span class="c2">(u,v) </span><span class="c11">(u). Then there must exist a certain shortest path between </span><span class="c6">w and v containing edge (u, v) in the original graph, where each internal vertex is an affected vertex in AV</span><span class="c2">(u,v)</span><span class="c11">(u). </span></p><p class="c93"><span class="c59">149 </span></p><p class="c0 c32 c98"><span class="c6">Lemma 6. After removing the failed edge (u, v) from graph G, for any vertex s, t in G</span><span class="c25">&prime;</span><span class="c6">, if d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(s, t) &gt; dist(s, t, L), and suppose a shortest path between s and t in G is &pi;</span><span class="c2">G</span><span class="c11">(s, t), then </span><span class="c6">we must have uv &isin; &pi;</span><span class="c5">G</span><span class="c6">(s, t) or vu &isin; &pi;</span><span class="c5">G</span><span class="c6">(s, t). </span></p><p class="c32 c76"><span class="c6">Proof. This can be proved by contradiction. Suppose we have d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(s, t) &gt; dist(s, t, L) but uv /&isin; &pi;</span><span class="c5">G</span><span class="c6">(s, t) and vu /&isin; &pi;</span><span class="c2">G</span><span class="c11">(s, t), which means edge (u, v) does not appear in &pi;</span><span class="c2">G</span><span class="c11">(s, t). </span><span class="c6">In such case, there must exist a path P</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(s, t) in G</span><span class="c25">&prime; </span><span class="c6">where &pi;</span><span class="c5">G</span><span class="c6">(s, t) = P</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(s, t). This means d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(s, t) must be at most the length of P</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(s, t), i.e., the length of &pi;</span><span class="c2">G</span><span class="c11">(s, t). Thus, we </span><span class="c6">must have d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(s, t) = dist(s, t, L</span><span class="c25">&prime;</span><span class="c6">) &le; d</span><span class="c5">G</span><span class="c6">(s, t). This contra- dicts our assumption d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(s, t) &gt; dist(s, t, L). </span></p><p class="c22 c96"><span class="c6">According to Lemma 6 and the definition of affected ver- tices, if we have d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(s, t) &gt; dist(s, t, L) = d</span><span class="c2">G</span><span class="c11">(s, t), we must </span><span class="c6">have that s, t &isin; AV</span><span class="c2">(u,v)</span><span class="c11">. This further means the shortest </span><span class="c6">path(s) between s and t in the original graph G must con- tain the failed edge (u, v). Then, after edge (u, v) fails, take any one of these shortest paths (if multiple shortest paths exist; if not, we will have one and only one shortest path con- taining (u, v)) as an example, denoted as &pi;</span><span class="c5">G</span><span class="c6">(s, t). Then it is easy to imagine that &pi;</span><span class="c2">G</span><span class="c11">(s, t) will become two segments: one </span><span class="c6">segment ends at u, denoted as Seg</span><span class="c5">u </span><span class="c6">and the other segment ends at v, denoted as Seg</span><span class="c5">v</span><span class="c6">. Without loss of generality, sup- pose s falls on the Seg</span><span class="c2">u </span><span class="c11">and t falls on Seg</span><span class="c2">v</span><span class="c11">. Since Seg</span><span class="c2">u </span><span class="c11">and </span><span class="c6">Seg</span><span class="c5">v </span><span class="c6">must also be shortest paths from s to u and from t to v, respectively, this means we must have d</span><span class="c2">G</span><span class="c11">(s, u) = d</span><span class="c5">&prime;</span><span class="c2">G</span><span class="c6">(s, u) and d</span><span class="c5">G</span><span class="c6">(t, v) = d</span><span class="c25">&prime;</span><span class="c5">G</span><span class="c60">(t, v). But in the meantime, we must have </span><span class="c6">d</span><span class="c2">G</span><span class="c11">(s, v) = d</span><span class="c5">&prime;</span><span class="c2">G</span><span class="c6">(s, v) and d</span><span class="c2">G</span><span class="c11">(t, u) = d</span><span class="c5">&prime;</span><span class="c2">G</span><span class="c6">(t, u) since otherwise we will have d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(s, t) = d</span><span class="c2">G</span><span class="c11">(s, t), which is impossible. Based </span><span class="c6">on this observation, we can see that vertices in AV</span><span class="c2">(u,v) </span><span class="c11">form </span><span class="c6">two disjoint sets: one set is AV</span><span class="c2">(u,v)</span><span class="c6">(u) and the other set is AV</span><span class="c2">(u,v)</span><span class="c11">(v), where for &forall;s &isin; AV</span><span class="c2">(u,v)</span><span class="c11">(u) and &forall;t &isin; AV</span><span class="c2">(u,v)</span><span class="c11">(v), </span><span class="c6">we must have d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(s, t) &gt; d</span><span class="c2">G</span><span class="c11">(s, t), d</span><span class="c2">G</span><span class="c11">(s, u) = d</span><span class="c5">&prime;</span><span class="c2">G</span><span class="c6">(s, u) and d</span><span class="c5">G</span><span class="c6">(t, v) = d</span><span class="c25">&prime;</span><span class="c5">G</span><span class="c60">(t, v). Since (u, v) is the failed edge, obviously, </span><span class="c6">we must have u &isin; AV</span><span class="c2">(u,v)</span><span class="c11">(u) or v &isin; AV</span><span class="c2">(u,v)</span><span class="c11">(v). Further, </span><span class="c6">it should be noted that, &forall;s, t &isin; AV</span><span class="c2">(u,v)</span><span class="c6">(u), we must have d</span><span class="c5">G</span><span class="c6">(s, t) = d</span><span class="c25">&prime;</span><span class="c5">G</span><span class="c60">(s, t). The same conclusion can be made on </span><span class="c6">&forall;s, t &isin; AV</span><span class="c2">(u,v)</span><span class="c6">(v). </span></p><p class="c0 c22 c49"><span class="c6">Next, we are going to show that all vertices s &isin; AV</span><span class="c2">(u,v)</span><span class="c11">(u) </span><span class="c6">form a tree rooted at u and similarly, all vertices t &isin; AV</span><span class="c2">(u,v)</span><span class="c11">(v) </span><span class="c6">also form a tree rooted at v. </span></p><p class="c119 c32 c123"><span class="c6">Lemma 7. After removing the failed edge (u, v), for any vertex w in G</span><span class="c25">&prime;</span><span class="c6">, suppose w is an affected vertex, i.e. w &isin; AV</span><span class="c2">(u,v)</span><span class="c11">(u) or w &isin; AV</span><span class="c2">(u,v)</span><span class="c11">(v). Without loss of generality, </span><span class="c6">we assume w &isin; AV</span><span class="c2">(u,v)</span><span class="c6">(u). Then we must have d</span><span class="c2">G</span><span class="c11">(w, v) = </span><span class="c6">d</span><span class="c5">G</span><span class="c6">(w, u)+1. </span></p><p class="c7"><span class="c6">Proof. Since w &isin; AV</span><span class="c2">(u,v)</span><span class="c6">(u), we must have that d</span><span class="c2">G</span><span class="c11">(w, v) </span><span class="c6">= d</span><span class="c25">&prime;</span><span class="c5">G</span><span class="c60">(w, v), which means that any shortest path between w </span><span class="c6">and v in G, denoted as p</span><span class="c5">wv </span><span class="c6">must contain the failed edge (u, v), which must also be a shortest path between w and v. Hence, there must exist a certain shortest path between w and v containing edge (u, v) in the original graph and we can denote it as p</span><span class="c5">wv </span><span class="c6">= p</span><span class="c5">wu </span><span class="c6">+ (u, v). Hence, we must have d</span><span class="c2">G</span><span class="c11">(w, v) = d</span><span class="c2">G</span><span class="c11">(w, u) + 1. </span></p><p class="c21 c32 c84"><span class="c6">Proof. Since w &isin; AV</span><span class="c2">(u,v)</span><span class="c6">(u), we must have that d</span><span class="c2">G</span><span class="c11">(w, v) </span><span class="c6">= d</span><span class="c25">&prime;</span><span class="c5">G</span><span class="c60">(w, v), which means that any shortest path between w </span><span class="c6">and v in G, denoted as p</span><span class="c5">wv </span><span class="c6">must contain the failed edge (u, v), which must also be a shortest path between w and v. Hence, there must exist a certain shortest path between w and v containing edge (u, v) in the original graph and we can denote it as p</span><span class="c5">wv </span><span class="c6">= p</span><span class="c5">wu </span><span class="c6">+ (u, v). Hence, we must have d</span><span class="c2">G</span><span class="c11">(w, v) = d</span><span class="c2">G</span><span class="c11">(w, u) + 1. </span></p><p class="c0"><span class="c6">Algorithm 1 Identify affected vertices </span></p><p class="c0"><span class="c6">Input: G, (u, v), distance vectors d</span><span class="c2">u</span><span class="c11">,d</span><span class="c2">v</span><span class="c11">,d</span><span class="c5">&prime;</span><span class="c2">u</span><span class="c6">,d</span><span class="c25">&prime;</span><span class="c5">v </span><span class="c11">Output: AV</span><span class="c2">(u,v)</span><span class="c11">(u), AV</span><span class="c2">(u,v)</span><span class="c11">(v) </span></p><p class="c0"><span class="c6">1: Initialize flag m[t] &larr; 0 for any vertex t in G 2: m[u] &larr; 1 3: Q &larr; &empty; 4: Enqueue u into Q 5: while Q is not empty do 6: Dequeue t from Q 7: for all neighbor vertex r of t do 8: if m[r]=0 then 9: if d</span><span class="c2">v</span><span class="c11">[r] = d</span><span class="c2">u</span><span class="c11">[r] + 1 and d</span><span class="c5">&prime;</span><span class="c2">v</span><span class="c6">[r] = d</span><span class="c2">u</span><span class="c11">[r]+1 then </span><span class="c6">10: AV</span><span class="c2">(u,v)</span><span class="c11">(u) &larr; AV</span><span class="c2">(u,v)</span><span class="c11">(u) &cup; {r} </span><span class="c6">11: Enqueue r into Q 12: m[r] &larr; 1 13: Repeat the above steps by mapping u &larr; v and v &larr; u </span></p><p class="c0"><span class="c6">to identify AV</span><span class="c2">(u,v)</span><span class="c11">(v) </span></p><p class="c0"><span class="c75">7</span><span class="c87">210 5 </span><span class="c75">6 91</span><span class="c81">8</span><span class="c75">30 </span></p><p class="c21"><span class="c81">4</span><span class="c75">7</span><span class="c87">10 </span><span class="c75">6 9</span><span class="c81">8</span><span class="c5">AV</span><span class="c34">(0,8)</span><span class="c144">(0)={0, 2} </span><span class="c5">AV</span><span class="c34">(0,8)</span><span class="c144">(8)={8} </span></p><p class="c0"><span class="c5">AV</span><span class="c34">(6,9)</span><span class="c5">(6)={6, 7, 8, 0, 3, 4, 1, 2, 5} AV</span><span class="c34">(6,9)</span><span class="c5">(9)={9, 10} </span></p><p class="c0"><span class="c5">Case (a): The failed edge is (0,8) </span></p><p class="c0"><span class="c5">Case (b): The failed edge is (6,9) </span><span class="c6">Figure 2: A</span><span class="c72">ff</span><span class="c6">ected vertices identification </span></p><p class="c21"><span class="c6">Proof. Since w &isin; AV</span><span class="c2">(u,v)</span><span class="c6">(u), then according to Lemma 7, we must have the fact that any shortest path between w and u, denoted as p</span><span class="c5">wu</span><span class="c6">, plus edge (u, v) in the original graph must be a shortest path between w and v. Then, there must exist a certain shortest path between w and v containing edge (u, v) in the original graph and we can denote it as p</span><span class="c5">wv </span><span class="c6">= p</span><span class="c5">wu </span><span class="c6">+ (u, v). </span></p><p class="c21"><span class="c6">It is clear that the internal vertices of p</span><span class="c5">wv </span><span class="c6">must also be on some shortest path p</span><span class="c2">wu</span><span class="c11">. And all shortest paths from these </span><span class="c6">internal vertices to vertex v must contain edge (u, v), which means, their distances to vertex v must have changed in the new graph G</span><span class="c25">&prime;</span><span class="c6">. Therefore, they must also be affected vertices in AV</span><span class="c2">(u,v)</span><span class="c6">(u) like w. </span></p><p class="c21"><span class="c6">Note that, according to Lemma 8, AV</span><span class="c2">(u,v)</span><span class="c6">(u) and AV</span><span class="c2">(u,v) </span><span class="c11">(v) can be considered as trees rooted at u and v, respectively. </span><span class="c6">Moreover, we must have AV</span><span class="c2">(u,v)</span><span class="c11">(u)</span><span class="c72">&#8898;</span><span class="c11">AV</span><span class="c2">(u,v)</span><span class="c11">(v) = &empty;. This </span><span class="c6">is because otherwise, any vertex r in AV</span><span class="c2">(u,v)</span><span class="c6">(u)</span><span class="c17">&#8898; </span><span class="c6">AV</span><span class="c2">(u,v)</span><span class="c6">(v) must have d</span><span class="c5">G</span><span class="c6">(r, v) = d</span><span class="c5">G</span><span class="c6">(r, u)+1 and d</span><span class="c5">G</span><span class="c6">(r, u) = d</span><span class="c5">G</span><span class="c6">(r, v)+1, which is impossible. Lemma 8 forms the basis of Algorithm 1. Note that, in Algorithm 1, we need to calculate distance vectors d</span><span class="c5">u</span><span class="c6">,d</span><span class="c5">v</span><span class="c6">,d</span><span class="c25">&prime;</span><span class="c5">u </span><span class="c60">and d</span><span class="c25">&prime;</span><span class="c5">v </span><span class="c60">for each single-edge failure case. </span><span class="c6">Here, d</span><span class="c2">u </span><span class="c11">stores distances from all vertices in G to vertex u </span><span class="c6">while d</span><span class="c25">&prime;</span><span class="c5">u </span><span class="c60">stores distances from all vertices in G</span><span class="c25">&prime; </span><span class="c6">to vertex u. Distance vectors d</span><span class="c2">v </span><span class="c11">and d</span><span class="c5">&prime;</span><span class="c2">v </span><span class="c6">are similar. The calculations can be done efficiently using a BFS algorithm. To reduce the calculation cost, we will fix an end point of failed edges, i.e., we will firstly compute affected vertices for all edges attached to u then we move to other vertices for processing the rest single-edge failure cases. </span></p><p class="c21"><span class="c6">Figure 2 shows two examples of identifying affected ver- tices. It uses the same graph in Figure 1. In this figure, the first example is Case (a), where the failed edge is (0,8). </span></p><p class="c0"><span class="c75">2</span><span class="c81">1</span><span class="c75">5 </span></p><p class="c0"><span class="c75">3</span><span class="c81">4</span><span class="c75">0 </span></p><p class="c0"><span class="c6">The second example is Case (b), where the failed edge is (6,9). In Case (a), starting from vertex 0, we identify the affected vertex set rooted at 0 as AV</span><span class="c2">(0,8)</span><span class="c6">(0) = {0,2} since only vertices 0 and 2 have changed their distance to vertex 8. Meanwhile, starting from vertex 8, we identify the af- fected vertex set rooted at 8 as AV</span><span class="c2">(0,8)</span><span class="c11">(8) = {8} since only </span><span class="c6">vertex 8 has changed its distance to vertex 0. Differently, in Case (b), as can be observed in the figure, the original graph will become two connected components rooted at vertices 6 and 9, respectively. In this case, it is obvious that we have AV</span><span class="c2">(6,9)</span><span class="c11">(6) = {6, 7,8,0,3, 4,2,5} and AV</span><span class="c2">(6,9)</span><span class="c11">(9) = {9, 10}. </span><span class="c43">4.3 Relabeling: Supplemental Index Construc- </span><span class="c47">tion </span><span class="c6">After identifying all affected vertices, we can start rela- beling the affected vertices in order for fast computation of shortest path distances on the graph with single-edge fail- ures. Only supplemental indexes will be created, i.e., only changed distance information will be captured in supplemen- tal indexes. All the unchanged distance information will be still computed using the original indexes (such as the dis- tance labeling in Table 1 for the example graph in Figure 1). We develop two relabeling algorithms for the supplemen- tal index construction, namely the BFS AFF algorithm and the BFS ALL algorithm. Detailed descriptions of these two algorithms are presented in the following. </span></p><p class="c0"><span class="c45">4.3.1 BFS AFF algorithm </span></p><p class="c21"><span class="c6">The BFS AFF algorithm relabels affected vertices using the traditional BFS algorithm. The BFS AFF algorithm uses a late label-pruning strategy which can save memory usage during the relabeling process. The detail steps are shown in Algorithm 2. To help understand the main idea of the BFS AFF algorithm, Figure 3 also depicts an example of the supplemental index construction process using the BFS AFF algorithm. </span></p><p class="c21"><span class="c6">The failed edge is (0,8) in this example and there are three steps in Figure 3. Each step relabels one affected vertex. At Step (1), BFS AFF algorithm performs BFS from vertex 0. The number beside each node is the distance from that node to the BFS root, vertex 0. In this step, vertex 8 is the only affected vertex in AV</span><span class="c2">(0,8)</span><span class="c11">(8) that has larger vertex </span><span class="c6">order than vertex 0. Therefore, the BFS process starting from vertex 0 will stop at distance 2 and will not examine vertices 9 and 10. After the BFS process stops, we add a supplemental label entry to the supplemental label of ver- tex 8, resulting in SL</span><span class="c2">(0,8)</span><span class="c11">(8) = {(0, 2)}. At Step (2), BFS </span><span class="c6">process starts from vertex 2. Note that, the distance infor- mation has been discarded at this step. Similarly, vertex 8 is the only affected vertex in AV</span><span class="c2">(0,8)</span><span class="c6">(8) that has larger vertex order than vertex 2. Then the BFS process starting from vertex 2 will stop at distance 3. Then we may want to add another label entry (2,3) into SL</span><span class="c2">(0,8)</span><span class="c6">(8). But based on the original index shown in Table 1 and the current sup- plemental label SL</span><span class="c2">(0,8)</span><span class="c6">(8) = {(0,2)}, we find that (2,3) is a redundant label entry in SL</span><span class="c2">(0,8)</span><span class="c11">(8) = {(0,2)} since the dis- </span><span class="c6">tance between vertex 2 and vertex 8 can be computed based on SL</span><span class="c2">(0,8)</span><span class="c6">(8) = {(0,2)} and the original index in Table 1. We call this the late-pruning strategy. Finally, at Step (3), the BFS process will start from vertex 8. However, since no vertex in AV</span><span class="c2">(0,8)</span><span class="c11">(0) has smaller vertex order than vertex 8, </span><span class="c6">no label entry will be added to the supplemental index at this step. The final supplemental index that is constructed </span></p><p class="c0"><span class="c59">150 </span></p><p class="c0"><span class="c6">Algorithm 2 BFS AFF algorithm </span></p><p class="c0"><span class="c6">Input: G, (u, v), AV</span><span class="c2">(u,v)</span><span class="c6">(u), AV</span><span class="c2">(u,v)</span><span class="c6">(v) Output: The supplemental index SI</span><span class="c2">u </span><span class="c11">and SI</span><span class="c2">v </span><span class="c11">for the edge </span></p><p class="c0"><span class="c6">failure case of (u, v) 1: G</span><span class="c25">&prime; </span><span class="c6">&larr; G &minus; {(u, v)} </span></p><p class="c0"><span class="c6">//Construct SI</span><span class="c5">u </span><span class="c6">for vertices in AV</span><span class="c2">(u,v)</span><span class="c11">(u) </span><span class="c6">2: SI</span><span class="c2">u </span><span class="c11">&larr; &empty; </span><span class="c6">3: for all r &isin; AV</span><span class="c2">(u,v)</span><span class="c6">(u) (in ascending vertex order) do 4: Initialize supplemental label for r: SL &larr; &empty; 5: Start BFS algorithm to compute all the distances from r to any vertices in AV</span><span class="c2">(u,v)</span><span class="c11">(v) that have larger vertex </span><span class="c6">order than &sigma;(r) 6: for all vertex t in AV</span><span class="c2">(u,v)</span><span class="c11">(v) that has &sigma;(t) &gt; &sigma;(r) do </span><span class="c6">7: if (t, d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(t, r)) is not a redundant label entry in SL </span></p><p class="c0"><span class="c6">then 8: SL &larr; SL &cup; (t, d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(t, r)) 9: SI</span><span class="c2">u </span><span class="c11">&larr; SI</span><span class="c2">u </span><span class="c11">&cup; (r,SL) </span></p><p class="c0"><span class="c6">//Construct SI</span><span class="c5">v </span><span class="c6">for vertices in AV</span><span class="c2">(u,v)</span><span class="c11">(v) </span><span class="c6">10: SI</span><span class="c2">v </span><span class="c11">&larr; &empty; </span><span class="c6">11: for all r &isin; AV</span><span class="c2">(u,v)</span><span class="c6">(v) (in ascending vertex order) do 12: Initialize supplemental label for r: SL &larr; &empty; 13: Start BFS algorithm to compute all the distances from r to any vertices in AV</span><span class="c2">(u,v)</span><span class="c11">(u) that have larger vertex </span><span class="c6">order than &sigma;(r) 14: for all vertex t in AV</span><span class="c2">(u,v)</span><span class="c11">(u) that has &sigma;(t) &gt; &sigma;(r) </span></p><p class="c0"><span class="c6">do 15: if (t, d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(t, r)) is not a redundant label entry in SL </span></p><p class="c0"><span class="c6">then 16: SL &larr; SL &cup; (t, d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(t, r)) 17: SI</span><span class="c5">v </span><span class="c6">&larr; SI</span><span class="c5">v </span><span class="c6">&cup; (r,SL) </span></p><p class="c21"><span class="c6">for the failed edge (0, 8) on the graph shown in Figure 1 is shown at Step (3). We will show later in Section 4.4 that such supplemental index is adequate for distance query eval- uation. </span></p><p class="c0"><span class="c45">4.3.2 BFS ALL algorithm </span></p><p class="c21"><span class="c6">The BFS ALL algorithm is very similar to the BFS AFF algorithm. The major diference is that the BFS ALL algo- rithm uses an early label-pruning strategy which consumes more memory during the relabeling process but gains ac- celeration of the relabeling process. The detail steps are shown in Algorithm 3. Figure 4 also depicts an example of the supplemental index construction process using the BFS ALL algorithm. </span></p><p class="c21"><span class="c6">The failed edge is also (0,8) in this example and there are three steps in Figure 4. The main difference between BFS ALL an BFS AFF algorithms is that, in the BFS ALL al- gorithm, the distance information will be kept at each BFS step, using a set of temporary labels stored in TL. This dis- tance information in TL can be used to prune label entries at the later BFS steps of the index construction process for all vertices in the graph and some vertices can be pruned during a BFS process. For example, at Step (2) in Figure 4, the number of vertices we need to visit (the vertices with bold label entries) is only seven, while at Step (2) in Figure 3, that number is 10 (by counting the vertices with dis- tance information). Therefore, three vertices can be pruned at Step (2) in the BFS ALL algorithm. We call this the early-pruning strategy. It is obvious that the BFS ALL al- gorithm introduces more memory usage since BFS ALL has TL while BFS AFF does not. But the benefit of TL is that it </span></p><p class="c0"><span class="c39">1 </span></p><p class="c0"><span class="c39">2</span><span class="c55">1 </span></p><p class="c0"><span class="c83">1</span><span class="c39">01 </span></p><p class="c0"><span class="c39">2 </span><span class="c8">23</span><span class="c39">2</span><span class="c8">5 </span></p><p class="c0"><span class="c8">0 </span></p><p class="c0"><span class="c40">14</span><span class="c55">2 </span></p><p class="c0"><span class="c8">25 </span><span class="c40">1</span><span class="c8">7</span><span class="c9">10 </span><span class="c8">6 9</span><span class="c40">8</span><span class="c8">Step (1): Relabel a </span></p><p class="c0"><span class="c39">(0,2) </span></p><p class="c0"><span class="c39">(2,3) </span></p><p class="c0"><span class="c6">Figure 3: Supplemental index construction: BFS AFF on failed edge (0,8) </span></p><p class="c21"><span class="c6">can prune vertices at an early stage, and as will be shown in Section 5, this can speed up the BFS process greatly. Nev- ertheless, the final supplemental index constructed by the BFS ALL algorithm is the same as that constructed by the BFS AFF algorithm as the construction of SI</span><span class="c5">u </span><span class="c6">and SI</span><span class="c5">v </span><span class="c6">in both algorithms is the same. </span></p><p class="c0"><span class="c43">4.4 Distance Query Evaluation on SIEF </span></p><p class="c20"><span class="c6">For each single-edge failure case, we classify all possible distance queries into different types. Suppose the graph is G, the original labeling index is L, the failed edge is (u, v), the affected vertices are in AV</span><span class="c2">(u,v)</span><span class="c6">(u) and AV</span><span class="c2">(u,v)</span><span class="c6">(v), and the supplemental index SI</span><span class="c2">v</span><span class="c11">). We also denote G</span><span class="c5">&prime; </span><span class="c6">is </span><span class="c11">= </span><span class="c6">SI</span><span class="c2">(u,v) </span><span class="c11">(here, G &minus; {(u, v)}. SI</span><span class="c2">(u,v) </span><span class="c11">= SI</span><span class="c2">u </span><span class="c11">&cup; Given any pair of </span><span class="c6">vertices s, t, we would like to compute the distance between s, t on G</span><span class="c25">&prime;</span><span class="c6">, denoted as d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(s, t). Then we have the following different cases: </span></p><p class="c0"><span class="c6">&bull; Case 1: s /&isin; AV</span><span class="c2">(u,v)</span><span class="c11">(u)&cup;AV</span><span class="c2">(u,v)</span><span class="c11">(v) and t /&isin; AV</span><span class="c2">(u,v)</span><span class="c11">(u)&cup; </span><span class="c6">AV</span><span class="c2">(u,v)</span><span class="c6">(v) </span></p><p class="c21"><span class="c6">&bull; Case 2: s /&isin; AV</span><span class="c2">(u,v)</span><span class="c11">(u)&cup;AV</span><span class="c2">(u,v)</span><span class="c11">(v) and t &isin; AV</span><span class="c2">(u,v)</span><span class="c11">(u)&cup; </span><span class="c6">AV</span><span class="c2">(u,v)</span><span class="c6">(v), or similarly, s &isin; AV</span><span class="c2">(u,v)</span><span class="c6">(u)&cup;AV</span><span class="c2">(u,v)</span><span class="c6">(v) and t /&isin; AV</span><span class="c2">(u,v)</span><span class="c6">(u) &cup; AV</span><span class="c2">(u,v)</span><span class="c6">(v) </span></p><p class="c0"><span class="c59">151 </span></p><p class="c0"><span class="c8">SL</span><span class="c1">(0,8)</span><span class="c8">(8)={ </span><span class="c57">(0,2)</span><span class="c8">} </span></p><p class="c0"><span class="c39">0 1 1 </span></p><p class="c110"><span class="c39">2 </span><span class="c8">37</span><span class="c9">10 </span></p><p class="c110"><span class="c39">1 2</span><span class="c8">0 6 9</span><span class="c39">2 </span><span class="c55">2 </span></p><p class="c0"><span class="c40">48</span><span class="c55">3 </span></p><p class="c0"><span class="c8">Step (2): Relabel a </span></p><p class="c0"><span class="c39">3 </span></p><p class="c0"><span class="c8">25 </span><span class="c40">1</span><span class="c8">SL</span><span class="c1">(0,8)</span><span class="c8">(8)={ </span><span class="c57">(0,2)</span><span class="c8">} </span></p><p class="c0"><span class="c8">37</span><span class="c9">10 </span></p><p class="c0"><span class="c8">0 6 9</span><span class="c40">48</span><span class="c8">SL</span><span class="c1">(0,8)</span><span class="c8">(0)={ } </span></p><p class="c0"><span class="c8">SL</span><span class="c1">(0,8)</span><span class="c8">(2)={ } SL</span><span class="c1">(0,8)</span><span class="c8">(8)={ </span><span class="c57">(0,2)</span><span class="c8">} </span></p><p class="c0"><span class="c8">Step (3): Relabel a </span></p><p class="c0"><span class="c8">ected vertices 0,2 from vertex 8 </span></p><p class="c0"><span class="c8">ected vertex 8 from vertex 0 </span></p><p class="c0"><span class="c8">ected vertex 8 from vertex 2 </span></p><p class="c0"><span class="c6">Algorithm 3 BFS ALL algorithm </span></p><p class="c0"><span class="c6">Input: G, (u, v), AV</span><span class="c2">(u,v)</span><span class="c6">(u), AV</span><span class="c2">(u,v)</span><span class="c6">(v) Output: The supplemental index SI</span><span class="c2">u </span><span class="c11">and SI</span><span class="c2">v </span><span class="c11">for the edge </span></p><p class="c0"><span class="c6">failure case of (u, v) 1: G</span><span class="c25">&prime; </span><span class="c6">&larr; G &minus; {(u, v)} </span></p><p class="c0"><span class="c6">//Construct SI</span><span class="c5">u </span><span class="c6">for vertices in AV</span><span class="c2">(u,v)</span><span class="c11">(u) </span><span class="c6">2: SI</span><span class="c2">u </span><span class="c11">&larr; &empty; </span><span class="c6">3: Initialize temporary labels TL &larr; &empty; 4: for all r &isin; AV</span><span class="c2">(u,v)</span><span class="c11">(u) (in ascending vertex order) do </span><span class="c6">5: Initialize supplemental label for r: SL &larr; &empty; 6: Start BFS algorithm to compute all the distances from r to any vertices in AV</span><span class="c2">(u,v)</span><span class="c6">(v) that have larger vertex order than &sigma;(r) and record all temporary labels for all encountered vertices in TL; during the BFS process, if a new temporary label entry for a vertex w is redun- dant in TL, all neighbor vertices of w can be ignored by BFS 7: for all vertex t in AV</span><span class="c2">(u,v)</span><span class="c11">(v) that has &sigma;(t) &gt; &sigma;(r) and </span><span class="c6">has been searched by the above BFS process do 8: if (t, d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(t, r)) is not a redundant label entry in SL </span></p><p class="c0"><span class="c6">then 9: SL &larr; SL &cup; (t, d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(t, r)) 10: SI</span><span class="c5">u </span><span class="c6">&larr; SI</span><span class="c5">u </span><span class="c6">&cup; (r, SL) </span></p><p class="c0"><span class="c6">//Construct SI</span><span class="c2">v </span><span class="c11">for vertices in AV</span><span class="c2">(u,v)</span><span class="c6">(v) 11: SI</span><span class="c5">v </span><span class="c6">&larr; &empty; 12: Initialize temporary labels TL &larr; &empty; 13: for all r &isin; AV</span><span class="c2">(u,v)</span><span class="c6">(v) (in ascending vertex order) do 14: Start BFS algorithm to compute all the distances from r to any vertices in AV</span><span class="c2">(u,v)</span><span class="c6">(u) that have larger vertex order than &sigma;(r) and record all temporary labels for all encountered vertices in TL; during the BFS pro- cess, if a new temporary label entry for a vertex w is redundant in TL, then all neighbor vertices of w will not be searched by BFS 15: for all vertex t in AV</span><span class="c2">(u,v)</span><span class="c11">(u) that has &sigma;(t) &gt; &sigma;(r) </span></p><p class="c0"><span class="c6">and has been searched by the above BFS process do 16: if (t, d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(t, r)) is not a redundant label entry in SL </span></p><p class="c0"><span class="c6">then 17: SL &larr; SL &cup; (t, d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(t, r)) 18: SI</span><span class="c5">v </span><span class="c6">&larr; SI</span><span class="c5">v </span><span class="c6">&cup; (r,SL) </span></p><p class="c0"><span class="c6">&bull; Case 3: s &isin; AV</span><span class="c2">(u,v)</span><span class="c11">(u) and t &isin; AV</span><span class="c2">(u,v)</span><span class="c11">(u), or similarly, </span><span class="c6">s &isin; AV</span><span class="c2">(u,v)</span><span class="c6">(v) and t &isin; AV</span><span class="c2">(u,v)</span><span class="c6">(v) </span></p><p class="c0"><span class="c6">&bull; Case 4: s &isin; AV</span><span class="c2">(u,v)</span><span class="c6">(u) and t &isin; AV</span><span class="c2">(u,v)</span><span class="c6">(v), or similarly, s &isin; AV</span><span class="c2">(u,v)</span><span class="c11">(v) and t &isin; AV</span><span class="c2">(u,v)</span><span class="c11">(u) </span></p><p class="c0"><span class="c6">Case 1 is trivial and we must have d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(s, t) = d</span><span class="c5">G</span><span class="c6">(s, t) = dist(s, t, L). </span></p><p class="c21"><span class="c6">In Case 2 and in Case 3, according to Lemma 6 and the definition of affected vertices (see analysis in Section 4.2), we must also have d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(s, t) = d</span><span class="c2">G</span><span class="c11">(s, t) = dist(s, t, L). </span></p><p class="c21"><span class="c6">In Case 4, suppose s &isin; AV</span><span class="c2">(u,v)</span><span class="c11">(u) and t &isin; AV</span><span class="c2">(u,v)</span><span class="c11">(v) </span><span class="c6">(the other case can be analyzed in the same way). Obvi- ously, distance between s and t changes to a larger value due to the failed edge. If s and t become disconnected to each other in G</span><span class="c25">&prime;</span><span class="c6">, both will not have labels in SI</span><span class="c2">(u,v)</span><span class="c6">, then we have d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(s, t) = &infin;. If s and t is still connected in G</span><span class="c25">&prime; </span><span class="c6">and without loss of generality, suppose the vertex order is &sigma;(s) &lt; &sigma;(t), then at least vertex t contains supplemental label entries. This is because in both the BFS AFF algo- rithm and the BFS ALL algorithm, the affected vertex with </span></p><p class="c0"><span class="c39">(0,1) </span></p><p class="c0"><span class="c39">(0,2) </span></p><p class="c0"><span class="c39">(0,1) </span></p><p class="c0"><span class="c39">(0,1) </span></p><p class="c0"><span class="c39">(0,1) (0,2)</span><span class="c8">23</span><span class="c55">(0,2) </span><span class="c8">5 </span></p><p class="c0"><span class="c8">0 </span></p><p class="c0"><span class="c40">14</span><span class="c39">(0,2) </span></p><p class="c0"><span class="c8">Step (2): Relabel a</span><span class="c91">ff</span><span class="c8">ected vertex 8 from vertex 2 </span></p><p class="c0"><span class="c8">25 </span><span class="c40">1</span><span class="c8">7</span><span class="c9">10 </span><span class="c39">(0,0) </span><span class="c8">6 9</span><span class="c40">8</span><span class="c8">SL</span><span class="c1">(0,8)</span><span class="c8">(8)={ </span><span class="c57">(0,2)</span><span class="c8">} </span></p><p class="c0"><span class="c8">Step (1): Relabel a</span><span class="c91">ff</span><span class="c8">ected vertex 8 from vertex 0 </span></p><p class="c0"><span class="c39">(0,1) </span></p><p class="c0"><span class="c39">(0,1) (0,2)</span><span class="c106">(2,0) (2,1) (2,2)</span><span class="c39">(0,2) </span><span class="c106">(2,1) </span></p><p class="c0"><span class="c39">(0,1) </span></p><p class="c0"><span class="c55">(0,2) </span><span class="c74">(2,2) (2,3) </span></p><p class="c0"><span class="c39">(0,1) </span></p><p class="c110"><span class="c39">(0,2) </span><span class="c106">(2,3) </span></p><p class="c0"><span class="c6">Figure 4: Supplemental index construction: BFS ALL on failed edge (0,8) </span></p><p class="c21"><span class="c6">minimum vertex order in AV</span><span class="c2">(u,v)</span><span class="c6">(u) (which is at most &sigma;(s)) must produce one supplemental label entry for vertex t in SI</span><span class="c2">(u,v) </span><span class="c6">(see Lemma 3 for related details). For vertex s it- self, if it does not produce any supplemental label entry for vertex t in SI</span><span class="c2">(u,v)</span><span class="c11">, then it must be because the produced </span><span class="c6">label entry is a redundant label. This means, in either case, the label entries of the supplemental label for vertex t in SI</span><span class="c2">(u,v) </span><span class="c6">must already contain adequate distance information for the computation of d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(s, t). For example, to calculate d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(2,8) in Figure 4, SL</span><span class="c2">(0,8)</span><span class="c6">(8) = {(0,2)} combining with L(2) = {(0, 1) (2,0)} in Table 1 is adequate and we can see that d</span><span class="c2">G</span><span class="c26">&prime;</span><span class="c6">(2,8) = 1 + 2 = 3. </span></p><p class="c0"><span class="c43">4.5 Some Remarks </span></p><p class="c0"><span class="c6">Initial Index Construction. Pruned Landmark Labeling (PLL) technique presented in [2] is a state-of-the-art indexing tech- nique for large static graphs. Indexes constructed by PLL [2] already have well-ordering property defined in Section 3. Therefore we use indexes constructed by PLL as the initial indexes for all original graphs in our experiments. Time Complexity. Our algorithms can be directly applied on indexes constructed by PLL. Let w be the tree width [2] of G, n be the number of vertices and m be the number of edges in G. Also let (u, v) be the failed edge. If let p = |AV</span><span class="c2">(u,v)</span><span class="c6">(u)&cup; </span></p><p class="c0"><span class="c59">152 </span></p><p class="c0"><span class="c8">25 </span><span class="c40">1</span><span class="c8">30 </span></p><p class="c110"><span class="c40">4</span><span class="c8">7</span><span class="c9">10 </span><span class="c39">(0,0) </span><span class="c8">6 9</span><span class="c40">8</span><span class="c8">SL</span><span class="c1">(0,8)</span><span class="c8">(8)={ </span><span class="c57">(0,2)</span><span class="c8">} </span></p><p class="c0"><span class="c8">30 </span><span class="c40">4</span><span class="c8">7</span><span class="c9">10 </span><span class="c8">6 9</span><span class="c40">8</span><span class="c8">SL</span><span class="c1">(0,8)</span><span class="c8">(0)={ } </span></p><p class="c0"><span class="c8">SL</span><span class="c1">(0,8)</span><span class="c8">(2)={ } SL</span><span class="c1">(0,8)</span><span class="c8">(8)={ </span><span class="c57">(0,2)</span><span class="c8">} </span></p><p class="c0"><span class="c8">Step (3): Relabel a</span><span class="c91">ff</span><span class="c8">ected vertices 0,2 from vertex 8 </span></p><p class="c51"><span class="c6">AV</span><span class="c2">(u,v)</span><span class="c11">(v)| for each single-edge failure case (on average), </span><span class="c6">the time complexity of the BFS AFF algorithm is O(pn + pm) as it requires to perform p times BFS to compute SI</span><span class="c2">u </span><span class="c6">and SI</span><span class="c5">v</span><span class="c6">. Further, according to analysis of PLL in [2], the number of label entries per vertex is O(w log n). Then the time complexity of the BFS ALL algorithm is O(nw log n + p</span><span class="c25">2</span><span class="c6">w log n), where O(nw log n) is the time upper bound to build temporary labels TL (note that p BFS rounds are enough to build the TL index that contains at most nw log n label entries) and O(p</span><span class="c25">2</span><span class="c6">w log n) is the time upper bound for redundancy tests. </span></p><p class="c112 c130"><span class="c43">5. EXPERIMENTS </span></p><p class="c64 c134"><span class="c6">We evaluated the performance of our proposed SIEF ap- proach and this section reports the results. All experiments were performed under Linux (Ubuntu 10.04) on a server pro- vided by eResearch SA</span><span class="c25">2</span><span class="c6">. The server was running on Dell R910 with 32 processing cores (four 8-core Intel Xeon E7- 8837 CPUs at 2.67 GHz), 1024 GB main memory and 3 TB local scratch disk. All methods were implemented in C++ (the code of PLL [2] was obtained from the first author&rsquo;s code repository on GitHub</span><span class="c25">3</span><span class="c6">) using the same gcc compiler (version 4.4.6) with the optimizer option O3. It is worth mentioning that although we have a large amount of main memory on the server, the memory usage of our approach is in fact quite small and as observed during our experiments, the memory usage was within 12 GB for all datasets. </span><span class="c43">5.1 Datasets </span></p><p class="c134 c64"><span class="c6">Table 2 lists the six real-world datasets used in our exper- iments, which are briefly introduced as follows: </span></p><p class="c65"><span class="c6">&bull; Gnutella is a snapshot of the Gnutella peer-to-peer file sharing network collected in August 2002. Vertices represent hosts in the Gnutella network topology and edges represent connections between the hosts. </span></p><p class="c30"><span class="c6">&bull; The dataset Facebook consists of circles (or friends lists) from Facebook, which were collected from sur- vey participants using a Facebook app called Social Circles. </span></p><p class="c77"><span class="c6">&bull; Wiki-Vote contains all Wikipedia voting data from the inception of Wikipedia till January 2008. </span></p><p class="c37"><span class="c6">&bull; Oregon is a graph of Autonomous Systems (AS) peer- ing information inferred from Oregon route-views on May 26 2001. </span></p><p class="c30"><span class="c6">&bull; Ca-HepTh collaboration network of Arxiv High Energy Physics Theory category (there is an edge if authors coauthored at least one paper). The data covers papers in the period from January 1993 to April 2003 (124 months). </span></p><p class="c30"><span class="c6">&bull; Ca-GrQc collaboration network of Arxiv General Rela- tivity category. Like Ca-HepTh, the data covers papers in the period from January 1993 to April 2003 (124 months). </span></p><p class="c44"><span class="c6">More details on these datasets can be found at the Stan- ford Network Analysis Project website</span><span class="c25">4</span><span class="c6">. Similar to [3, 2], we treat all graphs as undirected, unweighted graphs. </span></p><p class="c113"><span class="c5">2</span><span class="c11">http://www.ersa.edu.au/ </span><span class="c5">3</span><span class="c11">https://github.com/iwiwi/pruned-landmark-labeling </span><span class="c5">4</span><span class="c11">http://snap.stanford.edu/ </span></p><p class="c0 c108"><span class="c5">5</span><span class="c11">We use the first three letters in the names of each dataset (e.g., Wik for Wiki-vote) for better illustration in the figure. </span></p><p class="c135"><span class="c59">153 </span></p><p class="c18 c22"><span class="c6">It should be noted that, in Table 2, |V | refers to the num- ber of vertices and |E| refers to the number of edges. In addition, IT denotes the indexing time or index construc- tion time (in seconds) and LN denotes the average number of label entries of each vertex. We obtained these IT and LN results by using the Pruned Landmark Labeling (PLL) tech- nique presented in [2]. As mentioned, we applied our index construction algorithms directly on the indexes constructed by PLL in our experiments. </span></p><p class="c94"><span class="c6">Table 2: Real-world Datasets and Their Statistics </span></p><p class="c105"><span class="c43">5.2 Performance Evaluation </span></p><p class="c127 c108 c22"><span class="c6">We have conducted extensive experiments to validate our proposed approach. In the experiments, we compared the numbers of affected vertices (Section 5.2.3), the average la- bel entry numbers with and without considering edge fail- ures (Section 5.2.1). We performed queries with and without SIEF indexes (Section 5.2.4) and great efficiency improve- ment was observed if using SIEF indexes. We also studied the impact of our approach in terms of index size, identi- fication time, and relabeling time for each dataset (Section 5.2.2 to 5.2.6). Note that, we construct SIEF indexes by computing supplemental indexes for all single-edge failure cases of a given graph. </span></p><p class="c41"><span class="c45">5.2.1 Supplemental Label Entry Numbers </span></p><p class="c22 c54"><span class="c6">Figure 5 shows the difference between the original label entry number (OLEN) without support of single-edge fail- ures and the supplemental label entry number (SLEN) with support of single-edge failures. SLEN and OLEN of Wiki- Vote</span><span class="c25">5 </span><span class="c6">have the biggest gap, i.e., the ratio of SLEN to OLEN is observed around 80. SLEN and OLEN of Facebook have the second biggest gap and the ratio of SLEN to OLEN is around 40. For other datasets, the ratios of SLEN to OLEN are all under 10. This means, compared with the total num- ber of label entries needed for the original graphs without considering edge failures, in the case of edge failures, the to- tal extra number of label entries (in supplemental indexes) is less than 10 times of the number of the label entries in the original index. These results indicate that the SIEF indexes are very compact. </span></p><p class="c128"><span class="c45">5.2.2 Index Size </span></p><p class="c54 c22"><span class="c6">Figure 6 shows the original index size for the graphs with no failed edges and the supplemental index size when con- sidering edge failures. The sum of the original index size and the supplemental index size is the total index size for han- dling shortest path distances on graphs with all single-edge failure cases. From the figure, the Gnutella dataset shows comparatively smaller proportion of its supplemental index over its total index size while the Facebook dataset shows </span></p><p class="c18 c22"><span class="c6">Figure 6 shows the original index size for the graphs with no failed edges and the supplemental index size when con- sidering edge failures. The sum of the original index size and the supplemental index size is the total index size for han- dling shortest path distances on graphs with all single-edge failure cases. From the figure, the Gnutella dataset shows comparatively smaller proportion of its supplemental index over its total index size while the Facebook dataset shows </span></p><p class="c0 c52"><span class="c4">Dataset </span></p><p class="c148 c23"><span class="c4">Gnutella </span></p><p class="c0 c23"><span class="c4">Gnutella </span></p><p class="c63 c131"><span class="c4">Facebook </span></p><p class="c3"><span class="c4">Wiki-Vote </span></p><p class="c79 c149"><span class="c4">Oregon </span></p><p class="c56"><span class="c4">Ca-HepTh </span></p><p class="c79 c140"><span class="c4">Ca-GrQc </span></p><p class="c0 c145"><span class="c4">11,174 </span></p><p class="c0 c145"><span class="c4">11,174 </span></p><p class="c0 c14"><span class="c4">6,301 </span></p><p class="c0 c14"><span class="c4">6,301 </span></p><p class="c0 c14"><span class="c4">6,301 </span></p><p class="c14 c63"><span class="c4">4,039 </span></p><p class="c0 c14"><span class="c4">4,039 </span></p><p class="c79 c14"><span class="c4">7,115 </span></p><p class="c0 c14"><span class="c4">7,115 </span></p><p class="c14 c118"><span class="c4">9,877 </span></p><p class="c0 c14"><span class="c4">9,877 </span></p><p class="c79 c14"><span class="c4">5,242 </span></p><p class="c0 c14"><span class="c4">5,242 </span></p><p class="c0 c97"><span class="c10">|</span><span class="c4">V</span><span class="c10">| </span></p><p class="c0 c97"><span class="c10">|</span><span class="c4">V</span><span class="c10">| </span></p><p class="c35 c139"><span class="c4">103,689 </span></p><p class="c0 c35"><span class="c4">103,689 </span></p><p class="c0 c35"><span class="c4">103,689 </span></p><p class="c0 c13"><span class="c4">20,777 </span></p><p class="c0 c13"><span class="c4">20,777 </span></p><p class="c0 c13"><span class="c4">20,777 </span></p><p class="c0 c13"><span class="c4">20,777 </span></p><p class="c63 c13"><span class="c4">88,234 </span></p><p class="c0 c13"><span class="c4">88,234 </span></p><p class="c0 c13"><span class="c4">88,234 </span></p><p class="c13 c112"><span class="c4">23,409 </span></p><p class="c0 c13"><span class="c4">23,409 </span></p><p class="c0 c13"><span class="c4">23,409 </span></p><p class="c63 c13"><span class="c4">51,971 </span></p><p class="c0 c13"><span class="c4">51,971 </span></p><p class="c0 c13"><span class="c4">51,971 </span></p><p class="c79 c13"><span class="c4">28,980 </span></p><p class="c0 c13"><span class="c4">28,980 </span></p><p class="c0 c13"><span class="c4">28,980 </span></p><p class="c0 c85"><span class="c10">|</span><span class="c4">E</span><span class="c10">| </span></p><p class="c0 c85"><span class="c10">|</span><span class="c4">E</span><span class="c10">| </span></p><p class="c0 c85"><span class="c10">|</span><span class="c4">E</span><span class="c10">| </span></p><p class="c0 c28"><span class="c4">IT (s) </span></p><p class="c0 c28"><span class="c4">IT (s) </span></p><p class="c0 c28"><span class="c4">IT (s) </span></p><p class="c0 c28"><span class="c4">IT (s) </span></p><p class="c78 c148"><span class="c4">0.825 </span></p><p class="c0 c78"><span class="c4">0.825 </span></p><p class="c0 c78"><span class="c4">0.825 </span></p><p class="c0 c78"><span class="c4">0.825 </span></p><p class="c0 c78"><span class="c4">0.825 </span></p><p class="c63 c78"><span class="c4">0.173 </span></p><p class="c0 c78"><span class="c4">0.173 </span></p><p class="c0 c78"><span class="c4">0.173 </span></p><p class="c0 c78"><span class="c4">0.173 </span></p><p class="c79 c78"><span class="c4">0.525 </span></p><p class="c0 c78"><span class="c4">0.525 </span></p><p class="c0 c78"><span class="c4">0.525 </span></p><p class="c0 c78"><span class="c4">0.525 </span></p><p class="c78 c79"><span class="c4">0.080 </span></p><p class="c0 c78"><span class="c4">0.080 </span></p><p class="c0 c78"><span class="c4">0.080 </span></p><p class="c0 c78"><span class="c4">0.080 </span></p><p class="c63 c78"><span class="c4">0.557 </span></p><p class="c0 c78"><span class="c4">0.557 </span></p><p class="c0 c78"><span class="c4">0.557 </span></p><p class="c0 c78"><span class="c4">0.557 </span></p><p class="c79 c78"><span class="c4">0.141 </span></p><p class="c0 c78"><span class="c4">0.141 </span></p><p class="c0 c78"><span class="c4">0.141 </span></p><p class="c0 c78"><span class="c4">0.141 </span></p><p class="c0 c12"><span class="c4">163.647 </span></p><p class="c0 c12"><span class="c4">163.647 </span></p><p class="c0 c12"><span class="c4">163.647 </span></p><p class="c0 c12"><span class="c4">163.647 </span></p><p class="c0 c12"><span class="c4">163.647 </span></p><p class="c0 c12"><span class="c4">163.647 </span></p><p class="c63 c29"><span class="c4">25.887 </span></p><p class="c0 c29"><span class="c4">25.887 </span></p><p class="c0 c29"><span class="c4">25.887 </span></p><p class="c0 c29"><span class="c4">25.887 </span></p><p class="c0 c29"><span class="c4">25.887 </span></p><p class="c79 c29"><span class="c4">69.915 </span></p><p class="c0 c29"><span class="c4">69.915 </span></p><p class="c0 c29"><span class="c4">69.915 </span></p><p class="c0 c29"><span class="c4">69.915 </span></p><p class="c0 c29"><span class="c4">69.915 </span></p><p class="c79 c29"><span class="c4">11.189 </span></p><p class="c0 c29"><span class="c4">11.189 </span></p><p class="c0 c29"><span class="c4">11.189 </span></p><p class="c0 c29"><span class="c4">11.189 </span></p><p class="c0 c29"><span class="c4">11.189 </span></p><p class="c63 c29"><span class="c4">75.311 </span></p><p class="c0 c29"><span class="c4">75.311 </span></p><p class="c0 c29"><span class="c4">75.311 </span></p><p class="c0 c29"><span class="c4">75.311 </span></p><p class="c0 c29"><span class="c4">75.311 </span></p><p class="c79 c29"><span class="c4">43.828 </span></p><p class="c0 c29"><span class="c4">43.828 </span></p><p class="c0 c29"><span class="c4">43.828 </span></p><p class="c0 c29"><span class="c4">43.828 </span></p><p class="c0 c29"><span class="c4">43.828 </span></p><p class="c0 c71"><span class="c4">LN </span></p><p class="c0 c71"><span class="c4">LN </span></p><p class="c0 c71"><span class="c4">LN </span></p><p class="c0 c71"><span class="c4">LN </span></p><p class="c0 c71"><span class="c4">LN </span></p><p class="c0"><span class="c24">450 </span></p><p class="c0"><span class="c90">5</span><span class="c42">) 01(r ebmuNy rtnEe lba</span><span class="c24">L</span><span class="c101">OLEN </span><span class="c24">400 </span></p><p class="c0"><span class="c101">SLEN </span></p><p class="c0"><span class="c24">350 </span></p><p class="c0"><span class="c24">300 </span></p><p class="c0"><span class="c24">250 </span></p><p class="c0"><span class="c24">200 </span></p><p class="c0"><span class="c24">150 </span></p><p class="c0"><span class="c24">100 </span></p><p class="c0"><span class="c42">50 </span></p><p class="c21"><span class="c42">0</span><span class="c24">Gnu Fac Wik Ore CaH CaG </span><span class="c6">Figure 5: Comparisons between supplemental la- bel entry numbers (SLENs) and original label entry numbers (OLENs) </span></p><p class="c21"><span class="c6">largest proportion of its supplemental index over the related total index size. The Wiki-Vote dataset has the largest sup- plemental index size due to the fact that each single-failure case incurs a large number of affected vertices as well as a relatively large number of supplemental label entries (for more details, please see Table 3). </span></p><p class="c0"><span class="c24">250 </span></p><p class="c0"><span class="c42">) setybageMn i(e ziSx edn</span><span class="c24">I</span><span class="c42">50 0</span><span class="c24">Gnu Fac Wik Ore CaH CaG </span><span class="c101">Supplemental Index Size </span></p><p class="c0"><span class="c101">Original Index Size </span></p><p class="c0"><span class="c24">200 </span></p><p class="c0"><span class="c24">150 </span></p><p class="c0"><span class="c24">100 </span></p><p class="c0"><span class="c6">Figure 6: Index Size </span></p><p class="c0"><span class="c45">5.2.3 Affected Vertices </span></p><p class="c21"><span class="c6">Table 3 presents the relationship between affected vertices and average supplemental label entry number. Avg 1AU1/1V 1 represents the average percentage of affected vertices in a single-edge failure case, showing the impact of a single-edge failure on a graph. It is also the average proportion of af- fected vertices of the original graphs. Avg 1AU1 represents the average number of affected vertices from the graph and Avg SLEN denotes the average number of supplemental la- bel entries in a single-edge failure case. </span></p><p class="c21"><span class="c6">From the table, we can see that the smallest percentage and the smallest average number of affected vertices are both observed in the Ca-GrQc dataset, with values of 1.486% and 77.884, respectively. We can also see from the table that the average supplemental label number decreases (or increases) together with the average number of the affected vertices. Also around 36% of vertices are affected in the Wiki-Vote </span></p><p class="c0"><span class="c45">5.2.4 Query Time </span></p><p class="c21"><span class="c6">Table 4 shows the average BFS query time and the average SIEF query time. The former represents query time without using indexes proposed in this work, while the latter repre- sents the query time when using SIEF indexes. From the ta- ble, we can see that the difference for Oregon dataset is the least, which still achieves at least 40 times faster when us- ing SIEF indexes compared with the traditional BFS query approach. The largest gap occurs in the Facebook dataset, where the average BFS query time is around 500 times more than the SIEF query time. These results show that when using SIEF indexes, the query efficiency can be improved significantly and the query response times are normally no more than 5 &mu;s. As mentioned in Section 4, we use supple- mental indexes to support edge failures, the query process needs to examine the supplemental indexes first. When ex- amining the supplemental indexes, SIEF checks whether the querying source and querying destination are both affected vertices given the edge failure constraint using binary search strategy. Based on the searching result, SIEF knows whether we can compute the shortest path distance based only on the supplemental indexes or based only on the original indexes. Nevertheless, the querying process is still much faster. The main reason is that the number of affected vertices for each single-edge failure case is typically small (more details are presented in Section 5.2.3) and hence the binary search pro- cess finishes quickly. This results in fast query responses in SIEF. </span></p><p class="c0"><span class="c45">5.2.5 Identification Time </span></p><p class="c21"><span class="c6">Table 5 shows the total time for identifying affected ver- tices for all single-edge failure cases. From the figure, we can see that, for the most datasets, the identification pro- cess can be done fairly fast and is normally finished within 80 seconds. The exception is Wiki-Vote, which requires a bit more than 600 seconds. The fast identification time is </span></p><p class="c0"><span class="c59">154 </span></p><p class="c21"><span class="c6">dataset, which is the largest proportion. The largest average number of affected vertices is observed in the Oregon dataset, which is around 2,861 affected vertices for one failed edge. However, no clear linear relationship is found between the two. The largest gap occurs in the Oregon dataset, which indicates that the label pruning process on the affected ver- tices is quite powerful, leading to much fewer label entries per affected vertex. Meanwhile, the smallest gap happens in the Gnutella dataset and this indicates that label pruning is not very effective in this dataset. </span></p><p class="c21"><span class="c6">Note that, although the proportion of affected vertices for a single-edge failure case could be large, as having been clarified in Figure 6, the final SIEF index for all single-edge failure cases is still of moderate sizes compared with the original index.</span><span class="c11">Table 3: A</span><span class="c143">ff</span><span class="c11">ected Vertices </span></p><p class="c0"><span class="c4">Dataset </span></p><p class="c0"><span class="c4">Gnutella </span></p><p class="c0"><span class="c4">Facebook </span></p><p class="c0"><span class="c4">Wiki-Vote </span></p><p class="c0"><span class="c4">Oregon </span></p><p class="c0"><span class="c4">Ca-HepTh </span></p><p class="c0"><span class="c4">Ca-GrQc </span></p><p class="c0"><span class="c4">Avg </span><span class="c10">|</span><span class="c4">AU</span><span class="c10">|</span><span class="c4">/</span><span class="c10">|</span><span class="c4">V </span><span class="c10">| </span></p><p class="c0"><span class="c4">16.099% </span></p><p class="c0"><span class="c4">35.841% </span></p><p class="c0"><span class="c4">25.605% </span></p><p class="c0"><span class="c4">6.053% </span></p><p class="c0"><span class="c4">2.743% </span></p><p class="c0"><span class="c4">1.486% </span></p><p class="c0"><span class="c4">Avg </span><span class="c10">|</span><span class="c4">AU</span><span class="c10">| </span></p><p class="c0"><span class="c4">2,550.090 </span></p><p class="c0"><span class="c4">2,861.070 </span></p><p class="c0"><span class="c4">381.386 </span></p><p class="c0"><span class="c4">650.241 </span></p><p class="c0"><span class="c4">270.881 </span></p><p class="c0"><span class="c4">77.884 </span></p><p class="c0"><span class="c4">Avg SLEN </span></p><p class="c0"><span class="c4">396.971 </span></p><p class="c0"><span class="c4">78.445 </span></p><p class="c0"><span class="c4">47.042 </span></p><p class="c0"><span class="c4">45.323 </span></p><p class="c0"><span class="c4">51.095 </span></p><p class="c0"><span class="c4">13.064 </span></p><p class="c21"><span class="c6">mainly because the affected vertices can be identified in a BFS manner and we only need to examine the distances be- tween the affected vertices to one of the end vertices of a failed edge. </span></p><p class="c0"><span class="c6">Table 5: Average Identification Time </span></p><p class="c0"><span class="c45">5.2.6 Labeling Time </span></p><p class="c21"><span class="c6">Figure 7 shows the time for relabeling the affected vertices, which need extra distance label information to maintain cor- rect distances to some other vertices due to a single-edge failure. Here, we used the estimated time for naive method (shown as &ldquo;Estd Time for Naive Method&rdquo; in the figure) as the baseline. The naive method refers to the method that we recompute a complete distance labeling index for each single-edge failure case. The process of labeling a new graph with a single-edge failure should be almost the same as the process of labeling the original graph. Therefore, the total labeling time of the naive method can be estimated by mul- tiplying the total edge number in the original graph, i.e., the total number of single-edge failure cases, with the index time of the original graph (see Table 2). </span></p><p class="c0"><span class="c24">10</span><span class="c15">6 </span></p><p class="c20"><span class="c92">Estd Time for Naive Method BFS AFF Time </span><span class="c24">10</span><span class="c15">5 </span></p><p class="c0"><span class="c92">BFS ALL Time </span><span class="c42">) sdnocesn i(e miTe lba</span><span class="c24">L10</span><span class="c15">4 </span><span class="c24">10</span><span class="c15">3 </span></p><p class="c0"><span class="c24">10</span><span class="c15">2 </span></p><p class="c0"><span class="c24">10</span><span class="c15">1 </span></p><p class="c0"><span class="c42">10</span><span class="c15">0 </span></p><p class="c0"><span class="c24">Gnu Fac Wik Ore CaH CaG </span><span class="c6">Figure 7: Labeling Time </span></p><p class="c0"><span class="c6">Then, we compared the labeling times of the naive method and the two labeling methods proposed in our work: BFS </span></p><p class="c0"><span class="c4">Dataset </span></p><p class="c0"><span class="c4">Gnutella </span></p><p class="c0"><span class="c4">Facebook </span></p><p class="c0"><span class="c4">Wiki-Vote </span></p><p class="c0"><span class="c4">Oregon </span></p><p class="c0"><span class="c4">Ca-HepTh </span></p><p class="c0"><span class="c4">Ca-GrQc </span></p><p class="c0"><span class="c6">Table 4: Average Query Time </span></p><p class="c0"><span class="c4">Dataset </span></p><p class="c0"><span class="c4">Gnutella </span></p><p class="c0"><span class="c4">Facebook </span></p><p class="c0"><span class="c4">Wiki-Vote </span></p><p class="c0"><span class="c4">Oregon </span></p><p class="c0"><span class="c4">Ca-HepTh </span></p><p class="c0"><span class="c4">Ca-GrQc </span></p><p class="c0"><span class="c4">BFS Query Time </span></p><p class="c0"><span class="c4">140.329 &mu;s </span></p><p class="c0"><span class="c4">243.060 &mu;s </span></p><p class="c0"><span class="c4">284.867 &mu;s </span></p><p class="c0"><span class="c4">163.465 &mu;s </span></p><p class="c0"><span class="c4">325.196 &mu;s </span></p><p class="c0"><span class="c4">159.412 &mu;s </span></p><p class="c0"><span class="c4">Identification Time </span></p><p class="c0"><span class="c4">SIEF Query Time </span></p><p class="c0"><span class="c4">43.3708 s </span></p><p class="c0"><span class="c4">80.6844 s </span></p><p class="c0"><span class="c4">612.522 s </span></p><p class="c0"><span class="c4">35.6307 s </span></p><p class="c0"><span class="c4">36.2022 s </span></p><p class="c0"><span class="c4">4.32942 s </span></p><p class="c0"><span class="c4">0.452 &mu;s </span></p><p class="c0"><span class="c4">0.522 &mu;s </span></p><p class="c0"><span class="c4">1.100 &mu;s </span></p><p class="c0"><span class="c4">4.985 &mu;s </span></p><p class="c0"><span class="c4">0.689 &mu;s </span></p><p class="c0"><span class="c4">0.479 &mu;s </span></p><p class="c21"><span class="c6">AFF and BFS ALL. Recall that BFS AFF uses a late-label- pruning strategy and avoids labeling any unaffected vertices while BFS ALL uses an early-label-pruning strategy which needs labeling the unaffected vertices. From the figure, we can see that for some datasets, such as Gnutella, Ca-HepTh and Ca-GrQc, BFS AFF outperforms the naive method be- cause the label-pruning process incurs some overhead when labeling unaffected vertices compared with the pure BFS process. However, BFS AFF is beaten by the naive method in terms of labeling time for other datasets, including Face- book, Wiki-Vote and Oregon, which contain a large number of vertices and/or a large number of edges. Hence, the late- label-pruning strategy in BFS AFF does not work well on all datasets. These results indicate that although label-pruning incurs some overhead on top of the BFS process, the label- pruning approach is quite effective in some datasets, espe- cially datasets with more vertices and edges. </span></p><p class="c21"><span class="c6">In contrast, BFS ALL performs the best on all datasets. For some datasets, such as Facebook, Wiki-Vote and Ca- Hepth, BFS ALL even performs orders of magnitude faster than both the naive method and the BFS AFF method. This confirms that the early-label-pruning strategy works very well on various datasets and the overhead on labeling unaffected vertices can be ignored due to the substantial label-pruning power it brings (for more details, please refer to Section 4.3). </span></p><p class="c0"><span class="c43">6. CONCLUSION </span></p><p class="c21"><span class="c6">This paper has studied the problem of computing the shortest path distance on graphs with single-edge failures based on 2-hop distance labeling techniques. The concept of well-ordering 2-hop distance labeling and its properties have been defined and analyzed. We have particularly fo- cused on the constructions of compact distance labeling for all possible single-edge failure cases, a challenging problem that remains open, to the best of our knowledge. A generic framework, SIEF, has been designed for this purpose. Based on the most recent technique Pruned Landmark Labeling (PLL) [2] that handles only static graphs, we have imple- mented an extended version using the SIEF framework de- veloped in this paper. Extensive experiments have also been performed on six real-world graphs to confirm its effective- ness and efficiency. SIEF is able to support compact in- dex construction for all single-edge failure cases on graphs efficiently. Specifically, the SIEF index size is compara- ble to that of the indexes constructed for original static graphs, which is very compact. SIEF can answer distance queries with edge failure constraints several orders of mag- nitude faster than traditional Breadth-First-Search (BFS) algorithms. </span></p><p class="c21"><span class="c6">In our future work, we will further investigate several as- pects of answering distance queries on graphs with edge failures. The first one centers on how to support distance queries with more complex edge failure constraints, i.e., dual- failure on edges. The second aspect is to further speed up the index construction process in order to process larger graphs. Finally, it is also interesting to investigate the problem of an- swering distance queries on graphs with node failures, which is even more challenging than edge failures. </span></p><p class="c110"><span class="c43">7. REFERENCES </span><span class="c11">[1] I. Abraham, D. Delling, A. V. Goldberg, and R. F. F. </span><span class="c6">Werneck. Hierarchical Hub Labelings for Shortest </span></p><p class="c0"><span class="c59">155 </span></p><p class="c133"><span class="c6">Paths. In Proc. of the 20th Annual European Symposium on Algorithms (ESA 2012), pages 24&ndash;35, Ljubljana, Slovenia, 2012. [2] T. Akiba, Y. Iwata, and Y. Yoshida. Fast Exact </span></p><p class="c53"><span class="c6">Shortest-Path Distance Queries on Large Networks by Pruned Landmark Labeling. In Proc. of the ACM SIGMOD International Conference on Management of Data (SIGMOD 2013), pages 349&ndash;360, New York, NY, USA, 2013. [3] T. Akiba, Y. Iwata, and Y. Yoshida. Dynamic and </span></p><p class="c79 c120"><span class="c6">historical shortest-path distance queries on large evolving networks by pruned landmark labeling. In Proc. of the 23rd International World Wide Web Conference (WWW 2014), pages 237&ndash;248, Seoul, Republic of Korea, 2014. [4] T. Akiba, C. Sommer, and K. Kawarabayashi. </span></p><p class="c63 c156"><span class="c6">Shortest-Path Queries for Complex Networks: Exploiting Low Tree-Width Outside the Core. In Proc. of the 15th International Conference on Extending Database Technology, (EDBT 2012), pages 144&ndash;155, Berlin, Germany, 2012. [5] S. Baswana, U. Lath, and A. S. Mehta. Single source </span></p><p class="c79 c138"><span class="c6">distance oracle for planar digraphs avoiding a failed node or link. In Proc. of the Twenty-Third Annual ACM-SIAM Symposium on Discrete Algorithms (SODA 2012), pages 223&ndash;232, 2012. [6] C. Bazgan, S. Toubaline, and D. Vanderpooten. </span></p><p class="c63 c66"><span class="c6">Efficient Algorithms for Finding the k Most Vital Edges for the Minimum Spanning Tree Problem. In Proc. of the 5th International on Conference Combinatorial Optimization and Applications (COCOA 2011), pages 126&ndash;140, 2011. [7] R. Bramandia, B. Choi, and W. K. Ng. Incremental Maintenance of 2-Hop Labeling of Large Graphs. IEEE Trans. Knowl. Data Eng., 22(5):682&ndash;698, 2010. [8] L. Chang, J. X. Yu, L. Qin, H. Cheng, and M. Qiao. </span></p><p class="c79 c122"><span class="c6">The exact distance to destination in undirected world. VLDB J., 21(6):869&ndash;888, 2012. [9] J. Cheng, Y. Ke, S. Chu, and C. Cheng. Efficient </span></p><p class="c63 c99"><span class="c6">Processing of Distance Queries in Large Graphs: A Vertex Cover Approach. In Proc. of the ACM SIGMOD International Conference on Management of Data (SIGMOD 2012), pages 457&ndash;468, Scottsdale, AZ, USA, 2012. [10] J. Cheng and J. X. Yu. On-line exact shortest distance query processing. In EDBT, pages 481&ndash;492, 2009. [11] A. Ciortea, O. Boissier, A. Zimmermann, and A. M. </span></p><p class="c137"><span class="c6">Florea. Reconsidering the social web of things: position paper. In Proc. the 2013 ACM International Joint Conference on Pervasive and Ubiquitous Computing (UbiComp 2013) (Adjunct Publication), pages 1535&ndash;1544, Zurich, Switzerland, 2013. [12] E. Cohen, E. Halperin, H. Kaplan, and U. Zwick. </span></p><p class="c132"><span class="c6">Reachability and distance queries via 2-hop labels. In Proc. of the Thirteenth Annual ACM-SIAM Symposium on Discrete Algorithms (SODA 2002), pages 937&ndash;946, San Francisco, CA, USA, 2002. [13] R. Duan and S. Pettie. Dual-failure distance and </span></p><p class="c63 c125"><span class="c6">connectivity oracles. In Proc. of the Twentieth Annual ACM-SIAM Symposium on Discrete Algorithms (SODA 2009), pages 506&ndash;515, 2009. </span></p><p class="c0 c95"><span class="c6">[14] H. K. Farsani, M. A. Nematbakhsh, and G. Lausen. </span></p><p class="c63 c67"><span class="c6">SRank: Shortest paths as distance between nodes of a graph with application to RDF clustering. J. Information Science, 39(2):198&ndash;210, 2013. [15] A. W.-C. Fu, H. Wu, J. Cheng, and R. C.-W. Wong. </span></p><p class="c63 c153"><span class="c6">IS-LABEL: an Independent-Set based Labeling Scheme for Point-to-Point Distance Querying. Proc.of the VLDB Endowment, 6(6):457&ndash;468, 2013. [16] J. Hershberger and S. Suri. Vickrey Prices and </span></p><p class="c116"><span class="c6">Shortest Paths: What is an Edge Worth? In Proc. of the 42nd Annual Symposium on Foundations of Computer Science (FOCS 2001), pages 252&ndash;259, 2001. [17] K. Iwano and N. Katoh. Efficient Algorithms for </span></p><p class="c63 c109"><span class="c6">Finding the Most Vital Edge of a Minimum Spanning Tree. Inf. Process. Lett., 48(5):211&ndash;213, 1993. [18] R. Jin, N. Ruan, Y. Xiang, and V. E. Lee. A </span></p><p class="c63 c119"><span class="c6">highway-centric labeling approach for answering distance queries on large sparse graphs. In Proc. of the ACM SIGMOD International Conference on Management of Data (SIGMOD 2012), pages 445&ndash;456, Scottsdale, AZ, USA, 2012. [19] P. K., S. P. Kumar, and D. Damien. Ranked answer graph construction for keyword queries on RDF graphs without distance neighbourhood restriction. In Proc. of the 20th International Conference on World Wide Web (WWW 2011, Companion Volume), pages 361&ndash;366, Hyderabad, India, 2011. [20] R. Schenkel, A. Theobald, and G. Weikum. Efficient Creation and Incremental Maintenance of the HOPI Index for Complex XML Document Collections. In Proc. of the 21st International Conference on Data Engineering (ICDE 2005), pages 360&ndash;371, Tokyo, Japan, 2005. [21] S. Vassilvitskii and E. Brill. Using Web-Graph </span></p><p class="c63 c126"><span class="c6">Distance for Relevance Feedback in Web Search. In Proc. of the 29th Annual International Conference on Research and Development in Information Retrieval (SIGIR 2006), pages 147&ndash;153, Seattle, Washington, USA, 2006. [22] K. Wehmuth and A. Ziviani. DACCER: Distributed </span></p><p class="c63 c109"><span class="c6">Assessment of the Closeness CEntrality Ranking in complex networks. Computer Networks, 57(13):2536&ndash;2548, 2013. [23] F. Wei. TEDI: efficient shortest path query answering </span></p><p class="c46"><span class="c6">on graphs. In Proc. of the ACM SIGMOD International Conference on Management of Data (SIGMOD 2010), pages 99&ndash;110, Indianapolis, Indiana, USA, 2010. [24] K. Xie, K. Deng, S. Shang, X. Zhou, and K. Zheng. </span></p><p class="c142"><span class="c6">Finding Alternative Shortest Paths in Spatial Networks. ACM Trans. Database Syst., 37(4):29, 2012. [25] L. Yao and Q. Z. Sheng. Exploiting Latent Relevance </span></p><p class="c63 c70"><span class="c6">for Relational Learning of Ubiquitous Things. In Proc. of the 21st ACM International Conference on Information and Knowledge Management (CIKM 2012), Maui, Hawaii, USA, 2012. [26] A. D. Zhu, X. Xiao, S. Wang, and W. Lin. Efficient </span></p><p class="c38"><span class="c6">Single-Source Shortest Path and Distance Queries on Large Graphs. In Proc. of the 19th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (KDD 2013), pages 998&ndash;1006, Chicago, IL, USA, 2013. </span></p><p class="c114"><span class="c59">156 </span></p></body></html>