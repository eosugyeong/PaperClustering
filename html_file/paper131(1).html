<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c185{margin-left:-21.7pt;padding-top:1.7pt;text-indent:30.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-21.4pt}.c17{margin-left:-29.5pt;padding-top:4.1pt;text-indent:38.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-15.2pt}.c91{margin-left:4.3pt;padding-top:1.2pt;text-indent:6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-4.4pt}.c32{margin-left:-20.5pt;padding-top:1.7pt;text-indent:29.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-28.8pt}.c25{margin-left:-29.5pt;padding-top:4.1pt;text-indent:38.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.1pt}.c135{margin-left:5.3pt;padding-top:1pt;text-indent:14.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:1.8pt}.c52{margin-left:-17.6pt;padding-top:1.4pt;text-indent:26.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-24.2pt}.c41{margin-left:-20.5pt;padding-top:1.4pt;text-indent:29.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-21.4pt}.c190{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:17.9pt;font-family:"Arial";font-style:normal}.c6{margin-left:-20.5pt;padding-top:1.7pt;text-indent:29.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-21.4pt}.c34{margin-left:-29.5pt;padding-top:1.7pt;text-indent:38.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.2pt}.c36{margin-left:-5.5pt;padding-top:1pt;text-indent:5.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:11.7pt}.c160{margin-left:-1.5pt;padding-top:112.1pt;text-indent:7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-2.2pt}.c82{margin-left:233.5pt;padding-top:277pt;text-indent:-224.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-21.4pt}.c30{margin-left:-29.5pt;padding-top:3.8pt;text-indent:38.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-12.3pt}.c50{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c38{margin-left:-25pt;padding-top:1.4pt;text-indent:39.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-10.9pt}.c164{margin-left:-11.3pt;padding-top:1pt;text-indent:19.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:121.8pt}.c31{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c46{margin-left:-26.6pt;padding-top:4.1pt;text-indent:35.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-15.4pt}.c16{margin-left:-25.2pt;padding-top:1.2pt;text-indent:35.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:47.7pt}.c134{margin-left:-26.6pt;padding-top:7.9pt;text-indent:35.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-15.4pt}.c15{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c20{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:19.9pt;font-family:"Arial";font-style:normal}.c182{margin-left:-6.3pt;padding-top:1pt;text-indent:21pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:157.4pt}.c53{margin-left:-20.5pt;padding-top:15.1pt;text-indent:29.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-21.4pt}.c59{margin-left:233.5pt;padding-top:224.6pt;text-indent:-224.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-21.4pt}.c7{margin-left:-17.6pt;padding-top:1.7pt;text-indent:26.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-24.5pt}.c10{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Courier New";font-style:normal}.c21{margin-left:233.5pt;padding-top:0pt;text-indent:-224.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-21.4pt}.c54{margin-left:-26.6pt;padding-top:1.7pt;text-indent:35.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-15.4pt}.c43{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Courier New";font-style:normal}.c66{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Times New Roman";font-style:italic}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Arial";font-style:normal}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Courier New";font-style:normal}.c131{margin-left:-20.5pt;padding-top:1.4pt;text-indent:29.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-32.6pt}.c44{margin-left:-29.5pt;padding-top:1.4pt;text-indent:38.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-12.3pt}.c81{margin-left:-20.5pt;padding-top:1.7pt;text-indent:29.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-24.2pt}.c80{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:16.6pt;font-family:"Arial";font-style:normal}.c69{margin-left:-14.5pt;padding-top:1pt;text-indent:29.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:100.6pt}.c110{margin-left:-20.5pt;padding-top:1.4pt;text-indent:29.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-22.8pt}.c74{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5pt;font-family:"Courier New";font-style:normal}.c149{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Courier New";font-style:normal}.c37{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Arial";font-style:normal}.c26{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Arial";font-style:normal}.c48{margin-left:-20.5pt;padding-top:3.8pt;text-indent:29.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-21.4pt}.c108{margin-left:233.5pt;padding-top:14.4pt;text-indent:-224.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-275.4pt}.c70{margin-left:-11.3pt;padding-top:1pt;text-indent:19.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:109.6pt}.c87{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:13.3pt;font-family:"Courier New";font-style:normal}.c155{margin-left:-15.2pt;padding-top:18.2pt;text-indent:57.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-31.9pt}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:13.3pt;font-family:"Arial";font-style:normal}.c24{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5pt;font-family:"Arial";font-style:normal}.c55{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10pt;font-family:"Courier New";font-style:normal}.c85{margin-left:233.5pt;padding-top:1.7pt;text-indent:-224.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-21.4pt}.c115{margin-left:-26.6pt;padding-top:1.4pt;text-indent:35.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-15.4pt}.c28{margin-left:-20.5pt;padding-top:74.9pt;text-indent:29.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-21.4pt}.c5{margin-left:-17.6pt;padding-top:1.4pt;text-indent:26.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-24.5pt}.c27{margin-left:-13.2pt;padding-top:8.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-15.4pt}.c181{margin-left:-7.2pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:140.1pt}.c183{margin-left:-27.4pt;padding-top:14.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:186.9pt}.c159{margin-left:5.9pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:47.8pt}.c184{margin-left:4.8pt;padding-top:1.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:101.2pt}.c158{margin-left:-18.7pt;padding-top:8.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-12.6pt}.c97{margin-left:-0.1pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:26.2pt}.c105{margin-left:-29.5pt;padding-top:9.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-15.7pt}.c161{margin-left:-29.5pt;padding-top:11.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:118.7pt}.c94{margin-left:-14.5pt;padding-top:20.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:190.1pt}.c93{margin-left:-7.2pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:4pt}.c116{margin-left:-18.3pt;padding-top:20.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:173.8pt}.c147{margin-left:218.2pt;padding-top:56.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-36.1pt}.c78{margin-left:-29.5pt;padding-top:170.9pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-12.6pt}.c47{margin-left:-20.5pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-20.6pt}.c90{margin-left:-29.5pt;padding-top:13.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:69pt}.c114{margin-left:-14.7pt;padding-top:12.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:58.1pt}.c75{margin-left:-20.5pt;padding-top:8.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:69.4pt}.c153{margin-left:-18.3pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:19.7pt}.c95{margin-left:-29.5pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-12.3pt}.c130{margin-left:-29.5pt;padding-top:163.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-12.6pt}.c172{margin-left:-11.3pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-20.7pt}.c176{margin-left:13.2pt;padding-top:19pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:24.4pt}.c167{margin-left:-16.8pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:66.6pt}.c72{margin-left:-19.2pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:142pt}.c127{margin-left:-16.3pt;padding-top:9.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:77.4pt}.c119{margin-left:-7.2pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:164.1pt}.c89{margin-left:-13.2pt;padding-top:7.9pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-15.4pt}.c84{margin-left:-16.3pt;padding-top:6.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-12.3pt}.c189{margin-left:-10.4pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:116.9pt}.c62{margin-left:-29.5pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.1pt}.c42{margin-left:-18.7pt;padding-top:7.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-12.3pt}.c57{margin-left:5.9pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:108.7pt}.c187{margin-left:-29.5pt;padding-top:12pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:119.4pt}.c67{margin-left:-6.3pt;padding-top:0.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:39.6pt}.c29{margin-left:233.5pt;padding-top:18.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-21.4pt}.c165{margin-left:-20pt;padding-top:16.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:50.4pt}.c143{margin-left:-26.6pt;padding-top:11.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.1pt}.c99{margin-left:-29.5pt;padding-top:15.1pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-12.3pt}.c118{margin-left:-11.3pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:105.5pt}.c65{margin-left:-29.5pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-12.3pt}.c166{margin-left:14.1pt;padding-top:19.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:7.2pt}.c23{margin-left:-29.5pt;padding-top:4.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-12.3pt}.c129{margin-left:-20.5pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:22.8pt}.c171{margin-left:-20.5pt;padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:79.4pt}.c107{margin-left:218.2pt;padding-top:222pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:217.9pt}.c124{margin-left:-10.4pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:23.3pt}.c33{margin-left:-13.2pt;padding-top:8.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-15.4pt}.c178{margin-left:2.6pt;padding-top:20.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:1.9pt}.c109{margin-left:-26.6pt;padding-top:3.8pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-15.4pt}.c169{margin-left:-20.5pt;padding-top:4.1pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-25.4pt}.c163{margin-left:-16.3pt;padding-top:9.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:26.6pt}.c150{margin-left:-16.3pt;padding-top:9.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-12.3pt}.c11{margin-left:-16.3pt;padding-top:8.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-12.3pt}.c88{margin-left:-29.5pt;padding-top:8.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-12.3pt}.c8{margin-left:-29.5pt;padding-top:8.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-12.3pt}.c179{margin-left:-16.3pt;padding-top:8.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-12.6pt}.c146{margin-left:-26.6pt;padding-top:20.2pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-15.4pt}.c96{margin-left:-5.5pt;padding-top:1.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:160.5pt}.c68{margin-left:-13.2pt;padding-top:8.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-15.4pt}.c193{margin-left:-17.8pt;padding-top:12.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:89.8pt}.c103{margin-left:-29.5pt;padding-top:8.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:101pt}.c63{margin-left:-20.5pt;padding-top:13.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:99.4pt}.c71{margin-left:-20.5pt;padding-top:25.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:45.8pt}.c77{margin-left:-20.5pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-21.4pt}.c61{margin-left:-29.5pt;padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:117pt}.c76{margin-left:-20.5pt;padding-top:7.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-21.4pt}.c170{margin-left:-26.9pt;padding-top:6.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:86.8pt}.c14{margin-left:218.2pt;padding-top:54.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-36.1pt}.c19{margin-left:-9.9pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:6pt}.c128{margin-left:-29.5pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-20.7pt}.c40{margin-left:-20.5pt;padding-top:8.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:35.5pt}.c73{margin-left:19.8pt;padding-top:20.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:19pt}.c60{margin-left:-20.6pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-12.3pt}.c112{margin-left:-16.3pt;padding-top:8.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-12.3pt}.c121{margin-left:-20.5pt;padding-top:10.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:105.6pt}.c13{margin-left:-29.5pt;padding-top:166.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-12.3pt}.c144{margin-left:4.1pt;padding-top:20.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:15.3pt}.c156{margin-left:-29.5pt;padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:107pt}.c51{margin-left:-25.7pt;padding-top:15.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:22pt}.c106{margin-left:-29.5pt;padding-top:10.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-6.8pt}.c18{margin-left:-16.3pt;padding-top:8.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.6pt}.c175{margin-left:18.2pt;padding-top:0.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:23.3pt}.c12{margin-left:-20.5pt;padding-top:115.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:86.4pt}.c35{margin-left:-16.3pt;padding-top:9.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:55.1pt}.c188{margin-left:-27.6pt;padding-top:10.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:1.8pt}.c168{margin-left:-29.5pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-12.6pt}.c137{margin-left:-20.2pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:6pt}.c174{margin-left:-17.6pt;padding-top:9.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:101.5pt}.c2{margin-left:0.7pt;padding-top:20.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:11.9pt}.c9{margin-left:-29.5pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-12.3pt}.c162{margin-left:-29.5pt;padding-top:12.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:98.8pt}.c113{margin-left:-29.5pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-15.2pt}.c152{margin-left:-5.5pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.8pt}.c104{margin-left:-26.6pt;padding-top:17pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:132.6pt}.c49{margin-left:-26.6pt;padding-top:16.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:52pt}.c86{margin-left:218.2pt;padding-top:317.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:217.9pt}.c4{margin-left:-20.5pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-21.4pt}.c139{margin-left:-18.7pt;padding-top:8.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-12.3pt}.c102{margin-left:-16.3pt;padding-top:8.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-12.3pt}.c101{margin-left:218.2pt;padding-top:576pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:217.9pt}.c123{margin-left:-29.5pt;padding-top:12.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:63.3pt}.c64{margin-left:-20pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:46.1pt}.c58{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c92{padding-top:12.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c22{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c192{padding-top:21.8pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c157{padding-top:12.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c145{padding-top:12pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c173{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c191{padding-top:21.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c148{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c125{padding-top:18.7pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c98{padding-top:4.1pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c180{padding-top:3.8pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c117{padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c111{padding-top:21.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c136{padding-top:8.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c141{padding-top:7.9pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c140{margin-left:233.5pt;text-indent:-224.6pt;margin-right:-279.9pt}.c126{margin-left:-20.5pt;text-indent:29.4pt;margin-right:-21.8pt}.c56{margin-left:-20.5pt;text-indent:29.4pt;margin-right:-21.4pt}.c120{margin-left:-20.5pt;text-indent:25pt;margin-right:12.7pt}.c39{margin-left:-17.6pt;text-indent:26.7pt;margin-right:-24.5pt}.c177{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c154{margin-left:233.5pt;margin-right:-275.4pt}.c100{margin-left:-29.5pt;margin-right:-12.3pt}.c133{margin-left:-29.5pt;margin-right:-15.4pt}.c142{margin-left:-17.6pt;margin-right:-24.2pt}.c122{margin-left:-20.5pt;margin-right:154.3pt}.c132{margin-left:1.6pt;margin-right:1pt}.c186{margin-left:-25pt;margin-right:22.7pt}.c138{margin-left:-20.5pt;margin-right:-16.8pt}.c79{margin-left:-20.5pt;margin-right:-21.4pt}.c83{text-indent:39.2pt}.c45{text-indent:38.4pt}.c151{text-indent:29.4pt}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:24pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:14pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c177"><p class="c58"><span class="c66">Industrial and Applications Paper </span></p><p class="c148"><span class="c190">Strudel: Framework for Transaction Performance Analyses on SQL/NoSQL Systems </span></p><p class="c58"><span class="c15">Junichi Tatemura </span><span class="c20">tatemura@nec-labs.com </span></p><p class="c58"><span class="c80">NEC Labs America </span><span class="c15">Oliver Po </span><span class="c20">oliver@nec-labs.com </span><span class="c80">NEC Labs America </span><span class="c15">Zheng Li </span><span class="c80">Univ. of </span><span class="c20">zli@cs.uml.edu </span></p><p class="c58"><span class="c80">Massachusetts Lowell </span><span class="c15">Hakan Hac&#305;g&uuml;m&uuml; &#807;s </span><span class="c20">hakan@nec-labs.com </span><span class="c80">NEC Labs America </span><span class="c15">ABSTRACT </span><span class="c1">The paper introduces Strudel, a development and execu- tion framework for transactional workloads both on SQL and NoSQL systems. Whereas a rich set of benchmarks and per- formance analysis platforms have been developed for SQL- based systems (RDBMSs), it is challenging for application developers to evaluate both SQL and NoSQL systems for their specific needs. The Strudel framework, which we have released as open-source software, helps such developers (as well as providers of NoSQL stores) to build, customize, and share benchmarks that can run on various SQL/NoSQL sys- tems. We describe Strudel&rsquo;s architecture and APIs, its com- ponents for supporting various NoSQL stores (e.g., HBase, MongoDB), example benchmarks included in the release, and performance experiments to demonstrate usefulness of the framework. </span></p><p class="c58"><span class="c15">1. INTRODUCTION </span></p><p class="c22"><span class="c1">As a large number of web applications adopt cloud com- puting platforms, various types of &ldquo;NoSQL&rdquo; systems have emerged and been employed as scalable and elastic data stores. They are expected to serve transactional workloads</span><span class="c55">1 </span><span class="c1">of an application that interacts with a large and varying number of users on top of commodity server resources (typ- ically in the cloud). </span></p><p class="c22"><span class="c1">Now that application developers have many choices of NoSQL systems as well as SQL systems (i.e., RDBMSs), they face various questions (which we would call &ldquo;SQL-or- NoSQL questions&rdquo;): When should we use a NoSQL store in- stead of a traditional RDBMS? How can we choose a NoSQL system that suits for our purpose? With a particular NoSQL system, what kind of trade-off do we face between scalabil- ity/elasticity gain and the cost of reduced consistency/in- tegrity support? What about other alternatives such as </span></p><p class="c58"><span class="c43">1</span><span class="c37">We focus on user-facing transactional application work- loads instead of analytic ones. </span></p><p class="c22"><span class="c1">c </span><span class="c26">2016, Copyright is with the authors. Published in Proc. 19th Inter- national Conference on Extending Database Technology (EDBT), March 15-18, 2016 - Bordeaux, France: ISBN 978-3-89318-070-7, on OpenPro- ceedings.org. Distribution of this paper is permitted under the terms of the Creative Commons license CC-by-nc-nd 4.0 </span></p><p class="c58"><span class="c1">purchasing a parallel RDBMS product or sharding (parti- tioning) open-source RDBMSs? </span></p><p class="c58"><span class="c1">Standard benchmarks (such as TPC-C) have been very helpful for evaluating and choosing RDBMS products. On the other hand, the effort on benchmarking for NoSQL does not seem catching up with the evolution of NoSQL systems. Currently, YCSB [16, 12] is the most commonly used bench- mark for NoSQL, but it mainly focuses on micro-benchmarking of key-value read/write operations. As NoSQL supports various features such as transaction and more complicated queries, more benchmarks are needed to capture the require- ments behind such features. </span></p><p class="c22"><span class="c1">It is challenging to develop benchmarks, especially to com- pare SQL-based systems and NoSQL systems together, given many different query APIs. It is also challenging to cover the wide range of the application needs. A transactional data store is just part of a larger application system, and its role and requirements are significantly different among applications. </span></p><p class="c173"><span class="c1">Thus, we can hardly expect that a limited number of stan- dard benchmarks are enough for transactional workloads over SQL/NoSQL systems. Given the variety of data stores and the variety of application needs, we need a way to ef- ficiently develop a large and evolving suite of benchmarks, from micro-benchmark level to application-level, with min- imum engineering effort in terms of (1) developing a new benchmark on existing SQL/NoSQL systems and (2) sup- porting a new SQL/NoSQL system for existing benchmarks. In this paper we introduce our development and execu- tion framework, called Strudel, for transactional benchmark workloads with expectation to contribute to the benchmark- ing effort in the community. </span></p><p class="c58"><span class="c1">The design philosophy of the Strudel framework is to pro- vide composability and reusability with (1) decomposing benchmark implementations into small components with mul- tiple abstraction layers and (2) employing a configuration description language to combine these components into a specific workload in a reproducible and shareable manner. In order to bridge the gaps among various data stores, the framework provides multiple abstraction layers: most no- tably Entity DB API and Session Workload framework. A configuration description language is adopted in the frame- work to enable developers to compose a system and workload with custom properties in XML. </span></p><p class="c22"><span class="c1">We have used and kept extending the framework for years through our research and product development of elastic re- lational stores (SQL engines on top of KVS [25]). As it </span></p><p class="c58"><span class="c50">Series ISSN: 2367-2005 580 </span><span class="c149">10.5441/002/edbt.2016.55 </span></p><p class="c8"><span class="c1">has matured as a generic and extensible framework, we re- cently released it (including benchmarks and SQL/NoSQL supports as described later) as open source software[9] for wider development purposes. </span></p><p class="c65 c45"><span class="c1">In this paper, we describe the design and architecture of the Strudel framework, its support on various NoSQL sys- tems, benchmark examples we have developed, and perfor- mance experiments to demonstrate usefulness of the frame- work. </span></p><p class="c156"><span class="c15">2. RELATED WORK </span></p><p class="c25"><span class="c1">YCSB The Yahoo! Cloud Serving Benchmark (YCSB) [16, 12] is the most commonly used benchmark for NoSQL sys- tems. However, from our objective to conduct performance studies on transactional aspects of SQL and NoSQL sys- tems, the original YCSB has very limited support of trans- actional workloads. Researchers have extended YCSB to ex- periment transactions over multiple key-value objects (e.g., [17]). With an appropriate framework, we should be able to share such custom efforts to serve for more general applica- tion performance analyses. </span></p><p class="c45 c113"><span class="c1">As NoSQL systems evolve from a simple Key-Value store, there are increasing needs of performance studies with higher- level (i.e., application-level) workloads, which are especially important to compare SQL systems and NoSQL system from the application developers&rsquo; viewpoints. YCSB++ [23] ex- tends the original YCSB to evaluate advanced features of NoSQL systems (HBase and Accumulo). The features that are relevant to transactional workload evaluation include (1) pushing filtering to the data store, (2) measurement of data staleness due to weak consistency. One possible idea is to in- tegrate such features with the Strudel framework to evaluate advanced NoSQL features not only for micro-benchmarks but also for application-level benchmarks. </span></p><p class="c45 c128"><span class="c1">OLTP-Bench OLTP-Bench [18, 6] is an extensible testbed for benchmarking RDBMSs for (primarily) transactional work- loads. Our framework and OTLP-Bench are not mutually exclusive but complimentary. We focus on a special class of OLTP problems where developers have &ldquo;SQL or NoSQL&rdquo; questions. OLTP-Bench, aiming for more general OLTP use cases, provides a lot of useful features that our framework misses, such as sophisticated (e.g., more realistically skewed) data and workload generation and a rich set of SQL work- loads (including traditional ones that we do not focus on). A skilled developer may reuse these features combined with the Strudel framework. </span></p><p class="c44"><span class="c1">Performance studies There have been various perfor- mance studies reported on NoSQL systems, including the the original work of YCSB [16]. For an example of per- formance studies from the application&rsquo;s viewpoint, Klein et al.[22] report their performance evaluation of NoSQL sys- tems for a healthcare application. Their customer (a health- care provider) requests them to evaluate NoSQL technolo- gies for a new electronic healthcare record system to replace the current version that uses an RDBMS. They developed evaluation tests by modifying the code of YCSB to fit the application&rsquo;s data model. With an appropriate development framework provided, their development could have been eas- ier. In addition, whereas their study excludes RDBMSs (according to the customer requirements), it would need more engineering effort, in general, to compare NoSQL with RDBMSs. </span></p><p class="c60"><span class="c1">Floratou et al. [20] report comparative performance stud- </span></p><p class="c58 c132"><span class="c1">Figure 1: Layered Architecture of Strudel </span></p><p class="c56 c157"><span class="c1">In Figure 1, red boxes labeled with </span><span class="c10">[A] </span><span class="c1">are components a developer needs to implement for each benchmark appli- cation, and green boxes with </span><span class="c10">[D] </span><span class="c1">are implemented for each NoSQL system. The label </span><span class="c10">[A,D] </span><span class="c1">indicates a component to be implemented for each pair of a benchmark and a NoSQL system, and our goal is to minimize such components. </span></p><p class="c41"><span class="c1">A developer can conduct a specific experiment by com- bining these components with a particular set of configu- ration parameters. We employ a configuration description language for such experiments to make experiments repro- ducible and individual components reusable across different experiments (Section 6). </span></p><p class="c4 c151"><span class="c1">Strudel also provides workload management and execu- tion engines for experiments in a cluster environment in an </span></p><p class="c14"><span class="c50">581 </span></p><p class="c22 c79"><span class="c1">ies between SQL and NoSQL systems, including comparison between SQL Server and MongoDB for YCSB workloads. We hope Strudel is useful to extend such studies to cover more NoSQL systems and various benchmarks that capture application-level requirements. </span></p><p class="c63"><span class="c15">3. ARCHITECTURE </span></p><p class="c48"><span class="c1">Figure 1 illustrates the layered architecture of the Strudel framework that provides composability and reusability in benchmark application development. The abstraction layers are visualized as orange boxes with underscored italic words (representing the names of APIs). Among them, Java Per- sistence API (JPA) is a Java standard for object-relational mapping (that converts Java object manipulation to SQL queries). The Strudel framework provides the other APIs. </span></p><p class="c6"><span class="c1">Entity DB is a simplified data access API that covers transactional data access features that are common in var- ious NoSQL systems as well as relational databases (Sec- tion 4). Basic implementation of Entity DB on a NoSQL system would not be very difficult (we also provide another API, Transactional KVS, to make it easier). If a benchmark is implemented on Entity DB API, it can run on various NoSQL systems as well as RDBMSs that support the JPA standard. </span></p><p class="c41"><span class="c1">The Session Workload is a framework that helps develop- ers to implement benchmark application on different data access APIs (Entity DB, JPA, and native NoSQL APIs) by reusing the code as much as possible (Section 5). </span></p><p class="c103"><span class="c1">automated manner (Section 7). </span></p><p class="c61"><span class="c15">4. ENTITY DB API </span></p><p class="c98 c100 c45"><span class="c1">Entity DB API is one of the abstraction layers that are useful to develop workloads that can run on various data stores. It employs a subset of JPA (Java Persistence API) to fill the gap between SQL and NoSQL systems. JPA is a standard Java API for Object-Relational Mapping, provid- ing a way to map Java objects (entities) and relational tables and a way to access data in a relational database through such Java objects. </span></p><p class="c65 c45"><span class="c1">JPA provides a basis for us to abstract out the details of underlying data stores so that application developers can focus on data handling in an object-oriented manner. How- ever, to most NoSQL systems, JPA is not applicable directly since the concept of object-relational mapping relies on ex- pressive power and declarativeness of SQL and the relational model. </span></p><p class="c117 c100 c45"><span class="c1">Thus, we have designed a simplified version of APIs that consists of standard Java annotations (e.g., @Entity, @Id) of JPA and extended annotations as well as simplified data access methods. Whereas this API is not meant for appli- cation production use (missing various features required in production)</span><span class="c55">2</span><span class="c1">, it would support simplified application proto- types to quickly compare data store alternatives before the real application version is developed. </span><span class="c15">4.1 Entity Group Annotations </span></p><p class="c98 c45 c100"><span class="c1">One of the key difference of NoSQL systems from the tra- ditional RDBMS is that not all the data items are equal in terms of transactional data access. Distributed transac- tions are often expensive in a commodity cluster (especially cloud) environment in order to handle a large number of con- current read/write accesses with high availability under a short response time requirement of interactive applications. Thus, most NoSQL systems provide a way to compromise transactional consistency for scalability to avoid distributed transaction as much as possible. In a typical case, a NoSQL system allows ACID data access only on a data set associ- ated with a single key. HBase [2] (open source implementa- tion of Bigtable [15]) provides an atomic check-and-update operation on a single row of a (big)table. For transactions over multiple rows, we need to use an external transaction manager (e.g., Omid [19]) to implement concurrency control and recovery. </span></p><p class="c44"><span class="c1">In order to provide a common API to incorporate such transaction support, we adopt the concept of entity groups. Helland [21] argued that, in order for an application to be truly scalable, it must forgo expensive distributed transac- tions; instead, each transaction must operate on a uniquely identifiable collection of data (i.e., entity groups) that lives on a single machine. Google Megastore [14] supports entity group as a way to associate multiple entities to a group key and guarantee efficient ACID transactions within a single group. </span></p><p class="c45 c95"><span class="c1">We introduce a set of annotations to specify entity groups in a similar way to Megastore. In addition to standard anno- tations (</span><span class="c10">@Entity</span><span class="c1">, </span><span class="c10">@Id</span><span class="c1">, </span><span class="c10">@IdClass</span><span class="c1">), we introduce the following annotations: </span><span class="c10">@Group</span><span class="c1">, </span><span class="c10">@GroupId</span><span class="c1">, </span><span class="c10">@GroupIdClass</span><span class="c1">. </span><span class="c43">2</span><span class="c37">For production use, there is an open source product, for example, DataNucleus that supports common APIs for Java data persistence on some of NoSQL systems: http://www.datanucleus.org/ </span></p><p class="c22 c56"><span class="c1">We illustrate how these annotations are used in an ex- ample benchmark (which emulates an auction application) in Figure 2 . The code uses the JPA standards to define Bid Java class as an entity (</span><span class="c10">@Entity</span><span class="c1">) with a compound key </span><span class="c10">(sellerId, itemNo, bidNo) </span><span class="c1">(as annotated with </span><span class="c10">@Id</span><span class="c1">), which is packaged as one object of a class BidId (</span><span class="c10">@IdClass</span><span class="c1">). </span></p><p class="c71"><span class="c26">@Group(parent = AuctionItem. class ) @Entity @Indexes(</span><span class="c3">{ </span></p><p class="c64"><span class="c26">@On(property = &rdquo;auctionItemId&rdquo;), @On(property = &rdquo;userId&rdquo;) </span><span class="c3">}</span><span class="c26">)</span><span class="c0">@GroupIdClass ( ItemId . class ) </span><span class="c26">@IdClass ( BidId . class ) public class Bid </span><span class="c3">{ </span></p><p class="c97"><span class="c26">@GroupId @Id private int sellerId ; @GroupId @Id private int itemNo ; @Id @GeneratedValue private int bidNo ; private double bidAmount ; private long bidDate ; private int userId ; </span></p><p class="c178"><span class="c1">Figure 2: Example code with annotations </span></p><p class="c53"><span class="c1">With extended annotations, a benchmark developer can associate two entity classes together (as a parent-child rela- tionship) in one group by specifying </span><span class="c10">@Group </span><span class="c1">annotation at a child class to indicate its parent. In this example, Bid is associated with AuctionItem (so that we can consistently access all the bids on one particular auction item and update the item when the maximum bid price changes). A group id (</span><span class="c10">@GroupId</span><span class="c1">) is a member of a compound key (a group key) that specifies a group instance. A set of group ids on an entity class must be a subset of the set of ids (i.e., a (com- pound) primary key) that are annotated with </span><span class="c10">@Id</span><span class="c1">. </span></p><p class="c75"><span class="c15">4.2 Data Access Operations </span></p><p class="c169"><span class="c1">CRUD Operations Entity DB API supports basic CRUD (Create-Read-Update-Delete) operations: (1) create (2) get, (3) update, and (4) delete operations (Figure 3). They (roughly) correspond to persist, find, merge, and remove op- erations of EntityManager, a data access interface of JPA</span><span class="c55">3</span><span class="c1">. Secondary Key Access Unlike JPA, the current Entity DB API does not support a SQL-like query language or au- tomatic retrieval of related entities with a join column (i.e., annotations such as </span><span class="c10">@OneToMany</span><span class="c1">, </span><span class="c10">@ManyToOne</span><span class="c1">). Instead, it provides a way to read multiple instances of the same entity class by specifying one of the entity&rsquo;s property as a secondary key (</span><span class="c10">getEntitiesByIndex </span><span class="c1">in Figure 3). </span></p><p class="c6"><span class="c1">Group Transactions The current version of the frame- work only supports a transaction within an entity group (de- signing API to indicate a &ldquo;global&rdquo; transaction is a plan for a future version). A transaction starts with a given group key and commits after multiple CRUD operations. Figure 4 shows an example of transaction execution. The applica- tion code gives an instance of EntityTask interface to the EntityDB API (&rdquo;</span><span class="c10">edb.run()</span><span class="c1">&rdquo;), then the underlying Entity </span></p><p class="c76"><span class="c43">3</span><span class="c37">A subtle difference from JPA is that there is no concept of attachment/detachment in the current version: an ap- plication always needs to use an update operation to apply changes in an entity Java object to the database. </span></p><p class="c14"><span class="c50">582 </span></p><p class="c188"><span class="c26">&lt;T&gt; T get(Class&lt;T&gt; entityClass , Object key ) ; void create ( Object entity ); void update(Object entity); void delete (Object entity ); &lt;T&gt; List&lt;T&gt; getEntitiesByIndex( </span></p><p class="c36"><span class="c26">Class&lt;T&gt; entityClass , String property , Object key); </span></p><p class="c144"><span class="c1">Figure 3: EntityDB Interface (partial) </span></p><p class="c146"><span class="c1">DB implementation runs the instance of EntityTask by giv- ing an EntityTranscation object (</span><span class="c10">run(EntityTransaction tx)</span><span class="c1">). The entity task (i.e., the application code) uses this transaction handler (</span><span class="c10">tx</span><span class="c1">) to issue multiple CRUD operations. The reason behind this rather convoluted API design (in- stead of providing usual begin/commit operations) is to ab- stract out transaction retry handling, especially for opti- mistic concurrency control. A transaction of applications for NoSQL systems is often simple and lightweight. It is easy to retry the entire transaction when a commit request fails under optimistic concurrency control. In order to an- alyze the impact of transaction conflict in different NoSQL systems, we want experiment different retry policies without changing the application code. </span></p><p class="c51"><span class="c26">BidResult r = edb.run(Bid. class , itemId , </span></p><p class="c167"><span class="c26">new EntityTask&lt;BidResult &gt;() </span><span class="c3">{ </span></p><p class="c152"><span class="c26">public BidResult run(EntityTransaction tx) </span><span class="c3">{ </span></p><p class="c184"><span class="c26">AuctionItem item = </span></p><p class="c135"><span class="c26">tx . get ( AuctionItem . class , itemId ); if (item == null ) </span><span class="c3">{ </span></p><p class="c91"><span class="c26">return BidResult .NONE; </span><span class="c3">}</span><span class="c0">if ( bid . amount ( ) &lt;= item . getMaxBid ( ) ) </span><span class="c87">{ </span></p><p class="c16"><span class="c26">return BidResult.LOST; </span><span class="c3">}</span><span class="c0">tx.create(bid); </span><span class="c26">item . setMaxBid ( bid . amount ( ) ) ; tx . update ( item ) ; return BidResult.SUCCESS; </span><span class="c3">} }</span><span class="c26">); </span></p><p class="c2"><span class="c1">Figure 4: Example of group transaction </span></p><p class="c49"><span class="c15">4.3 Auxiliary Data Maintenance </span></p><p class="c109"><span class="c1">Entity DB API supports two features that involve main- tenance of auxiliary data in the underlying data store: (1) values for automatic unique key generation and (2) indices. Auto Key Generation Entity DB API lets the devel- opers specify the standard </span><span class="c10">@GeneratedValue </span><span class="c1">annotation to use a generated unique value for an id. Just as the standard JPA, an underlying implementation can choose a way to generate unique values based on the data store&rsquo;s capability. The major difference from the standard specification is the uniqueness requirement: In JPA, </span><span class="c10">@GeneratedValue </span><span class="c1">is used to generate a unique value within a table. In Entity DB, it can only be locally unique: it is required that the compound group/primary keys that include this id as a member are unique. For example, in Figure 2, the id </span><span class="c10">bidNo </span><span class="c1">is automat- ically generated when a Bid entity instance is created. In fact, </span><span class="c10">itemNo </span><span class="c1">is also a generated value specified in the Aution- Item class definition. The value of </span><span class="c10">itemNo </span><span class="c1">must be unique </span></p><p class="c22 c142"><span class="c1">within a particular user (identified with </span><span class="c10">sellerId</span><span class="c1">), and the value of </span><span class="c10">bidNo </span><span class="c1">must be unique within a particular auction item. </span></p><p class="c52"><span class="c1">This local uniqueness requirement gives the underlying data store more freedom to use a scalable and efficient way to generate values. </span></p><p class="c7"><span class="c1">Indices To use secondary-key data access, the developers need to explicitly specify an index on a property of an en- tity. Notice that the role of an index at logical design level is different from the case with relational databases where selection of an index is logically transparent from queries. Thus, we introduce a special annotation (</span><span class="c10">@Indexes</span><span class="c1">) sepa- rated from JPA&rsquo;s index annotation (</span><span class="c10">@Table.indexes</span><span class="c1">). </span></p><p class="c7"><span class="c1">One non-trivial semantics of this index-based entity access is its consistency under a specific entity group design. In terms of transaction isolation, an index entry can be seen another (system-defined) entity, and question is whether it is grouped together with the entities it refers to. </span></p><p class="c7"><span class="c1">An index can be included (and is included by default) in the group if the compound index key (i.e., a set of ids) includes the compound group key. We call such an index an in-group index and otherwise we call it an out-of-group index. For example, in Figure 2, there are two indices on AuctionItemId (which is in fact a compound key with sell- erId and itemNo) and userId. The former index is in-group (the index key equals to the group key) and the latter index is out-of-group. </span></p><p class="c5"><span class="c1">If the index is not included in the group, we cannot prevent a phantom read: a transaction cannot read the all the bids on the same item (which is done through the index) in an isolated manner (e.g. it cannot be isolated from insertion of a new bid). </span></p><p class="c5"><span class="c1">In the current Entity DB, we only allow an index on im- mutable columns: the value is specified only at creation of an entity instance and does not change until the instance is deleted. </span></p><p class="c174"><span class="c15">4.4 Implementations </span></p><p class="c114"><span class="c31">4.4.1 Generic Transactional KVS </span></p><p class="c39 c98"><span class="c1">Whereas Entity DB API is simplified for minimum sup- port for entity data access, it still needs engineering efforts to develop an implementation for a particular NoSQL sys- tem. We provide yet another API for transactional key- value data access so that a provider of a NoSQL system can quickly implement this further simplified API instead of directly implementing Entity DB. </span></p><p class="c7"><span class="c1">In Transactional KVS, a data record is just a pair of byte- array key and value, and records are grouped by a group key (another byte array). Data access is done by a group transaction (started with a group key) and simple put/get operations. </span></p><p class="c7"><span class="c1">The framework provides an Entity DB implementation for Transactional KVS, which automates (1) mapping from en- tities to byte array key-value objects, (2) index management, and (3) auto key generation. </span></p><p class="c7"><span class="c1">Index and Key generation As a baseline implemen- tation of Entity DB API, we implemented an index and a key-generation counter as sets of key-value objects on top of the Transactional KVS data model. For each index key, we create an object with the index key and a value that en- codes the pointers to the indexed entities. A counter object is created for each parent key (i.e., the compound primary </span></p><p class="c14"><span class="c50">583 </span></p><p class="c88"><span class="c1">key except an ID to be generated) of an entity, and its value is a counter number. </span></p><p class="c45 c168"><span class="c1">Consider the example in Figure 2 when an application workload creates a new instance of Bid entity. Bid has two indices (</span><span class="c10">auctionItemId </span><span class="c1">and </span><span class="c10">userId</span><span class="c1">) and a generated key (</span><span class="c10">bidNo</span><span class="c1">). There are three auxiliary key-value objects up- dated when we create a new Bid (which is a new key-value object by itself): (a) an index object of type </span><span class="c10">auctionItemId </span><span class="c1">with key </span><span class="c10">(sellerId, itemNo)</span><span class="c1">, (b) an index object of type </span><span class="c10">userId </span><span class="c1">with key </span><span class="c10">userId</span><span class="c1">, and (c) a counter object of type </span><span class="c10">Bid </span><span class="c1">with key </span><span class="c10">(sellerId, itemNo)</span><span class="c1">. Among them only the object a is included in the group with the Bid entity, and creation of Bid involves a following sequence of three trans- actions: </span></p><p class="c42"><span class="c1">1. updates a counter object c and acquires a new value </span></p><p class="c119"><span class="c1">for </span><span class="c10">bidNo</span><span class="c1">. </span></p><p class="c158"><span class="c1">2. updates an index b to insert a key of Bid </span><span class="c10">(sellerId, </span></p><p class="c93"><span class="c10">itemNo, bidNo) </span><span class="c1">using the result of transaction 1. </span></p><p class="c139"><span class="c1">3. updates an index a and creates a new key-value object </span></p><p class="c181"><span class="c1">for a Bid entity. </span></p><p class="c100 c141"><span class="c1">The order of these transactions is important to keep an in- dex b consistent. Even if another transaction accesses the index b between transaction 2 and 3 (or even if transaction 3 fails), it will just read a dangling pointer in the index to a non-existent entity, which does not cause inconsistency. On the other hand, if these transactions create a Bid entity but fail to update the index b, it results in inconsistency (i.e., the existing entity cannot be accessed by the index). When the entity is deleted, the order of transactions will become opposite. When the entity is updated, we do not update the index (i.e., the current Entity DB assumes keys are immutable). </span></p><p class="c44"><span class="c1">Notice also that the counter object c could have been up- dated in the transaction 3 if there were no out-of-group index such as b (that needs a new committed value of </span><span class="c10">bidNo </span><span class="c1">from c). In this case, creation of an entity is done by a single transaction and the counter c and index a is implemented with a single key-value object since their have the same key. </span></p><p class="c117 c45 c133"><span class="c1">We have developed the following implementations of Trans- actional KVS. </span></p><p class="c34"><span class="c1">HBase [2] To implement transactions, we employ HBase&rsquo;s check-and-put operation, which is in general called a compare- and-swap (CAS) operation and operates value comparison (read) and update (write) in an atomic manner. </span></p><p class="c44"><span class="c1">Since check-and-put is applicable only to a single row, all the records (entities) that belong to the same group must be packed into one row. To do this, we implement each key- value record as a column name-value pair (HBase/Bigtable&rsquo;s columns are created in an ad-hoc manner). </span></p><p class="c44"><span class="c1">In addition to these columns, each row has a special col- umn that holds a transaction version. When the Entity DB starts a transaction, it will read the current value of this transaction version on a row that corresponds to an instance of entity group. All the updates are buffered at the client side during the transaction. At a commit request, the En- tity DB issues a check-and-put operation that applies the buffered updates to the corresponding row if the current transaction version equals to the one at the beginning of the transaction. </span></p><p class="c100 c45 c117"><span class="c1">Omid [5] Omid is a transaction server on top of HBase in order to realize ACID transactions over multiple rows [19]. It </span></p><p class="c22 c79"><span class="c1">employs optimistic multi-version concurrency control using multi-versioning of HBase (each row can have multiple ver- sions associated with (logical or physical) timestamps). For each transaction, Omid server issues a new timestamp value, with which a transaction client puts updates to HBase rows. A commit request is sent to the Omid server and ensured after conflict check and writing a log entry for recovery. Al- though it is a centralized server, the required computation at the transaction server is lightweight and it will not become a bottleneck for scalability easily. For our Entity DB imple- mentation, we also implemented sharded Omid servers, by applying hash partitioning over the group key and routing a transaction request to one of multiple Omid servers. In our small-scale experiments up to 10 HBase region servers, how- ever, we did not need more than one Omid server to achieve scalability (Section 8.2). </span></p><p class="c6"><span class="c1">MongoDB [3] MongoDB&rsquo;s update operation is atomic for a single document and consists of query part and update part (i.e., a more general form of the CAS operation). Similar to the HBase implementation, we pack entities of the same group into one document. In the query part of the update, we include the document id (that corresponds to a group key) and a value of a transaction version (stored as a field in a document). </span></p><p class="c131"><span class="c1">TokuMX [10] TokuMX is an enhanced version of Mon- goDB. One of the enhancements is to support a multi-statement transaction over multiple documents whereas the original MongoDB only supports a single statement transaction (i.e., an update operation) over a single document. A client can begin and commit or rollback a transaction. During a trans- action, a client can read and update multiple documents. Isolation is achieved by locking documents (i.e., it takes pes- simistic concurrency control). </span></p><p class="c6"><span class="c1">One big limitation in the current TokuMX version is it does not support a multi-statement transaction for sharded document collections (i.e., partitioned data). </span></p><p class="c6"><span class="c1">Our Entity DB implementation uses a cluster of inde- pendent TokuMX servers and partition data based on the group key. It emulates sharded MongoDB with application- level request routing. Since a transaction for one group key is always executable with a single server, we can employ TokuMX&rsquo;s multi-statement transaction. </span></p><p class="c185"><span class="c1">This implementation has a limitation when it is used in practice: it does not support rebalancing of partitions (or &ldquo;chunks&rdquo; in MongoDB&rsquo;s terminology), which is one of the most important feature of NoSQL to provide elasticity. </span></p><p class="c193"><span class="c31">4.4.2 Java Persistence API </span></p><p class="c48"><span class="c1">The Strudel framework includes an implementation of En- tity DB API using JPA so that a benchmark on Entity DB can run on any RDBMSs as long as it supports JPA. It is straightforward to implement Entity DB API using JPA since most of the features of Entity DB have the direct coun- terpart in JPA. </span></p><p class="c81"><span class="c1">The implementation automatically translates a secondary key access to a query in JP QL, JPA&rsquo;s standard query lan- guage (which is then translated to SQL of a specific RDBMS). </span></p><p class="c6"><span class="c1">In order to optimize physical design of the database, the developer can use any other JPA annotations. For exam- ple, selection of indices is an independent decision from the secondary key access specification (</span><span class="c10">@Indexes</span><span class="c1">) of Entity DB API: the developer specifies indices using the standard JPA (i.e., </span><span class="c10">indexes </span><span class="c1">attribute of </span><span class="c10">@Table </span><span class="c1">annotation). </span></p><p class="c14"><span class="c50">584 </span></p><p class="c170"><span class="c31">4.4.3 Native Implementations </span></p><p class="c30"><span class="c1">Our framework lets the developer implement a custom way to map entity access to a specific NoSQL system. We expect a future version of Strudel include such custom im- plementations for popular NoSQL systems. </span></p><p class="c65 c45"><span class="c1">For example, by mapping parent-child relationship to a specific data model supported by a NoSQL system, we can eliminate some of the indices specified in </span><span class="c10">@Indexes </span><span class="c1">as fol- lows:</span><span class="c37">Nested data structure Various NoSQL systems, such </span><span class="c1">as HBase and MongoDB, support a nested data structure: HBase&rsquo;s column family can be used to represent a set of child records (e.g., a set of bid records on a particular auc- tion item). MongoDB&rsquo;s data model is a document, allowing to group entities in a flexible manner. If the secondary key to access is the parent key (e.g., </span><span class="c10">auctionItemId </span><span class="c1">index in Figure 2), we can retrieve these nested entities in one oper- ation. </span></p><p class="c44"><span class="c1">Range key access. HBase employs range partition to distribute a table and supports a range query on the row ID. By encoding parent-child relationship as a prefix of a row ID, we can efficiently implement a secondary key access (if the secondary key to use is a parent key). </span></p><p class="c106"><span class="c15">5. SESSION WORKLOAD FRAMEWORK </span></p><p class="c30"><span class="c1">Although Entity DB provides a common API which is rea- sonably implementable for many NoSQL systems, it is often too restrictive for a specific NoSQL system or an RDBMS, which have more advanced features that can contribute to higher application workload performance. </span></p><p class="c65 c45"><span class="c1">We provide another abstraction layer, Session Workload, at an application level for session-oriented workloads so that developers can create benchmarks that can run various data access APIs besides Entity DB API. </span></p><p class="c44"><span class="c1">The Session Workload framework enables developers to build workloads that emulate interactive applications in a similar way to TPC-W [11] (emulating e-commerce) and RUBiS [8] (emulating auction) benchmarks. </span></p><p class="c9"><span class="c1">Emulated user interaction for each user is called a session, which consists of a sequence of actions (called interactions). An interaction is a unit of the application&rsquo;s work, which is a predefined data accessing procedure without user inter- vention (one interaction may execute multiple transactions to perform a unit of work). A user issues a request for an interaction one by one (with optional intervals called &ldquo;think time&rdquo;). A user behavior is modeled as a state transition and the next interaction request is chosen based on the prede- fined probability and the results of the previous interactions. The Session Workload framework makes the benchmark code reusable and customizable through the following fea- tures: (1) Interaction interface that separates data access logic and other part of benchmark code, and (2) highly con- figurable parameters including state transition definitions. </span><span class="c15">5.1 Interaction Interface </span></p><p class="c30"><span class="c1">Figure 5 shows the interface for interactions. An inter- action must implement three parts: </span><span class="c10">prepare</span><span class="c1">, </span><span class="c10">execute</span><span class="c1">, and </span><span class="c10">complete</span><span class="c1">. When an execution engine runs one interaction, it calls these three methods in this order. </span></p><p class="c65 c45"><span class="c1">The </span><span class="c10">prepare </span><span class="c1">operation is to generate a parameter that indicates a specific action that the interaction will take in the next </span><span class="c10">execute </span><span class="c1">operation. Typically, this operation emulates a thinking process of a human for this interaction (i.e. not </span></p><p class="c22 c79"><span class="c1">the application side procedure). For example, an auction benchmark emulates how a bid price is decided given the current session state (e.g., information on the auction item retrieved in the past interactions). </span></p><p class="c6"><span class="c1">The </span><span class="c10">execute </span><span class="c1">operation implements the actual action that accesses the data. Given the parameter (</span><span class="c10">param</span><span class="c1">) generated by </span><span class="c10">prepare </span><span class="c1">and the data access API (</span><span class="c10">db</span><span class="c1">), the method per- forms transactions with the data store. </span></p><p class="c41"><span class="c1">The </span><span class="c10">complete </span><span class="c1">operation defines how the session state is modified based on the result of </span><span class="c10">execute </span><span class="c1">operation. For ex- ample, to emulate a human&rsquo;s browsing activities on a web application, the result of a browsing interaction includes a list of retrieved items. The </span><span class="c10">complete </span><span class="c1">operation may choose one of such items as &ldquo;current item of interest&rdquo; (i.e. part of the state). The modified state is used in the following inter- action, which may take an action on the chosen item (e.g., placing a bid). </span></p><p class="c165"><span class="c26">public interface Interaction &lt;T&gt; </span><span class="c3">{ </span></p><p class="c19"><span class="c26">void prepare(ParamBuilder paramBuilder); Result execute(Param param, T db, </span></p><p class="c137"><span class="c26">ResultBuilder res ); void complete ( StateModifier modifier ); </span><span class="c3">} </span></p><p class="c73"><span class="c1">Figure 5: Interface for Interaction </span></p><p class="c56 c145"><span class="c1">We designed to split these methods so that we can imple- ment a benchmark in a reusable manner for multiple data access APIs, as we describe in the following. </span></p><p class="c6"><span class="c1">Generic Interaction Interface The Interaction inter- face employs Java&rsquo;s Generics to parameterize a data access API and reuse the benchmark code as much as possible. In Figure 5, the type variable </span><span class="c10">T </span><span class="c1">corresponds to a class of data access API (e.g., EntityDB and JPA&rsquo;s EntityManager). The application code can be written agnostic to a specific data access API as long as it does not need to know what </span><span class="c10">T </span><span class="c1">actu- ally is. For example, the prepare method does not have to know if an interaction is used with EntityDB or any other API.</span><span class="c37">Abstract Interaction Classes To make a benchmark </span><span class="c1">reusable for many data access methods, a developer is en- couraged to create an abstract interaction class for each in- teraction in the benchmark. An abstract interaction class implements two methods of the interface, </span><span class="c10">prepare </span><span class="c1">and </span><span class="c10">com- plete</span><span class="c1">, and lets its sub-class implement the remaining </span><span class="c10">exe- cute </span><span class="c1">method. </span></p><p class="c117 c126"><span class="c1">In the benchmarks we have developed, we implement both EntityDB and EntityManager (JPA) versions of interactions. These two implementations share majority of the benchmark code (e.g., entity definitions, data generation, workload pa- rameter generation, state transition) (see Section 8.6 for de- tails). </span><span class="c15">5.2 Session State Transition </span></p><p class="c48"><span class="c1">A benchmark workload based on the Session Workload framework can be easily customized for a specific experi- ment. A state transition model that emulates a user behav- ior is given at run-time as an XML data. Figure 6 shows an example of an XML element (</span><span class="c10">session</span><span class="c1">) that contains state transitions (</span><span class="c10">transitions</span><span class="c1">). The </span><span class="c10">session </span><span class="c1">element typically contains various other parameters that take part of the ses- sion state in order to customize behavior of the interactions. </span></p><p class="c14"><span class="c50">585 </span></p><p class="c183"><span class="c24">&lt;session&gt; </span></p><p class="c72"><span class="c24">&lt;packageName . . . /&gt; &lt;Transitions&gt; </span></p><p class="c118"><span class="c24">&lt;t r a n s i t i o n name=&rdquo;START&rdquo;&gt; </span></p><p class="c70"><span class="c24">&lt;next name=&rdquo;HOME&rdquo;/&gt; &lt;/transition&gt; &lt;t r a n s i t i o n name=&rdquo;HOME&rdquo;&gt; </span></p><p class="c172"><span class="c24">&lt;next name=&rdquo;SELL AUCTION ITEM&rdquo; prob=&rdquo; 0 . 2 &rdquo;/&gt; &lt;next name=&rdquo;SELL SALE ITEM&rdquo; prob=&rdquo;0.1 &rdquo;/&gt; &lt;next name=&rdquo;VIEW AUCTION ITEMS BY SELLER&rdquo; prob=&rdquo;0.1 &rdquo;/&gt; &lt;next name=&rdquo;VIEW SALE ITEMS BY SELLER&rdquo; prob=&rdquo;0.1 &rdquo; /&gt; &lt;next name=&rdquo;VIEW AUCTION ITEMS BY BUYER&rdquo; prob=&rdquo; 0 . 1 &rdquo;/&gt; &lt;next name=&rdquo;VIEW SALE ITEMS BY BUYER&rdquo; prob=&rdquo;0.1 &rdquo;/&gt; &lt;next name=&rdquo;VIEW BIDS BY BIDDER&rdquo; prob=&rdquo;0.1 &rdquo;/&gt; &lt;next name=&rdquo;VIEW WINNING BIDS BY BIDDER&rdquo; prob=&rdquo;0.1 &rdquo;/&gt; &lt;n e x t name=&rdquo;END&rdquo; p r o b=&rdquo; 0 . 1 &rdquo;/&gt; &lt;/transition&gt; &lt;t r a n s i t i o n name=&rdquo;SELL AUCTION ITEM&rdquo;&gt; </span></p><p class="c164"><span class="c24">&lt;next name=&rdquo;HOME&rdquo;/&gt; &lt;/transition&gt; </span></p><p class="c176"><span class="c1">Figure 6: State transition in XML </span></p><p class="c104"><span class="c15">5.3 Benchmarks </span></p><p class="c46"><span class="c1">The current Strudel also includes example implementa- tions of benchmarks for micro-level and application-level ex- periments on top of the Session Workload framework. </span></p><p class="c115"><span class="c1">Micro Benchmark The Micro benchmark emulates a simplified user content management application in order to serve as a microbenchmark. The data and workload scale in terms of user IDs. To represent different patterns of user data access, the user content consists of the following four types of entities: </span></p><p class="c89"><span class="c1">&bull; personal items represent content privately owned by individual users. Each user has a set of items as one entity group (i.e., the number of groups scales as the number of users). An item is only read and written by its owner. </span></p><p class="c33"><span class="c1">&bull; shared items represent shared content written and read by the users. Items are grouped into multiple entity groups associated with set IDs (which give another scaling factor besides the user IDs). </span></p><p class="c68"><span class="c1">&bull; public items represent individual users&rsquo; content that are open to the public for reading. An item is only written by its owner but can be read by other users. </span></p><p class="c27"><span class="c1">&bull; message items represent content exchanged from one user to another, having a sender ID and a receiver ID. </span></p><p class="c134"><span class="c1">The benchmark defines various read-write and read-only interactions for each type of entities. A developer can com- pose a workload by creating a state transition that includes any subset of these interactions. By mixing interactions on these four types of entities, a developer can emulate the need of a specific application to some degree without coding a new benchmark. </span></p><p class="c54"><span class="c1">In Section 8, we use personal items and shared items to demonstrate various scenarios of transaction performance analyses. </span></p><p class="c54"><span class="c1">Auction Benchmark For application-level benchmarks, we have implemented an auction benchmark, which is sim- ilar to AuctionMark in OLTP-Bench [6] and RUBiS bench- mark [8] but customized to use entity groups. The Bid entity in Figure 2 is part of this benchmark (shown after omitting some detailed code). </span></p><p class="c143"><span class="c15">6. CONFIGURATION DESCRIPTION LAN- </span></p><p class="c96"><span class="c15">GUAGE </span></p><p class="c22 c39"><span class="c1">The Strudel framework provides abstraction layers to sep- arate a benchmark application into various customizable pieces from a data access API implementation of a spe- cific data store to a parameter generation of a benchmark workload. In order to combine these pieces together as one specific benchmark experiment, we employ a configuration description language that is similar to ones used for sys- tem component deployment in Grid and cloud infrastruc- tures [13, 24, 7]. We have separately released this language as open source software called Congenio [1]. </span></p><p class="c7"><span class="c1">Our XML-based language supports the following features: (1) inheritance (</span><span class="c10">@extends </span><span class="c1">attribute), (2) document unfold- ing (</span><span class="c10">foreach </span><span class="c1">element), (3) reference resolution (</span><span class="c10">@ref </span><span class="c1">at- tribute), and (4) value expression (See the web site [1] for more details of the language). </span></p><p class="c7"><span class="c1">With </span><span class="c10">@extends</span><span class="c1">, an experiment document can refer to ex- isting templates (that define various components such as benchmarks and data stores) and customize the default val- ues of these templates. With </span><span class="c10">foreach </span><span class="c1">elements, an exper- iment document can generate a set of documents, each of which corresponds to one workload execution with a specific set of parameters. Figure 7 illustrates such an experiment document to run an auction benchmark on HBase with dif- ferent number of data servers (5, 10) and different workload scales (i.e. the number of users and worker servers). </span></p><p class="c116"><span class="c24">&lt;jobSuite&gt; </span></p><p class="c189"><span class="c24">&lt;f o r e a c h name=&rdquo; s c a l e &rdquo;&gt; </span></p><p class="c124"><span class="c24">&lt;s&gt;&lt;w&gt;1&lt;/w&gt;&lt;u&gt;10000&lt;/u&gt;&lt;/ s&gt; &lt;s&gt;&lt;w&gt;2&lt;/w&gt;&lt;u&gt;20000&lt;/u&gt;&lt;/ s&gt; &lt;s&gt;&lt;w&gt;4&lt;/w&gt;&lt;u&gt;40000&lt;/u&gt;&lt;/ s&gt; &lt;/foreach&gt; &lt;f o r e a c h name=&rdquo; s e r v e r &rdquo; s e p=&rdquo; &rdquo;&gt;5 10&lt;/foreach&gt; &lt;job extends=&rdquo;auction</span><span class="c74">&minus;</span><span class="c24">hbase &rdquo;&gt; </span></p><p class="c153"><span class="c24">&lt;workerNum r e f=&rdquo; s c a l e /w&rdquo;/&gt; &lt;serverNum ref=&rdquo;server&rdquo;/&gt; &lt;userNum r e f=&rdquo; s c a l e /u &rdquo;/&gt; &lt;/job&gt; &lt;/jobSuite&gt;</span><span class="c37">Figure 7: Job definition in XML </span></p><p class="c39 c92"><span class="c1">The definition of an experiment in Figure 7 refers to a spe- cific job template as illustrated in Figure 8. A job template combines various components including a workload (bench- mark), database (access to data stores), and cluster (worker servers that run workloads). </span></p><p class="c94"><span class="c24">&lt;job&gt; </span></p><p class="c67"><span class="c24">&lt;workerNum&gt;1&lt;/workerNum&gt; &lt;serverNum&gt;1&lt;/serverNum&gt; &lt;userNum&gt;10000&lt;/userNum&gt; &lt;threadsPerWorker&gt;200&lt;/threadsPerWorker&gt; &lt;cluster extends=&rdquo;cluster&rdquo;&gt; ...&lt;/cluster&gt; &lt;database extends=&rdquo;tkvs</span><span class="c74">&minus;</span><span class="c24">hbase &rdquo;&gt; </span></p><p class="c57"><span class="c24">&lt;name&gt;auction&lt;/name&gt; </span></p><p class="c182"><span class="c24">... &lt;/database&gt; &lt;workload&gt; </span></p><p class="c159"><span class="c24">&lt;s e s s i o n e x t e n d s=&rdquo; s e s s i o n </span><span class="c74">&minus;</span><span class="c24">auction &rdquo;&gt; </span></p><p class="c175"><span class="c24">&lt;numOfThreads ref=&rdquo;threadsPerWorker&rdquo;/&gt; </span></p><p class="c69"><span class="c24">... &lt;/session&gt; &lt;measure&gt; ... &lt;/measure&gt; &lt;/workload&gt; &lt;report&gt; ...&lt;/report&gt; &lt;/job&gt; </span></p><p class="c166"><span class="c1">Figure 8: Example of job composition </span></p><p class="c92 c39"><span class="c1">When the execution platform (Section 7) runs an exper- iment with a given job definition, it records a document after inheritance resolution along with other information </span></p><p class="c14"><span class="c50">586 </span></p><p class="c8"><span class="c1">(measured results, etc.). After inheritance resolution, the document includes all the information imported from other documents (referred to by </span><span class="c10">@extends</span><span class="c1">). This is very useful to reproduce the same experiments. In our lab, we use a version control system (git) to commit this document and experiment results together in the same version. </span></p><p class="c123"><span class="c15">7. EXECUTION PLATFORM </span></p><p class="c23 c45"><span class="c1">Strudel&rsquo;s execution platform consists of the workload man- ager and a cluster of workers. </span></p><p class="c65 c45"><span class="c1">The workload manager starts with a given job definition XML file (in the configuration description language) and in- teracts with worker servers as well as servers of SQL/NoSQL systems. The workload manager has the following features: </span></p><p class="c112"><span class="c1">&bull; server configuration and start-up (invoking external scripts for NoSQL/SQL systems). </span></p><p class="c127"><span class="c1">&bull; data generation and population </span></p><p class="c163"><span class="c1">&bull; workload control and workflow management </span></p><p class="c150"><span class="c1">&bull; performance monitoring (JMX) and aggregation of the reports from workloads. </span></p><p class="c35"><span class="c1">&bull; performance reporting as JSON files. </span></p><p class="c105"><span class="c1">The Strudel framework does not include the individual scripts to configure and start/stop servers since it depends on the infrastructure (e.g., whether the system is deployed on the cloud platform, a Hadoop cluster, or a simple cluster servers mounting a shared file system). </span></p><p class="c45 c65"><span class="c1">The actual workload is run by a cluster of worker nodes that receive a workload definition from the workload man- ager. A worker is a workload execution engine that is de- ployed on a cluster of server machines. The workload man- ager coordinates a cluster of workers to run a benchmark workload in a scalable manner (a large number of threads) to put enough load on a scalable data store. </span></p><p class="c65 c45"><span class="c1">The Session Workload is one type of workloads the workers can run. It can run any custom workloads if they implement a workload interface defined in the Strudel framework. For example, it should be easy to develop a special workload that runs the YCSB benchmark. </span></p><p class="c162"><span class="c15">8. DEMONSTRATION </span></p><p class="c98 c100 c45"><span class="c1">In this section, we demonstrate some use cases of Strudel to conduct performance experiments. Notice that the objec- tive of the following experiments is not a formal performance study to state any conclusive claims on a particular data store but a demonstration of the features of our framework. </span><span class="c15">8.1 System Settings </span></p><p class="c23"><span class="c1">In our experiments, we use the following settings. HBase [2] We use HBase version 1.1.1 on top of Hadoop version 2.7.1. HBase servers consist of a single master server (which manages the entire system and metadata) and a set of region servers (which manages data partitions (i.e., re- gions)). In the experiments, we mean the number of region servers by the number of data servers. A region server is col- located with Hadoop HDFS data node (to maximize locality of I/O). The name node of HDFS is located separately in a dedicated server. HBase also requires ZooKeeper processes to achieve coordination across servers. We use 3 ZooKeeper </span></p><p class="c58 c79"><span class="c1">processes collocated with the master server and two of the region servers. </span></p><p class="c6"><span class="c1">Omid [5] We use version 0.8.0. Omid works with HBase and we use the same setting for HBase as the HBase-only data store. Omid supports multiple ways to persist trans- action status for recovery. We use the default of the cur- rent version: storing the states on HBase. We use the same HBase cluster with the application (benchmark) workloads. In the experiment, we use only one Omid server and the number of data server refers to the number of region servers as in the case of the HBase-only setting. </span></p><p class="c6"><span class="c1">MongoDB [3] MongoDB&rsquo;s version is 3.0.5. To employ sharding (horizontal data partitioning), we need to deploy 3 config servers (just like ZooKeeper for HBase) and a set of shard servers (which we refer to by &ldquo;data servers&rdquo; in the experiments). We also need &ldquo;mongos&rdquo; servers that route ap- plications&rsquo; requests to appropriate shard servers. We deploy one mongos server for each worker server as it is a common use case to collocate a mongos server with an application server. </span></p><p class="c41"><span class="c1">TokuMX [10] For TokuMX we use version 2.0.1. As men- tioned in Section 4.4, when we use multi-statement trans- action with TokuMX, we cannot use sharding (automated partitioning). So we deploy a set of independent single-node TokuMX servers (which we call &ldquo;data servers&rdquo;), and let our EntityDB implementation route data access to these servers (emulating the application-level sharding). </span></p><p class="c110"><span class="c1">MySQL [4] For experimenting JPA-based implementa- tion of benchmarks, we use MySQL (Ver 14.14 Distrib 5.1.73) with default settings. We only use a single server MySQL in this demo. </span></p><p class="c6"><span class="c1">Server machines. We use cluster machines in our lab with the following features: CentOS 6.6 (Linux 2.6.52), Intel Xeon E5620 2.40 GHz 16 core CPU , 16GB 1333 MHz RAM, Intel Pro2500 SATA SSD 240GB. Some OS parameters (e.g., the maximum number of open files) are set as data store providers recommend. </span></p><p class="c171"><span class="c15">8.2 Data Store Scalability </span></p><p class="c48"><span class="c1">First, we demonstrate a simple workload running on var- ious data stores and show how these stores scale with an increasing number of data servers. </span></p><p class="c6"><span class="c1">Based on the Micro benchmark, we composed a work- load executing a single interaction that updates 4 personal items in the same group (which is randomly chosen from 1 M groups). We configure the workload so that transactions never conflict with each other: Each execution thread ran- domly chooses one user ID from an individual pool that is disjoint from the pools of other threads and uses the ID to choose a group (that belongs to this user). </span></p><p class="c32"><span class="c1">We measure the throughput of the workloads using 1600 session concurrency (16 workers each of which runs 100 threads that keep running the update interaction without think time) for different data stores (except Omid) with changing the number of data servers (3, 5, 10). We made sure that the throughput is saturated (i.e., increasing session concurrency does not increase the throughput). </span></p><p class="c6"><span class="c1">For Omid, we needed a larger number, 10800 (36 workers and 300 threads per worker), of concurrency to saturate the same number of data stores: Because one interaction takes longer time, a larger concurrency is needed to generate a suf- ficient number of read/write operations on the data stores. Using the Omid transaction server with HBase adds some </span></p><p class="c14"><span class="c50">587 </span></p><p class="c8"><span class="c1">overhead (longer response time for each interaction and a larger number of data servers to achieve a throughput num- ber) but it does not limit scalability at least for 10 region servers. </span></p><p class="c65 c45"><span class="c1">For MySQL we show the result of the JPA-based imple- mentation (the figure has only one bar for a single server MySQL execution). We also ran the same workload on the Entity DB-based implementation but it did not show any significant performance difference for this simple work- load (hence, it is omitted). In fact, these two implementa- tions would generate the same SQL queries. Notice that the throughput of MySQL is good as a single data server: A 3- node NoSQL system does not achieve the same throughput per data server. This observation is consistent with [20], which reports the superior efficiency of an RDBMS com- pared to NoSQL stores. If the application workload can fit with a single data server, an RDBMS might be the most cost effective approach. If elasticity (dynamic re-balancing of partitions) is not required, purchasing a parallel RDBMS product may pay off for its efficiency. </span></p><p class="c44"><span class="c1">In this demonstration, we did not cover parallel RDBMS products but it would be easy to run the same workload as long as the product is given with JPA support. </span></p><p class="c13"><span class="c1">Figure 9: Throughput of item update interactions (4 items per interaction, 1600 concurrent sessions) on different number of data servers. </span></p><p class="c90"><span class="c15">8.3 Transaction Concurrency </span></p><p class="c30"><span class="c1">The result of the previous experiment demonstrates effi- ciency of a lightweight implementation of entity-group trans- action with a simple check-and-update (HBase) compared to an approach with an additional transaction server (Omid). One drawback of this approach is that there is no concur- rency allowed within a group (i.e., concurrent updates on the same group will fail). In many applications, this may not be a problem: when a group is associated with an in- dividual user, a single user would not issue a large number of concurrent transactions. However it would not be always the case (e.g., auction bidding). </span></p><p class="c44"><span class="c1">The next experiment we demonstrate is to see the trade-off between HBase (single-row transaction) and Omid (multi- row transaction) in terms of transaction concurrency. We use a workload that updates one shared item randomly cho- sen from a randomly chosen group. We fix the total number of items (80K) and change the size of group (400, 40, 4 items per group). From the viewpoint of the Omid trans- action manager, these cases are identical (no difference be- </span></p><p class="c22 c154"><span class="c1">Figure 10: Throughput under different transac- tion concurrency: 3200 concurrent sessions, 5 data servers, 1 update/interaction, 80K items in G shared groups (K items/group) </span></p><p class="c12"><span class="c15">8.4 Transaction Conflict </span></p><p class="c98 c56"><span class="c1">Recall that TokuMX is an enhanced version of MongoDB and supports a multi-statement transaction based on locking of documents (data items). An application developer would wonder how and when this feature should be used. One interesting experiments using our framework would be com- parison between optimistic concurrency control with Mon- goDB (single-document transactions) and pessimistic con- currency control with TokuMX (multi-document transac- tions). </span></p><p class="c6"><span class="c1">At high-level, we know a rule of thumb, which is to take a pessimistic approach when conflict will likely happen in order to avoid unnecessary re-computation. But it always depends on a specific case. </span></p><p class="c41"><span class="c1">In this example, a workload consists of a single interac- tion that updates 4 items in a randomly chosen group. The difference from the experiments in Figure 9 is that there are (varying degrees of) conflicts. We use 3200 concurrent ses- sions that update items in 3200 groups under the following three conditions: (1) 400 personal items per group: each thread will keep updating its own group (i.e., no conflict), (2) 400 shared items per group: each thread will randomly choose one of 3200 groups and choose 4 from 400 items (i.e., mild conflict), (3) 40 shared items per group: each thread </span></p><p class="c22 c79"><span class="c1">tween intra-group and inter-group). But for HBase, the to- tal number of groups will decide the concurrency limit of the workloads (if two transaction updates different items in the same group, they will conflict with each other and only one can be successful). The result with 3200 concurrent sessions on 5 data servers (region servers) is shown in Figure 10. As the number of groups becomes smaller, HBase&rsquo;s throughput degrades and becomes worse than Omid. </span></p><p class="c59"><span class="c1">It is beneficial to use a transaction server when the con- currency within a group needs to be high, even if it adds significant extra overhead (additional commit processing) compared to the main part of transaction (amount of read- /write), </span></p><p class="c85"><span class="c1">In a real application development setting, developers will need to manage the trade-off by building workloads to em- ulate the application&rsquo;s needs and conducting similar exper- iments. </span></p><p class="c86"><span class="c50">588 </span></p><p class="c8"><span class="c1">will randomly choose one of 3200 groups and choose 4 from 40 items (i.e., heavy conflict). The results are shown in Fig- ure 11. </span></p><p class="c44"><span class="c1">We notice the difference besides the concurrency control in the two versions: they are also different in allowed trans- action concurrency (just like HBase and Omid). The Mon- goDB version of entity group transaction cannot have con- currency within a group. Hence, we do not see the difference between the case 2 and 3 for MongoDB. Their throughput values are almost equal to each other and are much lower than the throughput in the case 1. </span></p><p class="c9"><span class="c1">On the other hand, the TokuMX version employ a lock for each item (i.e., document) and it looks very effective in the case 2 showing only slight degradation from the case 1. However, the behavior of the TokuMX version is quite different in the case 3, showing a very low performance. In fact most of the transactions fail due to either deadlock or failure to acquire a lock, and these transaction will keep retrying until they finish successfully. </span></p><p class="c65 c45"><span class="c1">To compare optimistic and pessimistic concurrency con- trol under heavy conflict, there is a fundamental difference in the cost of retrying transactions. In this particular case of optimistic concurrency control using CAS operations, the conflict relationship among transactions is very simple and there will be no deadlock: i.e., at least one of the conflicting transactions will &ldquo;win.&rdquo; Although retrying involves ineffi- ciency, there is always progress in the computation. On the other hand, the pessimistic concurrency control may suffer from deadlock, in which case nobody wins. Thus, to ensure progress of the computation, the execution threads need to back off and wait longer time before retrying In fact, the above result is after tuning the back-off policy using config- uration options provided by the Strudel framework. </span></p><p class="c78"><span class="c1">Figure 11: Throughput under different degree of conflict: 3200 concurrent sessions, 5 data servers, 4 updates/interaction over 3200 shared/personal groups </span></p><p class="c45 c99"><span class="c1">When it is very cheap to retry a transaction, the opti- mistic concurrency control can be an easier approach. In a practical setting, employing pessimistic concurrency control might be tricky in a cluster environment (especially when the system is built with open-source components and de- ployed on the cloud platform). Careful performance analysis is necessary to validate if it is really worth employing. The best approach would depend on the requirement of a specific application, and our tool can help the developer to explore </span></p><p class="c58 c79"><span class="c1">Figure 12: Throughput of auction benchmark with different session concurrency on different data stores </span></p><p class="c108"><span class="c1">In this experiment, we increase the session concurrency from 200 to 3200 (200 threads per worker server) without think time on the same number of data servers (10 for HBase and 1 for MySQL). The number of users (and the size of the data set) is made proportional to the session concurrency (50 users per thread). The throughput of the workload is visualized in Figure 12. </span></p><p class="c28"><span class="c1">Another observation is that the JPA-based version per- forms better than Entity DB-based version on MySQL when the session concurrency is small, whereas the upper limit of throughput does not seem much different between these two implementations. </span></p><p class="c6"><span class="c1">To see more detail of the efficiency of interaction execu- tion, Figure 13 visualizes the average response time of in- dividual interactions when the session concurrency is small (200). For the purpose of presentation, we only visualize 5 interactions picked up from 15 interactions used in the workload. </span></p><p class="c41"><span class="c1">First, we observe the response time of two read-write in- teractions: sell-auction-item and store-bid. One noticeable point is that the store-bid interaction takes much longer time than the sell-auction-item on HBase (whereas the sell- auction-item performs similarly among three data stores). </span></p><p class="c58 c122"><span class="c1">various options. </span></p><p class="c40"><span class="c15">8.5 Application-level Performance </span></p><p class="c48"><span class="c1">To demonstrate a scenario of an application-level perfor- mance analysis, we compare HBase and MySQL using the auction benchmark. For MySQL we use two benchmark implementations based on Entity DB API and JPA, respec- tively. </span></p><p class="c41"><span class="c1">The JPA version of auction benchmark uses join queries when they are applicable. For example, in an interaction that shows the information on all the bidding by a particular bidder, the tables of items and bids are joined together. In the auction workload, all the interactions that use join are read-only, and the number of tables joined is always 2. </span></p><p class="c82"><span class="c1">As expected, HBase is scalable for an increasing number of concurrent user sessions. One observation, however, is that its throughput values are lower than the values of a single MySQL server when the number of concurrent sessions is small. This implies that MySQL&rsquo;s execution of interactions with SQL is more efficient than executing the same interac- tions with put/get operations of HBase. </span></p><p class="c107"><span class="c50">589 </span></p><p class="c130"><span class="c1">Figure 13: Response time of different interaction types in auction benchmark on different data stores (session concurrency = 200) </span></p><p class="c100 c111"><span class="c1">The store-bid interaction creates one Bid entity and updates one AuctionItem entity in one transaction (i.e. updating one row). In fact, however, creating one Bid involves two addi- tional row updates for out-of-group auxiliary data items: a key-generation counter and an index on the bidder id. On the other hand, key-generation and index maintenance are internal operations for MySQL, adding only negligible over- head.</span><span class="c37">We see much larger difference between HBase and MySQL </span><span class="c1">for read-only interactions. We picked up three read-only interactions to represent three types of queries: (1) view- auction-items-by-seller gets auction items with a secondary key (the user ID of a seller). It illustrates different use of an index in Entity DB and JPA, (2) view-bids-by-bidder gets bids by a particular bidder as well as the corresponding auc- tion items. The JPA-version uses a two-table join query with Bid and AuctionItem, (3) view-winning-bids-by-bidder gets bids by a particular bidder that won the auction items. The JPA-version uses a two-table join query with additional filtering conditions. </span></p><p class="c65 c45"><span class="c1">The view-auction-items-by-seller interaction reveals the difference in HBase and MySQL Entity DB: MySQL uses its internal index mechanism to implement Entity DB&rsquo;s sec- ondary key access, which is more efficient than an index object implemented on top of HBase. For this interaction, MySQL uses the same SQL for Entity DB version and JPA version (hence similar performance). </span></p><p class="c45 c62"><span class="c1">The view-bids-by-bidder interaction takes much longer time in Entity DB versions (MySQL and HBase) compared to the JPA-based implementation that uses a join query. However, the JPA-based implementation did not gain further benefit by adding filtering conditions for the view-winning-bids-by- bidder. </span></p><p class="c65 c45"><span class="c1">In a real development case, we need to take response time requirements for individual interactions to choose an imple- mentation strategy. For example, 200 milliseconds for the view-bids-by-bidder interaction of HBase in the figure might not be acceptable for an interactive web application. The current implementation of this interaction executes a nested loop of get operations to emulate a join of Bid and Auc- tionItem. A possible improvement is to issue get operations asynchronously to hide latency of individual get responses. </span><span class="c15">8.6 Code Reusability </span></p><p class="c58 c140"><span class="c1">In addition to the above experiment scenarios, we also demonstrate the reusability of the code enabled by the Strudel framework. </span></p><p class="c160"><span class="c26">TKVS HBase Omid MongoDB TokuMX 3130 (36) 796 (6) 454 (4) 680 (4) 507 (4) </span></p><p class="c56 c191"><span class="c1">Table 2 shows the size of components to implement Auc- tion and Micro benchmarks. The labels entity, param, and base correspond to definition of entity objects, parameters used in session interactions, and abstract interaction classes (Section 5), respectively. The remaining two columns, En- tity DB and JPA, are components specific to data access APIs. The table does not include XML files that define ses- sion state transitions, which are part of configuration the developer can customize for specific experiments. The ses- sion state transition is agnostic to data access APIs. </span></p><p class="c79 c125"><span class="c1">Table 2: The size of benchmark components: lines of code (number of classes) </span></p><p class="c155"><span class="c26">entity param base Entity DB JPA Auction 943 (9) 202 (3) 1346 (17) 1090 (18) 1043 (17) Micro 681 (8) 212 (4) 1004 (19) 931 (19) 985 (19) </span></p><p class="c56 c192"><span class="c1">Notice that a more important point than the number of lines is separation of concerns achieved by the framework. For example, the benchmark components that are specific to data access APIs only need to implement individual data reads and writes that appear in the interactions. </span><span class="c15">8.7 Other Scenarios </span></p><p class="c48"><span class="c1">Besides the scenarios the above demonstration covers, we have also used the Strudel framework for our research and development in a more customized manner. We developed custom components for our proprietary systems to run var- ious experiments, including: (1) elasticity analysis to eval- uate dynamic server scaling out (using a custom workflow that invokes various scripts to control data migration while a workload is running), (2) evaluation of bulk-loading APIs of NoSQL systems (using a custom workload that is not based on the session workload framework). </span></p><p class="c41"><span class="c1">Especially, the elasticity analysis is essential to evaluate NoSQL systems. In a future version, we plan to include a generalized version of our custom components in the frame- work. </span></p><p class="c121"><span class="c15">9. FUTURE WORK </span></p><p class="c56 c180"><span class="c1">We consider the following items in the future version of Strudel: </span></p><p class="c21"><span class="c1">Table 1 shows the size of components to implement the Entity DB interface for each NoSQL store. Each cell con- tains the lines of code and the number of classes (in a paren- thesis). In the table, TKVS refers to the code of Transac- tional KVS (Section 4.4) that is commonly used by every implementation. </span></p><p class="c29"><span class="c1">Table 1: The size of store components: lines of code (number of classes) </span></p><p class="c101"><span class="c50">590 </span></p><p class="c84"><span class="c1">&bull; Extended Entity DB API as a larger subset of JPA to incorporate more powerful query functionality of NoSQL (e.g. MongoDB) such as mapping parent-child entity relationship to a nested document (which en- ables retrieving parent and children together in one operation). </span></p><p class="c102"><span class="c1">&bull; Supporting multi-entity-group transactions on Entity DB API in a generic way to cover various solutions of multi-key transactions on NoSQL systems. </span></p><p class="c179"><span class="c1">&bull; Native EntityDB support of representative NoSQL sys- tems such as HBase and MongoDB (Section 4.4.3). </span></p><p class="c11"><span class="c1">&bull; Better support of online analyses (e.g., an additional framework for scale-out analysis) </span></p><p class="c11"><span class="c1">&bull; Various data/workload generation (e.g. integration with such features from YCSB, OLTP-Bench). </span></p><p class="c18"><span class="c1">&bull; Better and easier integration with underlying infras- tructure (e.g., software containers (e.g., Docker), re- source managers (Hadoop YARN), and cloud platforms) as well as software configuration and deployment tools (e.g., Puppet [7]). </span></p><p class="c100 c45 c136"><span class="c1">In actual applications, scalable transaction support is only part of the data management support. There are other data management features that must be considered: (1) entity search, (2) integration with analytic workloads. In either case, the developer has to choose if these functional- ity should be achieved by the same data store that serves transactions or done by external systems (search engines or analytic stores). Choice of SQL and NoSQL systems must take such features into account, which are beyond the scope of the current framework. </span></p><p class="c161"><span class="c15">10. CONCLUSION </span></p><p class="c17"><span class="c1">We introduce Strudel, a development and execution frame- work for transactional workloads both on SQL and NoSQL systems. Entity DB API provides a way to develop a bench- mark using a common access API that is reasonably im- plementable on various NoSQL systems as well as RDBMS (through JPA). Session Workload framework provides an- other abstraction layer to decouple logic on data access (with a particular access API) from other logic in the benchmark (such as session state transition and parameter generation). We have implemented Entity DB API for various NoSQL systems by introducing a lower level API for transactional key-value access. A future version of the framework will ex- plore custom EntityDB implementation on individual NoSQL systems to exploit advanced features of these systems (such as a query on a nested data structure). </span></p><p class="c187"><span class="c15">11. REFERENCES </span></p><p class="c180 c186"><span class="c1">[1] Congenio: Configuration generation language. </span></p><p class="c38"><span class="c1">github.com/tatemura/congenio. [2] HBase. www.hbase.apache.org. [3] MongoDB. www.mongodb.org. [4] MySQL. www.mysql.com. [5] Omid. github.com/yahoo/omid. [6] Otlp-bench. oltpbenchmark.com. [7] Puppet. puppetlabs.com. [8] RUBiS: Rice university bidding system. rubis.ow2.org. </span></p><p class="c58 c120"><span class="c1">[9] Strudel. github.com/tatemura/strudel. [10] TokuMX. www.percona.com/software/mongo- </span></p><p class="c83 c129"><span class="c1">database/percona-tokumx. [11] TPC-W. www.tpc.org/tpcw. [12] Ycsb. github.com/brianfrankcooper/YCSB. [13] CDDLM configuration description language </span></p><p class="c77"><span class="c1">specification version 1.0. www.ogf.org/documents/GFD.85.pdf, 2006. [14] J. Baker, C. Bond, J. Corbett, and J. J. Furman et al. Megastore: Providing scalable, highly available storage for interactive services. In CIDR, pages 223&ndash;234, 2011. [15] F. Chang, J. Dean, S. Ghemawat, W. C. Hsieh, D. A. Wallach, M. Burrows, T. Chandra, A. Fikes, and R. Gruber. Bigtable: A distributed storage system for structured data. In OSDI, pages 205&ndash;218, 2006. [16] B. F. Cooper, A. Silberstein, E. Tam, </span></p><p class="c117 c138"><span class="c1">R. Ramakrishnan, and R. Sears. Benchmarking cloud serving systems with YCSB. In Proceedings of the 1st ACM Symposium on Cloud Computing, SoCC 2010, Indianapolis, Indiana, USA, June 10-11, 2010, pages 143&ndash;154, 2010. [17] S. Das, D. Agrawal, and A. El Abbadi. Elastras: An elastic, scalable, and self-managing transactional database for the cloud. ACM Trans. Database Syst., 38(1):5:1&ndash;5:45, Apr. 2013. [18] D. E. Difallah, A. Pavlo, C. Curino, and </span></p><p class="c47"><span class="c1">P. Cudr&eacute;-Mauroux. Oltp-bench: An extensible testbed for benchmarking relational databases. PVLDB, 7(4):277&ndash;288, 2013. [19] D. G. Ferro, F. Junqueira, I. Kelly, B. Reed, and </span></p><p class="c77"><span class="c1">M. Yabandeh. Omid: Lock-free transactional support for distributed data stores. In IEEE 30th International Conference on Data Engineering, Chicago, ICDE 2014, IL, USA, March 31 - April 4, 2014, pages 676&ndash;687, 2014. [20] A. Floratou, N. Teletia, D. J. DeWitt, J. M. Patel, and D. Zhang. Can the elephants handle the nosql onslaught? Proc. VLDB Endow., 5(12):1712&ndash;1723, Aug. 2012. [21] P. Helland. Life beyond distributed transactions: an </span></p><p class="c77 c83"><span class="c1">apostate&rsquo;s opinion. In CIDR, pages 132&ndash;141, 2007. [22] J. Klein, I. Gorton, N. Ernst, P. Donohoe, K. Pham, and C. Matser. Performance evaluation of nosql databases: A case study. In Proceedings of the 1st Workshop on Performance Analysis of Big Data Systems, PABS &rsquo;15, pages 5&ndash;10, New York, NY, USA, 2015. ACM. [23] S. Patil, M. Polte, K. Ren, W. Tantisiriroj, L. Xiao, J. L&oacute;pez, G. Gibson, A. Fuchs, and B. Rinaldi. Ycsb++: Benchmarking and performance debugging advanced features in scalable table stores. In Proceedings of the 2Nd ACM Symposium on Cloud Computing, SOCC &rsquo;11, pages 9:1&ndash;9:14, New York, NY, USA, 2011. ACM. [24] R. Sabharwal. Grid infrastructure deployment using </span></p><p class="c4"><span class="c1">smartfrog technology. In Proceedings of the International Conference on Networking and Services, ICNS &rsquo;06, pages 73&ndash;, Washington, DC, USA, 2006. IEEE Computer Society. [25] J. Tatemura, O. Po, W.-P. Hsiung, and H. Hacig&uuml;m&uuml;s. Partiqle: an elastic sql engine over key-value stores. In SIGMOD Conference, pages 629&ndash;632, 2012. </span></p><p class="c147"><span class="c50">591 </span></p></body></html>