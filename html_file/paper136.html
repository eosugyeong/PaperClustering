<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c18{color:#262626;font-weight:700;text-decoration:none;vertical-align:super;font-size:10.5pt;font-family:"Arial";font-style:normal}.c55{margin-left:-17.6pt;padding-top:1.7pt;text-indent:26.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-24.2pt}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Arial";font-style:normal}.c81{margin-left:-26.6pt;padding-top:0.5pt;text-indent:35.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-15.4pt}.c52{margin-left:-17.6pt;padding-top:4.1pt;text-indent:26.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-28.3pt}.c2{margin-left:-17.6pt;padding-top:3.8pt;text-indent:26.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-24.5pt}.c19{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:4.5pt;font-family:"Arial";font-style:normal}.c31{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:13.3pt;font-family:"Arial";font-style:normal}.c30{margin-left:-26.6pt;padding-top:1.7pt;text-indent:35.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-15.4pt}.c11{color:#262626;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:6.3pt;font-family:"Arial";font-style:normal}.c26{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10pt;font-family:"Arial";font-style:normal}.c16{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Arial";font-style:normal}.c20{color:#808080;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Courier New";font-style:normal}.c23{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:16.6pt;font-family:"Arial";font-style:normal}.c47{margin-left:-0.5pt;padding-top:1.7pt;text-indent:63.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-1pt}.c5{color:#0000ff;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Courier New";font-style:normal}.c7{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5pt;font-family:"Courier New";font-style:normal}.c32{margin-left:3.1pt;padding-top:1.7pt;text-indent:60.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-1pt}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Courier New";font-style:normal}.c69{margin-left:-27.4pt;padding-top:74.9pt;text-indent:54pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.2pt}.c41{margin-left:-26.6pt;padding-top:3.8pt;text-indent:35.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18.6pt}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10pt;font-family:"Arial";font-style:normal}.c62{margin-left:-17.6pt;padding-top:4.1pt;text-indent:26.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-24.2pt}.c12{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Arial";font-style:normal}.c67{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:19.9pt;font-family:"Arial";font-style:normal}.c14{margin-left:-26.6pt;padding-top:4.1pt;text-indent:35.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-15.4pt}.c9{margin-left:-27.6pt;padding-top:4.1pt;text-indent:36.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-15.4pt}.c57{margin-left:-26.6pt;padding-top:5.8pt;text-indent:36.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-15.4pt}.c10{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c87{margin-left:-26.6pt;padding-top:1.4pt;text-indent:35.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-15.4pt}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Arial";font-style:normal}.c25{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Times New Roman";font-style:italic}.c48{margin-left:-26.6pt;padding-top:9.1pt;text-indent:36.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-15.4pt}.c74{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Courier New";font-style:normal}.c21{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c43{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c15{margin-left:-19.7pt;padding-top:1.7pt;text-indent:80.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-34.8pt}.c39{margin-left:-16.1pt;padding-top:1.4pt;text-indent:76.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-34.8pt}.c35{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:17.9pt;font-family:"Arial";font-style:normal}.c34{margin-left:-26.6pt;padding-top:9.1pt;text-indent:35.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-15.4pt}.c89{margin-left:-17.6pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-15.6pt}.c40{margin-left:-22.1pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-15.4pt}.c56{margin-left:218.2pt;padding-top:58.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-36.1pt}.c96{margin-left:-2.6pt;padding-top:6.2pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:24.5pt}.c66{margin-left:218.2pt;padding-top:56.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-36.1pt}.c91{margin-left:-4.2pt;padding-top:10.1pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-24.5pt}.c58{margin-left:-13.5pt;padding-top:1.9pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-17.3pt}.c24{margin-left:218.2pt;padding-top:54.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-36.1pt}.c22{margin-left:-14.7pt;padding-top:7.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:85pt}.c95{margin-left:-26.6pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-6.1pt}.c78{margin-left:-6pt;padding-top:136.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:5.4pt}.c13{margin-left:-23.8pt;padding-top:7.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:133.4pt}.c88{margin-left:-14.7pt;padding-top:7.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:74.6pt}.c60{margin-left:-23.8pt;padding-top:20.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:83.4pt}.c27{margin-left:-26.6pt;padding-top:23.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-15.4pt}.c51{margin-left:-17.6pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19pt}.c45{margin-left:-21.8pt;padding-top:8.2pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-9.1pt}.c77{margin-left:-26.6pt;padding-top:14.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:25.6pt}.c37{margin-left:218.2pt;padding-top:53.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-36.1pt}.c92{margin-left:-26.6pt;padding-top:5.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-15.4pt}.c94{margin-left:-26.6pt;padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.8pt}.c59{margin-left:218.2pt;padding-top:53pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-36.1pt}.c17{margin-left:-22.1pt;padding-top:3.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-11.4pt}.c38{margin-left:-4.2pt;padding-top:11.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-24.5pt}.c72{margin-left:-17.6pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-8.6pt}.c33{margin-left:-17.6pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-18.2pt}.c73{margin-left:-17.6pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-20.2pt}.c28{margin-left:-17.6pt;padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:28.1pt}.c84{margin-left:-22.1pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-15.2pt}.c80{margin-left:-22.1pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-10.2pt}.c50{margin-left:-26.6pt;padding-top:22.1pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-15.4pt}.c76{margin-left:-26.6pt;padding-top:8.9pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18.1pt}.c36{margin-left:-26.6pt;padding-top:9.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:122.3pt}.c46{padding-top:1.7pt;text-indent:26.7pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c44{padding-top:1.4pt;text-indent:26.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c82{padding-top:11.8pt;text-indent:26.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c85{padding-top:1.7pt;text-indent:26.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c64{padding-top:22.6pt;text-indent:26.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c68{padding-top:4.1pt;text-indent:26.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c6{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c8{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c61{padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c65{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c53{padding-top:22.3pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c49{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c71{margin-left:-16.1pt;text-indent:76.6pt;margin-right:-34.8pt}.c70{margin-left:-28.2pt;text-indent:55pt;margin-right:-20.9pt}.c29{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c75{margin-left:-22.1pt;margin-right:-6.8pt}.c90{margin-left:-17.6pt;margin-right:-25.4pt}.c63{margin-left:-17.6pt;margin-right:-18.2pt}.c54{margin-left:6.2pt;margin-right:-0.5pt}.c79{margin-left:5pt;margin-right:-1.9pt}.c93{margin-left:-26.6pt;margin-right:-10.4pt}.c86{margin-left:-22.1pt;margin-right:-15.4pt}.c42{margin-left:-17.6pt;margin-right:-24.5pt}.c83{margin-left:1.4pt;margin-right:-18.7pt}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:24pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:14pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c29"><p class="c6"><span class="c25">Industrial and Applications Paper </span></p><p class="c65"><span class="c35">Scalable Public Transportation Queries on the Database </span></p><p class="c6"><span class="c21">Alexandros Efentakis </span><span class="c23">Research Center &ldquo;Athena&rdquo; Artemidos 6 &amp; Epidavrou, </span><span class="c67">efentakis@imis.athena-innovation.gr </span><span class="c23">Marousi 15125, Greece </span><span class="c21">ABSTRACT </span><span class="c3">Recent scientific literature focuses on answering Earliest Ar- rival (EA), Latest Departure (LD) and Shortest Duration (SD) queries in (schedule-based) public transportation net- works. Unfortunately, most of the existing solutions ope- rate in main memory, making the proposed methods hard to scale for larger instances and difficult to integrate in a multi-user environment. This work proposes PTLDB (Pub- lic Transporation Labels on the DataBase), a novel, scalable, pure-SQL framework for answering EA, LD and SD queries, implemented entirely on an open-source database system. Moreover, we formulate four new types of queries targeting public transportation networks, namely the Earliest Arrival and Latest Departure k-Nearest Neighbor (kNN) and One- to-many queries and propose novel ways to efficiently answer them within PTLDB. Our experimentation will show that the proposed solution is fast, scalable and easy to use, mak- ing our PTLDB framework a serious contender for use in real-world applications. </span></p><p class="c6"><span class="c21">Categories and Subject Descriptors </span><span class="c3">H.2.8 [Database Applications ]: Spatial databases and GIS; G.2.2 [Graph Theory]: Graph algorithms </span></p><p class="c6"><span class="c21">General Terms </span><span class="c3">Algorithms, Design </span></p><p class="c6"><span class="c21">Keywords </span><span class="c3">Transportation networks, kNN queries, One-to-many queries </span></p><p class="c6"><span class="c21">1. INTRODUCTION </span></p><p class="c6"><span class="c3">Recent algorithmic advances have been very efficient in solving vertex-to-vertex queries on graphs, for a variety of different graph types and instances. For road networks, la- test papers focused on supporting additional types of shortest- path (SP) queries, including one-to-all (finding SP distances </span></p><p class="c8"><span class="c3">c </span><span class="c16">2016, Copyright is with the authors. Published in Proc. 19th Inter- national Conference on Extending Database Technology (EDBT), March 15-18, 2016 - Bordeaux, France: ISBN 978-3-89318-070-7, on OpenPro- ceedings.org. Distribution of this paper is permitted under the terms of the Creative Commons license CC-by-nc-nd 4.0 </span></p><p class="c8"><span class="c3">from a source vertex s to all other graph vertices) [8, 15], one-to-many (computing the SP distances between the source vertex s and all vertices of a set of targets T) [11, 15], range (find all nodes reachable from s within a given times- pan) [15], many-to-many (calculate a distance table between two sets of vertices S and T) [11] and k-Nearest Neighbor (kNN) queries in [12, 17, 21]. For large-scale networks, the works of [4, 9, 20], proposed methods for solving vertex-to- vertex queries, whereas the works of [16] and [14] deal with more complex queries, such as k-Nearest Neighbor, Reverse k-Nearest Neighbor (RkNN) and one-to-many queries, either on main memory or inside a database. Finally, for schedule- based public transportation networks recent works, either expand existing shortest-path techniques originally used for road networks, or work directly on the provided timetable. Most of the recent methods targeting public transit networks are surveyed in the latest literature overview on transporta- tion networks of [5]. </span></p><p class="c8"><span class="c3">Despite the inherent different characteristics between those three types of graph networks (road, large-scale and public transportation networks), the prevailing technique that ex- cels at all of them is the 2-hop labeling or hub labeling (HL) algorithm of [18],[6], in which we store a two-part label L(v) for every vertex v: a forward label L</span><span class="c0">f</span><span class="c12">(v) and a backward </span><span class="c3">label L</span><span class="c0">b</span><span class="c12">(v). These labels are then used to very fast answer </span><span class="c3">vertex-to-vertex shortest-path queries. This technique has been adapted successfully to (i) road networks [2, 3, 10], (ii) undirected, unweighted graphs in [4, 9, 20] and (iii) has also been extended to public transportation networks in [7] and [23]. The HL method has also been applied success- fully for one-to-many, many-to-many and kNN queries in road networks [11, 12] and kNN and RkNN queries in the context of large-scale networks in [16]. </span></p><p class="c8"><span class="c3">Although hub labeling is an extremely efficient shortest- path technique on main memory, there are very few works that extend those results for secondary storage. HLDB [13] stores the precomputed labels for road networks in a com- mercial database system and translated the hub labeling, vertex-to-vertex distance query to plain SQL commands. Moreover, it showed how to answer kNN queries and k-best via points, again with simple SQL queries. The work of [20] proposed HopDB, a C++ customized solution that utilizes secondary storage during preprocessing for large-scale net- works. Efentakis et al. proposed the COLD framework [14] that stores hub-labels for large-scale networks in an open- source database engine and answers vertex-to-vertex, one- to-many, kNN and RkNN queries, using SQL commands. </span></p><p class="c6"><span class="c3">In this work, we focus on timetable, public transporta- </span></p><p class="c6"><span class="c10">Series ISSN: 2367-2005 527 </span><span class="c74">10.5441/002/edbt.2016.50 </span></p><p class="c76"><span class="c3">tion networks and present a novel database framework that may service several route-planning queries on such networks. Our pure-SQL, PTLDB (Public Transporation Labels on the DataBase) framework, extends the hub labeling tech- nique for public transportation networks, as presented in Timetable Labeling (TTL) [23] and may answer multiple variations (Earliest Arrival, Latest Departure and Shortest- Duration) of vertex-to-vertex queries, entirely within a da- tabase. Moreover, we formulate four new types of route- planning queries for public transit, namely the Earliest Ar- rival and Latest Departure k-Nearest Neighbor (kNN) queries and their one-to-many versions, i.e., namely the Earliest Arrival and Latest Departure one-to-many queries. These newly defined public-transit queries may be very useful for a variety of applications utilizing public transport, such as mobile travel guides, transportation and urban planning or geomarketing applications. Our experimentation will show that the proposed PTLDB framework may answer all those different types of queries efficiently, while its implementation with an open-source database engine makes PTLDB very easy to integrate into existing multi-user, real-world appli- cations. Additionally, each type of query may be answered with a simple SQL command, making our results easily re- producible by anyone. Thus, the PTLDB framework is the only database solution that focuses on public-transportation networks, while ensuring excellent performance that is fast- enough for real-time applications. </span></p><p class="c30"><span class="c3">The outline of the remainder of this work is as follows. Section 2 presents related work. Section 3 describes the novel PTLDB framework and its implementation details. Experiments establishing the benefits of PTLDB are pro- vided in Section 4. Finally, Section 5 gives conclusions and directions for future work. </span></p><p class="c94"><span class="c21">2. BACKGROUND AND RELATED WORK </span><span class="c3">In this section we will present related work, relative to the hub labeling method for directed weighted graphs G(V,E,w), where V is the set of vertices, E &sube; V xV is the set of arcs and w is a positive weight function E &rarr; R</span><span class="c26">+</span><span class="c3">. We will also discuss the latest adaptations of this specific technique for public transportation networks. </span><span class="c21">2.1 Hub Labeling </span></p><p class="c14"><span class="c3">In the 2-hop labeling or Hub Labeling (HL) algorithm of [18, 6], preprocessing stores at every vertex v a forward L</span><span class="c0">f</span><span class="c12">(v) and a backward label L</span><span class="c0">b</span><span class="c12">(v). The forward label L</span><span class="c0">f</span><span class="c12">(v) </span><span class="c3">is a vector of pairs (u, dist(v, u)), with u&isin;V . Likewise, the backward label L</span><span class="c0">b</span><span class="c12">(v) contains pairs (w, dist(w, v)). Ver- </span><span class="c3">tices u and w are denoted as the hubs of v. The generated labels conform to the cover property, i.e., for any s and g, the set L</span><span class="c0">f</span><span class="c12">(s) &cap; L</span><span class="c0">b</span><span class="c12">(g) must contain at least one hub that is </span><span class="c3">on the shortest s &minus; g path. To find the network distance dist(s, g) between any two vertices s and g, a HL query seeks the hub v &isin; L</span><span class="c0">f</span><span class="c12">(s) &cap; L</span><span class="c0">b</span><span class="c12">(g) that minimizes the sum </span><span class="c3">dist(s, v) + dist(v, g). By sorting the pairs in each label by hub, this takes linear time by employing a coordinated sweep over both labels. The HL technique has been success- fully adapted for road networks in [2, 3, 10]. In the case of large-scale graphs, the Pruned Landmark Labeling (PLL) algorithm of [4] orders vertices by degree and then during preprocessing, performs one BFS per graph vertex, starting from the highest-order / degree vertices. At each iteration, each individual BFS is pruned by using the hub labels cal- </span></p><p class="c8 c42"><span class="c3">culated from the previous searches. Later, Delling et al. [9] improve the suggested vertex ordering and the storage of the hub labels for maximum compression. The HL method has also been extended to one-to-many, many-to-many and kNN queries on road networks in [11] and [12] respectively. The recent work of [16] has also proposed ReHub, a novel main- memory algorithm that extends the Hub Labeling approach to efficiently handle Reverse k-Nearest Neighbor (RkNN) queries on large-scale networks. </span></p><p class="c42 c44"><span class="c3">Regarding secondary-storage solutions, Jiang et al. [20] propose their HopDB algorithm for constructing an efficient HL index when the given graphs and the corresponding in- dex are too large to fit into main memory. Abraham et al. [1] introduced the HLDB system, which answers distance and kNN queries in road networks entirely within a database by storing the hub labels in database tables and translating the corresponding HL queries to SQL commands. In [14], Efentakis et al. presented the pure-SQL COLD framework (COmpressed Labels on the Database) for answering mul- tiple exact distance queries (vertex-to-vertex, kNN, RkNN and one-to-many) for large-scale networks, in a open-source database engine. Despite the fact that each type of query was translated to just few lines of SQL code, experiments have showed that COLD provides excellent performance and is thus, fast enough for real-time applications. </span></p><p class="c28"><span class="c21">2.2 Public transportation networks </span></p><p class="c2"><span class="c3">For methods targeting public transportation networks be- fore 2015, one can refer to the latest related literature over- view of [5]. In this section, we will mainly focus on the latest research works that appeared in 2015. </span></p><p class="c42 c85"><span class="c3">Recently, the hub labeling method has also been extended for public transportation networks, in Public Transit Label- ing presented in [7] and Timetable Labeling (TTL) presented in [23]. Since our work builds on Timetable Labeling (TTL), we will follow the notation presented there. A schedule- based, public transportation network may be modeled as a multigraph G, where each vertex is associated with a station or stop (i.e, &ldquo;distinct locations where one may board a tran- sit vehicle&rdquo; [7]) and each arc from a vertex u to a vertex v represents a trip b that departs from stop u at timestamp t</span><span class="c0">d </span><span class="c3">and arrives at v at timestamp t</span><span class="c4">a</span><span class="c3">. Thus, each arc e may be represented with a tuple &lt; u, v, t</span><span class="c0">d</span><span class="c12">,t</span><span class="c0">a</span><span class="c12">,b&gt;, where b, t</span><span class="c0">d</span><span class="c12">,t</span><span class="c0">a </span><span class="c12">are </span><span class="c3">the trip, departure time and arrival time of e respectively and t</span><span class="c0">a </span><span class="c12">&minus; t</span><span class="c0">d </span><span class="c12">is the corresponding duration of the arc. The </span><span class="c3">arc e is an outgoing arc for vertex-stop u and an incoming arc for vertex-stop v. Thus, there are multiple arcs connect- ing the same pair of vertices-stops that correspond to the different trips connecting those two stops together. </span></p><p class="c44 c90"><span class="c3">Timetable labelling (TTL) is a extension of Hierarchi- cal Hub Labeling [3] for public transportation networks. The TTL index preprocessing, computes two sets of labels, L</span><span class="c0">in</span><span class="c12">(v) and L</span><span class="c0">out</span><span class="c12">(v), for each vertex-stop v, such that each </span><span class="c3">label in L</span><span class="c4">in</span><span class="c3">(v) (or L</span><span class="c4">out</span><span class="c3">(v)) is a tuple describing a &ldquo;fast&rdquo; path that ends at (starts from) v. TTL assumes there is a strict vertex ordering, which, defines the relative impor- tance of each vertex with respect to the others. Hence, the rank r(v) of a vertex v is an integer &isin; [1,|V |]. It is as- sumed that the vertex v ranks lower (i.e., is less important) than u, when r(v) &gt; r(u). When given a timetable graph G and a node order r, the TTL index can be uniquely con- structed. The output of TTL preprocessing is two sets of labels, L</span><span class="c0">in</span><span class="c12">(v) and L</span><span class="c0">out</span><span class="c12">(v) for each vertex-stop v, whereas </span></p><p class="c37"><span class="c10">528 </span></p><p class="c8"><span class="c3">each label contains tuples &lt; hub, t</span><span class="c0">d</span><span class="c12">,t</span><span class="c0">a</span><span class="c12">, pivot, b &gt; represent- </span><span class="c3">ing a fast transit path between stops v and hub, passing through stop pivot, using trip b and departing at t</span><span class="c0">d </span><span class="c12">and </span><span class="c3">arriving at t</span><span class="c4">a</span><span class="c3">. The pivot information is required for recon- structing the full path, when it is comprised of multiple trips and is set to null, when the corresponding tuple describes a direct trip between stops v and hub (i.e., b =null). Note, that the label sets L</span><span class="c0">in</span><span class="c12">(v) and L</span><span class="c0">out</span><span class="c12">(v) for a vertex v only </span><span class="c3">contain paths between v and vertices of higher order. </span></p><p class="c6"><span class="c3">The labels calculated during the TTL preprocessing may be used for answering the following three types of queries: </span></p><p class="c6"><span class="c3">&bull; Earliest Arrival (EA). Given two stops s and g &isin; G and a starting timestamp t, the earliest arrival EA(s, g, t) query seeks the path with the earliest arrival time among those paths that (i) start from s no sooner than t and (ii) end at g. </span></p><p class="c8"><span class="c3">&bull; Latest Departure (LD). Given two stops s and g and an ending timestamp t , the latest departure LD(s, g, t ) query seeks the path with the latest departure time among those paths that (i) start from u and (ii) end at v no later than t . </span></p><p class="c8"><span class="c3">&bull; Shortest Duration (SD). Given two stops s and g, a starting t and an ending t timestamp, the shortest duration SD(s, g, t, t ) query seeks the path with the shortest duration among those that (i) start from s no sooner than t and (ii) end at g no later than t . </span></p><p class="c8"><span class="c3">During the query phase, TTL only has to visit the labels of stops s and g (without accessing the original graph G) and select the best solution from three candidate cases: (i) Tu- ples in L</span><span class="c0">out</span><span class="c12">(s) where hub = g, (ii) Tuples in L</span><span class="c0">in</span><span class="c12">(g) where </span><span class="c3">hub = s and (iii) Combining all tuples l</span><span class="c4">1 </span><span class="c3">&isin; L</span><span class="c4">out</span><span class="c3">(s) and l</span><span class="c0">2 </span><span class="c12">&isin; L</span><span class="c0">in</span><span class="c12">(g) where l</span><span class="c0">1</span><span class="c12">.hub = l</span><span class="c0">2</span><span class="c12">.hub and l</span><span class="c0">1</span><span class="c12">.ta &lt;= l2.td. The </span><span class="c3">experimentation in [23], showed that TTL may answer EA, LD and SD queries in less than 30&mu;s, while requiring pre- processing time of less than 17min for all datasets. </span></p><p class="c8"><span class="c3">In this work, based on the lessons learnt from the pre- vious COLD database framework [14], that answers multi- ple distance queries on large-scale graphs, we will: (i) show how to efficiently store the labels created from Timetable la- belling for public transportation networks into a database, (ii) translate the corresponding EA, LD and SD queries into simple SQL commands (iii) formulate four new types of queries for public transportation networks, namely the Earliest Arrival and Latest Departure k-Nearest Neighbor (kNN) and the Earliest Arrival and Latest Departure one- to-many queries and (iv) show how to efficiently answer those additional queries, by using simple SQL commands within the same database framework, implemented entirely on a popular, open-source database engine. The resulting PTLDB (Public Transporation Labels on the DataBase) framework will be described in the following section. </span></p><p class="c6"><span class="c21">3. THE PTLDB FRAMEWORK </span></p><p class="c6"><span class="c3">This section presents the PTLDB (Public Transporation Labels on the DataBase) database framework. PTLDB can answer multiple route-planning queries (Earliest Arrival [EA], Latest Departure [LD], Shortest Duration [SD] vertex-to- vertex, EA, LD k-Nearest Neighbor and EA, LD one-to- many) for public transportation networks using SQL com- mands. Since PTLDB builds on the Timetable Labeling </span></p><p class="c8"><span class="c3">Figure 1: An example timetable graph G with 7 vertices (stops) and 4 trips (each highlighted with a different color). Timestamps are in 100s, i.e., 360=&gt;36,000s (10:00h). Ver- tex 0 is the highest order vertex, followed by vertices 1,2,3,4 </span></p><p class="c6"><span class="c3">Table 1: The created labels for the example graph G </span><span class="c16">v L</span><span class="c0">out</span><span class="c31">(v) </span><span class="c16">&lt; hub,t</span><span class="c0">d</span><span class="c16">, t</span><span class="c4">a</span><span class="c16">, pivot, b &gt; &lt; hub, t</span><span class="c0">d</span><span class="c31">L</span><span class="c16">, </span><span class="c0">in</span><span class="c16">t</span><span class="c4">a</span><span class="c16">, (v) </span></p><p class="c6"><span class="c16">pivot, b &gt; 0 &lt; 0,360, 360, &minus;1,&minus;1 &gt; &lt; 0, 360,360, &minus;1, &minus;1 &gt; 1 &lt; 0, 324,360, 0,1 &gt; &lt; 0,360, 396,0, 2 &gt; </span></p><p class="c49"><span class="c16">&lt; 1, 324, 324,&minus;1, &minus;1 &gt; &lt; 1, 324,324, &minus;1, &minus;1 &gt; &lt; 1,396, 396, &minus;1,&minus;1 &gt; &lt; 1, 396,396, &minus;1, &minus;1 &gt; 2 &lt; 0, 324,360, 0,2 &gt; &lt; 0,360, 396,0, 1 &gt; </span></p><p class="c49"><span class="c16">&lt; 2, 324, 324,&minus;1, &minus;1 &gt; &lt; 2, 324,324, &minus;1, &minus;1 &gt; &lt; 2,396, 396, &minus;1,&minus;1 &gt; &lt; 2, 396,396, &minus;1, &minus;1 &gt; 3 &lt; 0, 324,360, 0,3 &gt; &lt; 0,360, 396,0, 4 &gt; </span></p><p class="c6"><span class="c16">&lt; 3, 396, 396,&minus;1, &minus;1 &gt; &lt; 3, 396,396, &minus;1, &minus;1 &gt; 4 &lt; 0, 324,360, 0,4 &gt; &lt; 0,360, 396,0, 4 &gt; </span></p><p class="c49"><span class="c16">&lt; 4, 396, 396,&minus;1, &minus;1 &gt; &lt; 4, 396,396, &minus;1, &minus;1 &gt; 5 &lt; 0, 288,360, 1,1 &gt; &lt; 0,360, 432,1, 2 &gt; &lt; 1, 288,324, 1,1 &gt; &lt; 1,396, 432,1, 2 &gt; &lt; 5, 432, 432,&minus;1, &minus;1 &gt; &lt; 5, 432,432, &minus;1, &minus;1 &gt; 6 &lt; 0, 288,360, 2,2 &gt; &lt; 0,360, 432,2, 1 &gt; &lt; 2, 288,324, 2,2 &gt; &lt; 2,396, 432,2, 1 &gt; &lt; 6, 432, 432,&minus;1, &minus;1 &gt; &lt; 6, 432,432, &minus;1, &minus;1 &gt; </span></p><p class="c8"><span class="c3">(TTL) [23], we will explain the basic concepts presented there. We chose PostgreSQL [22] for our implementation, given that it is a popular, open-source RDBMS. Although we use some PostgreSQL-specific data-types (namely arrays) and SQL extensions, we use only features included in its standard installation, without any third-party extensions. </span></p><p class="c6"><span class="c21">3.1 Vertex-to-Vertex (v2v) queries </span></p><p class="c8"><span class="c3">The PTLDB framework uses the labels generated by the Timetable Labeling (TTL) of [23] for public transportation networks. The respective TTL implementation (and the re- spective datasets) were made publicly available by the au- thors at [24]. To highlight the results of this process, the la- bels for the example timetable graph G of Figure 1 are shown in Table 1. The labels L</span><span class="c4">out</span><span class="c3">(v) and L</span><span class="c4">in</span><span class="c3">(v) for each vertex / stop v is a vector of tuples &lt; hub,t</span><span class="c0">d</span><span class="c12">,t</span><span class="c0">a</span><span class="c12">,pivot,b &gt; sorted </span><span class="c3">by hub, t</span><span class="c0">d </span><span class="c12">(see Section 2). To answer vertex-to-vertex (v2v) </span><span class="c3">queries between two stop s and g, TTL only has to visit the labels L</span><span class="c4">out</span><span class="c3">(s) and L</span><span class="c4">in</span><span class="c3">(g) and select the best solution from three candidate cases: (i) Tuples in L</span><span class="c0">out</span><span class="c12">(s) where hub = g, </span><span class="c3">(ii) Tuples in L</span><span class="c0">in</span><span class="c12">(g) where hub = s and (iii) Combining all </span><span class="c3">tuples l</span><span class="c4">1 </span><span class="c3">&isin; L</span><span class="c4">out</span><span class="c3">(s) and l</span><span class="c4">2 </span><span class="c3">&isin; L</span><span class="c4">in</span><span class="c3">(g) where l</span><span class="c4">1</span><span class="c3">.hub = l</span><span class="c4">2</span><span class="c3">.hub and l</span><span class="c0">1</span><span class="c12">.ta &lt;= l2.td. Although selecting between those three </span><span class="c3">cases is trivial for a main memory algorithm, it is complex to adapt in a database context. Thus, we need to gener- ate for every v &isin; G, some extra &ldquo;dummy&rdquo; tuples in both </span></p><p class="c6"><span class="c10">529 </span></p><p class="c6"><span class="c3">that L</span><span class="c4">out</span><span class="c3">(v) and L</span><span class="c4">in</span><span class="c3">(v) with hub = v and t</span><span class="c0">d </span><span class="c12">= t</span><span class="c0">a </span><span class="c12">for every DIS- </span></p><p class="c6"><span class="c3">in PTLDB, we do not need to store the pivot or the TINCT (hub, t</span><span class="c0">d</span><span class="c12">) combination existing in L</span><span class="c0">out</span><span class="c12">(u) and for </span></p><p class="c6"><span class="c3">trip information, since if we wanted to reconstruct the full every DISTINCT (hub, t</span><span class="c0">a</span><span class="c12">) combination existing in L</span><span class="c0">in</span><span class="c12">(u). </span></p><p class="c6"><span class="c3">path, it would make more sense to store on the database the Those dummy tuples for our example graph are highlighted </span></p><p class="c6"><span class="c3">expanded path for each tuple generated by the TTL prepro- in bold. Note that, those dummy tuples are only a small </span></p><p class="c6"><span class="c3">cessing. After all, this is another advantage of databases, fraction (&lt; 10%) of the total number of tuples and hence, </span></p><p class="c6"><span class="c3">also suggested by previous efforts like [1]. they add minimal overhead to the PTLDB framework&rsquo;s per- </span></p><p class="c6"><span class="c3">The resulting SQL commands for all types (Earliest Ar- formance. By generating those dummy tuples, we can en- </span></p><p class="c6"><span class="c3">rival, Latest Departure and Shortest Duration) of vertex-to- sure that each vertex-to-vertex query may be answered by </span></p><p class="c6"><span class="c3">vertex queries for PTLDB are shown in Code 1, where the combining exactly one tuple l</span><span class="c0">1 </span><span class="c12">&isin; L</span><span class="c0">out</span><span class="c12">(s) and one tuple </span></p><p class="c6"><span class="c3">user may choose between the lines 12, 14 and 16 and lines l</span><span class="c4">2 </span><span class="c3">&isin; L</span><span class="c4">in</span><span class="c3">(g) where l</span><span class="c4">1</span><span class="c3">.hub = l</span><span class="c4">2</span><span class="c3">.hub and l</span><span class="c4">1</span><span class="c3">.ta &lt;= l2.td, i.e., </span></p><p class="c6"><span class="c3">21, 23 depending on the specific type of query. We use Com- we unified the three separate cases of TTL query processing </span></p><p class="c6"><span class="c3">mon Table Expressions (CTEs) for greater readability and into one. Thus, the answer to the EA(1,1,324) query is 324 </span></p><p class="c6"><span class="c3">we exploit the fact that PostgreSQL &ldquo;guarantees that paral- by combining the tuples &lt;1,324,324,...&gt;, present in both </span></p><p class="c6"><span class="c3">lel unnesting&rdquo; for hubs, tds and tas for each nested query L</span><span class="c0">out</span><span class="c12">(1) and L</span><span class="c0">in</span><span class="c12">(1). </span></p><p class="c6"><span class="c3">&ldquo;will be in sync&rdquo;, i.e., each tuple &lt; hub, td, ta &gt; is expanded </span></p><p class="c6"><span class="c3">Code 1: Vertex-to-vertex (v2v) queries for PTLDB </span></p><p class="c49"><span class="c3">correctly since for the same v the respective arrays have the same number of elements</span><span class="c26">1</span><span class="c3">. It is obvious that the PTLDB </span><span class="c7">1 </span><span class="c1">WITH outp </span><span class="c5">AS </span></p><p class="c6"><span class="c3">vertex-to-vertex query is very simple, since it is implemented </span><span class="c7">2 </span><span class="c1">(</span><span class="c5">SELECT UNNEST</span><span class="c1">(hubs) </span><span class="c5">AS </span><span class="c1">hub, </span></p><p class="c6"><span class="c3">with just a few lines of SQL code and at the same time, it </span><span class="c7">3 </span><span class="c5">UNNEST</span><span class="c1">(tds) </span><span class="c5">AS </span><span class="c1">td, </span></p><p class="c6"><span class="c3">is highly optimized since it only has to fetch only one row </span><span class="c7">4 </span><span class="c5">UNNEST</span><span class="c1">(tas) </span><span class="c5">AS </span><span class="c1">ta </span></p><p class="c6"><span class="c3">from each lout and lin DB tables. </span><span class="c7">5 </span><span class="c5">FROM </span><span class="c1">lout </span><span class="c5">WHERE </span><span class="c1">v=s), </span><span class="c7">6 </span><span class="c1">inp </span><span class="c5">AS </span></p><p class="c6"><span class="c3">Theorem 3.1.1. The PTLDB v2v query is correct. </span><span class="c7">7 </span><span class="c1">(</span><span class="c5">SELECT UNNEST</span><span class="c1">(hubs) </span><span class="c5">AS </span><span class="c1">hub, </span><span class="c7">8 </span><span class="c5">UNNEST</span><span class="c1">(tds) </span><span class="c5">AS </span><span class="c1">td, </span><span class="c7">9 </span><span class="c5">UNNEST</span><span class="c1">(tas) </span><span class="c5">AS </span><span class="c1">ta </span><span class="c7">10 </span><span class="c5">FROM </span><span class="c1">lin </span><span class="c5">WHERE </span><span class="c1">v=g) </span><span class="c7">11 </span><span class="c20">/* For EA queries */ </span><span class="c7">12 </span><span class="c5">SELECT MIN</span><span class="c1">(inp.ta) </span><span class="c7">13 </span><span class="c20">/* For LD queries */ </span><span class="c7">14 </span><span class="c5">SELECT MAX</span><span class="c1">(out.td) </span><span class="c7">15 </span><span class="c20">/* For SD queries */ </span><span class="c7">16 </span><span class="c5">SELECT MIN</span><span class="c1">(inp.ta-outp.td) </span><span class="c7">17 </span><span class="c5">FROM </span><span class="c1">outp, </span></p><p class="c8"><span class="c3">Proof. By adding the dummy tuples to the lout and lin DB tables, we can guarantee that the solution to any vertex- to-vertex query is a combination of one tuple l1 &isin; lout and one tuple l2 &isin; lin with l1.hub = l2.hub and l1.ta &lt;= l2.td (Line 19). Considering the fact that PostgreSQL guarantees correct unnesting of the hubs, tds and tas arrays (line 2- 4, 7-9) for the respective rows for u and v and the extra conditions specific for each type of query (Lines 12,14 and 16 and lines 21, 23) then the resulting PTLDB vertex-to- vertex query is correct. </span></p><p class="c6"><span class="c7">18 </span><span class="c1">inp </span><span class="c7">19 </span><span class="c5">WHERE </span><span class="c1">outp.hub=inp.hub </span><span class="c5">AND </span><span class="c1">outp.ta&lt;=inp.td </span></p><p class="c6"><span class="c21">3.2 EA and LD </span><span class="c3">k</span><span class="c21">NN queries </span><span class="c7">20 </span><span class="c20">/* For EA,SD queries */ </span></p><p class="c6"><span class="c3">The k-Nearest Neighbour (kNN) query, either for Eu- </span><span class="c7">21 </span><span class="c5">AND </span><span class="c1">outp.td&gt;=t </span></p><p class="c6"><span class="c3">clidean space or for network databases, is a very well-studied </span><span class="c7">22 </span><span class="c20">/* For LD,SD queries */ </span></p><p class="c6"><span class="c3">problem in database systems due to its wide range of appli- </span><span class="c7">23 </span><span class="c5">AND </span><span class="c1">inp.ta&lt;=t&rsquo; </span></p><p class="c6"><span class="c3">cations. Unfortunately, it has not been extended yet, to </span></p><p class="c8"><span class="c3">After generating the additional dummy tuples for simpli- fying the TTL vertex-to-vertex queries, we need to store the respective L</span><span class="c0">out</span><span class="c12">(v) and L</span><span class="c0">in</span><span class="c12">(v) labels in the database, as two </span><span class="c3">separate DB tables denoted lout and lin, respectively. Simi- </span></p><p class="c8"><span class="c3">public transportation networks. To this propose, we for- mulate the Earliest Arrival and Latest Departure k-Nearest Neighbour (kNN) queries for schedule-based timetable net- works, according to the following definitions: </span></p><p class="c8"><span class="c3">lar to the previous work COLD [14], we take advantage of the fact that PostgreSQL features an array data type that allows columns of a DB table to be defined as variable-length arrays. Hence, in PTLDB we store hubs, departure times- tamps t</span><span class="c0">d </span><span class="c12">and arrival timestamps t</span><span class="c0">a </span><span class="c12">for a vertex (all ordered </span><span class="c3">by hub, t</span><span class="c0">d</span><span class="c12">) as arrays in three separate columns (i.e., hubs, </span><span class="c3">tds and tas) in a single row. The resulting lout and lin DB </span></p><p class="c8"><span class="c3">&bull; Earliest Arrival kNN query (EA-kNN). Given a stop q, a set of target-stops T and a starting timestamp t, the earliest arrival EA&minus;kNN(q,T,t,k) query seeks the k- distinct stops &isin; T with the earliest arrival time among the paths that (i) start from q no sooner than t and (ii) end in any stop &isin; T. </span></p><p class="c8"><span class="c3">tables are shown in Tables 2 and 3. Similar to COLD, this approach has considerable advantages: (i) The lout and lin DB tables have exactly |V | rows (ii) Each of those DB tables has the column v as primary key, minimizing the size of the respective index. (iii) For any v2v query, PTLDB needs to access exactly two rows, regardless of the sizes of |L</span><span class="c0">out</span><span class="c12">(s)| </span><span class="c3">and |L</span><span class="c0">in</span><span class="c12">(g)|, thus minimizing the secondary-storage utiliza- </span></p><p class="c6"><span class="c3">&bull; Latest Departurel kNN query (LD-kNN). Given a stop q, a set of target-stops T and an ending timestamp t, the latest departure LD&minus;kNN(q,T,t,k) query seeks the k-distinct stops &isin; T with the latest departure time from stop q from among the paths that (i) start from q and (ii) end in any stop &isin; T no later than t. </span></p><p class="c8"><span class="c3">tion, even working inside a database. In case of timetables changing depending on the weekday (e.g., weekdays vs week- ends) or the time of the year (e.g., on holidays) in PTLDB we would need to have different versions of the lout and </span></p><p class="c8"><span class="c3">Both these type of queries may be used in a wide range of useful applications, such as an tourist deciding to visit the nearest Point of Interest (POI) using public transport </span></p><p class="c6"><span class="c3">lin DB tables, for servicing each different period. Also note </span></p><p class="c6"><span class="c4">1</span><span class="c12">http://stackoverflow.com/a/23838131 </span></p><p class="c6"><span class="c10">530 </span></p><p class="c6"><span class="c3">Table Table 2: The lout table used in PTLDB for the example </span></p><p class="c6"><span class="c3">3: The lin table used for PTLDB for the example graph Ggraph G</span><span class="c31">v hubs tds tas </span></p><p class="c6"><span class="c31">v hubs tds tas </span><span class="c16">... ... ... ... </span></p><p class="c6"><span class="c16">... ... ... ... 1 {0, 1, 1} {324,324, 396} {360, 324,396} </span></p><p class="c6"><span class="c16">1 {0, 1, 1} {360,324, 396} {396, 324,396} ... ... ... ... </span></p><p class="c6"><span class="c16">... ... ... ... 4 {0,4} {324, 396} {360, 396} </span></p><p class="c6"><span class="c16">4 {0,4} {360, 396} {396, 396} ... ... ... ... </span></p><p class="c6"><span class="c16">... ... ... ... </span></p><p class="c6"><span class="c3">Table 4: The ea knn naive table for the example graph G, T = {4,6} and k = 1 </span></p><p class="c6"><span class="c16">hub td vs tds </span></p><p class="c6"><span class="c16">0 360 {4,6} {396,432} 2 396 {6} {432} 4 396 {4} {396} 6 432 {6} {432} </span></p><p class="c8"><span class="c3">(EA-kNN) or how a city visitor may determine his remain- ing time for finishing his breakfast, before reaching one of his preferred POI-destinations by 11:00 (LD-kNN). To the best of our knowledge, this is the first time that these queries have been formalized for public transit networks and there- fore we are not aware of any previous approach tackling them. Throughout this work we assume that targets are not changing, which is a reasonable assumption for pub- lic transportation networks, since, e.g., for location based services we already know the stops that are located near attractive POIs or the most visited city-landmarks. In the following sections, we will show how to efficiently solve those queries within PTLDB. For our example graph G (Figure 1) and the remainder of this section, we assume that target stops are 4 and 6, i.e., T = {4,6} </span></p><p class="c6"><span class="c43">3.2.1 Implementation </span></p><p class="c8"><span class="c3">In this section, we will mainly discuss EA-kNN queries. The solution to LD-kNN queries will be directly analogous. Typically, to solve kNN queries with the hub labeling method, we need to group the L</span><span class="c0">in </span><span class="c12">tuples of the targets by hub [1, </span><span class="c3">16, 14] and keep the k-best entries per hub. Unfortunately, this approach cannot be extended directly to public trans- portation networks, due to the condition l</span><span class="c0">1</span><span class="c12">.ta &lt;= l2.td </span><span class="c3">that must always hold. A naive solution to this problem, would be to group the L</span><span class="c0">in </span><span class="c12">tuples of the targets per hub </span><span class="c3">and t</span><span class="c0">d </span><span class="c12">instead, and again keep the best distinct k-entries </span><span class="c3">per hub, t</span><span class="c0">d </span><span class="c12">ordered by t</span><span class="c0">a</span><span class="c12">, with ties broken arbitrarily. The </span><span class="c3">results of this process would then be stored in the DB ta- ble ea knn naive, with the data structure shown in Ta- ble 4. As seen there, for k = 1, hub = 0 and td = 360 we only need to keep the best entry that corresponds to v = 4 and td = 396. The primary key of ea knn naive table will be the (hub, td) combination. After building this table, the EA-kNN(q,T,t,k) query may be solved by the SQL of Code 2, that combines the row of lout DB table that cor- responds to vertex q, with the ea knn naive table. There- fore the EA&minus;kNN(0,{4,6},360,1) will have the correct an- swer (4,396), i.e., the NN of vertex 0 for departure time 360 or later is the vertex 4 with arrival time 396. As showcased in [14], it makes sense to create one large ea knn naive table for the maximum value kmax of k (e.g., for k = 16) that may be serviced by the DB framework and that same table will be used for all kNN queries up to k = kmax. In this case, we only need to retrieve k-entries per (hub, td) com- bination and thus we only expand vs[1 : k] and tas[1 : k] </span></p><p class="c6"><span class="c3">(Lines 14-15) for k &lt; kmax. </span></p><p class="c6"><span class="c3">Code 2: EA-kNN naive query for PTLDB </span><span class="c7">1 </span><span class="c1">WITH n1 </span><span class="c5">AS </span><span class="c7">2 </span><span class="c1">(</span><span class="c5">SELECT </span><span class="c1">v, hub, td, ta </span><span class="c7">3 </span><span class="c5">FROM </span><span class="c7">4 </span><span class="c1">(</span><span class="c5">SELECT </span><span class="c1">v </span><span class="c5">AS </span><span class="c1">v, </span><span class="c7">5 </span><span class="c5">UNNEST</span><span class="c1">(hubs) </span><span class="c5">AS </span><span class="c1">hub, </span><span class="c7">6 </span><span class="c5">UNNEST</span><span class="c1">(tds) </span><span class="c5">AS </span><span class="c1">td, </span><span class="c7">7 </span><span class="c5">UNNEST</span><span class="c1">(tas) </span><span class="c5">AS </span><span class="c1">ta </span><span class="c7">8 </span><span class="c5">FROM </span><span class="c1">lout </span><span class="c7">9 </span><span class="c5">WHERE </span><span class="c1">v=q) n1a </span><span class="c7">10 </span><span class="c5">WHERE </span><span class="c1">td &gt;=t) </span><span class="c7">11 </span><span class="c5">SELECT </span><span class="c1">v2,</span><span class="c5">MIN</span><span class="c1">(n2.ta) </span><span class="c7">12 </span><span class="c5">FROM </span><span class="c1">n1, </span><span class="c7">13 </span><span class="c1">(</span><span class="c5">SELECT </span><span class="c1">hub, td, </span><span class="c7">14 </span><span class="c5">UNNEST</span><span class="c1">(vs[1:k]) </span><span class="c5">AS </span><span class="c1">v2, </span><span class="c7">15 </span><span class="c5">UNNEST</span><span class="c1">(tas[1:k]) </span><span class="c5">AS </span><span class="c1">ta </span><span class="c7">16 </span><span class="c5">FROM </span><span class="c1">ea_knn_naive) n2 </span><span class="c7">17 </span><span class="c5">WHERE </span><span class="c1">n1.hub=n2.hub </span><span class="c7">18 </span><span class="c5">AND </span><span class="c1">n2.td&gt;=n1.ta </span><span class="c7">19 </span><span class="c5">GROUP BY </span><span class="c1">v2 </span><span class="c7">20 </span><span class="c5">ORDER BY MIN</span><span class="c1">(n2.ta), v2 </span><span class="c7">21 </span><span class="c5">LIMIT </span><span class="c1">k; </span></p><p class="c6"><span class="c3">Theorem 3.2.1. The naive EA-kNN query is correct. Proof. The naive EA-kNN query joins the l1 tuples in q row of DB table lout, with the l2 tuples of ea knn naive DB table with l1.hub = l2.hub and l1.ta &lt;= l2.td. Since for each individual (hub, td) combination the ea knn naive DB table stores the top-k (earliest arrival) entries, this ensures that the naive EA-kNN query provides correct results. </span></p><p class="c8"><span class="c3">Although the EA-kNN naive query is very simple, it can- not scale well for large metropolitan networks. In a realistic setting, multiple buses or trains leave the same hub every few minutes and therefore for each hub we will have multi- ple t</span><span class="c0">d </span><span class="c12">entries. Thus, the size of ea knn naive DB table and </span><span class="c3">its primary key index will vastly increase (even after keeping only the best k-entries per hub, t</span><span class="c0">d</span><span class="c12">). The number of rows that </span><span class="c3">should be joined will also grow, making queries too slow for real-time applications. Hence, we must further group entries per hub and create a condensed knn ea DB table. Ideally, each tuple contained in the q row of lout DB table should be joined with only a single row in the knn ea table, dur- ing a EA-kNN query. To achieve that, we can group hub entries per hour of departure, i.e., making a separate entry per hub and hour of departure for the available timestamp ranges of t</span><span class="c0">d </span><span class="c12">in lin DB table. The resulting knn ea table </span><span class="c3">will have the data structure showcased in Table 5 and the combination of hub, dephour as a primary key. For a specific hub and hour, e.g., hub = 0, dephour = 10, (i) the columns tds&minus;exp, vs&minus;exp and tas&minus;exp, contain ALL tuples of lin </span></p><p class="c6"><span class="c10">531 </span></p><p class="c96"><span class="c3">Table 5: The knn ea table data structure </span><span class="c16">hub dephour vs tas tds-exp vs-exp tas-exp </span></p><p class="c32"><span class="c16">top-k entries (v) top-k entries (ta) all entries (td) all entries (v) all entries (ta) 0 0 hub = 0, hour &ge; 1 hub = 0, hour &ge; 1 hub = 0, 0 &le; hour &le; 1 hub = 0, 0 &le; hour &le; 1 hub = 0, 0 &le; hour &le; 1 </span></p><p class="c47"><span class="c16">top-k entries (v) top-k entries (ta) all entries (td) all entries (v) all entries (ta) 0 1 hub = 0, hour &ge; 2 hub = 0, hour &ge; 2 hub = 0, 1 &le; hour &le; 2 hub = 0, 1 &le; hour &le; 2 hub = 0, 1 &le; hour &le; 1 ... ... ... ... ... ... ... </span></p><p class="c32"><span class="c16">top-k entries (v) top-k entries (ta) all entries (td) all entries (v) all entries (ta) 1 0 hub = 1, hour &ge; 1 hub = 1, hour &ge; 1 hub = 1, 0 &le; hour &le; 1 hub = 1, 0 &le; hour &le; 1 hub = 1, 0 &le; hour &le; 1 </span></p><p class="c32"><span class="c16">top-k entries (v) top-k entries (ta) all entries (td) all entries (v) all entries (ta) 1 1 hub = 1, hour &ge; 2 hub = 1, hour &ge; 2 hub = 1, 1 &le; hour &le; 2 hub = 1, 1 &le; hour &le; 2 hub = 1, 1 &le; hour &le; 1 </span></p><p class="c50"><span class="c3">for targets T, with hub = 0 and t</span><span class="c0">d </span><span class="c12">between 10:00 and 11:00 </span><span class="c3">ordered by t</span><span class="c0">d</span><span class="c12">, whereas (ii) the columns vs and tas contain </span><span class="c3">only the best top-k (earliest arrival) distinct entries for tar- gets T and hub = 0, t</span><span class="c0">d</span><span class="c12">&ge;11:00. </span></p><p class="c81"><span class="c3">Thus, the optimized EA-kNN query must implement those two separate cases: (i) Expanding the l2 tuples for a spe- cific hub between e.g., 10:00 and 11:00 contained in DB columns tds&minus;exp, vs&minus;exp and tas&minus;exp (still checking that l1.ta &lt;= l2.td for those entries) and (ii) Expanding the l3 tuples that leave the specific hub after 11:00. As showcased earlier, both cases are included in a single row per hub of the knn ea DB table. The resulting query is shown in Code 3. For combining those aforementioned cases we still have to use the UNION operator (Line 30) and for increasing perfor- mance, the JOIN between the lout and knn ea DB tables happens AFTER expanding the lout tuples for q row and BEFORE expanding the tuples in knn ea DB table (Lines 1- 18). Note, that if each row in lout DB table contains on av- erage |L</span><span class="c4">out</span><span class="c3">|/|V | tuples, then the optimized EA-kNN query will always access at most |L</span><span class="c0">out</span><span class="c12">|/|V | rows from the knn ea </span><span class="c3">DB table, thus minimizing secondary storage utilization. </span></p><p class="c48"><span class="c3">Theorem 3.2.2. The construction of the knn ea DB ta- ble and the corresponding EA-kNN query are correct. </span></p><p class="c57"><span class="c3">Proof. For the EA-kNN query (q,T,t), assume there is a tuple l1 =&lt; h, td, ta &gt; with td &ge; t for the query vertex q, included in the lout DB table. The EA-kNN query will join this tuple with exactly one row in the knn ea DB table for which hub = h and dephour = FLOOR(ta/3600). This specific knn ea row contains (i) all l2 tuples of targets T for hub = h and dephour between FLOOR(ta/3600) and FLOOR(ta/3600)+1 (we still need to check for those entries that l1.ta &lt;= l2.td) but (ii) only the best top-k (earliest arrival) distinct l3 tuples for targets T that leave hub = h after FLOOR(ta/3600) + 1. There is no need to search for any other tuples for hub = h after FLOOR(ta/3600) + 1 because all other tuples will have worst arrival time than the l3 tuples. Also, there is no need to look for any other tuples for hub = h before FLOOR(ta/3600), because the l1 trip arrives at hub h after FLOOR(ta/3600). Since the EA-kNN query will similarly join all tuples in lout DB that leave query vertex q after timestamp t, the resulting EA- kNN query is correct. </span></p><p class="c34"><span class="c3">Considering the choice of an hour as the tuning parameter for grouping the knn ea DB table entries, we could have chosen any other valid time interval to that purpose. In fact, we have even experimented with other intervals (smaller or larger than an hour) but (i) when smaller intervals are used, the respective knn ea table has more rows (which makes queries slower) and (ii) when larger intervals are used (e.g., 3 hours) the number of tuples stored in tds &minus; exp, vs &minus; exp </span></p><p class="c8 c42"><span class="c3">and tas &minus; exp columns vastly increases, which counteracts the benefit of the smaller number of total rows. Thus, a time interval of an hour seems like the best compromise between those two scenarios and worked well for all tested datasets. However, it can be tuned according to the specific use-cases and user needs for a particular public transit network. </span></p><p class="c42 c46"><span class="c3">In the case of LD-kNN queries, the corresponding knn ld table will have a similar data structure to the knn ea ta- ble. There are some main differences though: (i) Entries are grouped by hub and hour of ARRIVAL, i.e., for a specific hub and hour, e.g., hub = 0, arrhour = 10, the columns tds&minus;exp, vs&minus;exp and tas&minus;exp, contain all tuples of lin for targets T, with hub = 0 and t</span><span class="c0">a </span><span class="c12">between 10:00 and 11:00 </span><span class="c3">ordered by t</span><span class="c0">d</span><span class="c12">. Likewise, the combination of hub, arrhour </span><span class="c3">will be the primary key. (ii) The columns vs and tds (and not tas as before) contain only the best top-k (latest depar- ture) distinct entries for targets T and hub = 0, t</span><span class="c4">a</span><span class="c3">&le;10:00. The corresponding LD-kNN query (see Code 4) will also be slightly different (e.g., </span><span class="c1">MIN(n3.ta)</span><span class="c3">, </span><span class="c1">MIN(n2.ta) </span><span class="c3">will be re- placed by </span><span class="c1">MAX(n1_td) </span><span class="c3">or the </span><span class="c1">DESC </span><span class="c3">ordering) but it will still offer the same performance benefits as before. </span><span class="c21">3.3 EA and LD One-to-many queries </span></p><p class="c62"><span class="c3">Similar to kNN, we formulate the Earliest Arrival and Latest Departure One-to-many queries for schedule-based timetable networks, according to the following definitions: </span></p><p class="c38"><span class="c3">&bull; Earliest Arrival One-to-many query (EA-OTM). Gi- ven a stop q, a set of target-stops T and a starting timestamp t, the earliest arrival EA &minus; OTM(q,T,t) query seeks the earliest arrival time for all target-stops for trips that start from q no sooner than t. </span></p><p class="c91"><span class="c3">&bull; Latest Departurel One-to-many query (LD-OTM). Gi- ven a stop q, a set of target-stops T and an ending timestamp t, the latest departure LD &minus; OTM(q,T,t) query seeks the latest departure times for trips starting from q and end in any stop &isin; T no later than t. </span></p><p class="c42 c82"><span class="c3">Again the EA-OTM and LD-OTM queries have a wide range of useful applications, such as transportation plan- ning (e.g., find faraway stops) or geomarketing applications (e.g., nearby what stop one must build a franchise store to be more easily reachable by clients). To the best of our knowledge, this is also the first time that these queries have been formalized for public transportation. How to efficiently solve them within PTLDB, will be shown in the following. </span></p><p class="c55"><span class="c3">For answering the EA-OTM query, we need to build a new otm ea DB table that will have the data structure showcased in Table 6. In the otm ea table the columns hub, dephour (= hour of departure), tds &minus; exp, vs &minus; exp and tas &minus; exp are identical to the knn ea DB table and </span></p><p class="c24"><span class="c10">532 </span></p><p class="c69"><span class="c3">Code 3: EA-kNN and EA-OTM queries for PTLDB </span><span class="c7">1 </span><span class="c1">WITH n1 </span><span class="c5">AS </span><span class="c7">2 </span><span class="c1">(</span><span class="c5">SELECT </span><span class="c1">v,hub, td, ta </span><span class="c7">3 </span><span class="c5">FROM </span><span class="c7">4 </span><span class="c1">(</span><span class="c5">SELECT </span><span class="c1">v, </span><span class="c7">5 </span><span class="c5">UNNEST</span><span class="c1">(hubs) </span><span class="c5">AS </span><span class="c1">hub, </span><span class="c7">6 </span><span class="c5">UNNEST</span><span class="c1">(tds) </span><span class="c5">AS </span><span class="c1">td, </span><span class="c7">7 </span><span class="c5">UNNEST</span><span class="c1">(tas) </span><span class="c5">AS </span><span class="c1">ta </span><span class="c7">8 </span><span class="c5">FROM </span><span class="c1">lout </span><span class="c7">9 </span><span class="c5">WHERE </span><span class="c1">v=q) n1a </span><span class="c7">10 </span><span class="c5">WHERE </span><span class="c1">td &gt;=t), </span><span class="c7">11 </span><span class="c1">n1b </span><span class="c5">AS </span><span class="c7">12 </span><span class="c1">(</span><span class="c5">SELECT </span><span class="c1">n1bb.*, </span><span class="c7">13 </span><span class="c1">n1.ta </span><span class="c5">AS </span><span class="c1">n1_ta </span><span class="c7">14 </span><span class="c1">n1.td </span><span class="c5">AS </span><span class="c1">n1_td </span><span class="c7">15 </span><span class="c20">/* EA-$k$NN query */ </span><span class="c7">16 </span><span class="c5">FROM </span><span class="c1">knn_ea n1bb,n1 </span><span class="c7">17 </span><span class="c20">/* EA-OTM query */ </span><span class="c7">18 </span><span class="c5">FROM </span><span class="c1">otm_ea n1bb,n1 </span><span class="c7">19 </span><span class="c5">WHERE </span><span class="c1">n1bb.hub=n1.hub </span><span class="c7">20 </span><span class="c5">AND </span><span class="c1">n1bb.dephour=</span><span class="c5">FLOOR</span><span class="c1">(n1.ta/3600)) </span><span class="c7">21 </span><span class="c5">SELECT </span><span class="c1">v2,</span><span class="c5">MIN</span><span class="c1">(ta) </span><span class="c7">22 </span><span class="c5">FROM </span><span class="c1">( </span><span class="c7">23 </span><span class="c1">(</span><span class="c5">SELECT </span><span class="c1">v2,</span><span class="c5">MIN</span><span class="c1">(n3.ta) </span><span class="c5">AS </span><span class="c1">ta </span><span class="c7">24 </span><span class="c5">FROM </span><span class="c7">25 </span><span class="c1">(</span><span class="c5">SELECT </span><span class="c7">26 </span><span class="c20">/* EA-$k$NN query */ </span><span class="c7">27 </span><span class="c5">UNNEST</span><span class="c1">(tas[1:k]) </span><span class="c5">AS </span><span class="c1">ta, </span><span class="c7">28 </span><span class="c5">UNNEST</span><span class="c1">(vs[1:k]) </span><span class="c5">AS </span><span class="c1">v2 </span><span class="c7">29 </span><span class="c20">/* EA-OTM query */ </span><span class="c7">30 </span><span class="c5">UNNEST</span><span class="c1">(tas) </span><span class="c5">AS </span><span class="c1">ta, </span><span class="c7">31 </span><span class="c5">UNNEST</span><span class="c1">(vs) </span><span class="c5">AS </span><span class="c1">v2 </span><span class="c7">32 </span><span class="c5">FROM </span><span class="c1">n1b) n3 </span><span class="c7">33 </span><span class="c5">GROUP BY </span><span class="c1">v2 </span><span class="c7">34 </span><span class="c5">ORDER BY MIN</span><span class="c1">(n3.ta),v2 </span><span class="c7">35 </span><span class="c20">/* EA-$k$NN query */ </span><span class="c7">36 </span><span class="c5">LIMIT </span><span class="c1">k </span><span class="c7">37 </span><span class="c1">) </span><span class="c7">38 </span><span class="c5">UNION </span><span class="c7">39 </span><span class="c1">(</span><span class="c5">SELECT </span><span class="c1">n2.v2,</span><span class="c5">MIN</span><span class="c1">(n2.ta) </span><span class="c5">AS </span><span class="c1">ta </span><span class="c7">40 </span><span class="c5">FROM </span><span class="c7">41 </span><span class="c1">(</span><span class="c5">SELECT </span><span class="c1">n1_ta, </span><span class="c7">42 </span><span class="c5">UNNEST</span><span class="c1">(tds_exp) </span><span class="c5">AS </span><span class="c1">td, </span><span class="c7">43 </span><span class="c5">UNNEST</span><span class="c1">(vs_exp) </span><span class="c5">AS </span><span class="c1">v2, </span><span class="c7">44 </span><span class="c5">UNNEST</span><span class="c1">(tas_exp) </span><span class="c5">AS </span><span class="c1">ta </span><span class="c7">45 </span><span class="c5">FROM </span><span class="c1">n1b) n2 </span><span class="c7">46 </span><span class="c20">/* Check for l1.ta&lt;=l2.td */ </span><span class="c7">47 </span><span class="c5">WHERE </span><span class="c1">n1_ta&lt;=n2.td </span><span class="c7">48 </span><span class="c5">GROUP BY </span><span class="c1">n2.v2 </span><span class="c7">49 </span><span class="c5">ORDER BY MIN</span><span class="c1">(n2.ta),v2 </span><span class="c7">50 </span><span class="c20">/* EA-$k$NN query */ </span><span class="c7">51 </span><span class="c5">LIMIT </span><span class="c1">k </span><span class="c7">52 </span><span class="c1">)) S53 </span><span class="c7">53 </span><span class="c5">GROUP BY </span><span class="c1">v2 </span><span class="c7">54 </span><span class="c5">ORDER BY MIN</span><span class="c1">(ta),v2 </span><span class="c7">55 </span><span class="c20">/* EA-$k$NN query */ </span><span class="c7">56 </span><span class="c5">LIMIT </span><span class="c1">k; </span></p><p class="c6 c70"><span class="c3">Code 4: LD-kNN and LD-OTM queries for PTLDB </span><span class="c7">1 </span><span class="c1">WITH n1 </span><span class="c5">AS </span><span class="c7">2 </span><span class="c1">(</span><span class="c5">SELECT </span><span class="c1">v,hub,td,ta </span><span class="c7">3 </span><span class="c5">FROM </span><span class="c7">4 </span><span class="c1">(</span><span class="c5">SELECT </span><span class="c1">v, </span><span class="c7">5 </span><span class="c5">UNNEST</span><span class="c1">(hubs) </span><span class="c5">AS </span><span class="c1">hub, </span><span class="c7">6 </span><span class="c5">UNNEST</span><span class="c1">(tds) </span><span class="c5">AS </span><span class="c1">td, </span><span class="c7">7 </span><span class="c5">UNNEST</span><span class="c1">(tas) </span><span class="c5">AS </span><span class="c1">ta </span><span class="c7">8 </span><span class="c5">FROM </span><span class="c1">lout </span><span class="c7">9 </span><span class="c5">WHERE </span><span class="c1">v=q) n1a), </span><span class="c7">10 </span><span class="c1">n1b </span><span class="c5">AS </span><span class="c7">11 </span><span class="c1">(</span><span class="c5">SELECT </span><span class="c1">n1bb.*, </span><span class="c7">12 </span><span class="c1">n1.ta </span><span class="c5">AS </span><span class="c1">n1_ta, </span><span class="c7">13 </span><span class="c1">n1.td </span><span class="c5">AS </span><span class="c1">n1_td </span><span class="c7">14 </span><span class="c20">/* LD-$k$NN query */ </span><span class="c7">15 </span><span class="c5">FROM </span><span class="c1">knn_ld n1bb,n1 </span><span class="c7">16 </span><span class="c20">/* LD-OTM query */ </span><span class="c7">17 </span><span class="c5">FROM </span><span class="c1">otm_ld n1bb,n1 </span><span class="c7">18 </span><span class="c5">WHERE </span><span class="c1">n1bb.hub=n1.hub </span><span class="c7">19 </span><span class="c5">AND </span><span class="c1">n1bb.arrhour=</span><span class="c5">FLOOR</span><span class="c1">(t/3600)) </span><span class="c7">20 </span><span class="c5">SELECT </span><span class="c1">v2,</span><span class="c5">MAX</span><span class="c1">(td) </span><span class="c7">21 </span><span class="c5">FROM </span><span class="c1">( </span><span class="c7">22 </span><span class="c1">(</span><span class="c5">SELECT </span><span class="c1">v2,</span><span class="c5">MAX</span><span class="c1">(n3.n1_td) </span><span class="c5">AS </span><span class="c1">td </span><span class="c7">23 </span><span class="c5">FROM </span><span class="c7">24 </span><span class="c1">(</span><span class="c5">SELECT </span><span class="c1">n1_td, n1_ta, </span><span class="c7">25 </span><span class="c20">/* LD-$k$NN query */ </span><span class="c7">26 </span><span class="c5">UNNEST</span><span class="c1">(tds[1:k]) </span><span class="c5">AS </span><span class="c1">td, </span><span class="c7">27 </span><span class="c5">UNNEST</span><span class="c1">(vs[1:k]) </span><span class="c5">AS </span><span class="c1">v2 </span><span class="c7">28 </span><span class="c20">/* LD-OTM query */ </span><span class="c7">29 </span><span class="c5">UNNEST</span><span class="c1">(tds) </span><span class="c5">AS </span><span class="c1">td, </span><span class="c7">30 </span><span class="c5">UNNEST</span><span class="c1">(vs) </span><span class="c5">AS </span><span class="c1">v2 </span><span class="c7">31 </span><span class="c5">FROM </span><span class="c1">n1b) n3 </span><span class="c7">32 </span><span class="c5">WHERE </span><span class="c1">n3.td&gt;=n1_ta </span><span class="c7">33 </span><span class="c5">GROUP BY </span><span class="c1">v2 </span><span class="c7">34 </span><span class="c5">ORDER BY MAX</span><span class="c1">(n3.n1_td) </span><span class="c5">DESC</span><span class="c1">, v2 </span><span class="c7">35 </span><span class="c20">/* LD-$k$NN query */ </span><span class="c7">36 </span><span class="c5">LIMIT </span><span class="c1">k </span><span class="c7">37 </span><span class="c1">) </span><span class="c7">38 </span><span class="c5">UNION </span><span class="c7">39 </span><span class="c1">(</span><span class="c5">SELECT </span><span class="c1">n2.v2,</span><span class="c5">MAX</span><span class="c1">(n2.n1_td) </span><span class="c5">AS </span><span class="c1">td </span><span class="c7">40 </span><span class="c5">FROM </span><span class="c7">41 </span><span class="c1">(</span><span class="c5">SELECT </span><span class="c1">n1_td,n1_ta, </span><span class="c7">42 </span><span class="c5">UNNEST</span><span class="c1">(tds_exp) </span><span class="c5">AS </span><span class="c1">td, </span><span class="c7">43 </span><span class="c5">UNNEST</span><span class="c1">(vs_exp) </span><span class="c5">AS </span><span class="c1">v2, </span><span class="c7">44 </span><span class="c5">UNNEST</span><span class="c1">(tas_exp) </span><span class="c5">AS </span><span class="c1">ta </span><span class="c7">45 </span><span class="c5">FROM </span><span class="c1">n1b) n2 </span><span class="c7">46 </span><span class="c5">WHERE </span><span class="c1">n2.td&gt;=n1_ta </span><span class="c7">47 </span><span class="c5">AND </span><span class="c1">n2.ta&lt;=t </span><span class="c7">48 </span><span class="c5">GROUP BY </span><span class="c1">n2.v2 </span><span class="c7">49 </span><span class="c5">ORDER BY MAX</span><span class="c1">(n2.n1_td) </span><span class="c5">DESC</span><span class="c1">, v2 </span><span class="c7">50 </span><span class="c20">/* LD-$k$NN query */ </span><span class="c7">51 </span><span class="c5">LIMIT </span><span class="c1">k </span><span class="c7">52 </span><span class="c1">)) S53 </span><span class="c7">53 </span><span class="c5">GROUP BY </span><span class="c1">v2 </span><span class="c7">54 </span><span class="c5">ORDER BY MAX</span><span class="c1">(td) </span><span class="c5">DESC</span><span class="c1">, v2 </span><span class="c7">55 </span><span class="c20">/* LD-$k$NN query */ </span><span class="c7">56 </span><span class="c5">LIMIT </span><span class="c1">k; </span></p><p class="c59"><span class="c10">533 </span></p><p class="c45"><span class="c3">Table 6: The otm ea table data structure </span><span class="c16">hub dephour vs tas tds-exp vs-exp tas-exp </span></p><p class="c39"><span class="c16">best entry per target (v) best entry per target (ta) all entries (td) all entries (v) all entries (ta) 0 0 hub = 0, hour &ge; 1 hub = 0, hour &ge; 1 hub = 0,0 &le; hour &le; 1 hub = 0,0 &le; hour &le; 1 hub = 0, 0 &le; hour &le; 1 </span></p><p class="c15"><span class="c16">best entry per target (v) best entry per target (ta) all entries (td) all entries (v) all entries (ta) 0 1 hub = 0, hour &ge; 2 hub = 0, hour &ge; 2 hub = 0,1 &le; hour &le; 2 hub = 0,1 &le; hour &le; 2 hub = 0, 1 &le; hour &le; 1 ... ... ... ... ... ... ... </span></p><p class="c39"><span class="c16">best entry per target (v) best entry per target (ta) all entries (td) all entries (v) all entries (ta) 1 0 hub = 1, hour &ge; 1 hub = 1, hour &ge; 1 hub = 1,0 &le; hour &le; 1 hub = 1,0 &le; hour &le; 1 hub = 1, 0 &le; hour &le; 1 </span></p><p class="c61 c71"><span class="c16">best entry per target (v) best entry per target (ta) all entries (td) all entries (v) all entries (ta) 1 1 hub = 1, hour &ge; 2 hub = 1, hour &ge; 2 hub = 1,1 &le; hour &le; 2 hub = 1,1 &le; hour &le; 2 hub = 1, 1 &le; hour &le; 1 </span></p><p class="c27"><span class="c3">the combination (hub, dephour) again serves as the primary key. The only difference is in the vs and tas columns, where we must store the best tuple (earliest arrival) per vertex for the following hours, instead of only the top-k entries over all targets (as in knn ea table), i.e., the vs and tas columns will store at-most |V | tuples per row, instead of only k. Although this makes the resulting EA-OTM query slower, its SQL implementation is practically identical to the EA-kNN query (see Code 3). We only need to replace the knn ea table with otm ea (Line 16), remove the </span><span class="c1">LIMIT k </span><span class="c3">clauses (Lines 36,51,56) and use </span><span class="c1">UNNEST(tas), UNNEST(vs) </span><span class="c3">(Lines 30,31) instead of the lines 27,28. </span></p><p class="c30"><span class="c3">Likewise, for LD-OTM queries we need to build the cor- responding otm ld DB table that follows the same structure as knn ld DB table, except that in the vs and tds columns, we must store the best tuple (latest departure) per vertex for the PREVIOUS hours, instead of only the top-k entries over all targets (as in knn ld table). The respective LD- OTM query is very similar to the previous LD-kNN query, as showcased in Code 4. </span></p><p class="c30"><span class="c3">Conclusively, for any query vertex q (containing on av- erage |L</span><span class="c0">o</span><span class="c12">ut|/|V | tuples), then the proposed kNN and One- </span><span class="c3">to-many queries will always access at most |L</span><span class="c4">o</span><span class="c3">ut|/|V | rows from the respective knn or otm DB tables. Thus, it will be hard to achieve better secondary storage utilization inside a database. It is important to note that once we load the TTL labels and create the lout and lin DB tables, all the auxiliary DB tables within PTLDB (namely the knn ea, knn ld, otm ea and otm ld) may also be created by sim- ple SQL commands (the corresponding queries were omitted due to space restrictions). This fact also demonstrates that PTLDB is truly a pure-SQL framework for servicing multi- ple route-planning queries on public transportation graphs. In the following experimentation section, we will benchmark PTLDB&rsquo;s performance for various real-world datasets. </span></p><p class="c77"><span class="c21">4. EXPERIMENTAL EVALUATION </span></p><p class="c9"><span class="c3">To assess the performance of PTLDB on various pub- lic transportation graphs, we conducted experiments on a workstation with a 4-core Intel i7-4771 processor clocked at 3.5GHz and 32Gb of RAM, running Ubuntu 14.04. In our experiments, we use the same 11 public transportation net- works from [19] , as in Timetable Labeling (TTL) [23], where &ldquo;each dataset records the timetable of the public transporta- tion network of a major city or country on a weekday&rdquo; [23]. The characteristics of these networks and the necessary TTL preprocessing (using the vertex ordering files provided by its authors) for creating the labels are presented in Table 7. The graphs&rsquo; average degree is between 53 and 413 and the TTL algorithm creates 630 &minus; 7,230 tuples per vertex, requiring 4.5 &minus; 353.6s for the labels&rsquo; construction. </span></p><p class="c6 c54"><span class="c3">Table 7: Public transportation graphs statistics </span></p><p class="c58"><span class="c3">TTL Avg Preproc. Graph </span><span class="c1">l</span><span class="c3">V</span><span class="c1">l l</span><span class="c3">E</span><span class="c1">l </span><span class="c3">degr. </span><span class="c1">l</span><span class="c3">HL</span><span class="c1">l</span><span class="c3">/</span><span class="c1">l</span><span class="c3">V</span><span class="c1">l </span><span class="c3">Time (s) Austin 2K 317K 119 1,600 11.3 Berlin 12K 2,081K 153 1,734 184.7 Budapest 5K 1,446K 252 2,486 54.4 Denver 10K 7,11K 75 1,190 27.3 Houston 10K 1,113K 113 2,196 72.6 Los Angeles 15K 1928K 127 2,572 194.5 Madrid 4K 1,913K 413 7,230 338.5 Roma 9K 2,281K 258 4,370 353.6 Salt Lake City 6K 330K 53 630 4.5 Sweden 51K 4,072K 76 775 179.1 Toronto 10K 3,300K 305 2,987 262.1 </span></p><p class="c42 c64"><span class="c3">PTLDB was implemented in PostgeSQL 9.3.6, 64bit with the same settings used in [14] (8192Mb shared buffers and 64Mb temp buffers). We conducted experiments belonging to the following query types: (i) Earliest Arrival (EA), La- test Departure (LD) and Shortest Duration (SD) vertex-to- vertex, (ii) Earliest Arrival (EA) and Latest Departure kNN and (iii) Earliest Arrival (EA), Latest Departure (LD) one- to-many. For each experiment, we used 1,000 random start vertices (and goal vertices for vertex-to-vertex queries), re- porting the average running time. Starting timestamps for EA and SD queries are randomly selected from the first quar- ter of timestamp ranges, whereas ending timestamps for LD and SD queries are randomly selected from the fourth quar- ter of timestamp ranges, to ensure that in the majority of the cases we actually get trip results that service a particular type of query. Contrarily, selecting timestamps randomly from all available ranges would significantly lower query times, since a significant percent of those queries would pro- vide no results (no trip would fill the suggested criteria). Be- fore each experiment, we restart the PostgreSQL server for clearing its internal query cache and we also clear the operat- ing system&rsquo;s cache for accurate benchmarking. All kNN and one-to-many charts are plotted in logarithmic scale. Note that (i) PTLDB is the only pure-SQL framework tailored for servicing public transportation queries and (ii) to the best of our knowledge there is no previous work or any working sys- tem trying to tackle EA, LD kNN and one-to-many queries for such networks. Thus, we only present our results, since there is no previous secondary-storage work for comparison. </span><span class="c21">4.1 Performance on HDD </span></p><p class="c2"><span class="c3">In our first round of experiments, we ran experiments on an HDD, specifically a SATA3, ST3000DM001, 7200rpm Seagate Barracuda disk with 64Mb cache. </span></p><p class="c66"><span class="c10">534 </span></p><p class="c78"><span class="c3">Figure 2: EA, LD and SD v2v queries on a HDD </span></p><p class="c60"><span class="c43">4.1.1 Vertex-to-vertex queries </span></p><p class="c41"><span class="c3">Figure 2 shows results for vertex-to-vertex (v2v) queries for PTLDB. Results show that LD queries are 35% faster than EA queries, because in the LD queries we select times- tamps from the fourth quarter of timestamp ranges where there are less trips than the beginning of the day (as in EA queries). SD queries are on average 26% slower than EA queries, due to the increased complexity of the query. In all cases, EA and SD queries take less than 19.2ms and LD queries take less than 7.7ms, which is an considerable achievement, since even main memory solutions (before TTL) would require a few ms for vertex-to-vertex queries and the suggested datasets [23]. Moreover, we may answer such queries with a simple SQL command inside a database, which ensures scalability, regardless of the numbers of users or the size of the datasets and with a performance that is fast enough for real-time online applications. </span></p><p class="c13"><span class="c43">4.1.2 </span><span class="c3">k</span><span class="c43">NN queries </span></p><p class="c14"><span class="c3">In this section, we provide the PTLDB&rsquo;s results for EA and LD kNN queries. Similar to previous works [14], we will experiment with varying values of k and target density D, i.e., the ratio |T|/|V |, where T is the set of target-stops in the graph and |V | is the total number of vertices. As explained in Section 3.2.1, for database frameworks it makes sense to create large knn tables for the maximum value kmax of k that will be serviced by the respective framework. Thus, we have created two versions of kNN DB tables for PTLDB, one for kmax = 4 and one for kmax = 16. Then, the kNN DB table for kmax = 4 is used for answering kNN queries for k = 1, k = 2 and k = 4 and the kNN table for kmax = 16 is used for answering kNN queries for k = 8 and k = 16. </span></p><p class="c87"><span class="c3">In our first set of kNN experiments, we compare our op- timized EA-kNN and LD-kNN queries (see Codes 3, 4) in comparison to the corresponding naive kNN implementa- tion (Code 2) for varying values of k. Results are presented in Figure 3. Results show that the optimized versions are 11 &minus; 53&times; faster than their naive counterparts. Thus, it re- ally pays off to group tuples in the knn ea (and knn ld) DB tables by departure (arrival) hour. For the remainder of the paper, we will only provide results for the optimized EA-kNN and LD-kNN queries, since those queries provide significantly superior performance. </span></p><p class="c30"><span class="c3">Figure 4 shows the absolute times of optimized EA-kNN and LD-kNN queries for the same scenario, i.e., for D = 0.01 and varying values of k. Results show that the EA-kNN queries require &lt;64ms for all values of k (except the highest ratio |HL|/|V | dataset of Madrid and k = 8,16). LD-kNN </span></p><p class="c6 c79"><span class="c3">Figure 7: EA, LD and SD v2v queries on a SSD </span></p><p class="c42 c53"><span class="c3">queries are even faster, requiring less than 32ms on all cases. In our third set of kNN experiments, we assess the per- formance of PTLDB for varying values of D. For each value for D, we have build separate versions of knn ea and knn ld DB tables for D &middot; |V | targets selected at random from each dataset and kmax = 4. Figure 5 shows re- sults for k = 4 and D = {0.001,0.005,0.01,0.05,0.1}. Re- sults show, that although PTLDB&rsquo;s performance degrades for larger values of D, kNN queries may still be answered in less than 128ms (with the exception of Madrid for EA queries and Toronto for LD queries and D = 0.1). For the smaller datasets (Austin, Berlin, Budapest, Denver, Hous- ton, Los Angeles, Salt Lake City, even Sweden) kNN queries always take less than 32ms. Moreover, EA-kNN queries are more robust to increasing values of D than LD-kNN queries that perform significantly worse for denser targets (i.e., for D = 0.1). Conclusively, the PTLDB framework provides excellent kNN query performance for all values of D and k. </span></p><p class="c22"><span class="c43">4.1.3 One-to-Many queries </span></p><p class="c52"><span class="c3">In our third round of experiments, we assess the perfor- mance of PTLDB for one-to-many queries. Figure 6 presents the corresponding results for varying values of D (D = {0.001,0.005,0.01,0.05,0.1}). PTLDB answers EA-OTM queries in less than 512ms for all datasets and values of D (except the Madrid and Toronto datasets that require 1084ms and 751ms respectively for D = 0.1). For LD-OTM queries PTLDB requires less than 256ms for all datasets and values of D (except the Madrid, Roma and Toronto datasets that require 303ms, 325ms and 349ms respectively for D = 0.1). Note, that for such high values of D, the one-to-many query almost degrades to the one-to-all query and hence, it cannot get any faster on a secondary storage device. </span><span class="c21">4.2 Performance on SSD </span></p><p class="c42 c68"><span class="c3">Having established PTLDB&rsquo;s performance in the HDD, we repeat most previous experiments on a SSD (a SATA3 Crucial CT512MX100SSD1 MX100 512GB 2.5&rdquo;) to measure how the secondary-storage device type impacts results. </span></p><p class="c88"><span class="c43">4.2.1 Vertex-to-vertex queries </span></p><p class="c2"><span class="c3">Results for all variants of vertex-to-vertex queries on the SSD are shown in Figure 7. Results show that by using the SSD, PTLDB is 3 - 20&times; faster for EA, 6 - 17&times; faster for LD and 3 - 19&times; faster for SD vertex-to-vertex queries. Thus, EA queries may now be answered in less than 2.5ms, SD queries may now be answered in less than 3.2ms and LD queries may now be answered in less than 0.6ms. Conclusively, the usage </span></p><p class="c24"><span class="c10">535 </span></p><p class="c6"><span class="c3">(b) LD-kNN Figure 5: kNN queries for k = 4 and varying values of D </span></p><p class="c8"><span class="c3">of SSD benefits significantly all vertex-to-vertex variations within PTLDB and therefore PTLDB may easily be used for public-transit real-time applications and such queries, since query times always require less than 3.2ms. </span></p><p class="c6"><span class="c43">4.2.2 </span><span class="c3">k</span><span class="c43">NN and One-to-many queries </span></p><p class="c8"><span class="c3">In this section, we repeated all the kNN and one-to-many experiments performed in Sections 4.1.2 and 4.1.3 on the SSD. Results for kNN queries, D = 0.01 and varying values </span></p><p class="c8"><span class="c3">of k are presented in Figure 8. Results show that for kNN queries, the usage of the SSD does not provide any further benefits (in fact sometimes the SSD performs slightly worse), meaning that in PTLDB we have effectively minimized sec- ondary storage utilization for kNN queries and thus, adding a faster storage medium adds no performance benefits. The same pattern was encountered on all experiments, for differ- ent values of D or k, including the respective one-to-many queries and therefore the resulting figures are omitted. </span></p><p class="c6"><span class="c10">536 </span></p><p class="c49"><span class="c11">S</span><span class="c18">64 </span><span class="c19">Austin Berlin Budapest Denver Houston Los Angeles </span><span class="c18">32</span><span class="c19">Madrid </span></p><p class="c6"><span class="c19">Roma </span><span class="c18">p udeep</span><span class="c19">Salt Lake City </span></p><p class="c6"><span class="c19">Sweden Toronto </span></p><p class="c6"><span class="c18">16</span><span class="c11">8</span><span class="c3">(a) EA-kNN </span></p><p class="c49"><span class="c18">64 </span><span class="c19">Austin Berlin Budapest Denver Houston Los Angeles </span><span class="c18">32</span><span class="c19">Madrid </span></p><p class="c6"><span class="c19">Roma </span><span class="c18">p udeep</span><span class="c11">S</span><span class="c19">Salt Lake City </span></p><p class="c6"><span class="c19">Sweden Toronto </span></p><p class="c6"><span class="c18">16</span><span class="c11">1 2 4 8 16 </span></p><p class="c65"><span class="c11">8</span><span class="c3">(b) LD-kNN Figure 3: Speedup of optimized kNN queries, in comparison to the naive versions for D = 0.01 and varying values of k </span></p><p class="c6"><span class="c3">(a) EA-kNN </span></p><p class="c6"><span class="c3">(a) EA-kNN </span></p><p class="c6"><span class="c3">(b) LD-kNN Figure 4: kNN queries for D = 0.01 and varying values of k </span></p><p class="c6"><span class="c11">k </span></p><p class="c6"><span class="c11">1 2 4 8 16 </span></p><p class="c6"><span class="c11">k </span></p><p class="c6"><span class="c3">(b) LD-kNN Figure 8: kNN queries for D = 0.01 and varying values of k on the SSD </span></p><p class="c6"><span class="c21">4.3 Summary </span></p><p class="c6"><span class="c3">Our experimentation has shown that our proposed PTLDB framework provides excellent performance for all public trans- portation planning queries. Using HDDs, PTLDB may an- swer vertex-to-vertex queries in less than 19.2ms For SSDs, this time drops down to 3.2ms. For the newly formulated EA and LD kNN queries, PTLDB requires less than 64ms and 32ms, for k = 16 and D = 0.01 for the vast majority of the tested datasets. Even the EA and LD One-to-many queries require less than 512ms and 256ms respectively, for most datasets and varying values of D. Regarding memory requirements, PTLDB is very modest, since all DB tables and primary key indexes, including the lout, lin, knn ea, knn ld (for all values of D and kmax = 4,16) and the otm ea, otm ld tables (for all available values of D) for all tested datasets, require less than 12GB. Hence, PTLDB may easily scale to even significantly larger datasets. Over- all, not only PTLDB is the only pure-SQL framework tai- lored for multiple public-transportation queries, offering ex- cellent performance for real-time applications but the sim- plicity of its SQL queries, makes its integration with existing real-world applications very easy and seamless. </span></p><p class="c6"><span class="c21">5. CONCLUSION </span></p><p class="c49"><span class="c3">This work presented PTLDB, a novel SQL framework for answering multiple route-planning queries for public trans- portation graphs on a database. Our results showed that PTLDB provides excellent query performance, minimum secondary storage utilization and maximum scalability. More- over, we have extended kNN and one-to-many queries for public transportation networks and proposed how to effi- ciently answer them within PTLDB, with a few lines of SQL code. This establishes PTLDB as a competitive database- driven solution for querying public transportation networks. The paper gives the complete design and implementation details of PTLDB using a popular, open-source database engine, along with the exact SQL queries used in our im- plementation. This easily allows the replication of our re- sults and might provide the necessary foundation for other researchers to expand the PTLDB framework towards han- dling additional types of queries and novel use-cases. In terms of future work, currently the PTLDB framework aims at optimizing travel times, without taking the number of transfers as an additional optimization criterion. Integrat- ing this additional constraint would further improve the use- cases and marketability of the PTLDB framework. </span></p><p class="c6"><span class="c10">537 </span></p><p class="c6"><span class="c3">(a) EA-OTM </span></p><p class="c6"><span class="c3">(a) EA-kNN </span></p><p class="c6"><span class="c3">(b) LD-OTM Figure 6: One-to-many queries for varying values of D </span></p><p class="c92"><span class="c21">Acknowledgments </span><span class="c3">This work was partially funded by the project &ldquo;Research Programs for Excellence 2014-2016 / CitySense-ATHENA R.I.C.&rdquo; The author would also like to thank the authors of Timetable Labeling (TTL) [23]. </span></p><p class="c36"><span class="c21">6. REFERENCES </span></p><p class="c17"><span class="c3">[1] I. Abraham, D. Delling, A. Fiat, A. V. Goldberg, and </span></p><p class="c40"><span class="c3">R. F. Werneck. Hldb: Location-based services in databases. In SIGSPATIAL GIS. ACM, November 2012. [2] I. Abraham, D. Delling, A. Goldberg, and R. Werneck. </span></p><p class="c61 c75"><span class="c3">A hub-based labeling algorithm for shortest paths in road networks. In P. Pardalos and S. Rebennack, editors, Experimental Algorithms, volume 6630 of Lecture Notes in Computer Science, pages 230&ndash;241. Springer Berlin Heidelberg, 2011. [3] I. Abraham, D. Delling, A. V. Goldberg, and R. F. </span></p><p class="c40"><span class="c3">Werneck. Hierarchical hub labelings for shortest paths. In L. Epstein and P. Ferragina, editors, Algorithms &ndash; ESA 2012, volume 7501 of Lecture Notes in Computer Science, pages 24&ndash;35. Springer Berlin Heidelberg, 2012. [4] T. Akiba, Y. Iwata, and Y. Yoshida. Fast exact </span></p><p class="c84"><span class="c3">shortest-path distance queries on large networks by pruned landmark labeling. In Proceedings of the ACM SIGMOD International Conference on Management of Data, SIGMOD 2013, New York, USA, pages 349&ndash;360, 2013. [5] H. Bast, D. Delling, A. V. Goldberg, </span></p><p class="c61 c86"><span class="c3">M. M&uuml;ller-Hannemann, T. Pajor, P. Sanders, D. Wagner, and R. F. Werneck. Route planning in transportation networks. CoRR, abs/1504.05140, 2015. [6] E. Cohen, E. Halperin, H. Kaplan, and U. Zwick. </span></p><p class="c80"><span class="c3">Reachability and distance queries via 2-hop labels. In Proceedings of the Thirteenth Annual ACM-SIAM Symposium on Discrete Algorithms, SODA &rsquo;02, pages 937&ndash;946, Philadelphia, PA, USA, 2002. Society for Industrial and Applied Mathematics. [7] D. Delling, J. Dibbelt, T. Pajor, and R. Werneck. </span></p><p class="c61 c93"><span class="c3">Public transit labeling. In E. Bampis, editor, Experimental Algorithms, volume 9125 of Lecture Notes in Computer Science, pages 273&ndash;285. Springer International Publishing, 2015. [8] D. Delling, A. V. Goldberg, A. Nowatzyk, and R. F. Werneck. Phast: Hardware-accelerated shortest path trees. In Proceedings of the 2011 IEEE International Parallel &amp; Distributed Processing Symposium, IPDPS &rsquo;11, pages 921&ndash;931, Washington, DC, USA, 2011. [9] D. Delling, A. V. Goldberg, T. Pajor, and R. F. Werneck. Robust distance queries on massive networks. In Algorithms - ESA 2014 - 22th Annual European Symposium, Wroclaw, Poland, September 8-10, 2014. Proceedings, pages 321&ndash;333, 2014. [10] D. Delling, A. V. Goldberg, and R. F. Werneck. Hub </span></p><p class="c95"><span class="c3">label compression. In Experimental Algorithms, 12th International Symposium, SEA 2013, Rome, Italy, June 5-7, 2013. Proceedings, pages 18&ndash;29, 2013. [11] D. Delling, A. V. Goldberg, and R. F. F. Werneck. Faster batched shortest paths in road networks. In ATMOS, pages 52&ndash;63, 2011. [12] D. Delling and R. F. Werneck. Customizable </span></p><p class="c6 c63"><span class="c3">point-of-interest queries in road networks. In 21st SIGSPATIAL International Conference on Advances in Geographic Information Systems, SIGSPATIAL 2013, Orlando, FL, USA, November 5-8, 2013, pages 490&ndash;493, 2013. [13] D. Delling and R. F. F. Werneck. Better bounds for </span></p><p class="c42 c61"><span class="c3">graph bisection. In Algorithms - ESA 2012 - 20th Annual European Symposium, Ljubljana, Slovenia, September 10-12, 2012. Proceedings, pages 407&ndash;418, 2012. [14] A. Efentakis, C. Efstathiades, and D. Pfoser. Cold. revisiting hub labels on the database for large-scale graphs. In C. Claramunt, M. Schneider, R. C.-W. Wong, L. Xiong, W.-K. Loh, C. Shahabi, and K.-J. Li, editors, Advances in Spatial and Temporal Databases, volume 9239 of Lecture Notes in Computer Science, pages 22&ndash;39. Springer International Publishing, 2015. [15] A. Efentakis and D. Pfoser. GRASP. Extending graph separators for the single-source shortest-path problem. In A. S. Schulz and D. Wagner, editors, Algorithms - ESA 2014, volume 8737 of Lecture Notes in Computer Science, pages 358&ndash;370. Springer Berlin Heidelberg, 2014. [16] A. Efentakis and D. Pfoser. Rehub. extending hub </span></p><p class="c72"><span class="c3">labels for reverse k-nearest neighbor queries on large-scale networks. CoRR, abs/1504.01497, 2015. [17] A. Efentakis, D. Pfoser, and Y. Vassiliou. Salt. a </span></p><p class="c73"><span class="c3">unified framework for all shortest-path query variants on road networks. In E. Bampis, editor, Experimental Algorithms, volume 9125 of Lecture Notes in Computer Science, pages 298&ndash;311. Springer International Publishing, 2015. [18] C. Gavoille, D. Peleg, S. P&eacute;rennes, and R. Raz. </span></p><p class="c89"><span class="c3">Distance labeling in graphs. In Proceedings of the Twelfth Annual ACM-SIAM Symposium on Discrete Algorithms, SODA &rsquo;01, pages 210&ndash;219, Philadelphia, PA, USA, 2001. Society for Industrial and Applied Mathematics. [19] GoogleTransitDataFeed. PublicFeeds. List of publicly-accessible transit data feeds [online]. </span><span class="c1">https://code.google.com/p/ googletransitdatafeed/wiki/PublicFeeds</span><span class="c3">, 2015. [20] M. Jiang, A. W. Fu, R. C. Wong, and Y. Xu. Hop doubling label indexing for point-to-point distance querying on scale-free networks. PVLDB, 7(12):1203&ndash;1214, 2014. [21] B. Liao, L. U, M. Yiu, and Z. Gong. Beyond </span></p><p class="c33"><span class="c3">millisecond latency k nn search on commodity machine. Knowledge and Data Engineering, IEEE Transactions on, 27(10):2618&ndash;2631, Oct 2015. [22] PostgreSQL. The world&rsquo;s most advanced open source database [online]. </span><span class="c1">http://www.postgresql.org/</span><span class="c3">, 2015. [23] S. Wang, W. Lin, Y. Yang, X. Xiao, and S. Zhou. </span></p><p class="c51"><span class="c3">Efficient route planning on public transportation networks: A labelling approach. In Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data, SIGMOD &rsquo;15, pages 967&ndash;982, New York, NY, USA, 2015. ACM. [24] S. Wang, W. Lin, Y. Yang, X. Xiao, and S. Zhou. </span></p><p class="c61 c83"><span class="c3">Timetable labelling [online]. </span><span class="c1">http://sourceforge.net/projects/ttl2015/</span><span class="c3">, 2015. </span></p><p class="c56"><span class="c10">538 </span></p></body></html>