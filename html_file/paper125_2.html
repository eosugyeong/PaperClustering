<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c12{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.5pt;font-family:"Arial";font-style:normal}.c96{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.7pt;font-family:"Times New Roman";font-style:normal}.c67{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:19.4pt;font-family:"Times New Roman";font-style:normal}.c46{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.8pt;font-family:"Arial";font-style:normal}.c21{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:9.7pt;font-family:"Arial";font-style:normal}.c36{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Courier New";font-style:normal}.c17{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8.7pt;font-family:"Arial";font-style:italic}.c11{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:9pt;font-family:"Times New Roman";font-style:normal}.c41{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:19.4pt;font-family:"Arial";font-style:normal}.c100{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10.8pt;font-family:"Times New Roman";font-style:normal}.c97{color:#000000;font-weight:700;text-decoration:none;vertical-align:sub;font-size:14.5pt;font-family:"Times New Roman";font-style:normal}.c57{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:16.1pt;font-family:"Arial";font-style:normal}.c60{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:9.7pt;font-family:"Courier New";font-style:normal}.c103{color:#000000;font-weight:700;text-decoration:none;vertical-align:super;font-size:11.3pt;font-family:"Times New Roman";font-style:normal}.c0{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:6.8pt;font-family:"Times New Roman";font-style:normal}.c28{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:17.4pt;font-family:"Arial";font-style:normal}.c20{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.5pt;font-family:"Arial";font-style:normal}.c16{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:8.7pt;font-family:"Times New Roman";font-style:normal}.c95{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8.7pt;font-family:"Courier New";font-style:normal}.c33{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11.6pt;font-family:"Arial";font-style:normal}.c8{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.8pt;font-family:"Arial";font-style:normal}.c14{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:4.8pt;font-family:"Times New Roman";font-style:normal}.c52{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.9pt;font-family:"Courier New";font-style:normal}.c40{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.9pt;font-family:"Arial";font-style:normal}.c7{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:9.7pt;font-family:"Arial";font-style:normal}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.7pt;font-family:"Arial";font-style:normal}.c72{margin-left:-18.5pt;padding-top:1.4pt;text-indent:27.1pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.6pt}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.8pt;font-family:"Arial";font-style:normal}.c55{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.1pt;font-family:"Arial";font-style:normal}.c80{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:7.7pt;font-family:"Times New Roman";font-style:normal}.c76{margin-left:-18.5pt;padding-top:3.1pt;text-indent:27.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.6pt}.c98{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10.8pt;font-family:"Times New Roman";font-style:normal}.c32{margin-left:-18.5pt;padding-top:4.1pt;text-indent:27.1pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.6pt}.c13{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11.3pt;font-family:"Arial";font-style:normal}.c75{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.4pt;font-family:"Times New Roman";font-style:normal}.c49{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:11.3pt;font-family:"Arial";font-style:normal}.c70{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10.7pt;font-family:"Times New Roman";font-style:normal}.c43{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.8pt;font-family:"Courier New";font-style:normal}.c35{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:8.7pt;font-family:"Arial";font-style:italic}.c82{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12.9pt;font-family:"Courier New";font-style:normal}.c50{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.5pt;font-family:"Arial";font-style:italic}.c37{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c102{margin-left:-19pt;padding-top:1pt;text-indent:25.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:60.4pt}.c22{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.5pt;font-family:"Times New Roman";font-style:normal}.c62{color:#000000;font-weight:700;text-decoration:none;vertical-align:sub;font-size:11.3pt;font-family:"Times New Roman";font-style:normal}.c42{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.7pt;font-family:"Courier New";font-style:normal}.c54{color:#000000;font-weight:700;text-decoration:none;vertical-align:sub;font-size:12.9pt;font-family:"Times New Roman";font-style:normal}.c27{margin-left:-16.9pt;padding-top:1.7pt;text-indent:25.5pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18.5pt}.c64{margin-left:-18.5pt;padding-top:1.7pt;text-indent:27.1pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.6pt}.c19{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.7pt;font-family:"Arial";font-style:italic}.c44{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.3pt;font-family:"Arial";font-style:normal}.c15{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.5pt;font-family:"Arial";font-style:normal}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8.7pt;font-family:"Arial";font-style:normal}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12.9pt;font-family:"Arial";font-style:normal}.c9{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11.6pt;font-family:"Times New Roman";font-style:normal}.c25{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.1pt;font-family:"Arial";font-style:normal}.c18{margin-left:-16.9pt;padding-top:1.4pt;text-indent:25.5pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18.5pt}.c39{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.6pt;font-family:"Courier New";font-style:normal}.c58{margin-left:4.3pt;padding-top:4.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:45.3pt}.c61{margin-left:-18.5pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.6pt}.c105{margin-left:2.2pt;padding-top:24.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:4pt}.c68{margin-left:-8.2pt;padding-top:3.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-18.5pt}.c83{margin-left:-15.8pt;padding-top:9.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:91.4pt}.c86{margin-left:-14.2pt;padding-top:20.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:67.4pt}.c48{margin-left:-18.5pt;padding-top:18.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.6pt}.c65{margin-left:-13.9pt;padding-top:5.5pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-5.1pt}.c73{margin-left:-18.5pt;padding-top:16.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.6pt}.c71{margin-left:-18.5pt;padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-2.2pt}.c5{margin-left:237.1pt;padding-top:42pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-272.5pt}.c104{margin-left:-18.5pt;padding-top:3.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.6pt}.c31{margin-left:-18.5pt;padding-top:9.4pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-17.8pt}.c56{margin-left:-15.8pt;padding-top:9.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:101pt}.c34{margin-left:98.4pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-5.1pt}.c84{margin-left:-5.5pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.6pt}.c101{margin-left:-18.5pt;padding-top:3.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.6pt}.c69{margin-left:-5.5pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.6pt}.c90{margin-left:-16.9pt;padding-top:13.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:14.2pt}.c45{margin-left:-18.5pt;padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:99.3pt}.c77{margin-left:218.2pt;padding-top:75.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-36.1pt}.c79{margin-left:-18.5pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-16.6pt}.c88{margin-left:-18.5pt;padding-top:11.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.6pt}.c63{margin-left:218.2pt;padding-top:461.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:217.9pt}.c10{margin-left:-9.8pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-0.6pt}.c81{margin-left:-13.9pt;padding-top:4.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-10.4pt}.c89{margin-left:4.3pt;padding-top:5.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:7.8pt}.c30{margin-left:-18.5pt;padding-top:305.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.6pt}.c94{margin-left:-17.4pt;padding-top:4.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:79.4pt}.c78{margin-left:-16.6pt;padding-top:4.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:47.7pt}.c92{margin-left:-16.9pt;padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:61.9pt}.c87{padding-top:70.1pt;text-indent:25.5pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c51{padding-top:3.8pt;text-indent:25.5pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c66{padding-top:1.7pt;text-indent:25.5pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c93{padding-top:3.8pt;text-indent:25.5pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c74{padding-top:1.4pt;text-indent:25.5pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c91{padding-top:10.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c24{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c23{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c59{padding-top:18pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c26{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c29{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c53{margin-left:237.1pt;margin-right:-18.5pt}.c38{margin-left:-16.9pt;margin-right:-18.5pt}.c47{margin-left:36pt;margin-right:37.8pt}.c85{margin-left:-12.6pt;margin-right:61pt}.c99{text-indent:27.1pt}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:24pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:14pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c29"><p class="c1"><span class="c37">Series ISSN: 2367-2005 120 </span><span class="c36">10.5441/002/edbt.2017.12 </span></p><p class="c1"><span class="c28">Finding Socio-Textual Associations Among Locations </span></p><p class="c1"><span class="c33">Paras Mehta </span><span class="c57">Freie Universit&auml;t Berlin Germany </span><span class="c41">paras.mehta@fu- berlin.de </span></p><p class="c1"><span class="c33">Dimitris Sacharidis </span><span class="c57">Technische Universit&auml;t Wien </span><span class="c41">dimitris@ec.tuwien.ac.at </span></p><p class="c1"><span class="c57">Austria </span><span class="c33">Dimitrios Skoutas </span><span class="c57">IMIS, Athena R.C. </span><span class="c41">dskoutas@imis.athena- innovation.gr </span><span class="c57">Greece </span><span class="c33">Agn&egrave;s Voisard </span><span class="c57">Freie Universit&auml;t Berlin Germany </span><span class="c41">agnes.voisard@fu-berlin.de </span></p><p class="c1"><span class="c9">ABSTRACT </span><span class="c3">An increasing amount of user-generated content on the Web is geotagged. This often results in the formation of user trails, e.g., sequences of photos, check-ins, or text messages, that users gener- ate while visiting various locations. In this paper, we introduce and study the problem of identifying sets of locations that are strongly associated under social and textual criteria. We say that a loca- tion set is associated with a set of keywords if there exists a user with posts around these locations whose textual descriptions cover all keywords. We measure the strength of this association by the number of users with posts that support it. Although the prob- lem reminisces frequent itemset mining, we show that our support measure does not satisfy the necessary anti-monotonicity property, which is used to effectively prune the search space. Nonetheless, by studying the characteristics of the support measure, we are able to devise an efficient approach. We present a basic and two opti- mized algorithms, exploiting an inverted or a spatio-textual index to increase efficiency. Finally, we conduct an experimental evalu- ation using geotagged Flickr photos in three major cities. From a qualitative perspective, the results indicate that the introduced type of query returns meaningful and interesting location sets, which are not discovered by other existing approaches. Furthermore, the pro- posed optimizations and the use of appropriate indexes significantly reduce computation time. </span></p><p class="c1"><span class="c9">1. INTRODUCTION </span></p><p class="c24"><span class="c3">With the increasingly widespread use of mobile GPS-enabled devices and social networks, the amount of geotagged content on the Web is constantly growing. A user moving around a city may upload photos, post tweets, or check in at various locations, generating a </span><span class="c17">digital trail </span><span class="c3">of activities, which can be represented as a sequence of geotagged posts. Such publicly available trails enable the analysis and extraction of location associations that are implicitly defined by the activities of city dwellers or visitors. In turn, these associations can be used to build smarter location-based services and better understand how people experience their urban environment. </span></p><p class="c24"><span class="c3">&copy;</span><span class="c96">2017, Copyright is with the authors. Published in Proc. 20th Inter- national Conference on Extending Database Technology (EDBT), March 21-24, 2017 - Venice, Italy: ISBN 978-3-89318-073-8, on OpenProceed- ings.org. Distribution of this paper is permitted under the terms of the Cre- ative Commons license CC-by-nc-nd 4.0 </span></p><p class="c24"><span class="c3">In this work, we seek to find </span><span class="c17">Socio-Textual Associations </span><span class="c3">(STAs) among locations that are strongly supported by a corpus of geo- tagged social media content. Given a set of keywords, we say that a group of locations are socio-textually associated if a user has posts near each of these locations, and the combined keyword set of these posts contains all query keywords. The more people make an asso- ciation, i.e., the stronger its support in the corpus is, the likelier it is that there exists a latent thematic connection among the locations. </span></p><p class="c24"><span class="c3">Compared to previous works that search for connections among a group of locations, our work has the distinguishing and novel aspect that it considers </span><span class="c17">social and textual criteria in unison </span><span class="c3">to define asso- ciations. In one line of work (e.g., [12, 10, 15, 3, 19, 23]), which we term </span><span class="c17">Location Patterns </span><span class="c3">(LP), the objective is to determine groups, patterns or sequences of locations (or regions) that are frequent in terms of purely social criteria, i.e., how many people support them. Since the process ignores the textual aspect, the identified locations are not semantically characterized or distinguished, and thus there is no mechanism to explore or exploit the resulting groups under a thematic context. For instance, this limits queries to finding the overall most frequent sequence of locations in a given area, or the most frequent Point of Interest (POI) to visit next. Even though one could easily enrich locations with textual information </span><span class="c17">after </span><span class="c3">the mining process, say to support recommending the most frequent restaurant to visit next, the locations remain only socially associ- ated, and not thematically, because the computed frequencies still ignore the textual aspect. </span></p><p class="c24"><span class="c3">Another related line of work is the </span><span class="c17">Collective Spatial Keyword </span><span class="c3">(CSK) query [21, 4], where locations are grouped according to tex- tual criteria (i.e., they must collectively cover the given keywords) and spatial criteria (i.e., they must be close to each other and/or to the user&rsquo;s location). Thus, the optimization objective is an ag- gregate spatial distance, instead of some evidence-based frequency metric. In other words, the strength of the association among a valid group of locations (i.e., one that covers all keywords) is defined by spatial proximity alone. Again, this </span><span class="c17">proximity-based </span><span class="c3">approach fails to establish a thematic connection evidenced by users&rsquo; behavior. For example, the fact that there is a restaurant next to an art exhibi- tion venue, does not necessarily imply that art-loving people would find this particular restaurant attractive, unless such a connection is indeed supported by a large number of posts, from the same users, containing, for example, both keywords &ldquo;</span><span class="c17">art</span><span class="c3">&rdquo; and &ldquo;</span><span class="c17">restau- rant</span><span class="c3">&rdquo; around these locations. As a matter of fact, if a strong thematic association among nearby locations exists, our problem formulation will certainly capture it. </span></p><p class="c1"><span class="c3">A rather straightforward way to associate locations with keywords </span></p><p class="c105"><span class="c16">Table 1: Categorization of Existing Work and Ours </span></p><p class="c81"><span class="c0">Line of Work Information Exploited Optimization </span></p><p class="c34"><span class="c0">Spatial Textual Social Objective </span></p><p class="c65"><span class="c8">Location Patterns (LP) </span><span class="c46">[3, 10, 12, 15, 19, 23] </span><span class="c8">&times; &times; frequency Collective Spatial Keyword (CSK) </span><span class="c46">[4, 21] </span><span class="c8">&times; &times; proximity Aggregate Popularity (AP) &times; &times; &times; popularity Socio-Textual Associations (STA) &times; &times; &times; frequency </span></p><p class="c73"><span class="c3">according to users&rsquo; behavior is based on rank aggregation [8]. For each keyword, consider a ranking of locations according to the keyword popularity, i.e., the number of posts that contain it. Then, to derive a group of locations that is most associated with a set of keywords, one can simply collect the most popular location for each keyword. This approach, which we call </span><span class="c17">Aggregate Popularity </span><span class="c3">(AP), has the advantage that individual locations are strongly associated with their respective keywords, but the location set as a whole may lack a strong socio-textual association. Indeed, each location may be popular for a different type of users, hence there may be no significantly sized population for which all these locations are popular. Exactly as in the case of proximity-based associations, if a strong thematic association among popular locations exists, our socio-textual approach will discover it. </span></p><p class="c72"><span class="c3">Another differentiating trait of our work is that we consider the textual information that is included in the posts themselves, and do not rely on an external categorization of locations or POIs. The reason is that we seek to exploit the </span><span class="c17">wisdom of the crowd </span><span class="c3">to also determine textual relevance, in addition to quantify the strength of derived associations. Nonetheless, our methods can be readily adapted to take into account external textual descriptions as well. </span></p><p class="c79"><span class="c3">To better frame our contribution with respect to previous works, Table 1 summarizes all approaches according to the type of infor- mation they exploit, i.e., spatial, textual, or social (user id), as well as the objective they optimize for. Mining location patterns does not exploit textual information, and seeks for groups of locations that maximize the frequency with which they co-appear among users&rsquo; trails. On the other hand, collective spatial keyword queries ignore the social aspect, and look for location sets that maximize their proximity (to each other and/or a target location) subject to the constraint that they cover given keywords. An approach based on aggregating popularity considers all types of information avail- able, and strives to include locations that are individually popular for some keyword and collectively cover given keywords. Our work also considers all types of information, but optimizes for a frequency metric that counts co-appearances of locations under a certain theme/topic/context, which is defined by the given keywords. As an example, consider a search for locations in Berlin using the keywords &ldquo;</span><span class="c17">wall</span><span class="c3">&rdquo;, &ldquo;</span><span class="c17">art</span><span class="c3">&rdquo; and &ldquo;</span><span class="c17">restaurant</span><span class="c3">&rdquo;. Figure 1 depicts the results returned by different alternative approaches for combin- ing locations to satisfy these keywords. Our socio-textual based approach returns the following location set as the top result (star- shaped markers): &#12296; &ldquo;East Side Gallery&rdquo;, &ldquo;Hackescher Markt&rdquo; &#12297;. The former is a portion of the Berlin wall covered with paintings, hence hosting many posts with the keywords &ldquo;</span><span class="c17">wall</span><span class="c3">&rdquo; and &ldquo;</span><span class="c17">art</span><span class="c3">&rdquo;. The latter is a popular square in the city center, hosting also a series of restaurants frequently visited by tourists and travelers. As it turns out, these locations are neither the most popular ones for each indi- vidual keyword (see locations with circle-shaped markers, returned by the AP approach) nor close to each other. Yet, they reveal an interesting association, hinting to the fact that many travelers that have visited or plan to visit the Wall, being interested in art, tend to also prefer restaurants located at Hackescher Markt. </span></p><p class="c61 c99"><span class="c3">Furthermore, a search based on CSK identified around 350 sin- gleton locations, for which there exists at least one user with posts </span></p><p class="c1 c38"><span class="c16">Figure 1: Example of location sets retrieved for keywords &ldquo;</span><span class="c35">wall</span><span class="c16">&rdquo;, &ldquo;</span><span class="c35">art</span><span class="c16">&rdquo; and &ldquo;</span><span class="c35">restaurant</span><span class="c16">&rdquo; in Berlin. </span></p><p class="c38 c91"><span class="c3">containing all query keywords. One of these results is illustrated in Figure 1 (square-shaped marker). It is not straightforward how to select the best among these results; in fact, several of them may even be due to outliers or noise, which are inherent to crowdsourced content. Since a CSK query does not take frequency into account, it is better suited for cases where the query terms refer to (curated) POI categories, while being error prone and sensitive to outliers when searching on raw tags. On the other hand, the top result based on AP consists of Brandenburg Gate (for &ldquo;</span><span class="c17">wall</span><span class="c3">&rdquo;), a famous monu- ment close to where the Berlin wall used to pass; the intersection of Gneisenaustr. and Mehringdamm streets (for &ldquo;</span><span class="c17">restaurant</span><span class="c3">&rdquo;), a place with many popular restaurants; and Stattbad Wedding (for &ldquo;</span><span class="c17">art</span><span class="c3">&rdquo;), a former well-known art venue. Each of these locations is popular for the respective query keyword, but they do not represent any strong shared interest between the people visiting them. </span></p><p class="c27"><span class="c3">Existing algorithms for related problems cannot be used to extract socio-textual associations. Although our problem seems similar to mining frequent location patterns, the requirement for the locations to collectively cover certain keywords significantly complicates the problem, as we discuss in Section 4. Specifically, our notion of support (frequency) for a location set </span><span class="c17">does not exhibit the anti- monotonicity property </span><span class="c3">necessary to apply an Apriori-like algorithm [1]. Briefly, such a property would allow for early pruning of location sets that cannot be extended to produce valid results. Prac- tically, the implication is that a na&iuml;ve algorithm for even a relatively small-sized city-level dataset, with around 20,000 distinct locations, would need to investigate more than 10</span><span class="c21">13 </span><span class="c3">sets of three locations. </span></p><p class="c18"><span class="c3">Nevertheless, by studying the problem characteristics, we are able to introduce a weaker notion of support that (1) exhibits anti- monotonicity, and (2) is an upper bound on the actual support of location sets. Armed with these two properties, we then intro- duce a methodology to efficiently identify location sets with strong socio-textual associations. Moreover, we study three different im- plementations of this methodology, each having its own merits. In the simplest, we assume that no pre-processing is allowed and that no index structure is available. We then present a method based on a simple off-the-shelf inverted index, and demonstrate how it can significantly speed up processing. The only caveat is that the association of locations with nearby posts is assumed to be known beforehand. Finally, leveraging the recent advances in spatio-textual indices, we devise an algorithm that exploits their general function- ality. In particular, we consider the state-of-the-art I</span><span class="c21">3 </span><span class="c3">index [22], which we also extend further to derive an even faster approach. Compared to the inverted index approach, the spatio-textual index methods allow to define the association of locations with nearby </span></p><p class="c77"><span class="c37">121 </span></p><p class="c48"><span class="c3">posts dynamically, which causes an overhead in execution time but provides higher flexibility. </span></p><p class="c64"><span class="c3">In addition, we consider the problem of ranking socio-textually associated location sets instead of relying on a user-specified min- imum support threshold. Thus, we directly address the problem of identifying the k most strongly associated location sets. We de- scribe a general methodology, and propose algorithms that build upon their threshold-based counterparts. </span></p><p class="c10"><span class="c3">The main contributions of our work are summarized below: </span></p><p class="c69"><span class="c3">&bull; We introduce and formally define the problem of finding socio-textually associated location sets. </span></p><p class="c84"><span class="c3">&bull; We study the problem characteristics and introduce a gen- eral framework based on a weaker support measure, which satisfies the desirable anti-monotonicity property. </span></p><p class="c84"><span class="c3">&bull; We present a basic algorithm, and two efficient algorithms that exploit an inverted index and a spatio-textual index, re- spectively, to significantly speed up computation. </span></p><p class="c69"><span class="c3">&bull; We consider the ranking variant of the problem, and discuss the necessary adaptations to all proposed algorithms. </span></p><p class="c61"><span class="c3">&bull; We present results from an experimental evaluation using real-world data from geolocated Flickr photo trails in three major cities. The rest of the paper is structured as follows. In the next section, we present related work. Then, we formally define the problems in Section 3, and study their characteristics in Section 4. Following this analysis, we present our algorithms in Section 5, and extend them to the top-k variant in Section 6. Finally, Section 7 presents our experimental evaluation, and Section 8 concludes the paper. </span></p><p class="c45"><span class="c9">2. RELATED WORK </span></p><p class="c99 c104"><span class="c3">Next, we review related work on the topics of mining frequent locations from geotagged posts and spatial keyword search. </span><span class="c9">2.1 Mining Geotagged Posts </span></p><p class="c32"><span class="c3">Several approaches analyze trails of geotagged posts, mainly pho- tos, to extract interesting Location Patterns (LP), such as scenic routes or frequently traveled paths. A typical methodology is to use a clustering algorithm to extract landmark locations from the original posts, and then apply sequence pattern mining. </span></p><p class="c64"><span class="c3">In [12], clustering is first used to identify POIs; then, association rule mining is applied to extract associative patterns among them. In [10], each photo is first assigned to a nearby POI, whereas, for the remaining ones, a density-based clustering algorithm is applied to generate additional locations. Then, a travel sequence is constructed for each user, and sequence patterns are mined from these individual travel sequences. In [15], kernel vector quantization is used to find clusters of photos; then, routes are defined as sequences of photos from the same user, and patterns are revealed by applying hierarchical clustering on routes using the Levenshtein distance. In [3], a trajectory pattern mining algorithm is applied on geotagged Flickr photos to identify frequent travel patterns and regions of interest. In [16], a clustering method is applied on geotagged photos to identify and rank popular travel landmarks. </span></p><p class="c72"><span class="c3">Geotagged photos have been used to measure the attractiveness of road segments in route recommendation. A tree-based hierar- chical graph is used in [24] to infer users&rsquo; travel experiences and interest of a location from individual sequences. Considering the transition probability between locations, frequent travel sequences are identified. Ranking trajectory patterns mined from sequences of geotagged photos is investigated in [19]. The mean-shift algorithm extracts locations from the original GPS coordinates of the photos; then, the PrefixSpan algorithm identifies the frequent sequential patterns, which are ranked based on user and location importance. </span></p><p class="c24 c38"><span class="c3">In [23], density-based clustering is used to identify regions of at- tractions from trails of geotagged photos; then, the Markov chain model is applied to mine transition patterns among them. </span></p><p class="c18"><span class="c3">Other efforts have focused on automatic trip planning or per- sonalized scenic route recommendations based on geotagged photo trails, taking into account user preferences, current or previous lo- cations, and/or time budget (e.g., [13, 17]). In [6], individual photo streams are integrated into a POI graph, and itineraries are con- structed based on POI popularity, available time, and destination. In [14], users&rsquo; traveling preferences are learned from their travel his- tories in one city, and then used to recommend travel destinations and routes in a different city. In [11], a set of location sequences that match the user&rsquo;s preferences, present location, and time budget, are computed from individual itineraries. From a different perspective, a Bayesian approach is applied in [2] to test different hypotheses about how photo trails are produced. Various assumptions are as- sessed, e.g., that users tend to take photos close to the city center, near POIs, close to their previous location, or a mixture of these. </span></p><p class="c38 c66"><span class="c3">Similar to the works presented above, we also select locations that appear frequently in users&rsquo; posts. However, in our case these locations should be strongly associated with a given set of keywords, a requirement which complicates the search. </span><span class="c9">2.2 Spatial Keyword Search </span></p><p class="c51 c38"><span class="c3">Spatial keyword search involves queries that comprise a user location and a set of keywords. Both the spatial and the textual parts can be applied as boolean filters or as ranking criteria. For example, the query may retrieve all relevant objects within a specified distance from the given location, or rank them based on their proximity to it; similarly, it may retrieve all objects containing one or more of the query keywords, or rank them based on relevance. A comprehensive survey of existing approaches is presented in [5]. </span></p><p class="c18"><span class="c3">These efforts focus on combining spatial and textual indices into hybrid ones. Accordingly, they can be characterized as text-first or space-first [7]. For example, the IF-R*-tree uses an inverted file where the postings in each inverted list are indexed by an R-tree; on the other hand, the R*-tree-IF employs an R*-tree where inverted files are attached to each leaf node [25]. More recent methods have focused on retrieving top-k objects, ranked by an aggregate score combining both spatial proximity and textual relevance [22, 20]. </span></p><p class="c18"><span class="c3">More closely related to our work are Collective Spatial Keyword (CSK) queries, such as the mCK query [21]. Given m keywords, it retrieves a set of spatio-textual objects that are as close to each other as possible and collectively contain all keywords. A similar variant is defined in [4], where the retrieved objects need to be as close to the user location as possible, and, optionally, in close proximity to each other. </span></p><p class="c18"><span class="c3">In our work, we search for a set of locations that cover all given keywords. However, instead of optimizing for spatial proximity, we seek to maximize their co-occurrence in user trails. Thus, the approach for addressing the problem is fundamentally different. </span></p><p class="c92"><span class="c9">3. PROBLEM DEFINITION </span></p><p class="c51 c38"><span class="c3">Assume a database of posts P made by users U. Each post p &isin; P is a tuple p = &#12296;u, l,&Psi;&#12297;, where p.u &isin; U is the user that made the post, p.l = (lon, lat) is the geotag (location) of the post, and p.&Psi; is a set of keywords that characterize it. We use P</span><span class="c7">u </span><span class="c12">to denote all posts </span><span class="c3">of user u, i.e., P</span><span class="c7">u </span><span class="c12">= {p &isin; P : p.u = u}. Furthermore, assume </span><span class="c3">a database of locations L. These may correspond to the posts&rsquo; locations, or, for generality, may also be defined independently of P. For instance, one may use a POI database to populate L, or apply a clustering algorithm on the posts&rsquo; geotags and then construct L from the cluster centroids. Thus, we reserve the term </span><span class="c17">location </span><span class="c3">for </span></p><p class="c77"><span class="c37">122 </span></p><p class="c1"><span class="c16">Table 2: Notation </span><span class="c80">Symbol Definition </span></p><p class="c1"><span class="c4">p, P post, database of posts u, P</span><span class="c7">u </span><span class="c2">user, posts of user </span><span class="c4">l, L, L location, set of locations, database of locations </span></p><p class="c1"><span class="c4">&psi;, &Psi; keyword, set of keywords U</span><span class="c7">L&Psi; </span><span class="c4">set of users supporting (L,&Psi;) U</span><span class="c7">L </span><span class="c6">&nbsp;&#771;</span><span class="c7">&Psi; </span><span class="c4">set of users weakly supporting (L,&Psi;) </span></p><p class="c1"><span class="c4">U</span><span class="c7">&Psi; </span><span class="c2">set of users relevant to &Psi; </span><span class="c4">sup(L,&Psi;) support of (L, &Psi;) w_sup(L,&Psi;) weak support of (L,&Psi;) rw_sup(L,&Psi;) relevant and weak support of (L,&Psi;) </span></p><p class="c1"><span class="c4">&sigma; support threshold </span></p><p class="c1"><span class="c3">a member of L, and refer to a post&rsquo;s location as its </span><span class="c17">geotag</span><span class="c3">. Table 2 summarizes the most important notation. </span></p><p class="c24"><span class="c3">Locations are the principle objects in our work. We seek to identify sets of locations that are </span><span class="c17">strongly associated </span><span class="c3">with a set of keywords. To define this association, we first introduce the concepts of locality and (textual) relevance for a post. </span></p><p class="c24"><span class="c3">D 1 (L P ). </span><span class="c17">A post </span><span class="c3">p </span><span class="c17">is </span><span class="c3">local </span><span class="c17">to location </span><span class="c3">l </span><span class="c17">if the post&rsquo;s geotag is within distance </span><span class="c3">&#491; </span><span class="c17">to</span><span class="c3">l</span><span class="c17">, i.e., if </span><span class="c3">d(p.l, l) &le; &#491;</span><span class="c17">, where </span><span class="c3">d </span><span class="c17">is a distance metric (e.g., Euclidean). </span></p><p class="c1"><span class="c3">D 2 (R P ). </span><span class="c17">A post </span><span class="c3">p </span><span class="c17">is </span><span class="c3">relevant </span><span class="c17">to key- word </span><span class="c3">&psi; </span><span class="c17">if the post&rsquo;s keyword set contains </span><span class="c3">&psi;</span><span class="c17">, i.e., if </span><span class="c3">&psi; &isin; p.&Psi;</span><span class="c17">. </span></p><p class="c24"><span class="c3">Posts associate locations with keywords. These associations are bestowed by users themselves, as opposed, for example, to a spe- cific POI categorization made by a particular source; thus, they capture the wisdom of the crowd. To model the relationships be- tween users&rsquo; posts, locations, and keywords, we introduce a bipartite graph, where the two types of vertices correspond to keywords and locations, while edges correspond to users&rsquo; posts. </span></p><p class="c24"><span class="c3">D 3 (A G ). </span><span class="c17">The </span><span class="c3">Association Graph </span><span class="c17">is a bipartite graph </span><span class="c3">G = (V,E)</span><span class="c17">, where </span><span class="c3">V = &Psi;&cup;L </span><span class="c17">and </span><span class="c3">E &sube; &Psi;&times;L</span><span class="c17">, such that an edge </span><span class="c3">e = (&psi;, l) </span><span class="c17">exists iff there exists at least one post </span><span class="c3">p </span><span class="c17">which is local to </span><span class="c3">l </span><span class="c17">and relevant to </span><span class="c3">&psi;</span><span class="c17">; moreover, </span><span class="c3">e </span><span class="c17">is labeled with the set of users that have made such posts. </span></p><p class="c24"><span class="c3">Figure 2 shows a running example with the posts of five users u</span><span class="c7">1</span><span class="c12">,...,u</span><span class="c7">5 </span><span class="c12">around three locations l</span><span class="c7">1</span><span class="c12">,l</span><span class="c7">2</span><span class="c12">,l</span><span class="c7">3</span><span class="c12">, containing two key- </span><span class="c3">words &psi;</span><span class="c7">1</span><span class="c12">,&psi;</span><span class="c7">2</span><span class="c12">. Post p</span><span class="c7">ij </span><span class="c12">denotes the j-th post of the i-th user. For in- </span><span class="c3">stance, post p</span><span class="c7">12 </span><span class="c12">= &#12296;u</span><span class="c7">1</span><span class="c12">,l</span><span class="c7">2</span><span class="c12">,{&psi;</span><span class="c7">1</span><span class="c12">,&psi;</span><span class="c7">2</span><span class="c12">}&#12297; of user u</span><span class="c7">1 </span><span class="c12">is local to location </span><span class="c3">l</span><span class="c7">2 </span><span class="c12">and relevant to keywords &psi;</span><span class="c7">1 </span><span class="c12">and &psi;</span><span class="c7">2</span><span class="c12">. The resulting Association </span><span class="c3">Graph is depicted in Figure 3. </span></p><p class="c24"><span class="c3">The association between a keyword and a location is explicit, and its strength can be quantified by the number of users making it. For example, three users have associated keyword &psi;</span><span class="c7">1 </span><span class="c12">with location l</span><span class="c7">3 </span><span class="c3">in the running example. On the other hand, the association between sets of keywords and sets of locations is not immediately apparent, e.g., what the textual description of the location set {l</span><span class="c7">1</span><span class="c12">,l</span><span class="c7">2</span><span class="c12">} should </span><span class="c3">be. If it is simply the set of keywords that have an edge towards the location set, then how do we quantify its strength if different users have made different associations? The location set should be strongly associated with a set of keywords not because there exist edges with multiple users in the Association Graph, but because there exists </span><span class="c17">a large number of users that agree on this association</span><span class="c3">. Therefore, the key question to answer is when a user supports an association between a location set and a keyword set. </span></p><p class="c24"><span class="c3">D 4 (S U ). </span><span class="c17">A user </span><span class="c3">u supports </span><span class="c17">the as- sociation between a location set </span><span class="c3">L </span><span class="c17">and keyword set </span><span class="c3">&Psi;</span><span class="c17">, denoted as </span><span class="c3">u &isin; U</span><span class="c7">L&Psi;</span><span class="c50">, if: </span></p><p class="c23"><span class="c80">Locations Users </span><span class="c4">l</span><span class="c7">1 </span><span class="c2">l</span><span class="c7">2 </span><span class="c2">l</span><span class="c7">3 </span></p><p class="c1"><span class="c4">u</span><span class="c7">1 </span><span class="c2">p</span><span class="c7">11 </span><span class="c2">: {&psi;</span><span class="c7">1</span><span class="c2">} p</span><span class="c7">12 </span><span class="c2">: {&psi;</span><span class="c7">1</span><span class="c2">,&psi;</span><span class="c7">2</span><span class="c2">} p</span><span class="c7">13 </span><span class="c2">: {&psi;</span><span class="c7">1</span><span class="c2">} </span><span class="c4">u</span><span class="c7">2 </span><span class="c2">p</span><span class="c7">21 </span><span class="c2">: {&psi;</span><span class="c7">1</span><span class="c2">} p</span><span class="c7">22 </span><span class="c2">: {&psi;</span><span class="c7">1</span><span class="c2">} </span><span class="c4">u</span><span class="c7">3 </span><span class="c2">p</span><span class="c7">31 </span><span class="c2">: {&psi;</span><span class="c7">2</span><span class="c2">} p</span><span class="c7">32 </span><span class="c2">: {&psi;</span><span class="c7">1</span><span class="c2">} p</span><span class="c7">33 </span><span class="c2">: {&psi;</span><span class="c7">1</span><span class="c2">} </span><span class="c4">u</span><span class="c7">4 </span><span class="c2">p</span><span class="c7">42 </span><span class="c2">: {&psi;</span><span class="c7">2</span><span class="c2">} p</span><span class="c7">43 </span><span class="c2">: {&psi;</span><span class="c7">1</span><span class="c2">} </span><span class="c4">u</span><span class="c7">5 </span><span class="c2">p</span><span class="c7">51 </span><span class="c2">: {&psi;</span><span class="c7">1</span><span class="c2">,&psi;</span><span class="c7">2</span><span class="c2">} </span></p><p class="c23"><span class="c4">L = {l</span><span class="c7">1</span><span class="c2">,l</span><span class="c7">2</span><span class="c2">}, &Psi; = {&psi;</span><span class="c7">1</span><span class="c2">,&psi;</span><span class="c7">2</span><span class="c2">} </span><span class="c4">U</span><span class="c7">L&Psi; </span><span class="c2">= {u</span><span class="c7">1</span><span class="c2">,u</span><span class="c7">3</span><span class="c2">}, U</span><span class="c7">L </span><span class="c6">&nbsp;&#771;</span><span class="c7">&Psi; </span><span class="c4">= {u</span><span class="c7">1</span><span class="c2">,u</span><span class="c7">2</span><span class="c2">,u</span><span class="c7">3</span><span class="c2">} </span><span class="c4">U</span><span class="c7">&Psi; </span><span class="c2">= {u</span><span class="c7">1</span><span class="c2">,u</span><span class="c7">3</span><span class="c2">,u</span><span class="c7">4</span><span class="c2">,u</span><span class="c7">5</span><span class="c2">}, U </span><span class="c7">&nbsp;&#771;L&Psi; </span><span class="c4">= {u</span><span class="c7">1</span><span class="c2">,u</span><span class="c7">3</span><span class="c2">,u</span><span class="c7">5</span><span class="c2">} </span><span class="c4">sup(L,&Psi;) = 2, w_sup(L,&Psi;) = 3, rw_sup(L,&Psi;) = 2 </span></p><p class="c1"><span class="c16">Figure 2: Running example. </span></p><p class="c24"><span class="c3">&bull; </span><span class="c17">for each keyword </span><span class="c3">&psi; &isin; &Psi;</span><span class="c17">, the user has made a post relevant to </span><span class="c3">&psi; </span><span class="c17">and local to a location </span><span class="c3">l</span><span class="c21">&prime; </span><span class="c3">&isin; L</span><span class="c17">, i.e., every </span><span class="c3">&psi; &isin; &Psi; </span><span class="c17">is connected via a </span><span class="c3">u</span><span class="c17">-labeled edge to some </span><span class="c3">l</span><span class="c21">&prime; </span><span class="c3">&isin; L</span><span class="c17">; and </span></p><p class="c24"><span class="c3">&bull; </span><span class="c17">for each location </span><span class="c3">l &isin; L</span><span class="c17">, the user has made a post local to </span><span class="c3">l </span><span class="c17">and relevant to a keyword </span><span class="c3">&psi;</span><span class="c21">&prime; </span><span class="c3">&isin; &Psi;</span><span class="c17">, i.e., every </span><span class="c3">l &isin; L </span><span class="c17">is connected via a </span><span class="c3">u</span><span class="c17">-labeled edge to some </span><span class="c3">&psi;</span><span class="c21">&prime; </span><span class="c3">&isin; &Psi;</span><span class="c17">. </span></p><p class="c24"><span class="c3">Hence, a user supports association (L, &Psi;) if her posts connect each keyword in &Psi; to some location in L, and, vice versa, each location in L to some keyword in &Psi;. This implies a tight coupling between </span><span class="c17">all </span><span class="c3">keywords and </span><span class="c17">all </span><span class="c3">locations, according to the user. </span></p><p class="c24"><span class="c3">An association extracted from a user&rsquo;s posts between a keyword set and a location set could be arbitrary. After all, the content of a post is not always related to the location where it was made, and crowdsourced content is known to be characterized by errors and noise. Hence, an association acquires credence by the number of users supporting it. Accordingly, we use this to measure the strength of a keywords-locations association. </span></p><p class="c24"><span class="c3">D 5 (S ). </span><span class="c17">The </span><span class="c3">support </span><span class="c17">of an association be- tween a location set </span><span class="c3">L </span><span class="c17">and keyword set </span><span class="c3">&Psi; </span><span class="c17">is the number of users supporting </span><span class="c3">(L, &Psi;)</span><span class="c17">, i.e., </span><span class="c3">sup(L, &Psi;) = |U</span><span class="c7">L&Psi;</span><span class="c12">|</span><span class="c50">. </span></p><p class="c24"><span class="c3">Returning to our example, user u</span><span class="c7">1 </span><span class="c12">supports the location set L = </span><span class="c3">{l</span><span class="c7">1</span><span class="c12">,l</span><span class="c7">2</span><span class="c12">} and keyword set &Psi; = {&psi;</span><span class="c7">1</span><span class="c12">,&psi;</span><span class="c7">2</span><span class="c12">}. For instance, post p</span><span class="c7">11 </span><span class="c3">(resp. p</span><span class="c7">12</span><span class="c12">) is relevant to &psi;</span><span class="c7">1 </span><span class="c12">(resp. &psi;</span><span class="c7">2</span><span class="c12">) and local to some location </span><span class="c3">among L; hence the first condition is satisfied; similarly, the second condition is also satisfied. It is not hard to see that the conditions are also satisfied for user u</span><span class="c7">3</span><span class="c12">. Therefore, sup(L,&Psi;) = 2. </span></p><p class="c24"><span class="c3">We can now formally state the objective of this work. Given a set of keywords, we formulate two variants, one that retrieves all associations above a support threshold, and one that retrieves the k most strongly supported associations. </span></p><p class="c1"><span class="c3">P 1 (F S -T A ). </span><span class="c17">Given a keyword set </span><span class="c3">&Psi; </span><span class="c17">and a support threshold </span><span class="c3">&sigma;</span><span class="c17">, identify all the location sets, up to cardinality </span><span class="c3">m</span><span class="c17">, that have support above </span><span class="c3">&sigma;</span><span class="c17">. </span></p><p class="c1"><span class="c3">P 2 (T -k S -T A ). </span><span class="c17">Given a key- word set </span><span class="c3">&Psi;</span><span class="c17">, identify </span><span class="c3">k </span><span class="c17">location sets, up to cardinality </span><span class="c3">m</span><span class="c17">, that have the highest support. </span></p><p class="c24"><span class="c3">The restriction on the cardinality of the location set is because, as explained in Section 4, adding more locations can increase the support of the set. </span></p><p class="c1"><span class="c9">4. OBSERVATIONS AND APPROACH </span></p><p class="c24"><span class="c3">Our approach is based on some key observations regarding the intrinsic characteristics of the studied problems. In fact, the stated problems reminisce the frequent itemset problem; however, the key </span></p><p class="c1"><span class="c37">123 </span></p><p class="c23"><span class="c22">l</span><span class="c100">{u</span><span class="c11">1</span><span class="c22">,u</span><span class="c11">3</span><span class="c22">,u</span><span class="c11">4</span><span class="c22">} </span><span class="c11">3 </span><span class="c15">&psi;</span><span class="c11">1 </span><span class="c22">{u</span><span class="c11">1</span><span class="c22">,u</span><span class="c11">2</span><span class="c22">,u</span><span class="c11">3</span><span class="c22">} {u</span><span class="c11">1</span><span class="c22">,u</span><span class="c11">2</span><span class="c22">,u</span><span class="c11">5</span><span class="c22">} </span><span class="c98">l</span><span class="c75">2 </span></p><p class="c1"><span class="c22">{u</span><span class="c11">1</span><span class="c22">,u</span><span class="c11">4</span><span class="c22">} </span></p><p class="c1"><span class="c15">&psi;</span><span class="c11">2 </span><span class="c100">{u</span><span class="c11">3</span><span class="c22">,u</span><span class="c11">5</span><span class="c22">} </span></p><p class="c1"><span class="c22">l</span><span class="c11">1 </span></p><p class="c1"><span class="c16">Figure 3: Association Graph for the running example. </span></p><p class="c24"><span class="c3">difference here is that the introduced support function does not have the necessary anti-monotonicity property which allows for applying the Apriori principle. Given two sets X, Y , this property states that if X &sube; Y , then sup(X) &ge; sup(Y ). In other words, adding more items to a set cannot increase its support. However, the support introduced in Definition 5 does not exhibit this property. </span></p><p class="c24"><span class="c3">T 1. </span><span class="c17">The support of a location set </span><span class="c3">L </span><span class="c17">and a keyword set </span><span class="c3">&Psi; </span><span class="c17">is not anti-monotonic with respect to the location set, i.e., there exist two location sets </span><span class="c3">L &sube; L</span><span class="c21">&prime; </span><span class="c17">and a keyword set </span><span class="c3">&Psi;</span><span class="c17">, such that </span><span class="c3">sup(L, &Psi;) &lt; sup(L</span><span class="c21">&prime;</span><span class="c3">,&Psi;)</span><span class="c17">. </span></p><p class="c23"><span class="c3">P . We prove via an example. Assume three keywords, four locations, and two users who have made posts in exactly those locations, as shown below:</span><span class="c12">l</span><span class="c7">1 </span><span class="c12">l</span><span class="c7">2 </span><span class="c12">l</span><span class="c7">3 </span><span class="c12">l</span><span class="c7">4 </span><span class="c3">u</span><span class="c7">1 </span><span class="c12">&psi;</span><span class="c7">1 </span><span class="c12">&psi;</span><span class="c7">2 </span><span class="c12">&psi;</span><span class="c7">3 </span><span class="c12">&psi;</span><span class="c7">1 </span><span class="c3">u</span><span class="c7">2 </span><span class="c12">&psi;</span><span class="c7">3 </span><span class="c12">&psi;</span><span class="c7">1 </span><span class="c12">&psi;</span><span class="c7">1 </span><span class="c12">&psi;</span><span class="c7">2 </span></p><p class="c26"><span class="c3">Consider the keyword set &Psi; = {&psi;</span><span class="c7">1</span><span class="c12">,&psi;</span><span class="c7">2</span><span class="c12">,&psi;</span><span class="c7">3</span><span class="c12">}. Notice that only </span><span class="c3">user 1. u</span><span class="c7">1 </span><span class="c12">supports location </span><span class="c3">On the other hand, </span><span class="c12">set L = {l</span><span class="c7">1</span><span class="c12">,l</span><span class="c7">2</span><span class="c12">,l</span><span class="c7">3</span><span class="c12">}, i.e., sup(L, </span><span class="c3">both users support location set </span><span class="c12">&Psi;) </span><span class="c3">L</span><span class="c21">&prime; </span><span class="c12">= </span><span class="c3">= {l</span><span class="c7">1</span><span class="c12">,l</span><span class="c7">2</span><span class="c12">,l</span><span class="c7">3</span><span class="c12">,l</span><span class="c7">4</span><span class="c12">}, i.e., sup(L</span><span class="c6">&prime;</span><span class="c12">, &Psi;) = 2. In fact, any 3-location set in </span><span class="c3">this example has support at most 1. </span></p><p class="c24"><span class="c3">As a matter of fact, the support of a location set and a keyword set can increase or decrease with respect to the location set. Despite this negative result, we devise an efficient filter-and-refine approach, where the filtering step exploits a weaker support measure. </span></p><p class="c24"><span class="c3">D 6 (W S U ). </span><span class="c17">A user </span><span class="c3">u weakly supports </span><span class="c17">a given location set </span><span class="c3">L </span><span class="c17">and keyword set </span><span class="c3">&Psi;</span><span class="c17">, denoted as </span><span class="c3">u </span><span class="c17">to </span><span class="c3">&isin; l </span><span class="c17">and </span><span class="c3">U</span><span class="c7">L &Psi;</span><span class="c6">&nbsp;&#771;</span><span class="c17">relevant , if for each to a location keyword </span><span class="c3">l </span><span class="c17">in </span><span class="c3">&isin; &Psi;</span><span class="c17">. </span></p><p class="c1"><span class="c3">L</span><span class="c17">, the user has made a post local </span></p><p class="c24"><span class="c3">The difference with respect to Definition 4 is that only the second condition applies. In other words, in the Association Graph, there must exist edges associating each one of the locations in L with keywords from &Psi;, but without necessarily involving all keywords in &Psi;. Accordingly, we define the notion of weak support. </span></p><p class="c24"><span class="c3">D 7 (W S ). </span><span class="c17">The </span><span class="c3">weak support </span><span class="c17">of a given location set </span><span class="c3">L </span><span class="c17">and keyword set </span><span class="c3">&Psi; </span><span class="c17">is the number of users weakly supporting </span><span class="c3">(L, &Psi;)</span><span class="c17">, i.e., </span><span class="c3">w</span><span class="c17">_</span><span class="c3">sup(L,&Psi;) = |U</span><span class="c7">L &Psi;</span><span class="c6">&nbsp;&#771;</span><span class="c3">|</span><span class="c17">. </span></p><p class="c24"><span class="c3">In our example, user u</span><span class="c7">2 </span><span class="c12">weakly supports (L,&Psi;), where L = </span><span class="c3">{l</span><span class="c7">1</span><span class="c12">,l</span><span class="c7">2</span><span class="c12">} and &Psi; = {&psi;</span><span class="c7">1</span><span class="c12">,&psi;</span><span class="c7">2</span><span class="c12">}. For both locations, u</span><span class="c7">2 </span><span class="c12">has local </span><span class="c3">posts (p</span><span class="c7">21 </span><span class="c12">and p</span><span class="c7">22</span><span class="c12">) that are relevant to at least one keyword (&psi;</span><span class="c7">1</span><span class="c12">). In </span><span class="c3">addition, users u</span><span class="c7">1</span><span class="c12">, u</span><span class="c7">3 </span><span class="c12">also weakly support the same location set and </span></p><p class="c1"><span class="c3">keyword set. On the other hand, u</span><span class="c7">4 </span><span class="c12">and u</span><span class="c7">5 </span><span class="c12">do not, as they do not </span><span class="c3">have posts local to both locations. Therefore, w_sup(L, &Psi;) = 3. </span></p><p class="c24"><span class="c3">Our filter and refine approach hinges on two properties of the weak support. The first is its anti-monotonicity, while the second is that it provides an upper bound for the support of an association. </span></p><p class="c24"><span class="c3">L 1. </span><span class="c17">The weak support of a location set and a keyword set is anti-monotonic with respect to the location set, i.e., for any two location sets </span><span class="c3">L</span><span class="c21">&prime; </span><span class="c3">&sube; L </span><span class="c17">and keyword set </span><span class="c3">&Psi;</span><span class="c17">, it holds that </span><span class="c3">w</span><span class="c17">_</span><span class="c3">sup(L</span><span class="c21">&prime;</span><span class="c3">, &Psi;) &ge; w</span><span class="c17">_</span><span class="c3">sup(L,&Psi;)</span><span class="c17">. </span></p><p class="c24"><span class="c3">P . We show that any user u that does not weakly support (L</span><span class="c21">&prime;</span><span class="c3">, &Psi;)cannot weakly support(L,&Psi;). Assume otherwise, meaning that for each location in L there exists a post of u that is local to that location and relevant to the set &Psi;. Trivially, this property also holds for any location in L</span><span class="c21">&prime; </span><span class="c3">&sube; L. Therefore, u must also support (L</span><span class="c21">&prime;</span><span class="c3">, &Psi;) &mdash; a contradiction. </span></p><p class="c1"><span class="c3">L 2. </span><span class="c17">The support of location set</span><span class="c3">L</span><span class="c17">and keyword set</span><span class="c3">&Psi;</span><span class="c17">is not greater than their weak support, i.e., </span><span class="c3">sup(L, &Psi;) &le; w</span><span class="c17">_</span><span class="c3">sup(L,&Psi;)</span><span class="c17">. </span></p><p class="c24"><span class="c3">P . We show that any useruthat supports(L, &Psi;)also weakly supports(L, &Psi;). As per Definition 4,u has made a post local to each location in L and relevant to a keyword in &Psi; (second condition). Therefore, the condition of Definition 8 applies, and u must also weakly support (L, &Psi;). </span></p><p class="c1"><span class="c3">Returning to the example, users u</span><span class="c7">1</span><span class="c12">,u</span><span class="c7">2</span><span class="c12">,u</span><span class="c7">3</span><span class="c12">,u</span><span class="c7">5 </span><span class="c12">weakly support </span><span class="c3">(L</span><span class="c21">&prime;</span><span class="c3">, &Psi;), whereL</span><span class="c21">&prime; </span><span class="c3">= {l</span><span class="c7">1</span><span class="c12">}. Hence, as per Lemma 1,w_sup(L</span><span class="c6">&prime;</span><span class="c12">,&Psi;) &ge; </span><span class="c3">w_sup(L,&Psi;). Moreover, as per Lemma 2, we have seen that the weak support of (L, &Psi;) is one more than its support. Based on these lemmas, we can derive the following important property. </span></p><p class="c24"><span class="c3">T 2. </span><span class="c17">If the weak support of a location set </span><span class="c3">L </span><span class="c17">and a key- word set </span><span class="c3">&Psi; </span><span class="c17">is less than </span><span class="c3">&sigma;</span><span class="c17">, then the support of any location set </span><span class="c3">L</span><span class="c21">&prime; </span><span class="c3">&supe; L </span><span class="c17">and </span><span class="c3">&Psi; </span><span class="c17">cannot be more than </span><span class="c3">&sigma;</span><span class="c17">. </span></p><p class="c24"><span class="c3">P . The premise suggests that &sigma; &gt; w_sup(L,&Psi;). From Lemma 1 we have that w_sup(L, &Psi;) &ge; w_sup(L</span><span class="c21">&prime;</span><span class="c3">,&Psi;), while from Lemma 2 we get w_sup(L</span><span class="c21">&prime;</span><span class="c3">,&Psi;) &ge; sup(L</span><span class="c21">&prime;</span><span class="c3">,&Psi;). Putting all three inequalities together we get &sigma; &gt; sup(L</span><span class="c21">&prime;</span><span class="c3">, &Psi;), i.e., the antecedent. </span></p><p class="c24"><span class="c3">This result leads us to the following filter and refine strategy. Similar to the candidate generation step of the Apriori algorithm, location sets of increasing cardinality are constructed. Then, the weak support of the set is counted, and if this is below the threshold, the set is filtered out. At the end of entire process (when set car- dinality reaches m), the refinement step is perfomed by explicitly counting the support of all surviving location sets. </span></p><p class="c24"><span class="c3">Still, this approach could be inefficient, producing many false positives. It is possible that the support of a location set is below the threshold even though its weak support is above the threshold. Its support may even be zero if there exists no user that has posts covering all keywords. Such a location set cannot be pruned by Theorem 2. Following our example, consider location set L = {l</span><span class="c7">1</span><span class="c12">,l</span><span class="c7">2</span><span class="c12">}, keyword set &Psi; = {&psi;</span><span class="c7">1</span><span class="c12">,&psi;</span><span class="c7">2</span><span class="c12">}, and assume that only user u</span><span class="c7">2 </span><span class="c3">exists. In this case, w_sup(L, &Psi;) = 1, but sup(L, &Psi;) = 0, since there exists no post from u</span><span class="c7">2 </span><span class="c12">relevant to &psi;</span><span class="c7">2</span><span class="c12">. Motivated by this, we </span><span class="c3">seek additional ways to identify location sets that cannot have high support. We first define the notion of a relevant user. </span></p><p class="c24"><span class="c3">D 8 (R U ). </span><span class="c17">We say that a user </span><span class="c3">u </span><span class="c17">is </span><span class="c3">rele- vant </span><span class="c17">to a given keyword set </span><span class="c3">&Psi;</span><span class="c17">, and denote as </span><span class="c3">u &isin; U</span><span class="c7">&Psi;</span><span class="c50">, if for each </span><span class="c17">keyword </span><span class="c3">&psi; &isin; &Psi;</span><span class="c17">, the user has made a post relevant to </span><span class="c3">&psi;</span><span class="c17">, i.e., the As- sociation Graph contains an edge that is adjacent to </span><span class="c3">&psi; </span><span class="c17">and includes </span><span class="c3">u </span><span class="c17">in its label. </span></p><p class="c1"><span class="c37">124 </span></p><p class="c1"><span class="c39">L </span></p><p class="c1"><span class="c39">L</span><span class="c52">L </span></p><p class="c23"><span class="c44">weakly supporting </span></p><p class="c1"><span class="c44">supporting </span></p><p class="c24"><span class="c16">Figure 4: Set relationships between supporting, weakly sup- porting, and relevant users with respect to the association be- tween location set </span><span class="c3">L </span><span class="c16">and keyword set </span><span class="c3">&Psi;</span><span class="c16">. </span></p><p class="c24"><span class="c3">Notice that user u</span><span class="c7">2 </span><span class="c12">is not relevant to &Psi; = {&psi;</span><span class="c7">1</span><span class="c12">,&psi;</span><span class="c7">2</span><span class="c12">}. The next </span><span class="c3">result shows that if we restrict the set of weakly supporting users to include only relevant users, we can still define a pruning rule. </span></p><p class="c24"><span class="c3">T 3. </span><span class="c17">If the number of relevant users that weakly support a location set </span><span class="c3">L </span><span class="c17">and a keyword set </span><span class="c3">&Psi; </span><span class="c17">is less than </span><span class="c3">&sigma;</span><span class="c17">, then the support of any location set </span><span class="c3">L</span><span class="c21">&prime; </span><span class="c3">&supe; L </span><span class="c17">and </span><span class="c3">&Psi; </span><span class="c17">cannot be more than </span><span class="c3">&sigma;</span><span class="c17">. </span></p><p class="c1"><span class="c3">P weakly . supporting Recall that users, U</span><span class="c7">&Psi;</span><span class="c12">, </span><span class="c3">respectively. </span><span class="c12">U</span><span class="c7">L &Psi; </span><span class="c6">&nbsp;&#771;</span><span class="c3">denote the Then, set the of relevant theorem users assumes and </span></p><p class="c26"><span class="c3">that that |U</span><span class="c7">&Psi; </span><span class="c3">user U|U</span><span class="c12">&cap; </span><span class="c3">u </span><span class="c7">L &Psi; </span><span class="c12">U</span><span class="c7">&Psi; </span><span class="c6">&nbsp;&#771;</span><span class="c3">that </span><span class="c7">L </span><span class="c12">&cap; </span><span class="c3">&supe; </span><span class="c7">&Psi;</span><span class="c6">&nbsp;&#771;</span><span class="c3">| </span><span class="c12">U</span><span class="c3">supports U&ge; </span><span class="c7">L L&Psi;</span><span class="c6">&nbsp;&#771;</span><span class="c43">&prime; </span><span class="c3">|U</span><span class="c7">&Psi;</span><span class="c3">| </span><span class="c6">&nbsp;&#771;</span><span class="c3">. &lt; </span><span class="c7">&Psi; </span><span class="c3">Therefore, </span><span class="c12">&cap; </span><span class="c3">&sigma;. (L</span><span class="c12">U</span><span class="c21">&prime;</span><span class="c7">L</span><span class="c3">, From </span><span class="c43">&prime; </span><span class="c3">&Psi;) </span><span class="c7">&Psi;</span><span class="c6">&nbsp;&#771;</span><span class="c3">|. must UFrom (the </span><span class="c7">&Psi; </span><span class="c3">proof of) Lemma 1 </span><span class="c12">&cap; U</span><span class="c3">(the </span><span class="c7">L &Psi; </span><span class="c6">&nbsp;&#771;</span><span class="c3">&supe; proof U</span><span class="c7">&Psi; </span><span class="c3">of) </span><span class="c12">&cap; U</span><span class="c3">Lemma </span><span class="c7">L</span><span class="c43">&prime; </span><span class="c7">&Psi; </span><span class="c6">&nbsp;&#771;</span><span class="c3">also weakly support we have and thus 2 any (L</span><span class="c21">&prime;</span><span class="c3">, &Psi;). In addition, u must be relevant to &Psi; due to the first condition of Definition 4. Hence, two derived inequalities |U</span><span class="c7">&Psi; </span><span class="c3">and </span><span class="c12">&cap; </span><span class="c3">the </span><span class="c12">U</span><span class="c7">L</span><span class="c43">&prime; </span><span class="c3">theorem </span><span class="c7">&Psi;</span><span class="c6">&nbsp;&#771;</span><span class="c3">| &ge; sup(L</span><span class="c21">&prime;</span><span class="c3">,&Psi;). assumption, Combining the we derive that sup(L</span><span class="c21">&prime;</span><span class="c3">, &Psi;) &lt; &sigma;. </span></p><p class="c24"><span class="c3">This result improves upon our filter and refine strategy, by allow- ing us to early prune a location set that cannot have support above &sigma;, even though its weak support might be above &sigma;. </span></p><p class="c26"><span class="c3">A better way to understand the relation between the sets of sup- porting location </span><span class="c39">L</span><span class="c52">&Psi; </span><span class="c44">relevant </span><span class="c39">L</span><span class="c52">L&Psi; </span><span class="c44">e</span><span class="c39">L</span><span class="c52">L&Psi; </span></p><p class="c26"><span class="c39">L</span><span class="c52">L&Psi; </span><span class="c40">e</span><span class="c3">Uset </span><span class="c7">L&Psi;</span><span class="c12">, </span><span class="c3">and </span><span class="c12">weakly </span><span class="c3">keyword </span><span class="c12">supporting </span><span class="c3">set (L, &Psi;)is </span><span class="c12">U</span><span class="c7">L &Psi; </span><span class="c6">&nbsp;&#771;</span><span class="c3">to and draw relevant a Venn Udiagram. </span><span class="c7">&Psi; </span><span class="c12">users </span><span class="c3">Fig- </span><span class="c12">of a </span></p><p class="c26"><span class="c3">ure 4 depicts these sets, and also includes for completeness their dual sets drawn with dashed lines (discussed in Section 5.2). We have shown that while the cardinality of set U</span><span class="c7">L&Psi; </span><span class="c12">is not anti-monotone </span><span class="c3">with Figure respect 4 emphasizes to L, the that cardinalities the intersection of sets Uof </span><span class="c7">L &Psi; </span><span class="c6">&nbsp;&#771;</span><span class="c3">relevant and U</span><span class="c7">&Psi; </span><span class="c3">and </span><span class="c12">&cap; U</span><span class="c7">L </span><span class="c3">weakly </span><span class="c7">&Psi; </span><span class="c6">&nbsp;&#771;</span><span class="c3">are. </span></p><p class="c24"><span class="c3">supporting users is a </span><span class="c17">tighter </span><span class="c3">superset of the desired supporting users set, while still allowing anti-monotonicity-based prunning. In the following, we write rw_sup(L, &Psi;) to denote the number of relevant Returning and weakly to the example supporting of Figure users, 2, i.e., the |Urelevant </span><span class="c7">&Psi; </span><span class="c12">&cap; U</span><span class="c7">L &Psi;</span><span class="c6">&nbsp;&#771;</span><span class="c3">to |. </span></p><p class="c24"><span class="c3">&Psi; users are all except u</span><span class="c7">2</span><span class="c12">. Therefore, we derive sup(L, &Psi;) = |{u</span><span class="c7">1</span><span class="c12">,u</span><span class="c7">3</span><span class="c12">}| = </span><span class="c3">2, w_sup(L, &Psi;) = |{u</span><span class="c7">1</span><span class="c12">,u</span><span class="c7">2</span><span class="c12">,u</span><span class="c7">3</span><span class="c12">}| = 3, and rw_sup(L, &Psi;) = </span><span class="c3">|{u</span><span class="c7">1</span><span class="c12">,u</span><span class="c7">3</span><span class="c12">}| = 2, showing that the relevant and weak support is </span><span class="c3">closer to the actual support than weak support is. </span></p><p class="c1"><span class="c9">5. FINDING FREQUENT ASSOCIATIONS </span></p><p class="c1"><span class="c3">We first present a baseline method for Problem 1, which serves as the foundation for more elaborate solutions based on indices. </span><span class="c9">5.1 Basic Algorithm </span></p><p class="c24"><span class="c3">This algorithm implements the filter and refine approach dis- cussed in Section 4. Recall that Theorems 2 and 3 allow to prune location sets with support less than &sigma; based on the concepts of rele- vant and weakly supporting users (filter step). While this guarantees </span></p><p class="c1"><span class="c16">Algorithm 1: </span><span class="c3">Algorithm STA </span></p><p class="c1"><span class="c0">Input: </span><span class="c8">keyword set &Psi;, maximum cardinality m, support threshold &sigma; </span><span class="c0">Output: </span><span class="c8">result set R</span><span class="c55">&sigma; </span><span class="c8">of all location sets with support at least &sigma; </span><span class="c14">1 </span><span class="c8">R</span><span class="c55">&sigma; </span><span class="c8">&larr; &empty; </span><span class="c14">2 </span><span class="c8">C</span><span class="c25">1 </span><span class="c13">&larr; L &#8882; candidate 1-location sets </span><span class="c14">3 </span><span class="c8">U</span><span class="c25">&Psi; </span><span class="c13">&larr; IdentifyRelevantUsers(&Psi;) </span><span class="c14">4 </span><span class="c0">for </span><span class="c8">1 &le; i &le; m </span><span class="c0">do </span><span class="c14">5 </span><span class="c8">F</span><span class="c25">i </span><span class="c13">&larr; &empty; &#8882; i-location sets with more than &sigma; relevant and weakly supporting </span></p><p class="c1"><span class="c8">users </span><span class="c14">6 </span><span class="c0">foreach </span><span class="c8">L &isin; C</span><span class="c25">i </span><span class="c62">do </span><span class="c14">7 </span><span class="c8">ComputeSupports(L, &Psi;) </span><span class="c14">8 </span><span class="c0">if </span><span class="c8">rw_sup(L, &Psi;) &ge; &sigma; </span><span class="c0">then </span><span class="c14">9 </span><span class="c8">F</span><span class="c25">i </span><span class="c13">&larr; F</span><span class="c25">i </span><span class="c13">&cup; {L} </span><span class="c14">10 </span><span class="c0">if </span><span class="c8">sup(L, &Psi;) &ge; &sigma; </span><span class="c0">then </span><span class="c14">11 </span><span class="c8">R</span><span class="c55">&sigma; </span><span class="c8">&larr; R</span><span class="c55">&sigma; </span><span class="c8">&cup; {L} </span></p><p class="c1"><span class="c14">12 </span><span class="c8">C</span><span class="c25">i+1 </span><span class="c13">&larr; CandidateGeneration(F</span><span class="c25">i</span><span class="c13">) &#8882; candidate (i + 1)-location sets </span></p><p class="c1"><span class="c16">Algorithm 2: </span><span class="c3">STA.IdentifyRelevantUsers </span></p><p class="c1"><span class="c0">Input: </span><span class="c8">keyword set &Psi; </span><span class="c0">Output: </span><span class="c8">set U</span><span class="c25">&Psi; </span><span class="c13">of relevant users </span><span class="c14">1 </span><span class="c8">U</span><span class="c25">&Psi; </span><span class="c13">&larr; &empty; </span><span class="c14">2 </span><span class="c0">foreach </span><span class="c8">u &isin; U </span><span class="c0">do </span><span class="c14">3 </span><span class="c8">cov&Psi; &larr; &empty; </span><span class="c14">4 </span><span class="c0">foreach </span><span class="c8">p &isin; P</span><span class="c25">u </span><span class="c62">do </span><span class="c14">5 </span><span class="c0">if </span><span class="c8">p.&psi; &isin; &Psi; </span><span class="c0">then </span><span class="c14">6 </span><span class="c8">cov&Psi; &larr; cov&Psi; &cup; {&psi;} </span><span class="c14">7 </span><span class="c0">if </span><span class="c8">|cov&Psi;| = |&Psi;| </span><span class="c0">then </span><span class="c14">8 </span><span class="c8">U</span><span class="c25">&Psi; </span><span class="c13">&larr; U</span><span class="c25">&Psi; </span><span class="c13">&cup; {u} </span></p><p class="c24"><span class="c3">no false negatives, there can still be false positives, i.e., location sets with support less than &sigma;, which need to be identified (refine step). Note that instead of performing this at the end, it can be done more efficiently during candidate generation, as explained later. </span></p><p class="c26"><span class="c3">Algorithm 1 outlines the basic method, denoted as STA. It op- erates on the set P of posts organized by user, i.e., the list P</span><span class="c7">u </span><span class="c3">containing the posts of each user u. The input includes the keyword set &Psi;, the maximum cardinality m of a location set, and the sup- port threshold &sigma;. STA exploits the Apriori principle (lines 4&ndash;12) to identify the location sets with support above &sigma;, filtering out each location set with fewer than &sigma; relevant and weakly supporting users. Initially, the result set is empty and the potential 1-location sets are set to all locations (lines 1&ndash;2). Also, the set of users relevant to &Psi; is identified (line 3). Procedure IdentifyRelevantUsers, depicted in Algorithm 2, iterates across every list P</span><span class="c7">u </span><span class="c12">and checks if </span><span class="c3">user u has made posts that cover all keywords that appear in &Psi;. </span></p><p class="c24"><span class="c3">Then, STA proceeds in m iterations, following the Apriori prin- ciple. At the i-th iteration, all i-location sets with rw_sup not less than &sigma; are stored in set F</span><span class="c7">i</span><span class="c12">. Among them, those with support not </span><span class="c3">less than &sigma; are added to the result set R</span><span class="c21">&sigma;</span><span class="c3">. After initializing F</span><span class="c7">i </span><span class="c12">(line </span><span class="c3">5), each candidate i-location set L is examined (lines 6&ndash;11). The set C</span><span class="c7">i </span><span class="c12">of candidate i-location sets was generated at the end of the </span><span class="c3">previous iteration (line 12) by the CandidateGeneration proce- dure that applies the Apriori principle. In particular, Candidate Generation creates candidate location sets of cardinality one more than what was just examined. It takes as input the i-location sets F</span><span class="c7">i </span><span class="c12">with relevant weak support above &sigma;, and inserts into C</span><span class="c7">i+1 </span><span class="c12">an </span><span class="c3">(i + 1)-location set only if all its i-location subsets are in F</span><span class="c7">i</span><span class="c12">, due </span><span class="c3">to the Apriori principle implied by Theorem 3. </span></p><p class="c24"><span class="c3">For candidate i-location set L, procedure ComputeSupports (described later) is invoked to determine the numberrw_sup(L,&Psi;) of relevant weakly supporting users, and the number sup(L, &Psi;) of supporting users (line 7). If the former support is above &sigma;, L is added to F</span><span class="c7">i </span><span class="c12">(lines 8&ndash;9). If, additionally, the latter support is greater </span><span class="c3">than &sigma;, then L is added to the result set R</span><span class="c21">&sigma; </span><span class="c3">(lines 10&ndash;11). This essentially corresponds to refining the surviving candidates. </span></p><p class="c1"><span class="c3">Algorithm 3 depicts the pseudocode for ComputeSupports. The </span></p><p class="c1"><span class="c37">125 </span></p><p class="c1"><span class="c16">Algorithm 3: </span><span class="c3">STA.ComputeSupports </span></p><p class="c1"><span class="c0">Input: </span><span class="c8">location set L, keyword set &Psi; </span><span class="c0">Output: </span><span class="c8">weak support and support of (L, &Psi;) </span><span class="c14">1 </span><span class="c8">r_sup(L, &Psi;) &larr; 0; sup(L, &Psi;) &larr; 0 </span><span class="c14">2 </span><span class="c0">foreach </span><span class="c8">u &isin; U</span><span class="c25">&Psi; </span><span class="c62">do </span><span class="c13">&#8882; relevant user </span><span class="c14">3 </span><span class="c8">covL &larr; &empty;; cov&Psi; &larr; &empty; </span><span class="c14">4 </span><span class="c0">foreach </span><span class="c8">p &isin; P</span><span class="c25">u </span><span class="c62">do </span><span class="c14">5 </span><span class="c0">foreach </span><span class="c8">l &isin; L </span><span class="c0">do </span><span class="c14">6 </span><span class="c0">if </span><span class="c8">d(p.l, l) &le; &#491; </span><span class="c0">then </span><span class="c14">7 </span><span class="c0">foreach </span><span class="c8">&psi; &isin; p.&Psi; &cap; &Psi; </span><span class="c0">do </span><span class="c14">8 </span><span class="c8">covL &larr; covL &cup; {l} </span><span class="c14">9 </span><span class="c8">cov&Psi; &larr; cov&Psi; &cup; {&psi;} </span></p><p class="c1"><span class="c14">10 </span><span class="c0">if </span><span class="c8">|covL| = |L| </span><span class="c0">then </span><span class="c8">&#8882; weakly supporting user </span><span class="c14">11 </span><span class="c8">rw_sup(L, &Psi;) &larr; rw_sup(L, &Psi;) + 1 </span><span class="c14">12 </span><span class="c0">if </span><span class="c8">|cov&Psi;| = |&Psi;| </span><span class="c0">then </span><span class="c8">&#8882; supporting user </span><span class="c14">13 </span><span class="c8">sup(L, &Psi;) &larr; sup(L, &Psi;) + 1 </span></p><p class="c1"><span class="c16">Table 3: Support of Associations Between Listed Location Sets And Keyword Set </span><span class="c3">&Psi; = {&psi;</span><span class="c7">1</span><span class="c12">,&psi;</span><span class="c7">2</span><span class="c12">} </span><span class="c97">Based on the Posts in Figure 2 </span><span class="c80">Location set wr_sup sup </span></p><p class="c26"><span class="c4">{l</span><span class="c7">1</span><span class="c2">} 3 1 </span><span class="c4">{l</span><span class="c7">2</span><span class="c2">} 3 1 </span><span class="c4">{l</span><span class="c7">3</span><span class="c2">} 3 0 </span><span class="c42">{</span><span class="c4">l</span><span class="c60">1</span><span class="c2">, l</span><span class="c60">2</span><span class="c82">} </span><span class="c2">2 </span><span class="c54">2 </span><span class="c4">{l</span><span class="c7">1</span><span class="c2">,l</span><span class="c7">3</span><span class="c2">} 2 1 </span><span class="c42">{</span><span class="c4">l</span><span class="c60">2</span><span class="c2">, l</span><span class="c60">3</span><span class="c82">} </span><span class="c2">3 </span><span class="c54">2 </span><span class="c4">{l</span><span class="c7">1</span><span class="c2">,l</span><span class="c7">2</span><span class="c2">,l</span><span class="c7">3</span><span class="c2">} 1 1 </span></p><p class="c24"><span class="c3">procedure iterates over all relevant users. Let u be the currently ex- amined user. The objective is to determine if u (weakly) supports (L,&Psi;). For this purpose, the sets covL and cov&Psi; are constructed to indicate what locations among L and keywords among &Psi;, re- spectively, are covered by u. Each post of u is examined (lines 4&ndash;9). If the post&rsquo;s location is within distance &#491; to some location in l &isin; L, and there exists a keyword &psi; &isin; &Psi; common with the post&rsquo;s keywords, then l and &psi; are inserted to covL and cov&Psi; (lines 6&ndash;9). If all keywords in L have been found in u&rsquo;s relevant posts, then the counter of relevant and weakly supporting users is incremented (lines 10&ndash;11). Additionally, if all keywords appear in these posts, the counter for the support is incremented (lines 12&ndash;13). </span></p><p class="c1"><span class="c3">Table 3 shows the relevant and weak support, and support for all location sets for keyword set &Psi; = {&psi;</span><span class="c7">1</span><span class="c12">,&psi;</span><span class="c7">2</span><span class="c12">}, as computed bySTAfor </span><span class="c3">the example of Figure 2 with support threshold &sigma; = 2. Recall that all users except u</span><span class="c7">2 </span><span class="c12">are relevant. As all 1-location sets have relevant </span><span class="c3">and weak support above &sigma; (although none is actually a result), all possible 2-location sets are constructed and their supports are counted. Among them, {l</span><span class="c7">1</span><span class="c12">,l</span><span class="c7">2</span><span class="c12">} and {l</span><span class="c7">2</span><span class="c12">,l</span><span class="c7">3</span><span class="c12">} (marked bold) have </span><span class="c3">support 2 and are thus results. Observe the anti-monotonicity in relevant and weak support, and the lack thereof in support. Finally, as all 2-location sets have wr_sup above &sigma;, the set {l</span><span class="c7">1</span><span class="c12">,l</span><span class="c7">2</span><span class="c12">,l</span><span class="c7">3</span><span class="c12">} is </span><span class="c3">also considered but found to have low relevant and weak support. </span><span class="c9">5.2 Inverted Index-Based Algorithm </span></p><p class="c24"><span class="c3">In STA, counting the weak support of a location set is particularly time consuming, since it scans the entire list of posts to find the weakly supporting users for each location. Even worse, if a location is part of multiple location sets, this is repeated multiple times. </span></p><p class="c24"><span class="c3">To address this performance bottleneck, we present next an ap- proach, termed STA-I, that is based on a preconstructed inverted index, which facilitates the identification of weakly supporting users for any location. The assumption here is that the distance parameter &#491; is known beforehand, i.e., it does not change with the queries. </span></p><p class="c1"><span class="c3">To construct the index, we identify the posts that are within dis- tance &#491; to each location l. Then, for each location, we compile an </span></p><p class="c1"><span class="c16">Table 4: Inverted Index for the Posts in Figure 2 </span></p><p class="c1"><span class="c16">Location Inverted list </span></p><p class="c24"><span class="c3">l</span><span class="c7">1 </span><span class="c12">&psi;</span><span class="c7">1 </span><span class="c12">: u</span><span class="c7">1</span><span class="c12">,u</span><span class="c7">5</span><span class="c12">, &psi;</span><span class="c7">2 </span><span class="c12">: u</span><span class="c7">3</span><span class="c12">,u</span><span class="c7">5 </span><span class="c3">l</span><span class="c7">2 </span><span class="c12">&psi;</span><span class="c7">1 </span><span class="c12">: u</span><span class="c7">1</span><span class="c12">,u</span><span class="c7">3</span><span class="c12">, &psi;</span><span class="c7">2 </span><span class="c12">: u</span><span class="c7">1</span><span class="c12">,u</span><span class="c7">4 </span><span class="c3">l</span><span class="c7">3 </span><span class="c12">&psi;</span><span class="c7">1 </span><span class="c12">: u</span><span class="c7">1</span><span class="c12">,u</span><span class="c7">3</span><span class="c12">,u</span><span class="c7">4 </span></p><p class="c1"><span class="c16">Algorithm 4: </span><span class="c3">STA-I.IdentifyRelevantUsers </span></p><p class="c1"><span class="c0">Input: </span><span class="c8">keyword set &Psi; </span><span class="c0">Output: </span><span class="c8">set U</span><span class="c25">&Psi; </span><span class="c13">of relevant users </span><span class="c14">1 </span><span class="c8">U</span><span class="c25">&Psi; </span><span class="c13">&larr; &empty; </span><span class="c14">2 </span><span class="c0">foreach </span><span class="c8">&psi; &isin; &Psi; </span><span class="c0">do </span><span class="c14">3 </span><span class="c8">C&larr;&empty; </span><span class="c14">4 </span><span class="c0">foreach </span><span class="c8">l &isin; L </span><span class="c0">do </span><span class="c14">5 </span><span class="c8">C&larr;C&cup;U(l, &psi;) </span><span class="c14">6 </span><span class="c8">U</span><span class="c25">&Psi; </span><span class="c13">&larr; U</span><span class="c25">&Psi; </span><span class="c13">&cap; C </span></p><p class="c24"><span class="c3">inverted list U(l), containing all users with posts local to l. To further speed up processing, we partition each list according to key- word, such that each sublist U(l, &psi;) contains users with posts local toland relevant to&psi;. Table 4 shows the lists for our example. STA-I operates identically to STA, but uses the inverted index during the procedures IdentifyRelevantUsers and ComputeSupports. </span></p><p class="c24"><span class="c3">The IdentifyRelevantUsers procedure is depicted in Algo- rithm 4. Recall, that the goal is to identify users who have made posts relevant to all keywords in &Psi;, irrespective of the posts&rsquo; geo- tags. Hence, for each keyword &psi; &isin; &Psi;, and each possible location l, it retrieves the list U(l, &psi;) of users with relevant and local posts, and it compiles the set of users with posts relevant to &psi; and local to some location in L. Finally, it computes the intersection of these sets. as U</span><span class="c7">&Psi; </span><span class="c3">This </span><span class="c12">= </span><span class="c3">&#8898;procedure </span><span class="c7">&psi;&isin;&Psi; </span></p><p class="c1"><span class="c3">essentially constructs the set of relevant users Algorithm 5 illustrates (&#8899;</span><span class="c7">l&isin;L </span><span class="c3">U(l, the &psi;)</span><span class="c20">)</span><span class="c3">. </span></p><p class="c26"><span class="c3">ComputeSupports procedure, which computes the weak support (lines 1&ndash;6) and the support (lines 8&ndash; 14) of location set and keyword set (L, &Psi;). Regarding the former, recall that a user weakly supports (L,&Psi;) if for each location l &isin; L there The to some set exists </span><span class="c20">&#8899;</span><span class="c3">keyword </span><span class="c6">&psi;&isin;&Psi; </span><span class="c3">a local </span><span class="c20">U(l, </span><span class="c3">in post </span><span class="c20">&psi;) </span><span class="c3">&Psi; that is relevant </span><span class="c20">represents users </span><span class="c3">and are local to to some keyword in &Psi;. </span><span class="c20">that have relevant posts </span><span class="c3">the specific location l. Thus the intersection over all locations the weakly supporting users, i.e., U</span><span class="c7">L &Psi; </span><span class="c6">&nbsp;&#771;</span><span class="c3">in = L </span><span class="c20">&#8898;</span><span class="c3">of </span><span class="c6">l&isin;L </span></p><p class="c26"><span class="c3">these (</span><span class="c12">&#8899;</span><span class="c7">&psi;&isin;&Psi; </span><span class="c3">sets represents U(l, &psi;)</span><span class="c20">)</span><span class="c3">. Specifically, the procedure computes the union in the inner loop (lines 3&ndash;4), and the intersection of the unions in the outer loop (lines 2&ndash;5). The weak support of (L,&Psi;) is computed after the non-relevant users are discarded (line 6). </span></p><p class="c26"><span class="c3">Only when the weak support of (L,&Psi;) exceeds threshold &sigma; (line 7), its support is computed (lines 8&ndash;14), but in a manner significantly different from that in STA. Recall from the discussion in Section 4 and Figure 4 that the set dual contains set U users </span><span class="c7">L&Psi; &#771;</span><span class="c3">, termed local-weakly that for each U</span><span class="c7">L &Psi; </span><span class="c6">&nbsp;&#771;</span><span class="c3">keyword of weakly supporting users has a supporting users. This latter set among &Psi; have a post local to some location among L. It is not hard to see that the users that are both (relevant-)weakly supporting and local-weakly supporting (L, &Psi;) are exactly those that support (L,&Psi;), i.e., it holds that U</span><span class="c7">L&Psi; </span><span class="c3">requirement </span><span class="c12">= U</span><span class="c7">L &Psi; </span><span class="c6">&nbsp;&#771;</span><span class="c3">of &cap; Definition U</span><span class="c7">L&Psi; &#771;</span><span class="c3">. Intuitively, the latter set satisfies the first </span></p><p class="c1"><span class="c3">4, whereas the former the second. Based on this observation, the ComputeSupports procedure first 13). as the Uinner </span><span class="c7">L&Psi; &nbsp;&#771;</span><span class="c3">computes With = loop similar </span><span class="c20">&#8898;</span><span class="c6">&psi;&isin;&Psi; </span></p><p class="c26"><span class="c3">(lines the (&#8899;reasoning local-weakly </span><span class="c7">l&isin;L </span><span class="c3">11&ndash;12), U(l, as and &psi;)before, </span><span class="c20">)</span><span class="c3">supporting the , where intersection the the procedure users union of U is </span><span class="c7">L&Psi; </span><span class="c3">builds the </span><span class="c7">&nbsp;&#771;</span><span class="c3">compiled unions (lines the 8&ndash; set in in the outer loop (lines 9&ndash;13). Then, it intersects it with the previously constructed U</span><span class="c7">L &Psi; </span><span class="c6">&nbsp;&#771;</span><span class="c3">set to compute the support of (L, &Psi;) (line 14). </span></p><p class="c1"><span class="c37">126 </span></p><p class="c86"><span class="c16">Algorithm 5: </span><span class="c3">STA-I.ComputeSupports </span></p><p class="c78"><span class="c0">Input: </span><span class="c8">location set L, keyword set &Psi; </span><span class="c0">Output: </span><span class="c8">weak support and support of (L, &Psi;) &#8882; construct set U</span><span class="c25">L </span><span class="c46">&nbsp;&#771;</span><span class="c25">&Psi; </span><span class="c8">of (relevant-)weakly supporting users </span><span class="c14">1 </span><span class="c8">U</span><span class="c25">L </span><span class="c46">&nbsp;&#771;</span><span class="c25">&Psi; </span><span class="c8">&larr; &empty; </span><span class="c14">2 </span><span class="c0">foreach </span><span class="c8">l &isin; L </span><span class="c0">do </span><span class="c14">3 </span><span class="c8">A&larr;&empty; </span><span class="c0">foreach </span><span class="c8">&psi; &isin; &Psi; </span><span class="c0">do </span><span class="c14">4 </span><span class="c8">A&larr;A&cup;U(l, &psi;) </span><span class="c14">5 </span><span class="c8">U</span><span class="c25">L </span><span class="c46">&nbsp;&#771;</span><span class="c25">&Psi; </span><span class="c8">&larr; U</span><span class="c25">L </span><span class="c46">&nbsp;&#771;</span><span class="c25">&Psi; </span><span class="c8">&cap; A </span><span class="c14">6 </span><span class="c8">rw_sup(L, &Psi;) &larr; |U</span><span class="c25">L </span><span class="c46">&nbsp;&#771;</span><span class="c25">&Psi; </span><span class="c8">&cap; U</span><span class="c25">&Psi;</span><span class="c13">| </span><span class="c14">7 </span><span class="c0">if </span><span class="c8">rw_sup(L, &Psi;) &lt; &sigma; </span><span class="c0">then return </span></p><p class="c102"><span class="c8">&#8882; construct set U </span><span class="c25">&nbsp;&#771;L&Psi; </span><span class="c8">of local-weakly supporting users </span><span class="c14">8 </span><span class="c8">U </span><span class="c25">&nbsp;&#771;L&Psi; </span><span class="c8">&larr; &empty; </span><span class="c14">9 </span><span class="c0">foreach </span><span class="c8">&psi; &isin; &Psi; </span><span class="c0">do </span><span class="c14">10 </span><span class="c8">B&larr;&empty; </span><span class="c14">11 </span><span class="c0">foreach </span><span class="c8">l &isin; L </span><span class="c0">do </span><span class="c14">12 </span><span class="c8">B&larr;B&cup;U(l, &psi;) </span><span class="c14">13 </span><span class="c8">U </span><span class="c25">&nbsp;&#771;L&Psi; </span><span class="c8">&larr; U </span><span class="c25">&nbsp;&#771;L&Psi; </span><span class="c8">&cap; B </span><span class="c14">14 </span><span class="c8">sup(L, &Psi;) &larr; |U</span><span class="c25">L </span><span class="c46">&nbsp;&#771;</span><span class="c25">&Psi; </span><span class="c8">&cap; U </span><span class="c25">&nbsp;&#771;L&Psi;</span><span class="c8">| </span></p><p class="c71"><span class="c9">5.3 Spatio-Textual Index-Based Algorithm </span></p><p class="c32"><span class="c3">Although precomputing the inverted index reduces dramatically the cost of calculating the weak support of a location set, it cannot handle different values of the distance parameter&#491;. Next, we present an alternative approach to accelerating weak support calculations based on spatio-textual indices. Instead of relying on precomputed static lists, we dynamically compile the information needed from the index. We first present a generic approach that works with the majority of existing spatio-textual indices, and then we consider a particular index and propose further optimizations. </span></p><p class="c56"><span class="c70">5.3.1 Generic Algorithm </span></p><p class="c99 c101"><span class="c3">We adapt the basic Apriori-like algorithm assuming the availabil- ity of a spatio-textual index which can process spatio-textual range queries with OR semantics. The latter specify a spatial range R and a set of keywords &Psi;, and seek all spatio-textual objects whose location is inside R and contain at least one of the keywords in &Psi;. </span></p><p class="c79"><span class="c3">We next describe the STA-ST algorithm which operates on top of such a general-purpose spatio-textual index. It operates similarly to STA, with the difference that procedure ComputeSupports is implemented in an index-aware manner, as outlined in Algorithm 6. It first constructs the set U</span><span class="c7">L </span><span class="c6">&nbsp;&#771;</span><span class="c7">&Psi; </span><span class="c3">of weakly supporting users, and then determines the support of (L, &Psi;). To build U</span><span class="c7">L </span><span class="c6">&nbsp;&#771;</span><span class="c7">&Psi;</span><span class="c3">, it issues a spatio- textual range query with parameters the disc (l, &#491;)of radius &#491;around each location l &isin; L and keyword set &Psi; (lines 2&ndash;9). For a specific location l, the results (set of posts) are stored in P</span><span class="c7">l </span><span class="c12">(line 4). Then, </span><span class="c3">it scans the results and inserts into a temporary variable A each encountered user p.u (line 8). In addition, it associates with each user a bitmap p.u.cov&Psi; indicating which query keywords appear in her posts (lines 6&ndash;7); this information is later used to determine if the user supports (L,&Psi;). Once all users with posts local to l and relevant to &Psi; have been identified in A, they are merged with the ones for previously examined locations (line 9). Eventually, U</span><span class="c7">L </span><span class="c6">&nbsp;&#771;</span><span class="c7">&Psi; </span><span class="c12">contains users with posts local to </span><span class="c50">every </span><span class="c12">location in L and relevant to </span><span class="c3">at least one keyword in &Psi;, i.e., the users weakly supporting (L, &Psi;). To compute the weak support among relevant users, the procedure takes the intersection of U</span><span class="c7">L </span><span class="c6">&nbsp;&#771;</span><span class="c7">&Psi; </span><span class="c3">with the known set U</span><span class="c7">&Psi; </span><span class="c12">of relevant </span><span class="c3">users (line 10). If the weak support is lower than the threshold, the algorithm returns (line 11). Otherwise it computes the support by examining whether each user has covered all query keywords (lines 13&ndash;15); this is determined directly from bitmaps p.u.cov&Psi;. </span></p><p class="c83"><span class="c70">5.3.2 Optimized Algorithm </span></p><p class="c76"><span class="c3">Next, we focus on a specific spatio-textual index, I</span><span class="c21">3 </span><span class="c3">[22], which we adapt to devise an even more efficient algorithm. </span></p><p class="c1 c85"><span class="c16">Algorithm 6: </span><span class="c3">STA-ST.ComputeSupports </span></p><p class="c94"><span class="c0">Input: </span><span class="c8">location set L, keyword set &Psi; </span><span class="c0">Output: </span><span class="c8">weak support and support of (L, &Psi;) </span><span class="c14">1 </span><span class="c8">U</span><span class="c25">L </span><span class="c46">&nbsp;&#771;</span><span class="c25">&Psi; </span><span class="c8">&larr; &empty; </span><span class="c14">2 </span><span class="c0">foreach </span><span class="c8">l &isin; L </span><span class="c0">do </span><span class="c14">3 </span><span class="c8">A&larr;&empty; </span><span class="c14">4 </span><span class="c8">P</span><span class="c25">l </span><span class="c13">&larr; ST-RANGE((l, &#491;), &Psi;) </span><span class="c14">5 </span><span class="c0">foreach </span><span class="c8">p &isin; P</span><span class="c25">l </span><span class="c0">do </span><span class="c14">6 </span><span class="c0">foreach </span><span class="c8">&psi; &isin; p.&Psi; &cap; &Psi; </span><span class="c0">do </span><span class="c14">7 </span><span class="c8">p.u.cov&Psi; &larr; p.u.cov&Psi; &cup; {&psi;} </span><span class="c14">8 </span><span class="c8">A&larr;A&cup; p.u </span><span class="c14">9 </span><span class="c8">U</span><span class="c25">L </span><span class="c46">&nbsp;&#771;</span><span class="c25">&Psi; </span><span class="c8">&larr; U</span><span class="c25">L </span><span class="c46">&nbsp;&#771;</span><span class="c25">&Psi; </span><span class="c8">&cap; A </span><span class="c14">10 </span><span class="c8">rw_sup(L, &Psi;) &larr; |U</span><span class="c25">L </span><span class="c46">&nbsp;&#771;</span><span class="c25">&Psi; </span><span class="c8">&cap; U</span><span class="c25">&psi;</span><span class="c13">| </span><span class="c14">11 </span><span class="c0">if </span><span class="c8">rw_sup(L, &Psi;) &lt; &sigma; </span><span class="c0">then return </span><span class="c14">12 </span><span class="c8">sup(L, &Psi;) &larr; 0 </span><span class="c14">13 </span><span class="c0">foreach </span><span class="c8">u &isin; U</span><span class="c25">L </span><span class="c46">&nbsp;&#771;</span><span class="c25">&Psi; </span><span class="c0">do </span><span class="c14">14 </span><span class="c0">if </span><span class="c8">|u.cov&Psi;| = |&Psi;| </span><span class="c0">then </span><span class="c14">15 </span><span class="c8">sup(L, &Psi;) &larr; sup(L, &Psi;) + 1 </span></p><p class="c38 c59"><span class="c3">We first elaborate on the index structure. For our purposes, the I</span><span class="c21">3 </span><span class="c3">index can be seen as a quadtree that hierarchically partitions the spa- tial domain. Each node corresponds to a specific rectangular region, and points to its four children corresponding to the quadrants of the region. Leaf nodes point to disk pages containing the actual posts grouped by keyword. We associate with each node some additional aggregate information. Specifically, for each keyword &psi;, we store the number of users with relevant posts that are contained within the subtree rooted at this node N. We denote this by N.count(&psi;). STA-STO differs from STA-ST in the first iteration of the main Apriori loop (lines 4&ndash;12 of Algorithm 1 for i = 1). Instead of computing the weak support (and support) of every location, it uses the index to identify locations with potentially high weak support, eliminating groups of locations with weak support less than &sigma;. To achieve this, it executes a best-first search (bfs) traversal [9], performing a simple test at each node to decide whether to continue in its subtree. Intuitively, we wish to terminate bfs when no location in the subtree can have weak support greater than &sigma;. </span></p><p class="c18"><span class="c3">Let Q be the priority queue implementing bfs. For each node N entering Q, the algorithm computes a(N) = </span><span class="c20">&sum;</span><span class="c6">&psi;&isin;&Psi; </span><span class="c20">N.count(&psi;), </span><span class="c3">and uses it as the queue&rsquo;s priority key. At each iteration, the node N in Q with the largest a(N)value is removed. If a(N)is greater than or equal to &sigma;, there may exist some location in the subtree of N with weak support greater than &sigma;. Otherwise, a safe conclusion cannot be drawn. Hence, the algorithm calculates an additional value b(N) for this node, which is an upper bound on the weak support of any location within N. Clearly, if b(N) &lt; &sigma;, the node contains no useful locations and can be pruned. Such pruned nodes, along with their a() values, are maintained in a deleted list D, which serves in the calculation of b()values as explained next. For nodeN, itsb(N) value is the sum of a() values for all nodes that are in Q or in D and that are within distance &#491; to N. An important observation here is that, due to the bfs traversal and the index structure, nodes in Q&cup;D do not spatially overlap and hence b(N) does not double count posts. To summarize, STA-STO first makes the quick a(N) &ge; &sigma; test, and only if this fails does it compute b(N) and makes the more expensive b(N) &ge; &sigma; test. If the latter fails too, the node definitely cannot contain a location set with weak support greater than &sigma;. </span></p><p class="c27"><span class="c3">For each location dequeued in the bfs traversal, STA-STO invokes the STA-ST.ComputeSupport procedure as described in the pre- vious section, to determine its exact weak support and its support. Compared to it, the benefit is that STA-STO executes the procedure only for promising locations instead of every possible location. </span></p><p class="c90"><span class="c9">6. FINDING TOP-K ASSOCIATIONS </span></p><p class="c68"><span class="c3">Next, we present algorithms for Problem 2. We start with a basic </span></p><p class="c77"><span class="c37">127 </span></p><p class="c1"><span class="c16">Algorithm 7: </span><span class="c3">Algorithm k-STA </span></p><p class="c1"><span class="c0">Input: </span><span class="c8">keyword set &Psi;, maximum cardinality m, number of results k </span><span class="c0">Output: </span><span class="c8">result set R</span><span class="c55">k </span><span class="c8">containing top-k location sets with highest support </span><span class="c14">1 </span><span class="c8">&sigma; &larr; DetermineSupportThreshold(&Psi;, k) </span><span class="c14">2 </span><span class="c8">R</span><span class="c55">&sigma; </span><span class="c8">&larr; STA (&Psi;, m, &sigma;) </span><span class="c14">3 </span><span class="c8">R</span><span class="c55">k </span><span class="c8">&larr; k location sets from R</span><span class="c55">&sigma; </span><span class="c8">with highest support </span></p><p class="c1"><span class="c3">approach, and then discuss more efficient index-based techniques. </span><span class="c9">6.1 Basic Algorithm </span></p><p class="c24"><span class="c3">In Problem 2, we seek the top-k location sets with the highest support, instead of setting a specific support threshold. However, a support threshold is needed in order to apply an Apriori-like method; thus, we explain how such a threshold can be computed. If we pick any set of k distinct location sets and compute their supports, then the minimum value among those can serve as the support threshold &sigma;; clearly, any other set with support lower than this cannot be in the result. The challenge is to construct initial location sets with high support so that the starting value of &sigma; is effectively high. </span></p><p class="c24"><span class="c3">Algorithm 7 outlines the generic method k-STA implementing this simple idea. First, procedure DetermineSupportThreshold is invoked to obtain an appropriate lower bound &sigma; on the support of the top-k set. Given &sigma;, it invokes the STA algorithm to derive all location sets with support above &sigma;. Finally, among the returned location sets, it returns the k with the highest support. </span></p><p class="c24"><span class="c3">Regarding the DetermineSupportThreshold procedure, the main idea is to construct at least k distinct location sets that cover all keywords &Psi;. Suppose that for each keyword &psi; &isin; &Psi; we have determined k(&psi;) distinct locations with local posts relevant to &psi;. Combining these k(&psi;) distinct locations for each keyword, we can construct distinct location sets. Note that a necessary condition to obtain k location sets is </span><span class="c20">&prod;</span><span class="c6">&psi;&isin;&Psi; </span><span class="c20">k(&psi;) &ge; k. </span></p><p class="c1"><span class="c3">Following this process, a heuristic for obtaining combinations with high support is to start with locations that are popular, i.e., have high weak support. In the absence of any index, procedure DetermineSupportThreshold iterates over the set of posts lists P</span><span class="c7">u</span><span class="c12">, skipping users that do not have relevant posts to each &psi;. For </span><span class="c3">the rest, the locations of the relevant posts to each &psi; are noted. In addition, a counter for the weak support of each location is maintained. After a sufficient number of locations for each keyword are seen, the procedure terminates. For each keyword, the locations with the highest weak support are chosen and combined. The support of each set is computed by ComputeSupports, and the k-th highest among these values is set as the support threshold &sigma;. </span><span class="c9">6.2 Index-Based Algorithms </span></p><p class="c1"><span class="c70">6.2.1 Inverted Index </span></p><p class="c24"><span class="c3">When an inverted index from locations to users with local posts is available, DetermineSupportThreshold collects locations with local posts relevant to each keyword in &Psi; in a different manner. It first computes the weak support of every location by invoking ComputeSupports. Note that this has to be executed anyway when we later invoke the STA-I algorithm irrespective of the support threshold &sigma;. Then, it examines locations in descending order of their weak support. For each location l, the procedure checks the inverted list and associates the location with each keyword in &Psi; for which a local and relevant post exists. Similar to the basic algorithm, once a sufficient number of locations per keyword are seen, location sets are generated and their support is computed. </span></p><p class="c1"><span class="c70">6.2.2 Spatio-Textual Index </span></p><p class="c1"><span class="c3">In a generic spatio-textual index,DetermineSupportThreshold </span></p><p class="c23"><span class="c16">Table 5: Dataset Characteristics </span><span class="c0">Dataset </span><span class="c103">Num. of Num. of Num. of Avg. num. of Avg. num. of Num. of </span><span class="c0">photos users distinct tags tags per photo tags per user locations </span></p><p class="c26"><span class="c8">London 1,129,927 16,171 266,495 8.1 61.2 48,547 Berlin 275,285 7,044 88,783 8.1 39.4 21,427 Paris 549,484 11,776 122,998 7.8 38.8 38,358 </span></p><p class="c24"><span class="c3">operates identically to the basic algorithm with the exception that the ComputeSupports procedure is index-aware. When the aug- mented I</span><span class="c21">3 </span><span class="c3">index is used, a different process is followed. Procedure DetermineSupportThreshold first performs a best-first search traversal similar to that described in Section 5.3.2. The difference is that initially there is no support threshold, and thus the b() val- ues need not be computed. Moreover, the traversal is progressive, meaning that at each step the next location with potentially high weak support is identified. For each such location, its local posts are retrieved (using the index) and it is marked for the keywords that appear in these posts. As before, once a sufficient number of locations per keyword are seen, the support threshold is computed. </span></p><p class="c1"><span class="c9">7. EXPERIMENTAL EVALUATION </span></p><p class="c1"><span class="c3">In this section, we present an experimental evaluation of our approach using real-world datasets comprising geolocated Flickr photos. We first describe our experimental setup, outlining the datasets and the queries used in the experiments, and then we report and discuss the results. </span><span class="c9">7.1 Datasets </span></p><p class="c24"><span class="c3">In our experiments, we have used geolocated photos from Flickr, extracted from a large-scale dataset that is provided publicly by Yahoo! for research purposes [18]. Specifically, we compiled datasets for the cities of London, Berlin and Paris. For each dataset, Table 5 lists the number of photos, users, and distinct keywords contained in it, as well as the average number of keywords per photo and distinct keywords per user. As a database of locations, we used POIs collected from the Foursquare API</span><span class="c95">1</span><span class="c3">. The number of distinct locations per city is also shown in Table 5. </span></p><p class="c1"><span class="c3">To construct a keyword set that is used to search for socio-textual associations, we followed the process described next. First, for each dataset, we retrieved the 100 most frequent keywords, where the fre- quency of a keyword was measured by the number of users having photos with it. From those, we manually picked a set of 30 key- words, removing more generic ones, such as </span><span class="c17">&ldquo;london&rdquo;</span><span class="c3">, </span><span class="c17">&ldquo;england&rdquo;</span><span class="c3">, </span><span class="c17">&ldquo;uk&rdquo;</span><span class="c3">, </span><span class="c17">&ldquo;iphone&rdquo;</span><span class="c3">, </span><span class="c17">&ldquo;canon&rdquo;</span><span class="c3">, etc. The top 10 selected keywords for each city are listed in Table 6, showing also the number of users with relevant posts to each one. Then, we combined these popular keywords to create keyword sets of cardinality up to 4. For each case, we selected the top 20 combinations according to the number of users having photos with those tags. Table 7 lists the first 5 among these 20 combinations for each case. In all reported experiments, we set the value of the spatial distance threshold parameter &#491;, used to associate photos to locations, to 100 meters. </span><span class="c9">7.2 Indicative Result </span></p><p class="c24"><span class="c3">Figure 5 shows an example of the socio-textual associations our methodology discovers. In particular, we look for locations that are strongly associated with the keyword set &Psi; = {</span><span class="c17">&ldquo;london eye&rdquo;</span><span class="c3">, </span><span class="c17">&ldquo;thames&rdquo;</span><span class="c3">}. The depicted green (resp., purple) points denote the lo- cations of photos that contain the keyword</span><span class="c17">&ldquo;thames&rdquo;</span><span class="c3">(resp., </span><span class="c17">&ldquo;london eye&rdquo;</span><span class="c3">) and belong to relevant users, i.e., they have also posted pho- tos containing the other keyword </span><span class="c17">&ldquo;london eye&rdquo; </span><span class="c3">(resp., </span><span class="c17">&ldquo;thames&rdquo;</span><span class="c3">). </span></p><p class="c1"><span class="c6">1</span><span class="c12">https://developer.foursquare.com/ </span></p><p class="c1"><span class="c37">128 </span></p><p class="c30"><span class="c16">Figure 5: Indicative example for London with </span><span class="c3">&Psi; </span><span class="c16">= </span><span class="c3">{london eye</span><span class="c16">, </span><span class="c3">thames}</span><span class="c16">. </span></p><p class="c88"><span class="c3">We can see that photos about </span><span class="c17">&ldquo;thames&rdquo; </span><span class="c3">are spread along the entire length of the river Thames. On the other hand, although London Eye has a specific location, due to its high visibility relevant photos can be found at various other locations, e.g., in and around St. James Park. Nevertheless, since London Eye happens to be located at the bank of river Thames, the regions covered by the respective sets of relevant photos have a high overlap. In fact, the single location drawn as a star in this overlap has the strongest association with the keyword set. In this case, there exists a singleton location set that covers both keywords and has the highest support in the data. </span></p><p class="c31"><span class="c9">7.3 Comparison with Other Association Types </span><span class="c3">As already explained (see Sections 1 and 2), there exist various approaches that discover different associations between locations and a given set of keywords. Hence, the purpose of our next exper- iment was to investigate whether the location sets returned by our approach (STA) are significantly different from those returned by other works, collective spatial keywords (CSK) and aggregate pop- ularity (AP). We note that we cannot compare with approaches that discover location patterns (LP) as they ignore textual information. </span></p><p class="c72"><span class="c3">To that end, we computed the top 10 results for STA, AP, and CSK, with respect to the keyword sets we compiled for the three datasets of London, Berlin, and Paris. Then, we computed the Jaccard similarity of the result sets of CSK and AP to ours. This measures the overlap in the query results, i.e., how many location sets STA and either CSK or AP return in common. </span></p><p class="c64"><span class="c3">The results of this experiment are presented in Table 8. The results are averaged across queries with the same keyword set car- dinality. As can be observed, the Jaccard similarity scores are very low in all cases, with values not exceeding 0.3. The highest scores are observed for queries with 2 keywords, where fewer possible location combinations exist. In those queries, on average, around </span></p><p class="c1 c47"><span class="c16">Table 6: Most Popular Keywords </span></p><p class="c58"><span class="c0">London Berlin Paris </span></p><p class="c89"><span class="c8">thames (2752) reichstag (876) louvre (2287) park (1738) fernsehturm (774) eiffel+tower (1742) london+eye (1730) architecture (716) seine (1488) big+ben (1698) alexanderplatz (713) notre+dame (1244) westminster (1543) wall (684) street (1194) architecture (1519) graffiti (575) montmartre (1184) museum (1386) street (562) architecture (1136) art (1319) art (543) museum (1022) tower+bridge (1276) museum (526) church (980) statue (1178) spree (492) art (970) </span></p><p class="c5"><span class="c16">Figure 6: Scatter plot where data points correspond to ex- periments with distinct keyword sets; the x axis indicates the number of associations above the support threshold, and the y axis indicates the highest support among the associations. </span></p><p class="c38 c87"><span class="c3">These results show that STA constitutes a novel and distinct cri- terion for discovering interesting socio-textual associations among locations, which cannot be replicated by existing approaches. </span><span class="c9">7.4 Number of Discovered Associations and </span><span class="c67">Maximum Support </span></p><p class="c38 c51"><span class="c3">Another aspect to investigate is the distribution of the number of results (associations found) and the support scores for different keyword set cardinalities. To that end, we computed the results for all keyword sets described in Section 7.1, i.e., 60 sets for each dataset, with cardinality |&Psi;| &isin; [2, 4]. For each keyword set of the respective dataset, we measured the number of results and the support of the top result. The results of this experiment are shown in Figure 6. We only present results for London; the other two datasets exhibited a similar pattern, and are hence omitted. In this result, the support threshold parameter was set &sigma; = 0.1% of the total number of users in the London dataset. Note that the value of the support threshold affects both the execution time and the number of results to be found. On the one hand, if the threshold is set too low, an excessive number of results may be returned, and the execution time may also be too high, since only few combinations can be pruned; on the other hand, setting the support threshold too high may return no results. Thus, the above value was selected experimentally according to this trade-off. </span></p><p class="c74 c38"><span class="c3">We notice the following trend in the results. Having only two keywords tends to produce results with high support (e.g., up to around 3% of the total number of users). As the number of key- words increases to 3 or 4, the maximum support among the returned results reduces significantly, dropping close to the support thresh- old; however, the number of returned results becomes much higher. This is an effect of the fact that, as explained in Section 4, the anti-monotonicity property does not hold in our problem. </span><span class="c9">7.5 Evaluation Time </span></p><p class="c38 c93"><span class="c3">Finally, we evaluate the efficiency of our proposed algorithms. In this experiment, we used the same keyword sets as above. </span></p><p class="c38 c74"><span class="c3">First, we compare the execution time of the three algorithms, STA-I, STA-ST and STA-STO, while varying the support threshold </span></p><p class="c24 c53"><span class="c3">2 or 3 of the top 10 location sets discovered by STA are common with those appearing in the results of AP or CSK. The degree of overlap drops even lower when the cardinality of the keyword set increases, allowing for a significantly larger number of candidate location sets. In those cases, often there is only one or zero results in common. This outcome is consistent across the three datasets. </span></p><p class="c63"><span class="c37">129 </span></p><p class="c1"><span class="c16">Table 7: Most Popular Keyword Sets </span></p><p class="c1"><span class="c8">|&Psi;| </span><span class="c0">London </span></p><p class="c1"><span class="c8">2 london+eye, thames (922); big+ben, london+eye (908); thames, westminster (898); park, thames (880); big+ben, thames (846) 3 </span><span class="c49">big+ben, london+eye, thames (557); big+ben, thames, westminster (497); big+ben, london+eye, westminster (472); london+eye, thames, westminster (464); park, thames, </span></p><p class="c1"><span class="c8">westminster (440) 4 </span><span class="c49">big+ben, london+eye, thames, westminster (358); big+ben, london+eye, thames, tower+bridge (293); art, green, park, thames (258); green, park, thames, trees (257); park, </span></p><p class="c1"><span class="c8">statue, thames, westminster (257) </span></p><p class="c1"><span class="c0">Berlin </span></p><p class="c1"><span class="c8">2 alexanderplatz, fernsehturm (404); fernsehturm, reichstag (320); alexanderplatz, reichstag (253); reichstag, wall (249); fernsehturm, spree (248) 3 </span><span class="c49">alexanderplatz, fernsehturm, reichstag (192); alexanderplatz, fernsehturm, spree (166); alexanderplatz, fernsehturm, wall (145); brandenburger+tor, fernsehturm, reichstag </span></p><p class="c1"><span class="c8">(144); fernsehturm, reichstag, spree (142) 4 </span><span class="c49">alexanderplatz, fernsehturm, reichstag, spree (106); alexanderplatz, brandenburger+tor, fernsehturm, reichstag (96); alexanderplatz, fernsehturm, reichstag, wall (95); </span></p><p class="c1"><span class="c8">alexanderplatz, fernsehturm, potsdamer+platz, reichstag (90); alexanderplatz, fernsehturm, museum, reichstag (82) </span></p><p class="c1"><span class="c0">Paris </span></p><p class="c1"><span class="c8">2 eiffel+tower, louvre (777); louvre, seine (745); louvre, museum (706); louvre, notre+dame (691); eiffel+tower, notre+dame (606) 3 </span><span class="c49">eiffel+tower, </span><span class="c8">(324) </span></p><p class="c1"><span class="c49">louvre, notre+dame (415); eiffel+tower, louvre, seine (343); louvre, notre+dame, seine (339); louvre, river, seine (327); arc+de+triomphe, eiffel+tower, louvre </span></p><p class="c1"><span class="c8">4 </span><span class="c49">eiffel+tower, louvre, notre+dame, seine (215); bridge, louvre, river, seine (209); arc+de+triomphe, eiffel+tower, louvre, notre+dame (208); louvre, museum, river, seine </span></p><p class="c1"><span class="c8">(189); bridge, river, seine, street (187) </span></p><p class="c1"><span class="c16">Table 8: Degree of Overlap Between the Associations Discovered by STA and those of Existing Approaches </span></p><p class="c23"><span class="c0">London Berlin Paris </span><span class="c8">|&Psi;| </span><span class="c0">AP CSK AP CSK AP CSK </span></p><p class="c24"><span class="c8">2 0.22 0.24 0.28 0.30 0.20 0.14 3 0.17 0.04 0.09 0.07 0.08 0.03 4 0.14 0.03 0.01 0.04 0.00 0.00 </span></p><p class="c24"><span class="c16">Table 9: Ratio of Number of Location Sets with Support Above Threshold over Number of Location Sets with Weak Support Above Threshold; </span><span class="c3">&sigma; = 0.2% </span></p><p class="c1"><span class="c8">|&Psi;| </span><span class="c0">London Berlin Paris </span></p><p class="c1"><span class="c8">2 13.29% 23.80% 25.98% 3 1.35% 1.09% 3.85% 4 0.01% 0.00% 0.36% </span></p><p class="c24"><span class="c3">parameter &sigma;, which is a percentage of the number of users in each dataset. Note that the basic STA method was at least an order of magnitude slower than all other methods and is thus omitted from all plots. Moreover, we include STA-ST in the comparison, in order to assess the benefits resulting by the STA-STO optimizations. The results are presented in Figures 7 and 8, for 2 and 4 keywords, respectively; results for |&Psi;| = 3 are similar and are omitted. </span></p><p class="c24"><span class="c3">As the support threshold increases, the performance of all meth- ods improves because fewer location sets survive the pruning. This is apparent in Paris, but not so much in London and Berlin for the specific range of support values depicted. Clearly, STA-I achieves the best performance. This is not surprising, since exploiting the preconstructed inverted index saves a substantial amount of the execution time during evaluation. It is worth noticing, however, that STA-STO is also very efficient, achieving competitive execu- tion times compared to STA-I. In fact, this is not a merit of the spatio-textual index per se, but rather a result of the proposed op- timizations; indeed, the execution times of the generic STA-ST are higher by an order of magnitude. The results appear to be consistent across the different datasets and for different number of keywords. </span></p><p class="c24"><span class="c3">Table 9 quantifies the number of location sets (or associations) discovered that have weak support above but actual support below the threshold, which was set to &sigma; = 0.2%. For example, in London for &Psi; = 2, we have that 13.29% of the location sets considered are actual results. As the keyword cardinality increases, the ratio decreases dramatically, because it becomes harder for location sets with weak support above the threshold to also cover all keywords. </span></p><p class="c1"><span class="c3">Finally, we evaluate the performance of the algorithms for the </span></p><p class="c24"><span class="c3">top-k version of the problem. The results are presented in Figure 9 for |&Psi;| = 3. A similar outcome is observed, with k-STA-I outper- forming k-STA-STO in all cases. For both algorithms, the execution time tends to increase with k as more results are requested. </span></p><p class="c1"><span class="c9">8. CONCLUSIONS </span></p><p class="c24"><span class="c3">In this paper, we have addressed the problem of finding socially and textually associated location sets from user trails on the Web. We have formally defined the problem and studied its characteristics. Based on this, we have proposed a general approach for addressing the problem, which we have elaborated to derive three algorithms based on different indices. Furthermore, we have extended our approach to address also the top-k variant of the problem. The pro- posed methods have been evaluated experimentally using geotagged Flickr photos in three different cities. </span></p><p class="c1"><span class="c9">Acknowledgements </span><span class="c3">This work was partially supported by the EU Project City.Risks (H2020-FCT-2014-653747). </span></p><p class="c1"><span class="c9">9. REFERENCES </span></p><p class="c1"><span class="c4">[1] R. Agrawal and R. Srikant. Fast algorithms for mining association </span></p><p class="c23"><span class="c4">rules in large databases. In </span><span class="c19">VLDB</span><span class="c4">, pages 487&ndash;499, 1994. [2] M. Becker, P. Singer, F. Lemmerich, A. Hotho, D. Helic, and </span></p><p class="c1"><span class="c4">M. Strohmaier. Photowalking the city: Comparing hypotheses about urban photo trails on Flickr. In </span><span class="c19">SocInfo</span><span class="c4">, pages 227&ndash;244, 2015. [3] G. Cai, C. Hio, L. Bermingham, K. Lee, and I. Lee. Mining frequent trajectory patterns and regions-of-interest from Flickr photos. In </span><span class="c19">HICSS</span><span class="c4">, pages 1454&ndash;1463, 2014. [4] X. Cao, G. Cong, C. S. Jensen, and B. C. Ooi. Collective spatial </span></p><p class="c23"><span class="c4">keyword querying. In </span><span class="c19">SIGMOD</span><span class="c4">, pages 373&ndash;384, 2011. [5] L. Chen, G. Cong, C. S. Jensen, and D. Wu. Spatial keyword query </span></p><p class="c1"><span class="c4">processing: An experimental evaluation. </span><span class="c19">PVLDB</span><span class="c4">, 6(3):217&ndash;228, 2013. [6] M. D. Choudhury, M. Feldman, S. Amer-Yahia, N. Golbandi, </span></p><p class="c1"><span class="c4">R. Lempel, and C. Yu. Automatic construction of travel itineraries using social breadcrumbs. In </span><span class="c19">HT</span><span class="c4">, pages 35&ndash;44, 2010. [7] M. Christoforaki, J. He, C. Dimopoulos, A. Markowetz, and T. Suel. Text vs. space: efficient geo-search query processing. In </span><span class="c19">CIKM</span><span class="c4">, pages 423&ndash;432, 2011. [8] C. Dwork, R. Kumar, M. Naor, and D. Sivakumar. Rank aggregation </span></p><p class="c23"><span class="c4">methods for the web. In </span><span class="c19">WWW</span><span class="c4">, pages 613&ndash;622, 2001. [9] G. R. Hjaltason and H. Samet. Distance browsing in spatial </span></p><p class="c1"><span class="c4">databases. </span><span class="c19">ACM TODS</span><span class="c4">, 24(2):265&ndash;318, 1999. </span></p><p class="c1"><span class="c37">130 </span></p><p class="c1"><span class="c3">(c) Paris </span><span class="c16">Figure 9: Varying number of results (</span><span class="c3">k</span><span class="c16">); </span><span class="c3">|&Psi;| = 3</span><span class="c16">. </span></p><p class="c1"><span class="c4">[10] S. Kisilevich, D. A. Keim, and L. Rokach. A novel approach to </span></p><p class="c1"><span class="c4">mining travel sequences using collections of geotagged photos. In </span><span class="c19">AGILE</span><span class="c4">, pages 163&ndash;182, 2010. [11] T. Kurashima, T. Iwata, G. Irie, and K. Fujimura. Travel route </span></p><p class="c1"><span class="c4">recommendation using geotags in photo sharing sites. In </span><span class="c19">CIKM</span><span class="c4">, pages 579&ndash;588, 2010. [12] I. Lee, G. Cai, and K. Lee. Mining points-of-interest association </span></p><p class="c1"><span class="c4">rules from geo-tagged photos. In </span><span class="c19">HICSS</span><span class="c4">, pages 1580&ndash;1588, 2013. [13] X. Lu, C. Wang, J. Yang, Y. Pang, and L. Zhang. Photo2Trip: </span></p><p class="c1"><span class="c4">generating travel routes from geo-tagged photos for trip planning. In </span><span class="c19">Multimedia</span><span class="c4">, pages 143&ndash;152, 2010. [14] A. Majid, L. Chen, G. Chen, H. T. Mirza, I. Hussain, and </span></p><p class="c26"><span class="c4">J. Woodward. A context-aware personalized travel recommendation system based on geotagged social media data mining. </span><span class="c19">International Journal of Geographical Information Science</span><span class="c4">, 27(4):662&ndash;684, 2013. [15] E. Spyrou, I. Sofianos, and P. Mylonas. Mining tourist routes from </span></p><p class="c1"><span class="c4">flickr photos. In </span><span class="c19">SMAP</span><span class="c4">, pages 1&ndash;5, 2015. [16] Y. Sun, H. Fan, M. Bakillah, and A. Zipf. Road-based travel </span></p><p class="c1"><span class="c4">recommendation using geo-tagged images. </span><span class="c19">Computers, Environment and Urban Systems</span><span class="c4">, 53:110&ndash;122, 2015. [17] C. Tai, D. Yang, L. Lin, and M. Chen. Recommending personalized </span></p><p class="c1"><span class="c4">scenic itinerary with geo-tagged photos. In </span><span class="c19">ICME</span><span class="c4">, pages 1209&ndash;1212, </span></p><p class="c1"><span class="c4">2008. [18] B. Thomee, D. A. Shamma, G. Friedland, B. Elizalde, K. Ni, </span></p><p class="c26"><span class="c4">D. Poland, D. Borth, and L.-J. Li. The new data and new challenges in multimedia research. </span><span class="c19">arXiv preprint arXiv:1503.01817</span><span class="c4">, 2015. [19] Z. Yin, L. Cao, J. Han, J. Luo, and T. S. Huang. Diversified </span></p><p class="c1"><span class="c4">trajectory pattern ranking in geo-tagged social media. In </span><span class="c19">SDM</span><span class="c4">, pages 980&ndash;991, 2011. [20] D. Zhang, C. Chan, and K. Tan. Processing spatial keyword query as </span></p><p class="c1"><span class="c4">a top-k aggregation query. In </span><span class="c19">SIGIR</span><span class="c4">, pages 355&ndash;364, 2014. [21] D. Zhang, Y. M. Chee, A. Mondal, A. K. H. Tung, and </span></p><p class="c23"><span class="c4">M. Kitsuregawa. Keyword search in spatial databases: Towards searching by document. In </span><span class="c19">ICDE</span><span class="c4">, pages 688&ndash;699, 2009. [22] D. Zhang, K.-L. Tan, and A. K. Tung. Scalable top-k spatial keyword </span></p><p class="c1"><span class="c4">search. In </span><span class="c19">EDBT</span><span class="c4">, pages 359&ndash;370, 2013. [23] Y. Zheng, Z. Zha, and T. Chua. Mining travel patterns from </span></p><p class="c1"><span class="c4">geotagged photos. </span><span class="c19">ACM TIST</span><span class="c4">, 3(3):56, 2012. [24] Y. Zheng, L. Zhang, X. Xie, and W. Ma. Mining interesting locations </span></p><p class="c1"><span class="c4">and travel sequences from GPS trajectories. In </span><span class="c19">WWW</span><span class="c4">, pages 791&ndash;800, 2009. [25] Y. Zhou, X. Xie, C. Wang, Y. Gong, and W. Ma. Hybrid index </span></p><p class="c1"><span class="c4">structures for location-based web search. In </span><span class="c19">CIKM</span><span class="c4">, pages 155&ndash;162, 2005. </span></p><p class="c1"><span class="c37">131 </span></p><p class="c1"><span class="c3">(a) London </span></p><p class="c1"><span class="c3">(a) London </span></p><p class="c1"><span class="c3">(a) London </span></p><p class="c1"><span class="c3">(c) Paris </span><span class="c16">Figure 7: Varying support threshold (</span><span class="c3">&sigma;</span><span class="c16">); </span><span class="c3">|&Psi;| = 2</span><span class="c16">. </span></p><p class="c1"><span class="c3">(c) Paris </span><span class="c16">Figure 8: Varying support threshold (</span><span class="c3">&sigma;</span><span class="c16">); </span><span class="c3">|&Psi;| = 4</span><span class="c16">. </span></p><p class="c1"><span class="c3">(b) Berlin </span></p><p class="c1"><span class="c3">(b) Berlin </span></p><p class="c1"><span class="c3">(b) Berlin </span></p></body></html>