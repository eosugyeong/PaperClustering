<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:13.3pt;font-family:"Arial";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.9pt;font-family:"Arial";font-style:normal}.c13{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7pt;font-family:"Arial";font-style:normal}.c113{margin-left:-22.2pt;padding-top:1.4pt;text-indent:31.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-26.2pt}.c112{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.3pt;font-family:"Arial";font-style:normal}.c73{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.2pt;font-family:"Arial";font-style:normal}.c52{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Courier New";font-style:normal}.c84{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.1pt;font-family:"Courier New";font-style:normal}.c30{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.5pt;font-family:"Arial";font-style:normal}.c57{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.6pt;font-family:"Courier New";font-style:normal}.c129{margin-left:-22.2pt;padding-top:15.4pt;text-indent:86.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-33.1pt}.c62{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:16.6pt;font-family:"Arial";font-style:normal}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Arial";font-style:normal}.c79{margin-left:-22.2pt;padding-top:4.1pt;text-indent:31.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.7pt}.c16{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Arial";font-style:normal}.c27{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8.5pt;font-family:"Arial";font-style:normal}.c130{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:15.5pt;font-family:"Courier New";font-style:normal}.c80{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10pt;font-family:"Courier New";font-style:normal}.c53{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11.3pt;font-family:"Arial";font-style:normal}.c96{margin-left:-31pt;padding-top:1.7pt;text-indent:39.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-10.9pt}.c22{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.3pt;font-family:"Arial";font-style:normal}.c42{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c11{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:6.6pt;font-family:"Arial";font-style:normal}.c102{margin-left:-31pt;padding-top:3.8pt;text-indent:39.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-10.9pt}.c98{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:17.7pt;font-family:"Arial";font-style:normal}.c94{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:18.6pt;font-family:"Courier New";font-style:normal}.c78{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:7.2pt;font-family:"Courier New";font-style:normal}.c56{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12.1pt;font-family:"Arial";font-style:normal}.c15{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11.2pt;font-family:"Courier New";font-style:normal}.c18{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.3pt;font-family:"Arial";font-style:normal}.c51{margin-left:-31pt;padding-top:4.1pt;text-indent:39.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-10.9pt}.c35{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10.4pt;font-family:"Arial";font-style:normal}.c69{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:17.9pt;font-family:"Arial";font-style:normal}.c71{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10.2pt;font-family:"Arial";font-style:normal}.c72{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.2pt;font-family:"Arial";font-style:normal}.c134{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.1pt;font-family:"Arial";font-style:normal}.c12{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Arial";font-style:normal}.c19{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.4pt;font-family:"Courier New";font-style:normal}.c82{margin-left:-29.5pt;padding-top:9.6pt;text-indent:32.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-3.4pt}.c91{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Courier New";font-style:normal}.c88{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12.4pt;font-family:"Courier New";font-style:normal}.c20{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:6.6pt;font-family:"Arial";font-style:normal}.c101{margin-left:-31pt;padding-top:59.3pt;text-indent:33.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-10.9pt}.c7{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Courier New";font-style:normal}.c95{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.8pt;font-family:"Arial";font-style:normal}.c77{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11.2pt;font-family:"Courier New";font-style:normal}.c32{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.8pt;font-family:"Courier New";font-style:normal}.c34{margin-left:-31pt;padding-top:1.4pt;text-indent:39.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-10.9pt}.c23{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.3pt;font-family:"Arial";font-style:normal}.c87{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11pt;font-family:"Courier New";font-style:normal}.c9{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10pt;font-family:"Courier New";font-style:normal}.c70{margin-left:-22.2pt;padding-top:1.7pt;text-indent:31.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.9pt}.c21{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10pt;font-family:"Arial";font-style:normal}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.7pt;font-family:"Arial";font-style:normal}.c131{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:7.2pt;font-family:"Arial";font-style:normal}.c38{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.8pt;font-family:"Arial";font-style:normal}.c28{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.2pt;font-family:"Arial";font-style:normal}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10pt;font-family:"Arial";font-style:normal}.c44{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12.4pt;font-family:"Arial";font-style:normal}.c107{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11pt;font-family:"Arial";font-style:normal}.c106{margin-left:-31pt;padding-top:0.5pt;text-indent:39.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-10.6pt}.c97{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:17.4pt;font-family:"Arial";font-style:normal}.c121{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:11pt;font-family:"Courier New";font-style:normal}.c45{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11.6pt;font-family:"Arial";font-style:normal}.c31{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Arial";font-style:normal}.c76{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Arial";font-style:normal}.c14{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:16.9pt;font-family:"Arial";font-style:normal}.c75{margin-left:-31pt;padding-top:1.4pt;text-indent:39.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-10.9pt}.c41{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c36{margin-left:-22.2pt;padding-top:0.5pt;text-indent:31.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.9pt}.c65{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.6pt;font-family:"Arial";font-style:normal}.c109{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:9pt;font-family:"Arial";font-style:normal}.c49{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.6pt;font-family:"Arial";font-style:normal}.c40{margin-left:-22.2pt;padding-top:1.7pt;text-indent:31.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.9pt}.c74{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:9pt;font-family:"Arial";font-style:normal}.c100{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10.6pt;font-family:"Arial";font-style:normal}.c90{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8.6pt;font-family:"Arial";font-style:normal}.c93{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7pt;font-family:"Courier New";font-style:normal}.c64{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.1pt;font-family:"Arial";font-style:normal}.c10{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Arial";font-style:normal}.c8{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10.3pt;font-family:"Arial";font-style:normal}.c61{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:7.5pt;font-family:"Arial";font-style:normal}.c48{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:7pt;font-family:"Arial";font-style:normal}.c60{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.7pt;font-family:"Courier New";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.4pt;font-family:"Arial";font-style:normal}.c63{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12.3pt;font-family:"Arial";font-style:normal}.c117{margin-left:-31pt;padding-top:1.7pt;text-indent:39.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-10.9pt}.c108{margin-left:-31pt;padding-top:14.9pt;text-indent:39.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-10.9pt}.c43{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9.3pt;font-family:"Courier New";font-style:normal}.c50{margin-left:-17.6pt;padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:87.1pt}.c128{margin-left:-17.8pt;padding-top:10.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-10.6pt}.c54{margin-left:42pt;padding-top:28.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:60.5pt}.c133{margin-left:18.2pt;padding-top:27.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:29.3pt}.c67{margin-left:29.4pt;padding-top:5pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:31.7pt}.c66{margin-left:-22.2pt;padding-top:17pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:59.3pt}.c125{margin-left:218.2pt;padding-top:32.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-36.1pt}.c89{margin-left:-31pt;padding-top:7.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-11.1pt}.c59{margin-left:-31pt;padding-top:7.4pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-10.9pt}.c26{margin-left:-22.2pt;padding-top:7.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.9pt}.c115{margin-left:218.2pt;padding-top:38.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-278pt}.c81{margin-left:-22.2pt;padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:112.1pt}.c25{margin-left:-31pt;padding-top:15.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-10.9pt}.c68{margin-left:-22.2pt;padding-top:13.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:49.9pt}.c114{margin-left:-8.7pt;padding-top:10.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.7pt}.c24{margin-left:-8.7pt;padding-top:10.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.7pt}.c116{margin-left:-17.8pt;padding-top:10.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-10.9pt}.c119{margin-left:218.2pt;padding-top:31pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-36.1pt}.c55{margin-left:-23.1pt;padding-top:5.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-8.4pt}.c37{margin-left:-31pt;padding-top:17.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:130.2pt}.c110{margin-left:-31pt;padding-top:7.2pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-10.9pt}.c29{margin-left:-31pt;padding-top:12.5pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-10.9pt}.c99{margin-left:-31pt;padding-top:14.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-10.9pt}.c58{margin-left:-22.2pt;padding-top:11.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.7pt}.c47{margin-left:-31pt;padding-top:7.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-10.9pt}.c122{margin-left:-31pt;padding-top:13pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:112pt}.c105{margin-left:59.8pt;padding-top:11.8pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:73.7pt}.c135{margin-left:-31pt;padding-top:15.8pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-15.9pt}.c39{margin-left:-31pt;padding-top:7.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-10.9pt}.c103{margin-left:-22.2pt;padding-top:7.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.9pt}.c83{margin-left:-8.7pt;padding-top:9.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-25.7pt}.c127{margin-left:-32.2pt;padding-top:13.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:189pt}.c86{margin-left:-31pt;padding-top:15.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-10.9pt}.c85{margin-left:-17.8pt;padding-top:10.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-10.9pt}.c126{padding-top:23pt;text-indent:31.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c136{padding-top:4.1pt;text-indent:31.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c124{padding-top:3.8pt;text-indent:31.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c111{padding-top:9.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c17{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c120{padding-top:7.4pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c92{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c33{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c46{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c123{margin-left:-32.2pt;text-indent:67.9pt;margin-right:35.9pt}.c118{margin-left:-22.2pt;margin-right:-24.7pt}.c132{margin-left:-22.2pt;margin-right:-21.8pt}.c104{margin-left:-22.2pt;margin-right:-19.9pt}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:24pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:14pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c46"><p class="c133"><span class="c69">Efficiently Computing Top-K Shortest Path Join </span></p><p class="c54"><span class="c42">Lijun Chang</span><span class="c21">&dagger;</span><span class="c42">, Xuemin Lin</span><span class="c21">&dagger;#</span><span class="c42">, Lu Qin</span><span class="c21">&para;</span><span class="c42">, Jeffrey Xu Yu</span><span class="c21">&Dagger;</span><span class="c42">, Jian Pei</span><span class="c21">&sect; </span></p><p class="c105"><span class="c13">&dagger;</span><span class="c62">University of New South Wales, Australia, {ljchang,lxue}@cse.unsw.edu.au </span><span class="c93">#</span><span class="c62">East China Normal University, China </span><span class="c13">&para;</span><span class="c62">University of Technology, Sydney, Australia, lu.qin@uts.edu.au </span><span class="c13">&Dagger;</span><span class="c62">The Chinese University of Hong Kong, Hong Kong, China, yu@se.cuhk.edu.hk </span><span class="c13">&sect;</span><span class="c62">Simon Fraser University, Canada, jpei@cs.sfu.ca </span></p><p class="c99"><span class="c42">ABSTRACT </span><span class="c2">Driven by many applications, in this paper we study the problem of computing the top-k shortest paths from one set of target nodes to another set of target nodes in a graph, namely the top-k shortest path join (KPJ) between two sets of target nodes. While KPJ is an extension of the problem of computing the top-k shortest paths (KSP) between two target nodes, the existing technique by convert- ing KPJ to KSP has several deficiencies in conducting the compu- tation. To resolve these, we propose to use the best-first paradigm to recursively divide search subspaces into smaller subspaces, and to compute the shortest path in each of the subspaces in a prioritized order based on their lower bounds. Consequently, we only compute shortest paths in subspaces whose lower bounds are larger than the length of the current k-th shortest path. To improve the efficiency, we further propose an iteratively bounding approach to tightening lower bounds of subspaces. Moreover, we propose two index struc- tures which can be used to reduce the exploration area of a graph dramatically; these greatly speed up the computation. Extensive performance studies based on real road networks demonstrate the scalability of our approaches and that our approaches outperform the existing approach by several orders of magnitude. Further- more, our approaches can be immediately used to compute KSP. Our experiment also demonstrates that our techniques outperform the state-of-the-art algorithm for KSP by several orders of magni- tude. </span></p><p class="c122"><span class="c42">1. INTRODUCTION </span></p><p class="c102"><span class="c2">Data are often modeled as graphs in many real applications such as social networks, information networks, gene networks, protein- protein interaction networks, and road networks. With the prolif- eration of graph data, significant research efforts have been made towards analyzing large graph data. These include the problem of computing the top-k shortest paths between two target nodes in a graph, namely the k shortest path (KSP) query. </span></p><p class="c34"><span class="c2">KSP is a fundamental graph problem with many applications. In general, KSP is used in the applications that besides lengths, other constraints against the paths could not be precisely defined [12, </span></p><p class="c101"><span class="c10">c 2015, Copyright is with the authors. Published in Proc. 18th Inter- national Conference on Extending Database Technology (EDBT), March 23-27, 2015, Brussels, Belgium: ISBN 978-3-89318-067-7, on OpenPro- ceedings.org. Distribution of this paper is permitted under the terms of the Creative Commons license CC-by-nc-nd 4.0 </span></p><p class="c17 c104"><span class="c2">25]. For example, computing KSP between two sensitive accounts in a large social network enables end-users to identify all accounts involved in the top-k shortest paths [14]. In gene networks, the lengths of top-k shortest paths may be used to define the impor- tance of a target gene to a source gene [26]. Other applications of KSP include multiple object tracking in pattern recognition [3], hy- pothesis generation in computational linguistics, and trip planning against road networks. Thus, KSP has been extensively studied [8, 9, 14, 15, 18, 24, 28]. </span></p><p class="c40"><span class="c2">The problem of computing the top-k shortest paths between two &ldquo;conceptual&rdquo; target nodes (instead of between two physical nodes) in a graph, called the top-k shortest path join (KPJ), is recently investigated in [15]. A conceptual node is a set of physical nodes in the graph, which can be identified by categories, concepts, and keywords in the above applications. While a KSP query is a special case of a KPJ query where each of the two conceptual target nodes only contains one physical node, KPJ can support more general application scenarios than KSP since a target node is allowed to be a set of physical nodes. For example, in a social network, the KPJ query can be used to detect user accounts involved in the top-k shortest paths between two criminal gangs to identify other &ldquo;most suspicious&rdquo; user accounts; the KPJ query can also be used in route planning where the destination is any one from a group of nodes (e.g., &ldquo;IKEA&rdquo;). In this paper, we study KPJ. </span></p><p class="c103"><span class="c2">Motivations and Challenges. KPJ query shares similarity with but is different from the well-studied KSP query. To process a KPJ query, [15] reduces it to a KSP query by introducing a virtual target node for each conceptual target node and connecting every physical node in the conceptual node to it. Then, [15] proposes to use the state-of-the-art algorithm for KSP developed in [15]. Since the technique for solving KSP in [15] is based on the deviation paradigm [9, 28], applying KSP to solve KPJ, as proposed in [15], has the following two deficiencies. 1) Firstly, the deviation based techniques for KSP need to compute O(k &middot; n) &ldquo;candidate paths&rdquo;. The candidate paths are computed by iteratively extend- ing all &ldquo;prefixes&quot; of the obtained l-th (l&lt;k) shortest path, where n is the number of nodes in a graph, and each candidate path is computed by running an expensive shortest path algorithm; this is time-consuming. 2) Secondly, edges that are added to connect to a virtual target node for processing KPJ by using the KSP tech- niques depend on queries. This makes the existing index structures [7, 10] for computing shortest paths inapplicable. Thus, the candi- date paths are computed by traversing the graph exhaustively; this is very costly. </span></p><p class="c104 c120"><span class="c2">Our Approaches. For presentation simplicity, in this paper we present our techniques against the simplified case, where one con- </span></p><p class="c115"><span class="c41">133 10.5441/002/edbt.2015.13 </span></p><p class="c86"><span class="c2">ceptual target node consists of one physical node only - called source node s, and the other conceptual target node may consist of multiple physical nodes - called destination nodes; then we extend our techniques to the general case where source nodes may also be multiple. Let P denote the set of all simple paths (i.e., paths without loops) from s to any of the destination nodes as the entire search space. Clearly, the result of KPJ is the set of k paths in P with the shortest lengths. </span></p><p class="c96"><span class="c2">We adopt the best-first paradigm to recursively divide P into smaller subspaces, and then compute shortest paths for the gen- erated subspaces in a prioritized order based on their lower bounds, where lower bound of a subspace is the lower bound of the length of all paths in the subspace. The top-k shortest paths may be itera- tively obtained over the subspaces whose lower bounds are smaller than the length of the current k-th shortest path, while other sub- spaces can be safely pruned without the time-consuming shortest path computation. </span></p><p class="c96"><span class="c2">We further propose to iteratively &ldquo;guess&quot; and tighten the lower bound &#8999; of a subspace. Initially, we assign the value of &#8999; as the length of the (1st) shortest path. Then, we always choose the sub- space with the smallest &#8999; to test whether the shortest path in it has length larger than &crarr; &middot; &#8999; (for an &crarr; &gt; 1). If the shortest path in the subspace can be determined larger than &crarr;&middot;&#8999;, then we enlarge &#8999; into &crarr; &middot; &#8999; for the subspace; otherwise the shortest path in the subspace is computed. Moreover, we propose two online-built index struc- tures, SPT</span><span class="c0">P </span><span class="c16">and SPT</span><span class="c0">I</span><span class="c16">, to significantly reduce the exploration area </span><span class="c2">of a graph in the lower bound testing as briefly described above. </span></p><p class="c110"><span class="c2">Contributions. Our primary contributions are summarized as fol- lows.</span><span class="c16">&bull; We propose a framework based on the best-first paradigm </span><span class="c2">for processing KPJ queries which significantly reduces the number of shortest path computations. </span></p><p class="c85"><span class="c2">&bull; We propose an iteratively bounding approach to guessing and tightening the lower bounds, as well as two online-built index structures to speed-up the lower bound testing. </span></p><p class="c116"><span class="c2">&bull; We conduct extensive performance studies and demonstrate the scalability of our approaches which outperform the base- line approach [15] by several orders of magnitude. </span></p><p class="c128"><span class="c2">&bull; Moreover, our approaches can be immediately used to pro- cess KSP queries, and our experiments also demonstrate that our techniques outperform the state-of-the-art algorithm for KSP query by several orders of magnitude. </span></p><p class="c29"><span class="c2">Organization. The rest of this paper is organized as follows. A brief overview of related work is given below. We give the prelimi- naries and problem statement in Section 2. The existing KSP-based approach is given in Section 3, in which we also discuss its defi- ciencies. We present the best-first paradigm in Section 4, in which we also implement a best-first approach. Under this paradigm, in Section 5 we propose an iteratively bounding approach and two online-built indexes for efficiently processing KPJ queries. In Sec- tion 6, we extend our techniques to cover other applications includ- ing the case that the source node has multiple physical nodes. We conducted extensive experimental studies and report our findings in Section 7, and we conclude this paper in Section 8. </span></p><p class="c39"><span class="c2">Related Work. Given two nodes s and t in a graph G, the problem of computing the top-k shortest paths from s to t is a long-studied problem, which can be classified into two categories, 1) top-k sim- ple shortest paths, and 2) top-k general shortest paths. </span></p><p class="c4 c118"><span class="c2">1) Top-k Simple Shortest Path. The existing algorithms for comput- ing top-k simple shortest paths are based on the deviation paradigm proposed by Yen [9, 28], which has a time complexity of O(k &middot; n &middot; (m + nlog n)), where m is the number of edges in G and O(m+n log n) is the time complexity of computing single source shortest paths. Techniques to improve its efficiency in practice have been studied in [8, 14, 15, 18, 24], which shall be discussed in Sec- tion 3. We discuss using these techniques to process KPJ queries in Section 3. 2) Top-k General Shortest Path. Finding top-k general shortest paths is studied in [2, 12, 19], where cycles in paths are allowed. Since not enforcing paths to be simple, the top-k general shortest path problem is generally easier than its counterpart. Eppstein&rsquo;s algo- rithm [12] has the best time complexity, O(m+nlog n+k), which is achieved by precomputing a shortest path tree rooted at the des- tination node and building a sophisticated data structure. Recently, the authors in [1] propose a heuristic search algorithm that has the same time complexity as [12]. However, due to different problem natures, these techniques are inapplicable to finding top-k simple shortest paths. Finding Top-k Objects by Keywords. Finding k objects closest to a query location and containing user-given keywords has been stud- ied in [13, 20, 22, 23, 29]. Ranking spatial objects by the com- bination of distance and relevance score is also studied in [4, 5, 27]. Distance oracles for node-label queries in a labeled graph are studied in [6, 17]; that is, given a query which contains a node and a label, it returns approximately the closest node to the query node that contains the query label. Nevertheless, the above queries are inherently different from KPJ, and their techniques cannot be applied to process KPJ queries. </span></p><p class="c81"><span class="c42">2. PRELIMINARY </span></p><p class="c104 c124"><span class="c2">In this paper, we focus on a weighted and directed graph G = (V,E,!), where V and E represent the set of nodes and the set of edges of G, respectively, and ! is a function assigning a weight to each edge in E. In G, nodes belong to categories, and each cate- gory represents a conceptual node consisting of all nodes belonging to that category. The number of nodes and the number of edges of G are denoted by n = |V | and m = |E|, respectively. </span></p><p class="c70"><span class="c2">A path P in G is a sequence of nodes (v</span><span class="c12">1</span><span class="c2">,...,v</span><span class="c12">l</span><span class="c2">) such that (v</span><span class="c0">i</span><span class="c16">,v</span><span class="c0">i+1</span><span class="c16">) 2 E,81 &#63743; i&lt;l, and we say that P consists of edges </span><span class="c2">(v</span><span class="c12">i</span><span class="c2">,v</span><span class="c12">i+1</span><span class="c2">), 81 &#63743; i&lt;l. Here, v</span><span class="c12">1 </span><span class="c2">and v</span><span class="c0">l </span><span class="c16">are called the source node </span><span class="c2">and destination node of P, respectively. P is a simple path if and only if all nodes in P are distinct (i.e., v</span><span class="c0">i </span><span class="c16">= v</span><span class="c0">j</span><span class="c16">,8i = j). A prefix of </span><span class="c2">P is a subpath of P starting from the source node of P. The length of a path is defined as the total weight of its constituent edges; that is !(P) = </span><span class="c31">P</span><span class="c12">(v</span><span class="c23">i</span><span class="c12">,v</span><span class="c23">i+1</span><span class="c12">)2P </span><span class="c31">!(v</span><span class="c21">i</span><span class="c31">,v</span><span class="c21">i+1</span><span class="c31">). The shortest distance </span><span class="c2">from v</span><span class="c0">1 </span><span class="c16">to v</span><span class="c0">2 </span><span class="c16">is the shortest length among all paths from v</span><span class="c0">1 </span><span class="c16">to v</span><span class="c0">2</span><span class="c16">, </span><span class="c2">denoted (v</span><span class="c12">1</span><span class="c2">,v</span><span class="c12">2</span><span class="c2">). Definition 2.1: Given a category T, a path P is said to be a path to category T if its destination node is in V</span><span class="c12">T</span><span class="c2">, where V</span><span class="c12">T </span><span class="c2">is the set of nodes belonging to category T. </span><span class="c7">n </span></p><p class="c58"><span class="c2">Problem Statement: Given a graph G, we study the top-k shortest path join (KPJ) query, which aims at finding the top-k shortest simple paths P</span><span class="c12">1</span><span class="c2">,...,P</span><span class="c0">k </span><span class="c16">from a source node s to a category T (i.e., </span><span class="c2">to any node in V</span><span class="c0">T </span><span class="c16">). </span></p><p class="c36"><span class="c2">Formally, a KPJ query is given as Q = {s,T,k}, where s is a source node in G, T represents a destination category, and k specifies the number of paths to find. It is to find k simple paths P</span><span class="c12">1</span><span class="c2">,...,P</span><span class="c12">k </span><span class="c2">such that: 1) each P</span><span class="c12">i </span><span class="c2">is a path from s to category T; 2) !(P</span><span class="c0">i</span><span class="c16">) &#63743; !(P</span><span class="c0">i+1</span><span class="c16">),81 &#63743; i &lt; k; 3) !(P</span><span class="c0">k</span><span class="c16">) &#63743; !(P) for any </span></p><p class="c119"><span class="c41">134 </span></p><p class="c4"><span class="c2">other path P from s to category T. </span><span class="c90">v</span><span class="c9">12 </span><span class="c18">v</span><span class="c9">13 </span></p><p class="c4"><span class="c27">3 </span></p><p class="c4"><span class="c27">10</span><span class="c90">v</span><span class="c9">14 </span><span class="c64">10 </span></p><p class="c4"><span class="c90">v</span><span class="c9">15 </span><span class="c18">t </span><span class="c9">H </span><span class="c27">4</span><span class="c80">H </span><span class="c90">v</span><span class="c9">11 </span><span class="c18">v</span><span class="c9">1 </span></p><p class="c4"><span class="c27">2 </span></p><p class="c4"><span class="c27">3 </span></p><p class="c4"><span class="c90">v</span><span class="c9">8 </span></p><p class="c4"><span class="c18">v</span><span class="c9">3 </span></p><p class="c4"><span class="c93">4 </span><span class="c90">v</span><span class="c9">7 </span><span class="c27">1 </span></p><p class="c4"><span class="c18">v</span><span class="c9">5 </span></p><p class="c4"><span class="c27">3 </span><span class="c90">v</span><span class="c9">6 </span><span class="c112">v</span><span class="c91">2 </span></p><p class="c4"><span class="c27">5 2 </span></p><p class="c4"><span class="c90">v</span><span class="c9">10 </span></p><p class="c4"><span class="c27">8 </span></p><p class="c4"><span class="c91">H </span><span class="c18">v</span><span class="c9">4 </span></p><p class="c4"><span class="c27">2 </span></p><p class="c4"><span class="c90">v</span><span class="c9">9 </span><span class="c2">Figure 1: An example graph </span></p><p class="c33"><span class="c2">Example 2.1: Fig. 1 illustrates a graph G, where V = {v</span><span class="c0">1</span><span class="c16">,...,v</span><span class="c0">15</span><span class="c16">} </span><span class="c2">and nodes v</span><span class="c12">4</span><span class="c2">,v</span><span class="c12">6</span><span class="c2">,v</span><span class="c12">7 </span><span class="c2">belong to category&ldquo;H&rdquo; (i.e., hotel). Here, edges are bidirectional, and weights are shown besides them with a default value 1. Consider a KPJ query Q = {v</span><span class="c0">1</span><span class="c16">,&ldquo;H&rdquo;,1}, which </span><span class="c2">is to find the top-1 shortest path from v</span><span class="c12">1 </span><span class="c2">to category &ldquo;H&rdquo;. The top-1 path is P</span><span class="c0">1 </span><span class="c16">= (v</span><span class="c0">1</span><span class="c16">,v</span><span class="c0">8</span><span class="c16">,v</span><span class="c0">7</span><span class="c16">) with !(P</span><span class="c0">1</span><span class="c16">)=2+3=5. </span><span class="c52">n </span><span class="c2">For a KPJ query, V</span><span class="c12">T </span><span class="c2">is the set of destination nodes. In the fol- lowing, we assume that an inverted index [21] is offline built on the categories of nodes such that V</span><span class="c12">T </span><span class="c2">can be efficiently retrieved online, and assume that a path is a simple path. </span></p><p class="c4"><span class="c42">3. THE EXISTING KSP-BASED APPROACH </span></p><p class="c4"><span class="c2">Reducing KPJ Query to KSP Query. The most related problem to KPJ is k shortest path (KSP) query defined below. Definition 3.1:[28] Given a graph G, a KSP query Q</span><span class="c21">0 </span><span class="c2">= {s, t, k} is to find k simple paths P</span><span class="c12">1</span><span class="c2">,...,P</span><span class="c0">k </span><span class="c16">from s to t such that, 1) !(P</span><span class="c0">i</span><span class="c16">) &#63743; </span><span class="c2">!(P</span><span class="c0">i+1</span><span class="c16">),81 &#63743; i&lt;k, and 2) !(P</span><span class="c0">k</span><span class="c16">) &#63743; !(P) for any other path P </span><span class="c2">from s to t. </span><span class="c7">n </span><span class="c2">KSP query is a special case of KPJ query where V</span><span class="c0">T </span><span class="c16">contains </span><span class="c2">only one node. In other words, KSP query considers a single desti- nation node while KPJ query considers multiple destination nodes. To process a KPJ query Q = {s,T,k}, [15] reduces it to a KSP query by adding a virtual destination node t to G and adding a directed edge from each node in V</span><span class="c0">T </span><span class="c16">to t with a weight 0. Then, </span><span class="c2">the result of Q on G is the same as the result of the KSP query Q</span><span class="c21">0 </span><span class="c2">= {s, t, k} on G</span><span class="c12">Q</span><span class="c2">. Reconsider the KPJ query in Example 2.1, the modified graph G</span><span class="c0">Q </span><span class="c16">is also shown in Fig. 1 with the virtual node </span><span class="c2">t and the additional edges (dashed lines). </span></p><p class="c4"><span class="c2">Deviation Algorithm (DA) for KSP Queries. The existing algo- rithms for KSP queries are based on the deviation paradigm [9, 28], denoted DA. It maintains a set C of candidate paths which include the next shortest path from s to t, and chooses k shortest paths from C one by one in a non-decreasing length order by incrementally updating C. Pseudo-tree. The set of already chosen paths are encoded using a compact trie-like structure [21], called pseudo-tree. It is named because the same node may appear at several places in the tree; thus, we refer to nodes in a pseudo-tree as vertices to distinguish them from nodes in a graph. Let PT</span><span class="c12">i </span><span class="c2">denote the pseudo-tree con- structed for paths P</span><span class="c0">1</span><span class="c16">,...,P</span><span class="c0">i</span><span class="c16">, and PT</span><span class="c0">0 </span><span class="c16">consists of a single vertex </span><span class="c2">s. PT</span><span class="c12">i+1 </span><span class="c2">is constructed by inserting P</span><span class="c12">i+1 </span><span class="c2">into PT</span><span class="c12">i </span><span class="c2">by sharing the longest prefix; let d be the last vertex of the shared prefix, it is called the deviation vertex of P</span><span class="c0">i+1 </span><span class="c16">from PT</span><span class="c0">i</span><span class="c16">. For example, Fig. 2 </span><span class="c2">shows PT</span><span class="c12">1</span><span class="c2">, PT</span><span class="c12">2</span><span class="c2">, and PT</span><span class="c12">3</span><span class="c2">, where PT</span><span class="c12">3 </span><span class="c2">is constructed by inserting path (v</span><span class="c0">1</span><span class="c16">,v</span><span class="c0">3</span><span class="c16">,v</span><span class="c0">7</span><span class="c16">,t) into PT</span><span class="c0">2</span><span class="c16">, and v</span><span class="c0">3 </span><span class="c16">is the deviation vertex. </span></p><p class="c4"><span class="c76">v</span><span class="c45">1</span><span class="c62">v</span><span class="c45">8</span><span class="c62">v</span><span class="c45">7</span><span class="c62">t</span><span class="c16">(a) PT</span><span class="c0">1 </span></p><p class="c4"><span class="c100">v</span><span class="c63">1 </span></p><p class="c4"><span class="c100">v</span><span class="c63">3</span><span class="c98">v</span><span class="c63">7</span><span class="c98">v</span><span class="c63">6 </span><span class="c98">t </span></p><p class="c4"><span class="c6">c</span><span class="c60">(</span><span class="c6">v</span><span class="c73">1</span><span class="c15">) </span></p><p class="c4"><span class="c35">v</span><span class="c56">1 </span></p><p class="c4"><span class="c35">v</span><span class="c56">7</span><span class="c97">t </span></p><p class="c4"><span class="c2">(b) PT</span><span class="c0">2 </span></p><p class="c4"><span class="c65">c</span><span class="c57">(</span><span class="c65">v</span><span class="c38">1</span><span class="c57">) </span><span class="c100">v</span><span class="c63">8 </span></p><p class="c4"><span class="c6">c</span><span class="c60">(</span><span class="c6">v</span><span class="c73">3</span><span class="c15">) </span></p><p class="c4"><span class="c35">v</span><span class="c56">8 </span></p><p class="c4"><span class="c65">c</span><span class="c57">(</span><span class="c65">v</span><span class="c38">8</span><span class="c57">) </span></p><p class="c4"><span class="c35">v</span><span class="c56">3 </span><span class="c107">c</span><span class="c87">(</span><span class="c107">v</span><span class="c134">3</span><span class="c87">) </span></p><p class="c4"><span class="c65">c</span><span class="c57">(</span><span class="c65">v</span><span class="c38">7</span><span class="c57">) </span></p><p class="c4"><span class="c35">v</span><span class="c56">6 </span><span class="c65">c</span><span class="c57">(</span><span class="c65">v</span><span class="c38">6</span><span class="c57">) </span><span class="c97">v</span><span class="c56">7 </span></p><p class="c4"><span class="c100">t </span></p><p class="c4"><span class="c35">t </span></p><p class="c4"><span class="c35">t </span></p><p class="c4"><span class="c2">(c) PT</span><span class="c0">3 </span></p><p class="c4"><span class="c2">Figure 2: pseudo-trees </span></p><p class="c17"><span class="c2">Candidate Path. Given a pseudo-tree PT</span><span class="c0">i</span><span class="c16">, theDA algorithm main- </span><span class="c2">tains a set C</span><span class="c12">i </span><span class="c2">of candidate paths, one corresponding to each ver- tex u in PT</span><span class="c0">i</span><span class="c16">, denoted c(u), which is the shortest one among all </span><span class="c2">paths from s to t that takes the path from s to u in PT</span><span class="c12">i </span><span class="c2">as pre- fix and contains none of the outgoing edges of u in PT</span><span class="c0">i</span><span class="c16">. For </span><span class="c2">example, in Fig. 2(c), c(v</span><span class="c0">3</span><span class="c16">) is the shortest one among all paths </span><span class="c2">from s to t that take edge (v</span><span class="c12">1</span><span class="c2">,v</span><span class="c12">3</span><span class="c2">) as prefix and contain neither (v</span><span class="c0">3</span><span class="c16">,v</span><span class="c0">6</span><span class="c16">) nor (v</span><span class="c0">3</span><span class="c16">,v</span><span class="c0">7</span><span class="c16">); thus c(v</span><span class="c0">3</span><span class="c16">) </span><span class="c2">{c(v</span><span class="c12">1</span><span class="c2">),c(v</span><span class="c12">8</span><span class="c2">),c(v</span><span class="c12">7</span><span class="c2">),c(v</span><span class="c12">3</span><span class="c2">),c(v</span><span class="c12">6</span><span class="c2">),c(v</span><span class="c16">= (v</span><span class="c12">7</span><span class="c21">0</span><span class="c31">)}. </span></p><p class="c4"><span class="c0">1</span><span class="c16">,v</span><span class="c0">3</span><span class="c16">,v</span><span class="c0">5</span><span class="c16">,v</span><span class="c0">6</span><span class="c16">,t), and C</span><span class="c0">3 </span><span class="c16">= </span></p><p class="c33"><span class="c2">Lemma 3.1: [28]. Given a pseudo-tree PT</span><span class="c12">i </span><span class="c2">and the correspond- ing C</span><span class="c0">i </span><span class="c16">of candidate paths, the (i + 1)-th shortest path from s to t </span><span class="c2">is the path in C</span><span class="c0">i </span><span class="c16">with shortest length. </span><span class="c52">n </span><span class="c2">Following from Lemma 3.1, the pseudocode of processing aKPJ query using DA is shown in Alg. 1, which is self-explanatory. The ingredient of Alg. 1 is to incrementally maintain PT</span><span class="c12">i </span><span class="c2">and C</span><span class="c12">i </span><span class="c2">after choosing each of the top-k paths. </span></p><p class="c4"><span class="c2">Algorithm 1: DA(G</span><span class="c0">Q</span><span class="c16">,Q</span><span class="c12">0 </span><span class="c16">= {s, t, k}) </span><span class="c30">1 </span><span class="c10">Initialize PT</span><span class="c30">2 </span><span class="c10">Compute the </span><span class="c30">3 </span><span class="c10">for each i </span><span class="c0">0 </span><span class="c10">shortest 1 </span><span class="c3">to </span><span class="c10">to </span><span class="c3">contain </span><span class="c10">k do </span></p><p class="c4"><span class="c10">path </span><span class="c3">a </span><span class="c10">c(s) </span><span class="c3">single </span><span class="c10">from </span><span class="c3">vertex </span><span class="c10">s to </span><span class="c3">s; </span></p><p class="c4"><span class="c10">t, and C</span><span class="c0">0 </span><span class="c3">= {c(s)}; </span></p><p class="c4"><span class="c30">4 5 </span><span class="c10">PConstruct </span><span class="c0">i </span><span class="c10">deviation </span><span class="c3">the path </span><span class="c10">vertex; </span></p><p class="c4"><span class="c10">PT</span><span class="c0">i </span><span class="c3">in by Cinserting </span><span class="c0">i 1 </span><span class="c3">with Pthe </span><span class="c0">i </span><span class="c3">into shortest PT</span><span class="c0">i </span><span class="c3">length; </span></p><p class="c4"><span class="c0">1</span><span class="c3">, and let d be the </span></p><p class="c4"><span class="c30">6 </span><span class="c10">Construct candidate paths C</span><span class="c0">i </span><span class="c3">by </span><span class="c10">corresponding </span><span class="c3">removing </span><span class="c10">inserting them into C</span><span class="c0">i </span><span class="c3">P</span><span class="c0">i </span><span class="c3">from </span><span class="c10">to vertices </span><span class="c3">C</span><span class="c0">i 1</span><span class="c3">; </span></p><p class="c4"><span class="c0">1</span><span class="c3">, </span><span class="c10">in </span><span class="c3">computing </span><span class="c10">P</span><span class="c0">i </span><span class="c10">from d </span><span class="c3">the </span></p><p class="c4"><span class="c10">to t, and </span></p><p class="c4"><span class="c30">7 </span><span class="c10">return the k paths P</span><span class="c0">1</span><span class="c3">,...,P</span><span class="c0">k</span><span class="c10">; </span></p><p class="c33"><span class="c2">Example 3.1: Fig. 2 demonstrates a running example for a KPJ query Q = {v</span><span class="c12">1</span><span class="c2">,&ldquo;H&quot;,3} form the graph G on the graph in Fig. 1. We first trans- into G</span><span class="c0">Q</span><span class="c16">, and reduce Q to a KSP query Q</span><span class="c12">0 </span><span class="c16">= </span><span class="c2">{v</span><span class="c12">1</span><span class="c2">, t,3}. The shortest path is P</span><span class="c12">1 </span><span class="c2">= (v</span><span class="c12">1</span><span class="c2">,v</span><span class="c12">8</span><span class="c2">,v</span><span class="c12">7</span><span class="c2">,t) with length 5. After inserting P</span><span class="c0">1 </span><span class="c16">into PT</span><span class="c0">0</span><span class="c16">, the resulting PT</span><span class="c0">1 </span><span class="c16">is shown in </span><span class="c2">Fig. 2(a), where C</span><span class="c0">1 </span><span class="c16">= {c(v</span><span class="c0">1</span><span class="c16">),c(v</span><span class="c0">8</span><span class="c16">),c(v</span><span class="c0">7</span><span class="c16">)}. The 2nd shortest </span><span class="c2">path is computed as P</span><span class="c12">2 </span><span class="c2">= c(v</span><span class="c12">1</span><span class="c2">) = (v</span><span class="c12">1</span><span class="c2">,v</span><span class="c12">3</span><span class="c2">,v</span><span class="c12">6</span><span class="c2">,t) which has the shortest length in C</span><span class="c0">1</span><span class="c16">, and PT</span><span class="c0">2 </span><span class="c16">is shown in Fig. 2(b). Then, can- </span><span class="c2">didate paths for v</span><span class="c12">1</span><span class="c2">,v</span><span class="c12">3</span><span class="c2">,v</span><span class="c12">6 </span><span class="c2">are updated or computed, and C</span><span class="c12">2 </span><span class="c2">= {c(v</span><span class="c0">8</span><span class="c16">),c(v</span><span class="c0">7</span><span class="c16">),c(v</span><span class="c0">1</span><span class="c16">),c(v</span><span class="c0">3</span><span class="c16">),c(v</span><span class="c0">6</span><span class="c16">)}. The 3rd shortest path is P</span><span class="c0">3 </span><span class="c16">= </span><span class="c2">c(v</span><span class="c12">3</span><span class="c2">)=(v</span><span class="c12">1</span><span class="c2">,v</span><span class="c12">3</span><span class="c2">,v</span><span class="c12">7</span><span class="c2">,t) with length 7. </span><span class="c7">n </span></p><p class="c17"><span class="c2">DA-SPT: Optimizations. The most time-consuming part of DA (Alg. 1) is Line 6, which needs to compute O(k&middot;n) candidate paths in total. To efficiently compute a candidate path, several optimiza- tion techniques have been recently proposed [14, 24]. Pascoal [24] observes that, when computing c(u) for u in a pseudo-tree PT, if the path formed by concatenating, 1) the path from s to u in PT, 2) an edge (u, v) in G</span><span class="c0">Q</span><span class="c16">, and 3) the shortest path from v to t in G</span><span class="c0">Q</span><span class="c16">, is </span><span class="c2">simple, then it is c(u). By preprocessing G</span><span class="c0">Q </span><span class="c16">to generate a shortest </span><span class="c2">path tree (SPT) storing shortest paths from all nodes to t, the path described above, if exists, can be found in constant time; otherwise, </span></p><p class="c4"><span class="c41">135 </span></p><p class="c4"><span class="c6">c</span><span class="c60">(</span><span class="c6">v</span><span class="c73">8</span><span class="c15">) </span></p><p class="c4"><span class="c6">c</span><span class="c60">(</span><span class="c6">v</span><span class="c73">7</span><span class="c15">) </span></p><p class="c4"><span class="c6">c</span><span class="c60">(</span><span class="c6">v</span><span class="c73">6</span><span class="c15">) </span></p><p class="c4"><span class="c65">c</span><span class="c57">(</span><span class="c65">v</span><span class="c38">7</span><span class="c84">/</span><span class="c121">) </span></p><p class="c17"><span class="c2">a shortest path algorithm is run to compute c(u). Gao et al. [14, 15] improve Pascoal&rsquo;s approach by iteratively testing the above prop- erty during running Dijkstra&rsquo;s algorithm [11], and obtaining c(u) once a simple path is found; this is known as the state-of-the-art approach, denoted DA-SPT, since a full SPT is built online. </span></p><p class="c17"><span class="c2">Deficiencies of DA and DA-SPT. Both DA and DA-SPT are in- efficient for processing KPJ queries due to the following three rea- sons. 1) Firstly, both need to compute O(k &middot; n) candidate paths which are computed by iteratively extending all prefixes of the ob- tained l-th (l&lt;k) shortest path; this is time-consuming. 2) Sec- ondly, for processing a KPJ query using KSP techniques, the edges added to connect nodes in V</span><span class="c0">T </span><span class="c16">to the virtual destination node depend </span><span class="c2">on queries; this makes the existing index structures [7, 10] for effi- ciently computing shortest paths inapplicable. Thus, the candidate paths are computed by traversing the graph exhaustively, which is very costly. 3) Thirdly, although DA-SPT, compared to DA, can compute candidate paths more efficiently, it is time-consuming to construct the full SPT, which may be the dominating cost espe- cially when the k shortest paths are short. </span></p><p class="c4"><span class="c42">4. A BEST-FIRST APPROACH </span></p><p class="c4"><span class="c2">In this section, to remedy the deficiencies of using the exist- ing KSP techniques to process KPJ queries, we adopt a best-first paradigm which significantly reduces the number of shortest path computations thus enables fast query processing. In the following, we first discuss the paradigm, and then give an implementation of a best-first approach. </span><span class="c42">4.1 Best-First Paradigm </span></p><p class="c17"><span class="c2">Given a KPJ query Q = {s,T,k}, let P</span><span class="c12">s,T</span><span class="c2">(G) denote the set of all paths in G from s to category T (i.e., to any node in V</span><span class="c0">T</span><span class="c16">). </span><span class="c2">When the context is clear, P</span><span class="c12">s,T</span><span class="c2">(G) is abbreviated to P. Then, the query Q is to find the k paths in P with shortest lengths. Note that the size of P can be exponential to n. </span></p><p class="c17"><span class="c2">Search Space and Subspace. The general idea is that we regard P as the entire search space S</span><span class="c12">0</span><span class="c2">. Then, the k paths in P with shortest lengths can be found by recursively dividing a subspace (initially S</span><span class="c12">0</span><span class="c2">) into smaller subspaces and computing the shortest path in each newly obtained subspace. </span></p><p class="c4"><span class="c19">S</span><span class="c8">3 </span></p><p class="c4"><span class="c19">S</span><span class="c8">2,r+1 </span></p><p class="c4"><span class="c72">p</span><span class="c78">3 </span></p><p class="c4"><span class="c88">S</span><span class="c8">2,r </span></p><p class="c4"><span class="c19">S</span><span class="c8">2,1 </span><span class="c72">p</span><span class="c78">2 </span><span class="c32">... </span></p><p class="c4"><span class="c19">S</span><span class="c8">2,2 </span></p><p class="c4"><span class="c32">... </span><span class="c72">p</span><span class="c19">S</span><span class="c78">1 </span></p><p class="c92"><span class="c8">1 </span><span class="c19">S</span><span class="c8">4 </span><span class="c19">S</span><span class="c8">l+1 </span></p><p class="c4"><span class="c2">Figure 3: Overview of search space division </span></p><p class="c17"><span class="c2">Before diving into the details, we first explain the main idea which is illustrated in Fig. 3. We conceptualize each path in P as a point, whose distance to the center (i.e., the origin) indicates the length of the path. Thus, the k paths with shortest lengths cor- respond to the k points closest to the center which can be computed as follows. First, we compute the closest point P</span><span class="c12">1 </span><span class="c2">= (v</span><span class="c12">1</span><span class="c2">,...,v</span><span class="c0">l</span><span class="c16">) </span><span class="c2">in the entire search space S</span><span class="c0">0 </span><span class="c16">= P. Second, we divide S</span><span class="c0">0 </span><span class="c16">into l +1 </span><span class="c2">subspaces, S</span><span class="c0">1</span><span class="c16">,S</span><span class="c0">2</span><span class="c16">,...,S</span><span class="c0">l</span><span class="c16">,S</span><span class="c0">l+1</span><span class="c16">. Here, S</span><span class="c0">1 </span><span class="c16">consists of only P</span><span class="c0">1 </span><span class="c16">and </span><span class="c2">is excluded from further considerations. Each of the remaining sub- spaces, S</span><span class="c0">2</span><span class="c16">,...,S</span><span class="c0">l+1</span><span class="c16">, represents the set of paths of P that share ex- </span></p><p class="c4"><span class="c2">actly the prefix of P</span><span class="c0">1 </span><span class="c16">from v</span><span class="c0">1 </span><span class="c16">to v</span><span class="c0">i 1</span><span class="c16">; consequently, S</span><span class="c0">i </span><span class="c16">= S</span><span class="c0">j</span><span class="c16">,8i = </span><span class="c2">j, and </span><span class="c31">S</span><span class="c12">l+1 </span></p><p class="c4"><span class="c12">i=1 </span><span class="c31">S</span><span class="c12">i </span><span class="c2">= S</span><span class="c0">0</span><span class="c16">. Third, we compute the closest point in each </span><span class="c2">of the l subspace, S</span><span class="c12">2</span><span class="c2">,...,S</span><span class="c0">l+1</span><span class="c16">, and the one that is closest to the </span><span class="c2">center among the l closest points represents the 2nd shortest path. Let it be P</span><span class="c0">2 </span><span class="c16">= (v</span><span class="c12">0</span><span class="c0">1</span><span class="c2">,...,v</span><span class="c21">0</span><span class="c12">r</span><span class="c31">), and assume it is in S</span><span class="c12">2</span><span class="c2">. Fourth, we fur- ther divide S</span><span class="c12">2 </span><span class="c2">into r + 1 subspaces, S</span><span class="c12">2,1</span><span class="c2">,S</span><span class="c12">2,2</span><span class="c2">,...,S</span><span class="c12">2,r</span><span class="c2">,S</span><span class="c12">2,r+1</span><span class="c2">, and compute the closest point in each of them, where S</span><span class="c0">2,1 </span><span class="c16">consists </span><span class="c2">of only P</span><span class="c12">2 </span><span class="c2">and is excluded from further considerations. Thus, the point that is closest to the center among closest points in all sub- spaces S</span><span class="c0">3</span><span class="c16">,&middot;&middot;&middot; ,S</span><span class="c0">l+1</span><span class="c16">,S</span><span class="c0">2,2</span><span class="c16">,...,S</span><span class="c0">2,r+1 </span><span class="c16">represents the 3rd shortest </span><span class="c2">path. We can repeat this process until k shortest paths are com- puted. Subspace Division. We formally define a subspace below. Definition 4.1: A subspace S is represented by a tuple hP</span><span class="c12">s,u</span><span class="c2">,X</span><span class="c12">u</span><span class="c2">i, where P</span><span class="c0">s,u </span><span class="c16">is a path from s to u and X</span><span class="c0">u </span><span class="c16">is a subset of the outgoing </span><span class="c2">edges of u. It consists of all paths in P that take P</span><span class="c0">s,u </span><span class="c16">as prefix and </span><span class="c2">exclude all edges of X</span><span class="c12">u</span><span class="c2">. </span><span class="c7">n </span><span class="c2">The entire search space S</span><span class="c0">0</span><span class="c16">(= P) is represented by hP</span><span class="c0">s,s </span><span class="c16">= </span><span class="c2">(s),X</span><span class="c12">s </span><span class="c2">= ;i. Assume the shortest path in subspace hP</span><span class="c12">s,u</span><span class="c2">,X</span><span class="c12">u</span><span class="c2">i is P, then after choosing P as one of the k shortest paths, the subspace is divided into l + 1 subspaces, where l is the number of nodes in the subpath of P from u to the destination node. The l+1 subspaces consist of a subspace containing only P, a subspace corresponding to node u (i.e., subspace hP</span><span class="c12">s,u</span><span class="c2">,X</span><span class="c12">u </span><span class="c2">[ {(u, w)}i), and one subspace corresponding to each node v in the subpath of P from u (exclusive) to the destination node (i.e., subspace hP</span><span class="c0">s,v</span><span class="c16">, {(v, w</span><span class="c12">0</span><span class="c16">)}i), where P</span><span class="c0">s,v </span><span class="c16">is the prefix of P to v, and (u, w) </span><span class="c2">and (v, w</span><span class="c21">0</span><span class="c2">) are edges in P. It is important to note that the l + 1 subspaces are disjoint, and their union is the original subspace hP</span><span class="c0">s,u</span><span class="c16">,X</span><span class="c0">u</span><span class="c16">i from which they are divided. </span><span class="c2">Example 4.1: Consider a KPJ query Q = {v</span><span class="c0">1</span><span class="c16">,&ldquo;H&rdquo;,2} on the </span><span class="c2">graph in Fig. 1. Initially, S</span><span class="c0">0 </span><span class="c16">= h(v</span><span class="c0">1</span><span class="c16">),;i in which the shortest </span><span class="c2">path is P</span><span class="c12">1 </span><span class="c2">= (v</span><span class="c12">1</span><span class="c2">,v</span><span class="c12">8</span><span class="c2">,v</span><span class="c12">7</span><span class="c2">). Then, S</span><span class="c12">0 </span><span class="c2">is divided into four subspaces, S</span><span class="c0">1 </span><span class="c16">= {P}, S</span><span class="c0">2 </span><span class="c16">= h(v</span><span class="c0">1</span><span class="c16">),{(v</span><span class="c0">1</span><span class="c16">,v</span><span class="c0">8</span><span class="c16">)}i, S</span><span class="c0">3 </span><span class="c16">= h(v</span><span class="c0">1</span><span class="c16">,v</span><span class="c0">8</span><span class="c16">),{(v</span><span class="c0">8</span><span class="c16">,v</span><span class="c0">7</span><span class="c16">)}i, </span><span class="c2">and S</span><span class="c12">4 </span><span class="c2">= h(v</span><span class="c12">1</span><span class="c2">,v</span><span class="c12">8</span><span class="c2">,v</span><span class="c12">7</span><span class="c2">),;i, where S</span><span class="c12">1 </span><span class="c2">is the subspace containing only P</span><span class="c0">1</span><span class="c16">. The 2nd shortest path is the one with shortest lengths </span><span class="c2">among shortest paths in S</span><span class="c0">2</span><span class="c16">,S</span><span class="c0">3</span><span class="c16">, S</span><span class="c0">4</span><span class="c16">. </span><span class="c52">n </span></p><p class="c4"><span class="c2">Paradigm. It is easy to verify that there is a one-to-one correspon- dence between candidate paths defined in Section 3 and subspaces defined above. In the deviation paradigm, subspaces are implicitly maintained by storing candidate paths based on the fact that each candidate path is the shortest path in a subspace. Considering that shortest paths are expensive to compute, we remedy the deficiency of deviation paradigm by computing lower bounds of subspaces and pruning subspaces based on their lower bounds. Definition 4.2: For a subspace S = hP</span><span class="c12">s,u</span><span class="c2">,X</span><span class="c12">u</span><span class="c2">i, we define the lower bound of a subspace, denoted lb(S) (or lb(P</span><span class="c0">s,u</span><span class="c16">,X</span><span class="c0">u</span><span class="c16">)), as </span><span class="c2">the lower bound of lengths of all paths in S, and denote the shortest path in a subspace by sp(S) (or sp(P</span><span class="c0">s,u</span><span class="c16">,X</span><span class="c0">u</span><span class="c16">)). </span><span class="c52">n </span><span class="c2">Based on lower bounds of subspaces, the best-first paradigm is shown in Alg. 2. Instead of directly computing the shortest path for each newly obtained subspace, we compute its lower bound first. All obtained subspaces and their lower bounds are main- tained in a minimum priority queue Q. Each entry of Q is a triple hS,lb(S),Pi, where S and lb(S) are a subspace and its lower bound, respectively, and P is either ; or the shortest path in S. Subspaces in Q are ranked by their lower bounds. Initially, Q con- tains a single entry representing the entire search space S</span><span class="c12">0 </span><span class="c2">(Line 1). Then, we iteratively remove the subspace with smallest lower bound from Q, denoted hS,lb(S),Pi (Line 4): if P = ;, then P is the </span></p><p class="c4"><span class="c41">136 </span></p><p class="c4"><span class="c2">Algorithm 2: BestFirst(G, Q = {s,T,k}) </span></p><p class="c4"><span class="c30">1 </span><span class="c10">Initialize a minimum priority queue Q to contain a single entry </span></p><p class="c4"><span class="c10">hS</span><span class="c12">0 </span><span class="c10">= h(s), ;i, lb(S</span><span class="c12">0</span><span class="c10">), ;i; </span><span class="c30">2 </span><span class="c10">i 1; </span><span class="c30">3 </span><span class="c10">while i &#63743; k do </span><span class="c30">4 </span><span class="c10">hS = hP</span><span class="c12">s,u</span><span class="c10">,X</span><span class="c12">u</span><span class="c10">i, lb(S),P i remove the top entry from Q; </span><span class="c30">5 </span><span class="c10">if P = ; then </span><span class="c30">6 </span><span class="c10">P</span><span class="c0">i </span><span class="c10">P; i i + 1; </span><span class="c30">7 </span><span class="c10">for each node v in the subpath of P from u to the </span></p><p class="c4"><span class="c10">destination node do </span><span class="c30">8 </span><span class="c10">Create a subspace S</span><span class="c21">0 </span><span class="c10">= hP</span><span class="c0">s,v</span><span class="c3">,X</span><span class="c0">v</span><span class="c3">i; </span><span class="c30">9 </span><span class="c10">lb(S</span><span class="c21">0</span><span class="c10">) max{CompLB(P</span><span class="c12">s,v</span><span class="c10">,X</span><span class="c12">v</span><span class="c10">),!(P)}; </span><span class="c30">10 </span><span class="c10">Put hS</span><span class="c21">0</span><span class="c10">, lb(S</span><span class="c21">0</span><span class="c10">),;i into Q; </span></p><p class="c4"><span class="c30">11 </span><span class="c10">else </span><span class="c30">12 </span><span class="c10">sp(S) CompSP(P</span><span class="c12">s,u</span><span class="c10">,X</span><span class="c12">u</span><span class="c10">); </span><span class="c30">13 </span><span class="c10">if sp(S) = ; then Put hS, !(sp(S)),sp(S)i into Q; </span></p><p class="c4"><span class="c30">14 </span><span class="c10">return the k paths P</span><span class="c0">1</span><span class="c3">,...,P</span><span class="c0">k</span><span class="c10">; </span></p><p class="c4"><span class="c2">next shortest path to be output (Line 6), and we divide S by P and put those newly obtained subspaces into Q (Lines 7-10); otherwise, we compute the shortest path in S and put S into Q again with the computed shortest path (Lines 12-13). We will present an imple- mentation of computing lower bound of a subspace and shortest path in a subspace in the next subsection. Lemma 4.1: The set of shortest paths computed in Alg. 2 is a sub- set of that computed in Alg. 1; thus, the number of shortest path computations in Alg. 2 is not larger than that in Alg. 1. Assume that computing lower bound takes less time than computing short- est path for a subspace, then the time complexity of Alg. 2 is not larger than that of Alg. 1. </span><span class="c7">n </span><span class="c2">Proof Sketch: We prove the first part of Lemma 4.1 by proving that there is a one-to-one correspondence between subspaces in- serted into Q in Alg. 2 and candidate paths computed in Alg. 1. This can be proved by induction. For k = 1, this is true, since there is only one subspace and one candidate path in Alg. 2 and Alg. 2, respectively. Now, we assume that this holds for general k 1, then we prove that it also holds for (k + 1). Since the k-th shortest path P</span><span class="c0">k </span><span class="c16">corresponds to subspace S in Alg. 2, to obtain the (k + 1)- </span><span class="c2">th shortest path, we generate O(n) new candidate paths from P</span><span class="c0">k </span><span class="c2">in Alg. 1 and O(n) new subspaces from S in Alg. 2; moreover, there is a one-to-one correspondence between these newly gener- ated subspaces and newly generated candidate paths. Thus, there is a one-to-one correspondence between subspaces inserted into Q in Alg. 2 and candidate paths computed in Alg. 1. Considering that we compute shortest paths only for a subset of the subspaces inserted into Q, the first part of the lemma holds. </span></p><p class="c17"><span class="c2">Moreover, if we set all lower bounds computed at Line 9 of Alg. 2 to be 0, then the number of shortest path computations in Alg. 2 is the same as that in Alg. 1. </span></p><p class="c33"><span class="c2">Second, in Alg. 2, any subspace is inserted into Q at most twice: once with computed lower bound (i.e., P = ;), and once with computed shortest path. Thus, given that computing lower bound takes less time than computing shortest path for a subspace, the time complexity of Alg. 2 is not larger than that of Alg. 1. </span><span class="c7">n </span><span class="c2">Following the proof of Lemma 4.1, we can also see that the max- imum size of Q in Alg. 2 is O(k&middot;n); moreover, given any algorithm computing a lower bound of a subspace, Alg. 2 correctly processes a KPJ query. Let P</span><span class="c0">k </span><span class="c16">be the k-th shortest path for a KPJ query. Ob- </span><span class="c2">viously, Alg. 2 does not compute shortest paths in subspaces whose lower bounds are larger than !(P</span><span class="c12">k</span><span class="c2">). Note that, in contrast, Alg. 1 needs to compute shortest paths in all subspaces in Q. Conceptu- </span></p><p class="c4"><span class="c19">S</span><span class="c8">3 </span></p><p class="c4"><span class="c88">S</span><span class="c8">2,r </span></p><p class="c4"><span class="c19">S</span><span class="c8">2,1 </span><span class="c19">S</span><span class="c8">4 </span><span class="c19">S</span><span class="c8">l+1 </span></p><p class="c4"><span class="c19">S</span><span class="c8">3 </span></p><p class="c4"><span class="c19">S</span><span class="c8">2,r+1 </span></p><p class="c4"><span class="c19">S</span><span class="c8">1 </span></p><p class="c92"><span class="c88">S</span><span class="c8">2,r </span><span class="c19">S</span><span class="c8">2,1 </span><span class="c19">S</span><span class="c8">4 </span><span class="c19">S</span><span class="c8">2,2</span><span class="c19">S</span><span class="c8">l+1 </span></p><p class="c4"><span class="c16">(a) Best First </span></p><p class="c4"><span class="c19">S</span><span class="c8">2,r+1 </span></p><p class="c4"><span class="c19">S</span><span class="c8">1 </span></p><p class="c4"><span class="c19">S</span><span class="c8">2,2 </span></p><p class="c4"><span class="c2">(b) Iteratively Bounding </span></p><p class="c4"><span class="c2">Figure 4: Instances of shortest path computations </span></p><p class="c17"><span class="c2">ally, Fig. 4(a) shows by shadow the subspaces in which the shortest paths are computed: Alg. 2 computes only 5 shortest paths instead of l + r + 2 which is done by Alg. 1. </span></p><p class="c4"><span class="c42">4.2 An Implementation of </span><span class="c2">BestFirst </span></p><p class="c17"><span class="c2">In the following, we present efficient techniques for computing a lower bound of a subspace (CompLB at Line 9 of Alg. 2) and for computing the shortest path in a subspace (CompSP at Line 12 of Alg. 2), denote the approach as BestFirst. </span></p><p class="c4"><span class="c2">Algorithm 3: CompLB(P</span><span class="c12">s,u</span><span class="c2">,X</span><span class="c12">u</span><span class="c2">) </span><span class="c30">1 </span><span class="c10">lb +1; </span><span class="c30">2 </span><span class="c10">for each outgoing edge (u, v) of u do </span><span class="c30">3 </span><span class="c10">if v /2 P</span><span class="c12">s,u </span><span class="c10">and (u, v) /2 X</span><span class="c12">u </span><span class="c10">then </span><span class="c30">4 5 </span><span class="c10">Compute lb min{lb,!(P</span><span class="c12">s,u</span><span class="c10">) lb(v, V</span><span class="c0">T </span><span class="c10">); </span></p><p class="c4"><span class="c10">+ !(u, v) + lb(v, V</span><span class="c0">T </span><span class="c3">)}; </span></p><p class="c4"><span class="c30">6 </span><span class="c10">return lb; </span></p><p class="c92"><span class="c2">Computing Lower Bound of a Subspace. Given a subspace S = hP</span><span class="c0">s,u</span><span class="c16">,X</span><span class="c0">u</span><span class="c16">i, the set of paths in it </span><span class="c2">from s to any node in V</span><span class="c12">T </span><span class="c2">in a subgraph </span><span class="c16">corresponds to the set of paths </span><span class="c2">G</span><span class="c21">0 </span><span class="c2">of G obtained as fol- lows. We first remove all edges of X</span><span class="c0">u </span><span class="c16">from G, and then for each </span><span class="c2">node v(= u) in P</span><span class="c12">s,u</span><span class="c2">, we remove from G all outgoing edges of v except the one that is in P</span><span class="c0">s,u</span><span class="c16">. </span><span class="c2">shortest distance from u to v </span><span class="c16">Thus, for any two nodes u and v, the </span><span class="c2">in G</span><span class="c21">0 </span><span class="c2">is lower bounded by that in G. Consequently, a naive lower bound of S is !(P</span><span class="c12">s,u</span><span class="c2">) + lb(u, V</span><span class="c12">T</span><span class="c2">), where lb(u, V</span><span class="c0">T</span><span class="c16">) is the lower bound of shortest distance from u </span><span class="c2">to any node in V</span><span class="c12">T </span><span class="c2">, whose computation shall be discussed shortly. However, this is loose considering that many outgoing edges of u (i.e., X</span><span class="c0">u</span><span class="c16">) are removed from G. Therefore, to estimate the lower </span><span class="c2">bound G</span><span class="c21">0</span><span class="c2">) of S (i.e., the shortest distance from s to any node in V</span><span class="c12">T </span><span class="c2">in more accurately, we consider all valid outgoing edges (u, v) of u (i.e., v /2 P</span><span class="c12">s,u </span><span class="c2">and (u, v) /2 X</span><span class="c12">u</span><span class="c2">), and choose the min- imum estimation. The pseudocode is shown in Alg. 3 which is self-explanatory, and its correctness immediately follows from the above discussions. Example 4.2: Continuing Example 4.1. After dividing S</span><span class="c12">0 </span><span class="c2">into S</span><span class="c0">1</span><span class="c16">,&middot;&middot;&middot; ,S</span><span class="c0">4</span><span class="c16">, lower bounds of S</span><span class="c0">2</span><span class="c16">,S</span><span class="c0">3</span><span class="c16">,S</span><span class="c0">4 </span><span class="c16">are computed. Here, we </span><span class="c2">illustrate how to compute lb(S</span><span class="c0">2</span><span class="c16">) = lb((v</span><span class="c0">1</span><span class="c16">), {(v</span><span class="c0">1</span><span class="c16">,v</span><span class="c0">8</span><span class="c16">)}). v</span><span class="c0">1 </span><span class="c16">has </span><span class="c2">three valid outgoing edges, (v</span><span class="c12">1</span><span class="c2">,v</span><span class="c12">2</span><span class="c2">), (v</span><span class="c12">1</span><span class="c2">,v</span><span class="c12">3</span><span class="c2">), and (v</span><span class="c12">1</span><span class="c2">,v</span><span class="c12">11</span><span class="c2">), that can be considered for lower bound estimation. Thus, lb(S</span><span class="c0">2</span><span class="c16">) is </span><span class="c2">computed as min{!(v</span><span class="c12">1</span><span class="c2">,v</span><span class="c12">2</span><span class="c2">)+lb(v</span><span class="c12">2</span><span class="c2">,V</span><span class="c12">T</span><span class="c2">),!(v</span><span class="c12">1</span><span class="c2">,v</span><span class="c12">3</span><span class="c2">)+lb(v</span><span class="c12">3</span><span class="c2">,V</span><span class="c12">T</span><span class="c2">), !(v</span><span class="c0">1</span><span class="c16">,v</span><span class="c0">11</span><span class="c16">) + lb(v</span><span class="c0">11</span><span class="c16">,V</span><span class="c0">T </span><span class="c16">)}. </span><span class="c52">n </span></p><p class="c17"><span class="c2">Computing lb(u, V</span><span class="c12">T </span><span class="c2">). We propose a landmark-based approach [16] to estimating lb(u, V</span><span class="c0">T </span><span class="c16">) in the following. Note that, the computa- </span><span class="c2">tion of lb(u, V</span><span class="c12">T</span><span class="c2">) has not been studied in the literature. </span></p><p class="c4"><span class="c2">A landmark is a subset of nodes, L &#10003; V . With L, the lower </span></p><p class="c4"><span class="c41">137 </span></p><p class="c4"><span class="c32">... </span></p><p class="c4"><span class="c32">... </span></p><p class="c4"><span class="c32">... </span></p><p class="c4"><span class="c32">... </span></p><p class="c4"><span class="c2">Therefore, bound lb(u, v) lb(u, = </span><span class="c31">.</span><span class="c2">v) of shortest distance max</span><span class="c12">w2L</span><span class="c2">{ (w, v) from u to v is estimated as, </span></p><p class="c4"><span class="c2">(w, u)}, </span><span class="c21">1 </span><span class="c2">where (w, v) and </span></p><p class="c33"><span class="c2">BestFirst will run fast if we can prune more subspaces based on their lower bounds (i.e., by computing tighter/larger lower (w, u) are the shortest distance from w to v and to u, respec- </span></p><p class="c4"><span class="c2">bounds for subspaces), considering that computing shortest path is tively, and are precomputed. This estimation is based on the fact </span></p><p class="c4"><span class="c2">time-consuming. However, in general, computing a tighter lower that (w, u) + (u, v) (w, v). Then, lb(u, V</span><span class="c0">T</span><span class="c16">) can be esti- </span></p><p class="c4"><span class="c2">bound takes longer time, and in the extreme case computing the mated as, </span></p><p class="c4"><span class="c2">shortest path in a subspace provides the tightest lower bound. In lb(u, V</span><span class="c0">T</span><span class="c16">) = </span><span class="c2">.= </span><span class="c16">min</span><span class="c2">min</span><span class="c12">v2V</span><span class="c0">v2V</span><span class="c23">T T </span><span class="c2">{lb(u, max</span><span class="c12">w2L</span><span class="c2">{ v)} </span></p><p class="c4"><span class="c2">(w, v) (w, u)} </span><span class="c31">(1) </span></p><p class="c4"><span class="c2">Alg. 3, we present a light-weight lower bound estimation by con- sidering only the immediate neighbors of u. Intuitively, we can compute a tighter lower bound by exploring multi-hop neighbors However, the computation time is O(|L|&middot;|V</span><span class="c12">T</span><span class="c2">|) which is too costly especially when V</span><span class="c0">T </span><span class="c16">is large. Therefore, motivated by the trans- </span><span class="c2">formed graph G</span><span class="c0">Q </span><span class="c16">in Section 3, we propose a new lower bound as </span><span class="c2">follows, </span></p><p class="c4"><span class="c2">lb(u, V</span><span class="c12">T</span><span class="c2">) = </span><span class="c31">.</span><span class="c2">= max</span><span class="c12">w2L </span><span class="c2">max</span><span class="c0">w2L</span><span class="c16">{min{ </span><span class="c2">min</span><span class="c12">v2V</span><span class="c16">(w, </span><span class="c23">T </span><span class="c2">{ </span><span class="c16">v) </span><span class="c2">(w, </span><span class="c16">| v </span><span class="c2">v) </span><span class="c16">2 V</span><span class="c0">T</span><span class="c16">} </span><span class="c2">(w, u)} </span></p><p class="c17"><span class="c16">(w, u)}(2) </span><span class="c2">The intuition is that, min{ (w, v) | v 2 V</span><span class="c0">T</span><span class="c16">} is the shortest dis- </span><span class="c2">tance from w to t in G</span><span class="c0">Q </span><span class="c16">(i.e., (w, t)); thus, Eq. (2) estimates </span><span class="c2">lb(u, t). Consequently, lb(u, V</span><span class="c12">T</span><span class="c2">) can be computed in O(|L|) time by precomputing (w, t) for all w 2 L prior to any lower bound estimations. In what follows, we use Eq. (2) to compute lb(u, V</span><span class="c12">T </span><span class="c2">). </span></p><p class="c4"><span class="c2">of u (e.g., neighbors of neighbors). </span></p><p class="c33"><span class="c2">We propose to guess and tighten lower bounds of subspaces in a controlled manner by a threshold &#8999;, which is achieved by a proce- dure TestLB. In a nutshell, given a subspace S and a threshold &#8999;, TestLB tests whether the shortest path in S has a length larger than &#8999;: if it is, then the lower bound is set as &#8999;; otherwise, the short- est path sp(S) is obtained and returned. Details of TestLB will be discussed shortly. Ideally, we can set &#8999; as !(P</span><span class="c0">k</span><span class="c16">), then all sub- </span><span class="c2">spaces whose lower bounds are larger than !(P</span><span class="c0">k</span><span class="c16">) are pruned with </span><span class="c2">the least amount of effort; however, P</span><span class="c12">k </span><span class="c2">is unknown. Considering that TestLB takes longer time for a larger &#8999;, we iteratively enlarge &#8999;, and the k shortest paths of a KPJ query will be found once &#8999; becomes no smaller than !(P</span><span class="c0">k</span><span class="c16">). </span><span class="c2">Remarks &amp; Time Complexity. Note that, the landmark index L is constructed offline in O(|L|(m + nlog n)) time where O(m + </span></p><p class="c4"><span class="c2">Algorithm 4: IterBound(G, Q = {s,T,k}) nlog n) is the time complexity of a shortest path algorithm, while its space complexity is O(|L| &middot; n). At the initialization phase of </span></p><p class="c4"><span class="c30">1 2 </span><span class="c10">Compute Initialize a the minimum shortest priority path P </span><span class="c21">0 </span><span class="c10">queue from s Q to to any contain node a in single V</span><span class="c0">T </span><span class="c10">in G; </span></p><p class="c4"><span class="c10">entry </span><span class="c2">query processing, we compute (w, t) which is query dependent. The time complexity for computing (w, t) for all w 2 L is O(|L|&middot; |V</span><span class="c12">T</span><span class="c2">|); note that this is only computed once for each query. </span></p><p class="c17"><span class="c2">Therefore, the time complexity of lower bound computation (i.e., Alg. 3) is O(d(u)|L|) where d(u) is the degree of u in G, since we traverse at most d(u) edges at Line 2 while computing each lb(v, V</span><span class="c0">T</span><span class="c16">) takes O(|L|) time. </span></p><p class="c4"><span class="c10">hS</span><span class="c0">0 </span><span class="c3">= h(s),;i,!(P </span><span class="c30">3 </span><span class="c10">i 1; &#8999; </span><span class="c12">0</span><span class="c3">),P </span><span class="c12">0</span><span class="c3">i; </span></p><p class="c4"><span class="c10">!(P </span><span class="c21">0</span><span class="c10">); </span><span class="c30">4 </span><span class="c10">while i &#63743; k do </span><span class="c30">5 </span><span class="c10">hS = hP</span><span class="c0">s,u</span><span class="c3">,X</span><span class="c0">u</span><span class="c3">i, lb(S),P i remove the top entry from Q; </span><span class="c30">6 </span><span class="c10">if P = ; then </span><span class="c30">7 </span><span class="c10">Same as Lines 6-10 of Alg. 3; and divide S into subspaces /</span><span class="c3">* </span><span class="c10">P</span><span class="c0">i </span><span class="c3">P, i *</span><span class="c10">/; </span></p><p class="c4"><span class="c3">i + 1, </span></p><p class="c4"><span class="c30">8 </span><span class="c10">else </span><span class="c2">Computing Shortest Path in a Subspace. We use A* search [16] to compute sp(P</span><span class="c12">s,u</span><span class="c2">,X</span><span class="c12">u</span><span class="c2">), denoted CompSP. In A* search, we consider only the valid edges (same as Line 3 of Alg. 3), and use </span></p><p class="c4"><span class="c30">9 10 11 12 </span><span class="c10">&#8999; &crarr; &middot; max{lb(S),Q.top().key}; P TestLB(P</span><span class="c12">s,u</span><span class="c10">,X</span><span class="c12">u</span><span class="c10">, &#8999;); </span></p><p class="c4"><span class="c10">/* Enlarge &#8999; */; </span></p><p class="c33"><span class="c10">if P = ; then Put hS, !(P ),Pi into Q; else Put hS,&#8999;, ;i into Q; </span><span class="c2">Eq. (2) to estimate the shortest distance to destination. We omit the pseudocode. </span></p><p class="c4"><span class="c30">13 </span><span class="c10">return the k paths P</span><span class="c0">1</span><span class="c3">,...,P</span><span class="c0">k</span><span class="c10">; </span></p><p class="c17"><span class="c2">Example 4.3: Continuing Example 4.2, after dividing S</span><span class="c0">0</span><span class="c16">, Q con- </span><span class="c2">tains three subspaces, S</span><span class="c0">2</span><span class="c16">, S</span><span class="c0">3</span><span class="c16">, S</span><span class="c0">4</span><span class="c16">, together with their lower bounds. </span><span class="c2">Assume the lower bounds are lb(S</span><span class="c0">2</span><span class="c16">) = 6, lb(S</span><span class="c0">3</span><span class="c16">) = 11, and </span><span class="c2">lb(S</span><span class="c12">4</span><span class="c2">) = 12. S</span><span class="c12">2 </span><span class="c2">has the smallest lower bound, and is removed from Q. Then, sp(S</span><span class="c0">2</span><span class="c16">) is computed, which is the 2nd shortest path </span><span class="c2">P</span><span class="c12">2</span><span class="c2">, since its length is smaller than lower bounds of subspaces in Q. Here, we compute the 2nd shortest path without computing shortest paths in subspaces S</span><span class="c0">3 </span><span class="c16">and S</span><span class="c0">4</span><span class="c16">. </span><span class="c52">n </span></p><p class="c33"><span class="c2">The algorithm IterBound is given in Alg. 4, which is similar to Alg. 2. We first compute the shortest path P </span><span class="c21">0 </span><span class="c2">in G (Line 1), put subspace initialize &#8999; as S</span><span class="c12">0 </span><span class="c2">!(P = </span><span class="c21">0</span><span class="c2">) h(s),;i (Line with path P </span><span class="c21">0 </span><span class="c2">into 3). Then, we iteratively Q (Line 2), remove and the subspace S with smallest lower bound, together with path P, from Q (Line 5). If P is not empty, then it is the next shortest path P</span><span class="c0">i</span><span class="c16">, </span><span class="c2">and we perform the same subspace division as Lines 6-10 of Alg. 2. Otherwise, we enlarge &#8999; (Line 9), test whether the shortest path of S has a distance larger than &#8999; (Line 10), and put S back into Q </span><span class="c42">5. AN ITERATIVELY BOUNDING APPROACH </span></p><p class="c17"><span class="c2">In this section, following the best-first paradigm in Section 4, we propose a new iteratively bounding approach to iteratively &ldquo;guess- ing&rdquo; and tightening lower bounds for subspaces in Section 5.1. Moreover, we propose two online-built indexes, in Section 5.2 and Section 5.3, respectively, based on which we can reduce the explo- ration area of a graph dramatically in tightening lower bounds. </span></p><p class="c4"><span class="c2">together with either the computed shortest path P or a larger lower bound &#8999; depending on what TestLB returns (Lines 11-12). </span></p><p class="c33"><span class="c2">Note that &#8999; controls the computation of a tighter lower bound which we want to make larger but a larger &#8999; will make TestLB slow. In our approach, we use a parameter &crarr; to control the speed of increasing &#8999; iteratively. Here, &crarr; can be any real number larger than 1, and we use &crarr; = 1.1 as default. At Line 9, we enlarge &#8999; as &crarr;&middot;max{lb(S),Q.top().key}, where Q.top().key is the key value </span><span class="c42">5.1 Iteratively Bounding </span></p><p class="c4"><span class="c2">In BestFirst, we prune subspaces whose lower bounds are larger than !(P</span><span class="c0">k</span><span class="c16">), where P</span><span class="c0">k </span><span class="c16">is the k-th shortest path for a KPJ query. </span></p><p class="c33"><span class="c2">(i.e., lower bound) in the top entry of Q and is defined to be +1 if Q = ;. The intuition is that, !(P</span><span class="c0">k</span><span class="c16">) should be not much larger than </span><span class="c2">!(P</span><span class="c12">1</span><span class="c2">), the initial &#8999; (Line 3). Note that lb(S) is the previous &#8999; we have tested for S; thus, the lower bound &#8999; we tested for a subspace </span><span class="c12">1</span><span class="c16">Note that this triangle inequality holds for the shortest distances based on any distance metrics not only Euclidean distance. Thus, our techniques work for general graphs. </span></p><p class="c17"><span class="c2">increases by a factor of at least &crarr;. Therefore, we iteratively enlarge &#8999; from !(P</span><span class="c0">1</span><span class="c16">) to approach !(P</span><span class="c0">k</span><span class="c16">), and obtain the k shortest paths </span><span class="c2">for a KPJ query once &#8999; becomes no smaller than !(P</span><span class="c0">k</span><span class="c16">). </span></p><p class="c4"><span class="c41">138 </span></p><p class="c135"><span class="c2">Theorem 5.1: Given TestLB, IterBound correctly computes k shortest paths for a KPJ query. </span><span class="c7">n </span><span class="c2">Proof Sketch: IterBound follows the best-first paradigm of Alg. 2, except that we iteratively compute lower bounds of subspaces. More- over, it is easy to prove that the lower bound &#8999; computed for the same subspace S at Line 9 is strictly increasing (assuming that &crarr; &gt; 1). Therefore, let P</span><span class="c0">i </span><span class="c16">be the correct i-th shortest path, we </span><span class="c2">can prove that &#8999; will be no less than !(P</span><span class="c0">i</span><span class="c16">) when the algorithm ter- </span><span class="c2">minates, and once &#8999; becomes no less than !(P</span><span class="c12">i</span><span class="c2">), the path P</span><span class="c12">i </span><span class="c2">will be computed and inserted into Q, thus will be output. </span><span class="c7">n </span><span class="c2">IterBound acts the same as BestFirst if we set &#8999; as +1. Nev- ertheless, by iteratively enlarging &#8999; with an initial value !(P</span><span class="c0">1</span><span class="c16">), </span><span class="c2">IterBound runs much faster than BestFirst by pruning more sub- spaces. Conceptually, Fig. 4(b) shows the subspaces in which the shortest paths are computed by IterBound. Compared to Fig. 4(a), S</span><span class="c12">4 </span><span class="c2">and S</span><span class="c12">2,r+1 </span><span class="c2">are pruned based on their tighter lower bounds that are computed by TestLB. The shadow areas of S</span><span class="c0">4 </span><span class="c16">and S</span><span class="c0">2,r+1 </span><span class="c16">in </span><span class="c2">Fig. 4(b) indicate the exploration areas of TestLB in testing lower bounds. </span></p><p class="c59"><span class="c2">Testing Lower Bound. TestLB tests whether the shortest path in a subspace has length larger than a given threshold &#8999;. This is achieved by considering multi-hop neighbors of u, denoted V</span><span class="c21">0</span><span class="c2">. Given &#8999;, V</span><span class="c21">0 </span><span class="c2">are those nodes v with </span><span class="c0">S</span><span class="c16">(s, v)+lb(v, V</span><span class="c0">T</span><span class="c16">) &#63743; &#8999;, where </span><span class="c12">S</span><span class="c2">(s, v) is the shortest distance from s to v constrained in S (i.e., G</span><span class="c21">0 </span><span class="c2">defined in Section 4.2). After obtaining V</span><span class="c21">0</span><span class="c2">, if V</span><span class="c21">0 </span><span class="c2">\V</span><span class="c12">T </span><span class="c2">= ; then !(sp(S)) &gt; &#8999;, otherwise, sp(S) is obtained by backtracking from V</span><span class="c21">0 </span><span class="c2">\ V</span><span class="c12">T</span><span class="c2">. </span></p><p class="c82"><span class="c2">Algorithm 5: TestLB(P</span><span class="c0">s,u</span><span class="c16">,X</span><span class="c0">u</span><span class="c16">, &#8999;) </span><span class="c30">1 </span><span class="c10">Initialize a minimum-priority queue Q</span><span class="c0">V </span><span class="c10">to contain hu, 0i; </span><span class="c30">2 </span><span class="c10">d</span><span class="c12">s</span><span class="c10">(u) !(P</span><span class="c12">s,u</span><span class="c10">), and d</span><span class="c12">s</span><span class="c10">(v) +1 for all other nodes; </span><span class="c30">3 </span><span class="c10">while Q</span><span class="c0">V </span><span class="c10">= ; do </span><span class="c30">4 </span><span class="c10">v remove the top node from Q</span><span class="c0">V </span><span class="c10">; </span><span class="c30">5 </span><span class="c10">if v 2 V</span><span class="c0">T </span><span class="c10">then return the path formed by concatenating P</span><span class="c0">s,u </span><span class="c3">with the computed shortest path from u to v; </span><span class="c30">6 </span><span class="c10">else for each outgoing edge (v, w) of v do </span><span class="c30">7 </span><span class="c10">if w /2 P</span><span class="c0">s,u</span><span class="c3">, (v, w) /2 X</span><span class="c0">u </span><span class="c3">and d</span><span class="c0">s</span><span class="c3">(v) + !(v, w) &lt; d</span><span class="c0">s</span><span class="c3">(w) </span></p><p class="c4 c123"><span class="c10">then </span><span class="c30">8 </span><span class="c10">d</span><span class="c12">s</span><span class="c10">(w) d</span><span class="c12">s</span><span class="c10">(v) + !(v, w); </span><span class="c30">9 </span><span class="c10">Compute lb(w, V</span><span class="c0">T </span><span class="c10">); </span><span class="c30">10 </span><span class="c10">if d</span><span class="c12">s</span><span class="c10">(w) + lb(w, V</span><span class="c0">T </span><span class="c3">) &#63743; &#8999; then </span><span class="c30">11 </span><span class="c10">Put hw, d</span><span class="c12">s</span><span class="c10">(w) + lb(w, V</span><span class="c0">T </span><span class="c10">)i into Q</span><span class="c0">V </span><span class="c10">; </span></p><p class="c127"><span class="c30">12 </span><span class="c10">return ;; </span></p><p class="c108"><span class="c2">The pseudocode of TestLB is shown in Alg. 5, which is similar to A* search [16], where d</span><span class="c12">s</span><span class="c2">(v) stores the length of a path from s to v constrained in S. We maintain the explored nodes together with their estimated distances (i.e., node v with d</span><span class="c12">s</span><span class="c2">(v) + lb(v, V</span><span class="c12">T</span><span class="c2">)) in a minimum-priority queue Q</span><span class="c0">V </span><span class="c16">, which is initialized to contain u; </span><span class="c2">nodes in Q</span><span class="c0">V </span><span class="c16">are ranked by their estimated distances. Then, nodes </span><span class="c2">are iteratively removed from Q</span><span class="c12">V </span><span class="c2">(Line 4), and their neighbors are inserted into Q</span><span class="c0">V </span><span class="c16">(Lines 6-11), until Q</span><span class="c0">V </span><span class="c16">= ; or we get a node from </span><span class="c2">V</span><span class="c12">T</span><span class="c2">; the latter case implies that sp(S) has been computed (Line 5). Here, V</span><span class="c21">0 </span><span class="c2">is the set of nodes removed from Q</span><span class="c0">V </span><span class="c16">. Note that, following </span><span class="c2">from [16], when a node v is removed from Q</span><span class="c0">V </span><span class="c16">, d</span><span class="c0">s</span><span class="c16">(v) stores the </span><span class="c2">shortest distance from s to v constrained in S (i.e., </span><span class="c12">S</span><span class="c2">(s, v)), and each node is removed from Q</span><span class="c0">V </span><span class="c16">at most once. </span></p><p class="c106"><span class="c2">The efficiency of TestLB is due to that, we only put into Q</span><span class="c12">V </span><span class="c2">those nodes whose estimated distance are not larger than &#8999;, as en- sured by Line 10, which prunes a lot of nodes especially for a small &#8999;.</span><span class="c16">Lemma 5.1: Given a subspace S and &#8999;, TestLB returns sp(S) if </span></p><p class="c17 c104"><span class="c2">!(sp(S)) &#63743; &#8999;, and returns ; otherwise. </span><span class="c7">n </span><span class="c2">Proof Sketch: First of all, we remark that if we remove Lines 9-10 from Alg. 5, then it is the same as the A* search algorithm [16] that computes the shortest path in S. Thus, if !(sp(S)) &#63743; &#8999;, then TestLB returns sp(S), since every node that is pruned at Line 10 will not be in sp(S) due to the nature of lower bound. </span></p><p class="c113"><span class="c2">Secondly, we prove that if !(sp(S)) &gt; &#8999;, then TestLB returns ;. The reason is that, for every node v obtained at Line 4 of Alg. 5, we have d</span><span class="c12">s</span><span class="c2">(v) &#63743; &#8999; due to the pruning at Line 10. Thus, Alg. 5 cannot find the path sp(S), and returns ;. </span><span class="c7">n </span><span class="c2">Time Complexity. The time complexity of Alg. 5 isO(m</span><span class="c21">0</span><span class="c2">+n</span><span class="c21">0 </span><span class="c2">log n</span><span class="c21">0</span><span class="c2">), where n</span><span class="c21">0 </span><span class="c2">and m</span><span class="c21">0 </span><span class="c2">are the number of visited nodes and edges in Alg. 5 (specifically, at Line 6), respectively. In the worst case, n</span><span class="c21">0 </span><span class="c2">= n and m</span><span class="c21">0 </span><span class="c2">= m; thus the time complexity is O(m+ nlog n). However, in practice, n</span><span class="c21">0 </span><span class="c2">and m</span><span class="c21">0 </span><span class="c2">are usually small and much smaller than n and m, respectively. Example 5.1: First, let&rsquo;s consider TestLB((v</span><span class="c12">1</span><span class="c2">,v</span><span class="c12">3</span><span class="c2">),{(v</span><span class="c12">3</span><span class="c2">,v</span><span class="c12">6</span><span class="c2">)},6). v</span><span class="c0">3 </span><span class="c16">has three valid out-neighbors, v</span><span class="c0">4</span><span class="c16">, v</span><span class="c0">5</span><span class="c16">, v</span><span class="c0">7</span><span class="c16">. v</span><span class="c0">4 </span><span class="c16">and v</span><span class="c0">7 </span><span class="c16">are pruned </span><span class="c2">because d</span><span class="c12">v</span><span class="c23">1</span><span class="c2">(v</span><span class="c12">3</span><span class="c2">) + !(v</span><span class="c12">3</span><span class="c2">,v</span><span class="c12">4</span><span class="c2">) &gt; 6 and d</span><span class="c12">v</span><span class="c23">1</span><span class="c2">(v</span><span class="c12">3</span><span class="c2">) + !(v</span><span class="c12">3</span><span class="c2">,v</span><span class="c12">7</span><span class="c2">) &gt; 6. Assume lb(v</span><span class="c0">5</span><span class="c16">,V</span><span class="c0">T</span><span class="c16">) = 2, then v</span><span class="c0">5 </span><span class="c16">is also pruned since d</span><span class="c0">v</span><span class="c23">1</span><span class="c2">(v</span><span class="c0">3</span><span class="c16">) + </span><span class="c2">!(v</span><span class="c0">3</span><span class="c16">,v</span><span class="c0">5</span><span class="c16">)+lb(v</span><span class="c0">5</span><span class="c16">,V</span><span class="c0">T</span><span class="c16">)=7. Thus, TestLB((v</span><span class="c0">1</span><span class="c16">,v</span><span class="c0">3</span><span class="c16">),{(v</span><span class="c0">3</span><span class="c16">,v</span><span class="c0">6</span><span class="c16">)},6) </span><span class="c2">returns ;. Now, let&rsquo;s consider &#8999; = 7. Among the three valid out- neighbors, v</span><span class="c0">4 </span><span class="c16">is pruned because d</span><span class="c0">v</span><span class="c23">1</span><span class="c2">(v</span><span class="c0">3</span><span class="c16">) + !(v</span><span class="c0">3</span><span class="c16">,v</span><span class="c0">4</span><span class="c16">)=8; v</span><span class="c0">5 </span><span class="c16">and </span><span class="c2">v</span><span class="c12">7 </span><span class="c2">are put into Q</span><span class="c12">V </span><span class="c2">with lower bounds 7. Then, v</span><span class="c12">5 </span><span class="c2">is removed from Q</span><span class="c0">V </span><span class="c16">, and its out-neighbor, v</span><span class="c0">6</span><span class="c16">, is put into Q</span><span class="c0">V </span><span class="c16">with lower bound 7. </span><span class="c2">After that, either v</span><span class="c0">6 </span><span class="c16">or v</span><span class="c0">7 </span><span class="c16">is removed from Q</span><span class="c0">V </span><span class="c16">, and the shortest </span><span class="c2">path in h(v</span><span class="c12">1</span><span class="c2">,v</span><span class="c12">3</span><span class="c2">),{(v</span><span class="c12">3</span><span class="c2">,v</span><span class="c12">6</span><span class="c2">)}i is obtained. </span><span class="c7">n </span></p><p class="c66"><span class="c42">5.2 Partial Shortest Path Tree </span></p><p class="c104 c136"><span class="c2">Motivated by DA-SPT, in this subsection we propose to com- pute and store a partial SPT, denoted SPT</span><span class="c0">P</span><span class="c16">, which provides a </span><span class="c2">more accurate estimation of lb(v, V</span><span class="c0">T </span><span class="c16">). Recall that lb(v, V</span><span class="c0">T </span><span class="c16">) is </span><span class="c2">used in TestLB to prune nodes, thus a more accurate estimation of TestLB will result in faster computation time. In contrast to DA-SPT which online constructs a full SPT by incurring high overheads, we obtain SPT</span><span class="c0">P </span><span class="c16">as a by-product of computing the short- </span><span class="c2">est path in G (i.e., Line 1 of Alg. 4) without any extra cost. </span></p><p class="c50"><span class="c2">Algorithm 6: PartialSPT(G, s, T) </span></p><p class="c55"><span class="c30">1 </span><span class="c10">Initialize an empty minimum-priority queue Q</span><span class="c0">T </span><span class="c10">; </span><span class="c30">2 </span><span class="c10">SPT</span><span class="c0">P </span><span class="c10">a virtual root node t; /</span><span class="c3">* </span><span class="c10">Build SPT</span><span class="c0">P </span><span class="c3">*</span><span class="c10">/; </span><span class="c30">3 </span><span class="c10">for each w 2 V</span><span class="c0">T </span><span class="c10">do </span><span class="c30">4 </span><span class="c10">Put hw,lb(s, w)i into Q</span><span class="c0">T </span><span class="c10">, d</span><span class="c12">t</span><span class="c10">(w) 0,p(w) t; </span><span class="c30">5 </span><span class="c10">while Q</span><span class="c0">T </span><span class="c10">= ; do </span><span class="c30">6 </span><span class="c10">v remove the top node from Q</span><span class="c0">T </span><span class="c10">; </span><span class="c30">7 </span><span class="c10">Add v as a child of p(v) to SPT</span><span class="c0">P</span><span class="c10">; /</span><span class="c3">* </span><span class="c10">Build SPT</span><span class="c0">P </span><span class="c3">*</span><span class="c10">/; </span><span class="c30">8 </span><span class="c10">if v = s then return the path from s to t; </span><span class="c30">9 </span><span class="c10">for each incoming edge (w, v) of v do </span><span class="c30">10 </span><span class="c10">if d</span><span class="c0">t</span><span class="c3">(v) + !(w, v) &lt; d</span><span class="c0">t</span><span class="c3">(w) then </span><span class="c30">11 </span><span class="c10">d</span><span class="c12">t</span><span class="c10">(w) d</span><span class="c12">t</span><span class="c10">(v) + !(w, v), p(w) v; </span><span class="c30">12 </span><span class="c10">Put hw, d</span><span class="c0">t</span><span class="c3">(w) + lb(s, w)i into Q</span><span class="c0">T </span><span class="c10">; </span></p><p class="c104 c126"><span class="c2">The algorithm to construct SPT</span><span class="c0">P </span><span class="c16">is given in Alg. 6, denoted </span><span class="c2">PartialSPT, which is the A* search algorithm for computing the shortest path from s to any node in V</span><span class="c12">T </span><span class="c2">in G by adding Lines 2,7. The algorithm runs in the reverse graph of G, since we want to compute shortest paths from different nodes to any node in V</span><span class="c12">T</span><span class="c2">. Q</span><span class="c0">T </span><span class="c16">is similar to Q</span><span class="c0">V </span><span class="c16">in Alg. 5 and initially contains all nodes of V</span><span class="c0">T </span><span class="c2">(Lines 3-4). Then, nodes are iteratively removed from Q</span><span class="c0">T </span><span class="c16">(Line 6) </span><span class="c2">and their incoming edges are explored (Lines 9-12). The shortest path from s to any node in V</span><span class="c0">T </span><span class="c16">is obtained when s is removed from </span></p><p class="c119"><span class="c41">139 </span></p><p class="c4"><span class="c2">Q</span><span class="c0">T </span><span class="c16">(Line 8). For all nodes v removed from Q</span><span class="c0">T</span><span class="c16">, we add v as a </span><span class="c2">child of p(v) to SPT</span><span class="c12">P</span><span class="c2">. Intuitively, SPT</span><span class="c12">P </span><span class="c2">contains all nodes re- moved from Q</span><span class="c0">T </span><span class="c16">prior to s when computing the shortest path from </span><span class="c2">s to any node in V</span><span class="c12">T</span><span class="c2">. Proposition 5.1: For nodes v 2 SPT</span><span class="c0">P</span><span class="c16">, the path from v to t in </span><span class="c2">SPT</span><span class="c0">P </span><span class="c16">is the shortest path from v to any node in V</span><span class="c0">T </span><span class="c16">in G. </span><span class="c52">n </span></p><p class="c17"><span class="c2">Computing lb(v, V</span><span class="c12">T</span><span class="c2">) using SPT</span><span class="c0">P</span><span class="c16">. Both CompLB and TestLB, </span><span class="c2">which are invoked by IterBound, require computing lb(v, V</span><span class="c0">T</span><span class="c16">) for </span><span class="c2">any v 2 V . Eq. (2) computes lb(v, V</span><span class="c12">T </span><span class="c2">) using a landmark-based approach. By utilizing SPT</span><span class="c0">P</span><span class="c16">, we can compute a more accurate </span><span class="c2">lb(v, V</span><span class="c0">T</span><span class="c16">) as follows. If v is in SPT</span><span class="c0">P</span><span class="c16">, then lb(v, V</span><span class="c0">T</span><span class="c16">) is computed as </span><span class="c2">the length of the path from v to t in SPT</span><span class="c12">P</span><span class="c2">, the correctness of which directly follows from Proposition 5.1; otherwise, it is computed by Eq. (2). Here, we give SPT</span><span class="c0">P </span><span class="c16">a higher priority, because if v 2SPT</span><span class="c0">P </span><span class="c16">, then the lower bound computed using SPT</span><span class="c0">P </span><span class="c16">is guaranteed to be </span><span class="c2">not smaller than that by Eq. (2); for lower bound, the larger the better. </span></p><p class="c4"><span class="c71">t </span></p><p class="c4"><span class="c71">v</span><span class="c53">7 </span><span class="c14">v</span><span class="c53">6</span><span class="c71">v</span><span class="c53">4 </span><span class="c71">v</span><span class="c53">8</span><span class="c14">v</span><span class="c53">3 </span><span class="c14">v</span><span class="c53">5</span><span class="c71">v</span><span class="c53">1 </span></p><p class="c4"><span class="c77">v</span><span class="c44">1 </span><span class="c27">0 </span><span class="c64">0</span><span class="c27">0 </span><span class="c64">33 2 </span><span class="c94">v</span><span class="c44">3 </span></p><p class="c92"><span class="c43">3 2</span><span class="c77">v</span><span class="c44">8 </span><span class="c43">2 3 </span></p><p class="c4"><span class="c130">3 </span><span class="c64">2</span><span class="c94">v</span><span class="c44">5 </span><span class="c77">v</span><span class="c44">6 </span><span class="c94">v</span><span class="c44">7 </span></p><p class="c4"><span class="c16">(a) SPT</span><span class="c0">P </span></p><p class="c4"><span class="c2">(b) SPT</span><span class="c0">I </span></p><p class="c4"><span class="c2">Figure 5: Partial and incremental SPT </span></p><p class="c17"><span class="c2">Example 5.2: Fig. 5(a) shows the SPT</span><span class="c0">P </span><span class="c16">constructed for Q = </span><span class="c2">{v</span><span class="c0">1</span><span class="c16">,&ldquo;H&rdquo;,3}. For each node v in SPT</span><span class="c0">P</span><span class="c16">, its distance to t in SPT</span><span class="c0">P </span><span class="c2">is the shortest distance from v to any node in V</span><span class="c0">T </span><span class="c16">and can be used </span><span class="c2">as an estimation of lb(v, V</span><span class="c12">T </span><span class="c2">). For example, lb(v</span><span class="c12">3</span><span class="c2">,V</span><span class="c12">T</span><span class="c2">) is estimated as 3. </span><span class="c7">n </span></p><p class="c4"><span class="c2">IterBound-SPT</span><span class="c0">P </span><span class="c16">Approach. We denote the approach that uses </span><span class="c2">SPT</span><span class="c0">P </span><span class="c16">to estimate lb(v, V</span><span class="c0">T</span><span class="c16">) in Alg. 4 asIterBound-SPT</span><span class="c0">P</span><span class="c16">. The cor- </span><span class="c2">rectness of IterBound-SPT</span><span class="c0">P </span><span class="c16">directly follows from that of IterBound </span><span class="c2">and the above discussions. </span></p><p class="c4"><span class="c42">5.3 Incremental Shortest Path Tree </span></p><p class="c17"><span class="c2">SPT</span><span class="c0">P </span><span class="c16">includes all nodes of V</span><span class="c0">T </span><span class="c16">which can be large for a KPJ </span><span class="c2">query, thus may take long time to construct. In this subsection, we propose an incremental SPT, denoted SPT</span><span class="c0">I</span><span class="c16">, by pruning nodes in </span><span class="c2">V</span><span class="c12">T </span><span class="c2">that are far-away from the source node s. Moreover, we incre- mentally enlarge SPT</span><span class="c0">I</span><span class="c16">, based on which we identify a new property </span><span class="c2">for reducing the exploration area of a graph by TestLB. </span></p><p class="c17"><span class="c2">Constructing SPT</span><span class="c0">I</span><span class="c16">. To prune from SPT</span><span class="c0">I </span><span class="c16">those nodes in V</span><span class="c0">T </span><span class="c16">that </span><span class="c2">are far-away from s, in SPT</span><span class="c12">I </span><span class="c2">we compute and store shortest paths from s to each node of a subset of V . Recall that, in SPT</span><span class="c0">P</span><span class="c16">, we store </span><span class="c2">shortest paths from each node of a subset of V to V</span><span class="c12">T</span><span class="c2">. Thus, the construction of SPT</span><span class="c0">I </span><span class="c16">is run on G by starting from s, and consists of </span><span class="c2">two phases. In the first phase, we construct an initial SPT</span><span class="c0">I</span><span class="c16">, which </span><span class="c2">is a by-product of computing the shortest path from s to any node in V</span><span class="c0">T </span><span class="c16">in a similar fashion to PartialSPT (i.e., Alg. 6) while running </span><span class="c2">on G and starting from s; this is invoked at Line 1 of Alg. 4. In the second phase, we incrementally enlarge SPT</span><span class="c0">I </span><span class="c16">by IncrementalSPT, </span><span class="c2">which is invoked after Line 9 and before Line 10 of Alg. 4. </span></p><p class="c17"><span class="c2">The pseudocode of IncrementalSPT is shown in Alg. 7, which is self-explanatory. The general idea is to include into SPT</span><span class="c0">I </span><span class="c16">all nodes </span><span class="c2">of V that are on paths from s to any node in V</span><span class="c12">T </span><span class="c2">whose lengths are not larger than &tau;. Therefore, IncrementalSPT iteratively removes </span></p><p class="c4"><span class="c2">Algorithm 7: IncrementalSPT(G,T, &tau;) </span></p><p class="c4"><span class="c30">1 </span><span class="c10">while Q</span><span class="c0">T </span><span class="c10">.top().key &#63743; &#8999; do </span><span class="c30">2 </span><span class="c10">v remove the top node from Q</span><span class="c0">T </span><span class="c3">; </span><span class="c30">3 </span><span class="c10">Add v as a child of p(v) to SPT</span><span class="c0">I</span><span class="c10">; </span><span class="c30">4 </span><span class="c10">if v 2 V</span><span class="c0">T </span><span class="c10">then Add v to D; </span><span class="c30">5 </span><span class="c10">for each outgoing edge (v, w) of v do </span><span class="c30">6 </span><span class="c10">if d</span><span class="c12">s</span><span class="c10">(v) + !(v, w) &lt; d</span><span class="c12">s</span><span class="c10">(w) then </span><span class="c30">7 </span><span class="c10">d</span><span class="c0">s</span><span class="c3">(w) d</span><span class="c0">s</span><span class="c3">(v) + !(v, w), p(w) v; </span><span class="c30">8 </span><span class="c10">Put hw, d</span><span class="c12">s</span><span class="c10">(w) + lb(w, V</span><span class="c0">T </span><span class="c10">)i into Q</span><span class="c0">T </span><span class="c10">; </span></p><p class="c4"><span class="c2">the top node v from Q</span><span class="c0">T </span><span class="c16">(Line 2), and adds v into SPT</span><span class="c0">I </span><span class="c16">(Line 3). </span><span class="c2">Meanwhile, the subset of V</span><span class="c0">T </span><span class="c16">that are in SPT</span><span class="c0">I </span><span class="c16">is maintained into a </span><span class="c2">set D (Line 4), which will be used later to improve the performance of testing lower bound for a subspace. In Fig. 5(b), the subtree in the rectangle shows the initial SPT</span><span class="c0">I </span><span class="c16">constructed, and the entire tree </span><span class="c2">is the resulting SPT</span><span class="c0">I </span><span class="c16">for &tau; = 7. Here, D = {v</span><span class="c0">6</span><span class="c16">,v</span><span class="c0">7</span><span class="c16">}. SPT</span><span class="c0">I </span><span class="c16">has </span><span class="c2">the following property. Proposition 5.2: TheSPT</span><span class="c0">I </span><span class="c16">constructed by Alg. 7 contains all nodes </span><span class="c2">on paths from s to any node in V</span><span class="c12">T </span><span class="c2">whose lengths are no larger than &tau;. </span><span class="c7">n </span></p><p class="c4"><span class="c2">Algorithm 8: CompLB-SPT</span><span class="c12">I </span><span class="c2">(P</span><span class="c12">t,u</span><span class="c2">,X</span><span class="c12">u</span><span class="c2">) </span><span class="c30">1 </span><span class="c10">if u = t then N(u) {in-neighbors of u} else N(u) D; </span><span class="c30">2 </span><span class="c10">lb +1; </span><span class="c30">3 </span><span class="c10">for each v 2 N(u) do </span><span class="c30">4 </span><span class="c10">if v /2 P</span><span class="c0">t,u </span><span class="c3">and (v, u) /2 X</span><span class="c0">u </span><span class="c3">then </span><span class="c30">5 </span><span class="c10">if v /2SPT</span><span class="c0">I </span><span class="c10">then Compute lb(s, v) using Eq. (2); </span><span class="c30">6 </span><span class="c10">else lb(s, v) the distance from s to v in SPT</span><span class="c0">I</span><span class="c10">; </span><span class="c30">7 </span><span class="c10">lb min{lb,!(P</span><span class="c0">t,u</span><span class="c3">) + !(v, u) + lb(s, v)}; </span></p><p class="c4"><span class="c30">8 </span><span class="c10">if u = t and lb = +1 and D = V</span><span class="c0">T </span><span class="c10">then lb 0; </span><span class="c30">9 </span><span class="c10">return lb; </span></p><p class="c17"><span class="c2">Computing Initial Lower Bound for a Subspace using SPT</span><span class="c0">I</span><span class="c16">. </span><span class="c2">We compute the lower bound of a subspace using SPT</span><span class="c0">I </span><span class="c16">in a similar </span><span class="c2">way to CompLB (Alg. 3), by considering the immediate neighbors of u. The algorithm is shown in Alg. 8, denoted CompLB-SPT</span><span class="c0">I</span><span class="c16">. </span><span class="c2">Note that, here P</span><span class="c12">t,u </span><span class="c2">is a path from u to t in G and X</span><span class="c12">u </span><span class="c2">is a subset of the incoming edges to u. CompLB-SPT</span><span class="c0">I </span><span class="c16">differs from CompLB in </span><span class="c2">the following two aspects. Firstly, lb(s, v) is estimated by utilizing SPT</span><span class="c0">I </span><span class="c16">in the same way as that in Section 5.2. Secondly, when u = t, </span><span class="c2">instead of considering all nodes of V</span><span class="c0">T</span><span class="c16">, we consider only the subset </span><span class="c2">that is in SPT</span><span class="c12">I </span><span class="c2">(i.e. D). The reason is that, the entire V</span><span class="c12">T </span><span class="c2">can be very large, while the small subset D is sufficient for our purpose of computing lb(P</span><span class="c12">t,u</span><span class="c2">,X</span><span class="c12">u</span><span class="c2">), which saves a lot of computations. </span></p><p class="c17"><span class="c2">The correctness of CompLB-SPT</span><span class="c0">I </span><span class="c16">when u = t directly follows </span><span class="c2">from that of CompLB. However, when u = t, there are two cases depending on whether there are any valid incoming edges to u. 1) If there is no valid incoming edge to u (i.e., every node of N(u) is either in P</span><span class="c12">t,u </span><span class="c2">or in X</span><span class="c12">u</span><span class="c2">, Lines 3-4), then lb will be +1. We reassign lb to 0 if D = V</span><span class="c0">T</span><span class="c16">. 2) Otherwise, lb = +1, which is </span><span class="c2">guaranteed to be a lower bound of the subspace hP</span><span class="c12">t,u</span><span class="c2">,X</span><span class="c12">u</span><span class="c2">i. </span></p><p class="c17"><span class="c2">Testing Lower Bound using SPT</span><span class="c0">I</span><span class="c16">. By utilizing SPT</span><span class="c0">I</span><span class="c16">, we pro- </span><span class="c2">pose a more efficient algorithm for testing lower bound, denoted TestLB-SPT</span><span class="c0">I</span><span class="c16">. We modify TestLB to develop TestLB-SPT</span><span class="c0">I </span><span class="c16">in the </span><span class="c2">same fashion as the development of CompLB-SPT</span><span class="c0">I</span><span class="c16">. Moreover, </span><span class="c2">we prune all nodes that are not in SPT</span><span class="c0">I </span><span class="c16">from consideration (i.e., </span><span class="c2">from putting into Q</span><span class="c0">V </span><span class="c16">). Consequently, every lb(s, w) is computed </span><span class="c2">as the distance from s to w in SPT</span><span class="c12">I</span><span class="c2">; that is, Eq. (2) is not evaluated. Therefore, TestLB-SPT</span><span class="c0">I </span><span class="c16">is more efficient than TestLB. We prove </span></p><p class="c4"><span class="c41">140 </span></p><p class="c25"><span class="c2">the correctness of TestLB-SPT</span><span class="c0">I </span><span class="c16">in the following lemma. </span><span class="c2">Lemma 5.2: Given a subspace S and &#8999;, TestLB-SPT</span><span class="c0">I </span><span class="c16">returns ; if </span><span class="c2">!(sp(S)) &#8999;, and returns sp(S) otherwise. </span><span class="c7">n </span><span class="c2">Proof Sketch: The lemma follows from Lemma 5.1 and Proposi- tion 5.2. </span><span class="c7">n </span><span class="c2">Example 5.3: We show running TestLB-SPT</span><span class="c0">I </span><span class="c16">for subspace h(v</span><span class="c0">7</span><span class="c16">), </span><span class="c2">{(v</span><span class="c12">7</span><span class="c2">,v</span><span class="c12">8</span><span class="c2">)}i with &#8999; = 6, where SPT</span><span class="c0">I </span><span class="c16">is shown in Fig. 5(b). Among </span><span class="c2">v</span><span class="c0">7</span><span class="c16">&rsquo;s in-neighbors, only v</span><span class="c0">3 </span><span class="c16">is considered, since v</span><span class="c0">13 </span><span class="c16">and v</span><span class="c0">14 </span><span class="c16">are not </span><span class="c2">in SPT</span><span class="c0">I</span><span class="c16">. For v</span><span class="c0">3</span><span class="c16">, lb(v</span><span class="c0">1</span><span class="c16">,v</span><span class="c0">3</span><span class="c16">) = 3 which is the distance in SPT</span><span class="c0">I</span><span class="c16">. </span><span class="c2">Then, v</span><span class="c0">3 </span><span class="c16">is also pruned since !(v</span><span class="c0">3</span><span class="c16">,v</span><span class="c0">7</span><span class="c16">) + lb(v</span><span class="c0">1</span><span class="c16">,v</span><span class="c0">3</span><span class="c16">) = 7, and </span><span class="c2">TestLB-SPT</span><span class="c0">I </span><span class="c16">returns ;. For &#8999; = 7, SPT</span><span class="c0">I </span><span class="c16">remains the same. Then, </span><span class="c2">v</span><span class="c12">3 </span><span class="c2">is not pruned and the shortest path in h(v</span><span class="c12">7</span><span class="c2">),{(v</span><span class="c12">7</span><span class="c2">,v</span><span class="c12">8</span><span class="c2">)}i is ob- tained, which is (v</span><span class="c0">1</span><span class="c16">,v</span><span class="c0">3</span><span class="c16">,v</span><span class="c0">7</span><span class="c16">) with length 7. </span><span class="c52">n </span></p><p class="c89"><span class="c2">IterBound-SPT</span><span class="c0">I </span><span class="c16">Approach. Based on SPT</span><span class="c0">I </span><span class="c16">and the discussions </span><span class="c2">above, we propose an approach following Alg. 4 for processing KPJ queries, denotedIterBound-SPT</span><span class="c12">I</span><span class="c2">. It runs on the reverse graph of G, and a subspace is represented by hP</span><span class="c0">t,u</span><span class="c16">,X</span><span class="c0">u</span><span class="c16">i where X</span><span class="c0">u </span><span class="c16">is a </span><span class="c2">subset of the incoming edges to u. </span></p><p class="c75"><span class="c2">IterBound-SPT</span><span class="c0">I </span><span class="c16">improves the efficiency by computing SPT</span><span class="c0">I </span><span class="c2">and pruning all nodes not in SPT</span><span class="c0">I </span><span class="c16">from consideration when con- </span><span class="c2">ducting the iteratively bounding search. That is, we take as input only the small subgraph of G induced by nodes in SPT</span><span class="c0">I</span><span class="c16">. Note that, </span><span class="c2">SPT</span><span class="c0">I </span><span class="c16">enlarges for a larger &#8999;, and the subgraph induced by nodes in </span><span class="c2">SPT</span><span class="c0">I </span><span class="c16">also enlarges; this guarantees that we can correctly process </span><span class="c2">any KPJ query. Time Complexity. The time complexity of the IterBound-SPT</span><span class="c0">I </span><span class="c16">ap- </span><span class="c2">proach is O(kn(m</span><span class="c21">0 </span><span class="c2">+ n</span><span class="c21">0 </span><span class="c2">log n</span><span class="c21">0</span><span class="c2">)), where n</span><span class="c21">0 </span><span class="c2">and m</span><span class="c21">0 </span><span class="c2">are the num- ber of nodes and edges, respectively, in the subgraph G</span><span class="c21">0 </span><span class="c2">of G that is induced by nodes w with d</span><span class="c12">s</span><span class="c2">(w) + lb(w, V</span><span class="c12">T</span><span class="c2">) &lt;= &#8999; (see Line 10 of Alg. 5) for the largest &#8999; obtained in IterBound-SPT</span><span class="c0">I</span><span class="c16">. </span><span class="c2">Note that, n</span><span class="c21">0 </span><span class="c2">and m</span><span class="c21">0 </span><span class="c2">are usually small in real applications; thus, IterBound-SPT</span><span class="c12">I </span><span class="c2">runs much faster than DA (see Alg. 1). </span></p><p class="c37"><span class="c42">6. EXTENSIONS </span></p><p class="c51"><span class="c2">In the following, we extend our techniques to other applications including the case that the source node also has multiple physical nodes and the case that landmarks are not available. </span></p><p class="c39"><span class="c2">General KPJ. A general KPJ (GKPJ) query is an extension of KPJ query where the source node also has multiple physical nodes, denote as Q = {S,T,k}, where both S and T are categories. It is to compute the top-k shortest paths from any node in V</span><span class="c0">S </span><span class="c16">to any </span><span class="c2">node in V</span><span class="c12">T </span><span class="c2">, whereV</span><span class="c12">S </span><span class="c2">is the set of nodes of V belonging to category S. We can convert a GKPJ query to a KPJ query by introducing a virtual source node s and connecting s to all nodes in V</span><span class="c12">S </span><span class="c2">with weights 0. Then, Q is reduced to a KPJ query Q</span><span class="c21">0 </span><span class="c2">= {s,T,k} on the new graph, and all our proposed techniques can be used to process the query. </span></p><p class="c47"><span class="c2">Computing without Landmark. Our techniques are presented based on landmarks which are used to estimate lb(u, V</span><span class="c0">T</span><span class="c16">). Nev- </span><span class="c2">ertheless, when landmarks are not available, all our techniques can still be directly applied by setting all lb(u, V</span><span class="c0">T </span><span class="c16">) (i.e., computed by </span><span class="c2">Eq. (2)) to be 0. Specifically, for IterBound-SPT</span><span class="c0">I</span><span class="c16">, the landmark </span><span class="c2">is only used for constructing the SPT</span><span class="c0">I </span><span class="c16">using A* search [16], as </span><span class="c2">discussed in Section 5.3; thus, without landmark, we construct the SPT</span><span class="c0">I </span><span class="c16">by setting lb(u, V</span><span class="c0">T</span><span class="c16">) to be 0 (the A* search then becomes the </span><span class="c2">Dijkstra&rsquo;s algorithm [11]), while other parts of IterBound-SPT</span><span class="c0">I </span><span class="c16">re- </span><span class="c2">main the same. </span></p><p class="c117"><span class="c2">Moreover, without landmark, our techniques still perform well; the reasons are as follows. The IterBound-SPT</span><span class="c0">I </span><span class="c16">approach mainly </span></p><p class="c17 c132"><span class="c2">consists of two parts: 1) incrementally constructing the partial short- est path tree SPT</span><span class="c12">I</span><span class="c2">, 2) computing lower bound or shortest path for a subspace. The dominating cost comes from the second part, while landmark is only used in the first part. Thus, by running IterBound-SPT</span><span class="c0">I </span><span class="c16">without landmark will only increase the cost of </span><span class="c2">the first part which is not a big factor in the total cost. </span></p><p class="c68"><span class="c42">7. PERFORMANCE STUDIES </span></p><p class="c79"><span class="c2">We conduct extensive performance studies to evaluate the effi- ciency of our approaches against the baseline approaches for pro- cessing KPJ queries. The following algorithms are implemented: </span></p><p class="c83"><span class="c2">&bull; DA[28] and DA-SPT [15]. They are in the deviation paradigm as discussed in Section 3, and are the baseline approaches for processing KPJ queries. </span></p><p class="c24"><span class="c2">&bull; BestFirst. It is the best-first approach as discussed in Sec- tion 4. </span></p><p class="c114"><span class="c2">&bull; IterBound, IterBound</span><span class="c0">P</span><span class="c16">, and IterBound</span><span class="c0">I</span><span class="c16">. They are the it- </span><span class="c2">eratively bounding approaches with or without SPT as dis- cussed in Section 5. IterBound</span><span class="c0">P </span><span class="c16">and IterBound</span><span class="c0">I </span><span class="c16">are abbre- </span><span class="c2">viations of IterBound-SPT</span><span class="c0">P </span><span class="c16">and IterBound-SPT</span><span class="c0">I</span><span class="c16">, respec- </span><span class="c2">tively. </span></p><p class="c24"><span class="c2">&bull; IterBound</span><span class="c0">I</span><span class="c16">-NL. It is the IterBound</span><span class="c0">I </span><span class="c16">approach however with- </span><span class="c2">out landmark, as discussed in Section 6. </span></p><p class="c104 c111"><span class="c2">Note that, 1) in our testings, a KSP query is also considered as a KPJ query where the query category uniquely identifies the desti- nation node; 2) the baseline approaches for processing KPJ queries are the state-of-the-art techniques for processing KSP queries. </span></p><p class="c40"><span class="c2">All algorithms are implemented in C++ and compiled with GNU GCC by -O3 option. All tests are conducted on a PC with an In- tel(R) Xeon(R) 2.66GHz CPU and 4GB memory running Linux. We evaluate the performance of the algorithms on real datasets as follows. </span></p><p class="c67"><span class="c2">Dataset #Nodes #Edges CAL 106,337 213,964 SJ 18,263 47,594 SF 174,956 443,604 COL 435,666 1,042,400 FLA 1,070,376 2,687,902 USA 6,262,104 15,119,284 </span></p><p class="c129"><span class="c2">Table 1: Summary of dataset Datasets. We use six real road networks with real/synthetic points of interest (POIs), and each POI belongs to a category. They are: California road network (CAL), San Joaquin road network (SJ), San Francisco road network (SF), Colorado road network (COL), Florida road network (FLA), and Western USA road network (USA). The first three are downloaded from </span><span class="c10">www.cs.utah.edu/~lifeifei/ SpatialDataset.htm</span><span class="c2">, and the last three are from DIMACS (</span><span class="c10">www. dis.uniroma1.it/~challenge9/download.shtml</span><span class="c2">). A sum- mary is given in Table 1. </span></p><p class="c26"><span class="c2">POIs. The CAL dataset is provided with real POIs, which have 62 different categories. For the other five road networks, we gener- ate synthetic POIs randomly located on nodes. For each road net- work, we generate four sets of POIs, denoted T</span><span class="c0">1</span><span class="c16">,T</span><span class="c0">2</span><span class="c16">,T</span><span class="c0">3</span><span class="c16">,T</span><span class="c0">4</span><span class="c16">, cor- </span><span class="c2">responding to different number of physical destination nodes (i.e., n&#8677;10 </span><span class="c21">4</span><span class="c2">,5n&#8677;10 </span><span class="c21">4</span><span class="c2">,10n&#8677;10 </span><span class="c21">4</span><span class="c2">,15n&#8677;10 </span><span class="c21">4 </span><span class="c2">POIs, respectively), where n is the number of nodes in a road network. For example, for </span></p><p class="c125"><span class="c41">141 </span></p><p class="c4"><span class="c2">COL, 1T</span><span class="c0">1</span><span class="c16">1 = 43, 1T</span><span class="c0">2</span><span class="c16">1 = 217, 1T</span><span class="c0">3</span><span class="c16">1 = 435, and 1T</span><span class="c0">4</span><span class="c16">1 = 653. Note </span><span class="c2">that, we generate the POIs in such a way that T</span><span class="c12">1 </span><span class="c2">&#8674; T</span><span class="c12">2 </span><span class="c2">&#8674; T</span><span class="c12">3 </span><span class="c2">&#8674; T</span><span class="c12">4</span><span class="c2">. </span></p><p class="c17"><span class="c2">Graphs. We model each road network with POIs as a graph G. Here, an edge (u, v) in G represents a road segment, and has a non-negative weight !(u, v) which can be any measure of the road segment, such as distance, travel time, travel cost, and etc. We take distance as weight in our experiments. Each node belongs to the categories of POIs that are located on it.</span><span class="c21">2 </span></p><p class="c4"><span class="c2">Queries. A query consists of a source node s, a destination node set V</span><span class="c12">T </span><span class="c2">indicated by category T, and a value k indicating the num- ber of paths to found. For each query, we first choose a category T, and then randomly generate source nodes. For the CAL dataset, we consider four representative categories, &ldquo;Glacier&rdquo;, &ldquo;Lake&rdquo;, &ldquo;Crater&rdquo;, and &ldquo;Harbor&rdquo;, which have 1, 8, 14, and 94 physical nodes, respec- tively. For the other datasets, we consider T</span><span class="c0">1</span><span class="c16">,T</span><span class="c0">2</span><span class="c16">,T</span><span class="c0">3</span><span class="c16">, and T</span><span class="c0">4</span><span class="c16">, and </span><span class="c2">choose T</span><span class="c0">2 </span><span class="c16">by default. </span></p><p class="c17"><span class="c2">For a destination category T, the source nodes in a query are randomly generated as follows. We sort all nodes in increasing order regarding their shortest path lengths to category T, partition them into 5 groups, and generate 5 query sets, Q</span><span class="c0">1</span><span class="c16">,Q</span><span class="c0">2</span><span class="c16">,Q</span><span class="c0">3</span><span class="c16">,Q</span><span class="c0">4</span><span class="c16">,Q</span><span class="c0">5</span><span class="c16">, </span><span class="c2">each of which consists of 100 nodes randomly selected from the corresponding group. Thus, nodes in Q</span><span class="c12">i </span><span class="c2">are closer to destination nodes than nodes in Q</span><span class="c0">j </span><span class="c16">do, for i&lt;j. We use Q</span><span class="c0">3 </span><span class="c16">as the default </span><span class="c2">query set. </span></p><p class="c4"><span class="c2">k is chosen from 10,20,30, and 50, with 20 as the default. </span><span class="c42">7.1 Experimental Results </span></p><p class="c4"><span class="c2">Eval-I: Parameters. We evaluate the influence of landmark size 1L1 and parameter &crarr; on the performance of IterBound</span><span class="c0">I</span><span class="c16">. </span></p><p class="c4"><span class="c28">40 </span><span class="c5">Crater </span><span class="c73">Glacier </span><span class="c28">30</span><span class="c73">Harbor Lake </span></p><p class="c4"><span class="c28">20</span><span class="c5">104 8 12 16 20 32 </span></p><p class="c4"><span class="c2">(a) Varying 1L1 </span></p><p class="c4"><span class="c5">Crater </span><span class="c73">Glacier Harbor Lake </span></p><p class="c4"><span class="c2">(b) Varying &crarr; </span></p><p class="c4"><span class="c2">Figure 6: Parameter testing on CAL (Q</span><span class="c12">3</span><span class="c2">,k = 20) </span></p><p class="c4"><span class="c2">Choosing 1L1. In our approaches, we use landmarks for estimat- ing lb(v, V</span><span class="c0">T </span><span class="c16">), the lower bound of shortest distance from v to any </span><span class="c2">node way in in [16].V</span><span class="c0">T</span><span class="c16">. </span><span class="c21">3 </span><span class="c16">The </span><span class="c2">Fig. </span><span class="c16">landmarks </span><span class="c2">6(a) </span><span class="c16">are chosen following the most popular </span><span class="c2">shows the processing time of IterBound</span><span class="c0">I </span><span class="c2">for different 1L1 values. Clearly, when 1L1 increases from 4 to 16, the processing time decreases, because more landmarks can pro- vide more accurate estimation of lb(v, V</span><span class="c12">T</span><span class="c2">). However, when 1L1 increases from 16 to 32, the processing time increases a little due to longer computation time of lb(v, V</span><span class="c0">T</span><span class="c16">). Therefore, we choose </span><span class="c2">1L1 = 16. Choosing &crarr;. The running time of IterBound</span><span class="c0">I </span><span class="c16">for different &crarr; values </span><span class="c2">are illustrated in Fig. 6(b). Recall that &crarr; is used in our iterative bounding approaches for controlling the increasing ratio of &#8999; (i.e., </span></p><p class="c4"><span class="c12">2</span><span class="c16">For simplicity, we assume that POIs are located on the nodes of G. When a POI is on an edge (u, v), we can add a new node w to G and connect w with u and v to replace (u, v). Note that, given a query with category T, we only need to consider the set of POIs belonging to category T. </span><span class="c12">3</span><span class="c16">We firstly pick a random start node and select the farthest node from the start node as the first landmark, and then iteratively choose the node that is farthest away from the current set of landmarks as the next landmark. </span></p><p class="c4"><span class="c28">25 </span></p><p class="c4"><span class="c28">15</span><span class="c5">51.05 1.1 1.2 1.5 1.8 </span></p><p class="c17"><span class="c2">controlling the computation of a tighter lower bound, see Alg. 4). The running time increases when &crarr; increases from 1.1 to 1.8 due to building a larger SPT</span><span class="c0">I</span><span class="c16">. However, when &crarr; decreases from 1.1 to </span><span class="c2">1.05, the processing time also increases due to taking more itera- tions to reach the final &#8999;. Therefore, we choose &crarr; = 1.1. </span></p><p class="c17"><span class="c2">Note that: 1) among our parameters, &#8999; is determined by &crarr;; 2) better choices of 1L1 and &crarr; will improve the performance of our algorithm marginally as shown in Fig. 6. It will be our future work to automatically find the best choice of 1L1 and &crarr;. </span></p><p class="c4"><span class="c22">DA DA-SPT </span></p><p class="c4"><span class="c95">IterBound</span><span class="c22">IterBound</span><span class="c48">I</span><span class="c22">-NL </span></p><p class="c4"><span class="c48">P </span><span class="c22">IterBound</span><span class="c48">I </span></p><p class="c4"><span class="c5">10 </span></p><p class="c4"><span class="c22">BestFirst IterBound </span></p><p class="c4"><span class="c5">10</span><span class="c20">3 </span></p><p class="c92"><span class="c5">Q</span><span class="c11">1 </span><span class="c5">Q</span><span class="c11">2 </span><span class="c5">Q</span><span class="c11">3 </span><span class="c5">Q</span><span class="c11">4 </span><span class="c5">Q</span><span class="c11">5 </span><span class="c2">(a) Vary Q (T = &ldquo;Lake&rdquo;) </span></p><p class="c4"><span class="c5">10</span><span class="c20">3 </span></p><p class="c4"><span class="c5">10</span><span class="c20">2 </span></p><p class="c4"><span class="c5">10</span><span class="c20">2 </span></p><p class="c4"><span class="c5">10 20 30 50 </span></p><p class="c4"><span class="c2">(b) Vary k (T = &ldquo;Lake&rdquo;) </span></p><p class="c4"><span class="c5">10 </span></p><p class="c4"><span class="c5">10 </span></p><p class="c4"><span class="c5">10</span><span class="c20">3 </span></p><p class="c92"><span class="c5">Q</span><span class="c11">1 </span><span class="c5">Q</span><span class="c11">2 </span><span class="c5">Q</span><span class="c11">3 </span><span class="c5">Q</span><span class="c11">4 </span><span class="c5">Q</span><span class="c11">5 </span><span class="c2">(c) Vary Q (T = &ldquo;Crater&rdquo;) </span></p><p class="c4"><span class="c5">10</span><span class="c20">3 </span></p><p class="c4"><span class="c5">10</span><span class="c20">2 </span></p><p class="c4"><span class="c5">10</span><span class="c20">2 </span></p><p class="c4"><span class="c5">10 20 30 50 </span></p><p class="c4"><span class="c2">(d) Vary k (T = &ldquo;Crater&rdquo;) </span></p><p class="c4"><span class="c5">10 </span></p><p class="c4"><span class="c5">10 </span></p><p class="c4"><span class="c5">10</span><span class="c20">2 </span></p><p class="c92"><span class="c5">Q</span><span class="c11">1 </span><span class="c5">Q</span><span class="c11">2 </span><span class="c5">Q</span><span class="c11">3 </span><span class="c5">Q</span><span class="c11">4 </span><span class="c5">Q</span><span class="c11">5 </span><span class="c2">(e) Vary Q (T = &ldquo;Harbor&rdquo;) </span></p><p class="c4"><span class="c5">10</span><span class="c20">2 </span></p><p class="c4"><span class="c5">10 20 30 50 </span></p><p class="c4"><span class="c2">(f) Vary k (T = &ldquo;Harbor&rdquo;) </span></p><p class="c4"><span class="c2">Figure 7: Against baseline approaches on CAL (Varying Q, k) </span></p><p class="c4"><span class="c2">Eval-II: Against the Baseline Approaches. Here, we evaluate the performances of our approaches against the baseline approaches on CAL dataset. KPJ Query. The processing time of the seven approaches by vary- ing query sets and k is demonstrated in Fig. 7, where the desti- nation category is chosen from &ldquo;Lake&rdquo;, &ldquo;Crater&rdquo;, and &ldquo;Harbor&rdquo;. In general, all our approaches, BestFirst, IterBound, IterBound</span><span class="c0">P</span><span class="c16">, </span><span class="c2">IterBound</span><span class="c0">I</span><span class="c16">, and IterBound</span><span class="c0">I</span><span class="c16">-NL, outperform the two baseline ap- </span><span class="c2">proaches, DA and DA-SPT. This is because our approaches use a best-first paradigm to reduce the number of shortest path com- putations. In Figures 7(a)-7(d), DA-SPT outperforms DA because DA-SPT online builds a full SPT to facilitate the shortest path computation. However, in Fig. 7(e)-7(f), DA-SPT performs worse due to the dominating cost of building the full SPT. When the lengths of shortest paths increase (i.e., varying Q from Q</span><span class="c0">1 </span><span class="c16">to Q</span><span class="c0">5</span><span class="c16">), </span><span class="c2">the running time of all approaches increases except DA-SPT which is steady, due to the dominating cost of constructing the full SPT. Moreover, although without landmarks, IterBound</span><span class="c0">I</span><span class="c16">-NL outperforms </span><span class="c2">all other approaches except IterBound</span><span class="c0">I </span><span class="c16">across all testings. The </span><span class="c2">trend of the processing time of these approaches by varying k is similar to that of varying query set. One exception is that, the pro- cessing time of DA-SPT also slightly increases due to computing more shortest paths for larger k. KSP Query. We test the approaches for processing KSP queries by setting the destination category as &ldquo;Glacier&rdquo; which has only one </span></p><p class="c4"><span class="c41">142 </span></p><p class="c4"><span class="c5">10 </span></p><p class="c4"><span class="c22">IterBoundDA DA-SPT </span></p><p class="c4"><span class="c22">BestFirst IterBound </span></p><p class="c4"><span class="c95">IterBound</span><span class="c48">I</span><span class="c22">-NL </span></p><p class="c4"><span class="c48">P </span><span class="c22">IterBound</span><span class="c48">I </span></p><p class="c4"><span class="c5">10</span><span class="c20">3 </span></p><p class="c4"><span class="c5">10 </span></p><p class="c92"><span class="c5">Q</span><span class="c11">1 </span><span class="c5">Q</span><span class="c11">2 </span><span class="c5">Q</span><span class="c11">3 </span><span class="c5">Q</span><span class="c11">4 </span><span class="c5">Q</span><span class="c11">5 </span><span class="c2">(a) Vary Q (T = &ldquo;Glacier&rdquo;) </span></p><p class="c4"><span class="c5">10</span><span class="c20">3 </span></p><p class="c4"><span class="c5">10</span><span class="c20">2 </span></p><p class="c4"><span class="c5">10 20 30 50 </span></p><p class="c4"><span class="c2">(b) Vary k (T = &ldquo;Glacier&rdquo;) </span></p><p class="c4"><span class="c2">Figure 8: Testing KSP queries on CAL (Varying Q and k) </span></p><p class="c4"><span class="c2">physical destination node; thus, the KPJ query is a KSP query. The results are shown in Fig. 8, which are similar to that for KPJ queries in Fig. 7. Summary. There is no clear winner between DA and DA-SPT, and all our approaches perform better than these two baseline ap- proaches. Despite using the same techniques, IterBound</span><span class="c0">I </span><span class="c16">outper- </span><span class="c2">forms IterBound</span><span class="c12">I</span><span class="c2">-NL, which demonstrates the effectiveness of us- ing landmarks for estimating lower bounds. Therefore, in the fol- lowing testings, we omit DA, DA-SPT, and IterBound</span><span class="c0">I</span><span class="c16">-NL, and </span><span class="c2">evaluate the other approaches which use different techniques and all use landmark. Eval-III: Evaluating Our Approaches. In this testing, we evalu- ate the efficiency of our different approaches, BestFirst, IterBound, IterBound</span><span class="c0">P</span><span class="c16">, and IterBound</span><span class="c0">I</span><span class="c16">, on SJ and COL. </span></p><p class="c4"><span class="c49">BestFirst IterBound IterBound</span><span class="c61">P </span><span class="c49">IterBound</span><span class="c61">I </span></p><p class="c4"><span class="c28">10 </span></p><p class="c92"><span class="c28">1</span><span class="c5">10</span><span class="c20">-1</span><span class="c5">Q</span><span class="c11">1 </span><span class="c5">Q</span><span class="c11">2 </span><span class="c5">Q</span><span class="c11">3 </span><span class="c5">Q</span><span class="c11">4 </span><span class="c5">Q</span><span class="c11">5 </span><span class="c2">(a) Vary Q (SJ) </span></p><p class="c4"><span class="c5">10</span><span class="c20">2 </span></p><p class="c4"><span class="c5">10 </span></p><p class="c4"><span class="c28">10 </span></p><p class="c4"><span class="c28">1</span><span class="c5">10</span><span class="c20">-1</span><span class="c5">10 20 30 50 </span></p><p class="c4"><span class="c2">(b) Vary k (SJ) </span></p><p class="c4"><span class="c5">10</span><span class="c20">2 </span></p><p class="c4"><span class="c28">10 </span></p><p class="c92"><span class="c5">1Q</span><span class="c11">1 </span><span class="c5">Q</span><span class="c11">2 </span><span class="c5">Q</span><span class="c11">3 </span><span class="c5">Q</span><span class="c11">4 </span><span class="c5">Q</span><span class="c11">5 </span><span class="c2">(c) Vary Q (COL) </span></p><p class="c4"><span class="c5">10</span><span class="c20">2 </span></p><p class="c4"><span class="c28">10 </span></p><p class="c4"><span class="c5">110 20 30 50 </span></p><p class="c4"><span class="c2">(d) Vary k (COL) </span></p><p class="c4"><span class="c2">Figure 9: Our approaches by varying Q and k (T = T</span><span class="c12">2</span><span class="c2">) </span></p><p class="c4"><span class="c2">Varying Q and k. The running time of the approaches on SJ and COL by varying Q and k is shown in Fig. 9. Similar to that in Fig. 7, the running time of these four approaches increases when either Q varies from Q</span><span class="c0">1 </span><span class="c16">to Q</span><span class="c0">5 </span><span class="c16">or k increases. IterBound slightly </span><span class="c2">outperforms BestFirst due to less number of shortest path compu- tations, however with more expensive lower bound computations. IterBound</span><span class="c0">P </span><span class="c16">performs better than IterBound because of the faster </span><span class="c2">lower bound testing. IterBound</span><span class="c0">I </span><span class="c16">runs faster than IterBound</span><span class="c0">P </span><span class="c16">be- </span><span class="c2">cause IterBound</span><span class="c0">I </span><span class="c16">can further reduce the exploration area of a graph </span><span class="c2">by SPT</span><span class="c0">I</span><span class="c16">. </span><span class="c2">Varying Number of Destination Nodes (|T|). Fig. 10 shows the pro- cessing time of these four approaches on SJ and COL by varying the number of destination nodes (i.e., varying |T|). For all these four approaches, the processing time decreases, when the num- ber of destination nodes increases (i.e., T varies from T</span><span class="c12">1 </span><span class="c2">to T</span><span class="c12">4</span><span class="c2">). This is because the shortest paths become shorter for more number </span></p><p class="c4"><span class="c49">BestFirst IterBound IterBound</span><span class="c61">P </span><span class="c49">IterBound</span><span class="c61">I </span></p><p class="c4"><span class="c28">10 </span></p><p class="c4"><span class="c28">1</span><span class="c5">10</span><span class="c20">-1</span><span class="c5">1 9 18 27 </span></p><p class="c4"><span class="c2">(a) SJ </span></p><p class="c4"><span class="c28">10 </span></p><p class="c4"><span class="c28">1</span><span class="c5">10</span><span class="c20">-1</span><span class="c5">43 217 435 653 </span></p><p class="c4"><span class="c2">(b) COL </span></p><p class="c4"><span class="c2">Figure 10: Vary #(destination nodes) (Q = Q</span><span class="c0">3</span><span class="c16">, k = 20) </span></p><p class="c17"><span class="c2">of destination nodes as shown in Fig. 11 which will be discussed shortly. IterBound</span><span class="c0">I </span><span class="c16">outperforms IterBound</span><span class="c0">P </span><span class="c16">which then outper- </span><span class="c2">forms BestFirst and IterBound. The improvement of IterBound</span><span class="c0">I </span><span class="c2">over IterBound</span><span class="c0">P </span><span class="c16">becomes more significant when there are more </span><span class="c2">destination nodes, since IterBound</span><span class="c0">I </span><span class="c16">can prune destination nodes </span><span class="c2">and reduce the exploration area of a graph by SPT</span><span class="c0">I</span><span class="c16">. </span></p><p class="c17"><span class="c1">100 </span><span class="c109">80 604020</span><span class="c1">0n 5n 10n 15n </span></p><p class="c4"><span class="c1">Vary |T| (x10</span><span class="c131">-4</span><span class="c1">) </span></p><p class="c4"><span class="c74">SF </span><span class="c1">SJ</span><span class="c74">COL FLA USA </span></p><p class="c4"><span class="c2">Figure 11: Shortest path length (Varying #(destination nodes)) </span></p><p class="c4"><span class="c2">Fig. 11 illustrates the influence of the number of destination nodes on the shortest path lengths. Specifically, for each category T</span><span class="c12">i</span><span class="c2">, we compute the longest length of shortest paths from nodes to T</span><span class="c0">i</span><span class="c16">, and </span><span class="c2">report its percentile position in the observations of all n &middot; n short- est path lengths in the graph. For all datasets, the shortest path lengths decrease with more number of destination nodes; thus all approaches run faster as shown in Fig. 10. Note that, for a specific T</span><span class="c0">i</span><span class="c16">, the number of destination nodes belonging to T</span><span class="c0">i </span><span class="c16">are different, </span><span class="c2">thus the shortest path lengths vary for different datasets; for exam- ple, for T</span><span class="c0">1</span><span class="c16">, the number of destination nodes for SJ, SF, COL, FLA, </span><span class="c2">USA are 1, 17, 43, 107, and 626, respectively. Summary. IterBound</span><span class="c0">I </span><span class="c16">outperforms the other approaches, BestFirst, </span><span class="c2">IterBound, and IterBound</span><span class="c0">P</span><span class="c16">, across all different datasets, different </span><span class="c2">number of destination nodes, different Q, and different k. Thus, in the following we only evaluate our IterBound</span><span class="c0">I </span><span class="c16">approach. </span></p><p class="c4"><span class="c28">3 </span></p><p class="c4"><span class="c5">IterBound</span><span class="c11">I </span></p><p class="c4"><span class="c28">21</span><span class="c5">0SJ SF COL FLA USA </span></p><p class="c4"><span class="c2">(a) Vary graph size (k = 20) </span></p><p class="c4"><span class="c5">IterBound</span><span class="c11">I </span></p><p class="c4"><span class="c2">(b) Vary k (COL) </span></p><p class="c4"><span class="c2">Figure 12: Scalability of IterBound</span><span class="c0">I </span><span class="c16">(T = T</span><span class="c0">2</span><span class="c16">, Q = Q</span><span class="c0">3</span><span class="c16">) </span></p><p class="c4"><span class="c2">Eval-IV: Scalability Testing. The scalability testing results of IterBound</span><span class="c0">I </span><span class="c16">by varying graph size and k are shown in Fig. 12. Al- </span><span class="c2">though the running time increases when either the graph size or k increases, IterBound</span><span class="c0">I </span><span class="c16">is scalable enough to process very large </span><span class="c2">graphs. For example, when the graph size increases 40 times (i.e., from SJ to USA), the running time of IterBound</span><span class="c12">I </span><span class="c2">only increases slightly (e.g., by no more than 3 times). Eval-V: GKPJ Testing. In this evaluation, we test the efficiency of IterBound</span><span class="c0">I </span><span class="c16">over DA-SPT, the state-of-the-art approach, for GKPJ </span></p><p class="c4"><span class="c41">143 </span></p><p class="c4"><span class="c28">10 </span></p><p class="c4"><span class="c5">110 50 100 200 500 </span></p><p class="c4"><span class="c2">[8] </span><span class="c5">10</span><span class="c20">3 </span></p><p class="c4"><span class="c73">IterBound</span><span class="c5">DA-SPT </span><span class="c11">I </span></p><p class="c4"><span class="c73">IterBound</span><span class="c5">DA-SPT </span><span class="c11">I </span></p><p class="c33"><span class="c2">E. de Queir&oacute;s Vieira Martins and M. M. B. Pascoal. A new implementation of yen&rsquo;s ranking loopless paths algorithm. 4OR, 1(2), 2003. [9] E. de Queir</span><span class="c31">&nbsp;&#769;</span><span class="c2">l &#779;os Vieira Martins, M. M. B. Pascoal, and J. L. E. dos Santos. The k shortest loopless paths problem, 1998. </span><span class="c5">43 217 435 653 </span></p><p class="c4"><span class="c2">[10] D. Delling, A. V. Goldberg, R. Savchenko, and R. F. (a) Vary #(destination nodes) </span><span class="c16">(k = 20) </span></p><p class="c4"><span class="c2">(b) Vary k (T = T</span><span class="c0">2</span><span class="c16">) </span></p><p class="c4"><span class="c2">Werneck. Hub labels: Theory and practice. In Proc. of SEA&rsquo;14, 2014. </span></p><p class="c4"><span class="c2">Figure 13: GKPJ query (COL) </span></p><p class="c33"><span class="c2">[11] E. W. Dijkstra. A note on two problems in connexion with graphs. NUMERISCHE MATHEMATIK, 1(1), 1959. [12] D. Eppstein. Finding the k shortest paths. SIAM J. Comput., queries Q = {S,T,k}. Here, the source category S has 4 physi- cal nodes which are randomly chosen. Fig. 13 shows the running time by varying the number of destination nodes (i.e., 1T1) or k. </span></p><p class="c4"><span class="c2">28(2), 1998. [13] I. D. Felipe, V. Hristidis, and N. Rishe. Keyword search on </span></p><p class="c4"><span class="c2">spatial databases. In Proc. of ICDE&rsquo;08, pages 656&ndash;665, 2008. The trends of running time of DA-SPT and IterBound</span><span class="c0">I </span><span class="c16">are similar </span><span class="c2">to the previous evaluations. The improvement of IterBound</span><span class="c12">I </span><span class="c2">over DA-SPT is more significant (e.g., by two orders of magnitude). </span></p><p class="c4"><span class="c5">10</span><span class="c20">3 </span></p><p class="c4"><span class="c5">10</span><span class="c20">2 </span></p><p class="c4"><span class="c5">10 20 30 50 </span></p><p class="c33"><span class="c2">[14] J. Gao, H. Qiu, X. Jiang, T. Wang, and D. Yang. Fast top-k simple shortest paths discovery in graphs. In Proc. of CIKM&rsquo;10, 2010. This is because the lengths of k shortest paths become smaller with </span></p><p class="c4"><span class="c2">[15] J. Gao, J. X. Yu, H. Qiu, X. Jiang, T. Wang, and D. Yang. multiple source nodes. </span></p><p class="c33"><span class="c2">Holistic top-k simple shortest path join in graphs. IEEE Trans. Knowl. Data Eng., 24(4):665&ndash;677, 2012. </span><span class="c42">8. CONCLUSION </span></p><p class="c4"><span class="c2">[16] A. V. Goldberg and C. Harrelson. Computing the shortest In this paper, we studied the problem of top-k shortest path join (KPJ). We adopted the best-first paradigm to reduce the number of shortest path computations, compared to the existing deviation paradigm, by pruning subspaces based on their lower bounds. To improve the efficiency, we further proposed an iteratively bound- </span></p><p class="c4"><span class="c2">path: A* search meets graph theory. In Proc. of SODA&rsquo;05, 2005. [17] D. Hermelin, A. Levy, O. Weimann, and R. Yuster. Distance </span></p><p class="c33"><span class="c2">oracles for vertex-labeled graphs. In Proc. of ICALP&rsquo;11, 2011. ing approach to tightening lower bounds of subspaces which is achieved by lower bound testing. Moreover, we proposed index structures to significantly reduce the exploration area of a graph in </span></p><p class="c4"><span class="c5">10</span><span class="c20">2 </span></p><p class="c4"><span class="c28">10 </span></p><p class="c33"><span class="c5">1</span><span class="c2">[18] J. Hershberger, M. Maxel, and S. Suri. Finding the k shortest simple paths: A new algorithm and its implementation. ACM Transactions on Algorithms, 3(4), 2007. lower bound testing. We conducted extensive performance studies </span></p><p class="c4"><span class="c2">[19] W. Hoffman and R. Pavley. A method for the solution of the using real road networks, and demonstrated that our proposed ap- </span></p><p class="c4"><span class="c2">nth best path problem. J. ACM, 6, October 1959. proaches significantly outperform the baseline approaches for KPJ </span></p><p class="c4"><span class="c2">[20] C. S. Jensen, J. Kol&aacute;rvr, T. B. Pedersen, and I. Timko. queries. Furthermore, our approaches can be immediately used to </span></p><p class="c4"><span class="c2">Nearest neighbor queries in road networks. In Proc. of process KSP queries, and they also outperform the state-of-the-art </span></p><p class="c4"><span class="c2">GIS&rsquo;03, 2003. algorithm for KSP queries by several orders of magnitude. </span></p><p class="c4"><span class="c2">[21] D. E. Knuth. The Art of Computer Programming, Volume III: </span></p><p class="c4"><span class="c2">Acknowledgements. Lijun Chang is supported by ARC DE150100563. Xuemin Lin is supported by NSFC61232006, ARC DP120104168, ARC DP140103578, and ARC DP150102728. Lu Qin is supported by ARC DE140100999. Jeffrey Xu Yu is supported by Research Grants Council of the Hong Kong SAR, China, 14209314 and 418512. Jian Pei is supported in part by an NSERC Discovery grant. </span></p><p class="c92"><span class="c2">Sorting and Searching. Addison-Wesley, 1973. [22] M. R. Kolahdouzan and C. Shahabi. Voronoi-based k nearest </span></p><p class="c4"><span class="c2">neighbor search for spatial network databases. In Proc. of VLDB&rsquo;04, 2004. [23] S. Nutanong and H. Samet. Memory-efficient algorithms for </span></p><p class="c33"><span class="c2">spatial network queries. In Proc. of ICDE&rsquo;13, 2013. [24] M. M. B. Pascoal. Implementations and empirical </span><span class="c42">9. </span><span class="c2">[1] H. </span><span class="c42">REFERENCES </span></p><p class="c4"><span class="c2">Aljazzar and S. Leue. K</span><span class="c31">*</span><span class="c2">: A heuristic search algorithm for finding the k shortest paths. Artif. Intell., 175(18):2129&ndash;2154, 2011. [2] R. Bellman and R. Kalaba. On kth best policies. Journal of </span></p><p class="c4"><span class="c2">the Society for Industrial and Applied Mathematics, 1960. [3] J. Berclaz, F. Fleuret, E. T&uuml;retken, and P. Fua. Multiple </span></p><p class="c4"><span class="c2">object tracking using k-shortest paths optimization. IEEE Trans. Pattern Anal. Mach. Intell., 33(9), 2011. [4] X. Cao, G. Cong, and C. S. Jensen. Retrieving top-k </span></p><p class="c4"><span class="c2">prestige-based relevant spatial web objects. PVLDB, 3(1), 2010. [5] X. Cao, G. Cong, C. S. Jensen, and B. C. Ooi. Collective </span></p><p class="c4"><span class="c2">spatial keyword querying. In Proc. of SIGMOD&rsquo;11, 2011. [6] S. Chechik. Improved distance oracles for vertex-labeled </span></p><p class="c4"><span class="c2">graphs. CoRR, abs/1109.3114, 2011. informal publication. </span></p><p class="c4"><span class="c28">10 </span></p><p class="c4"><span class="c5">1</span><span class="c2">comparison of k shortest loopless path algorithms, Nov. 2006. [25] D. Quercia, R. Schifanella, and L. M. Aiello. The shortest </span></p><p class="c4"><span class="c2">path to happiness: Recommending beautiful, quiet, and happy routes in the city. In Proc. of Hypertext&rsquo;14, 2014. [26] Y.-K. Shih and S. Parthasarathy. A single source k-shortest paths algorithm to infer regulatory pathways in a gene network. Bioinformatics, 28(12), 2012. [27] P. Venetis, H. Gonzalez, C. S. Jensen, and A. Y. Halevy. </span></p><p class="c4"><span class="c2">Hyper-local, directions-based ranking of places. PVLDB, 4(5), 2011. [28] J. Y. Yen. Finding the k shortest loopless paths in a network. </span></p><p class="c4"><span class="c2">Management Science, 17, 1971. [29] C. Zhang, Y. Zhang, W. Zhang, and X. Lin. Inverted linear </span></p><p class="c4"><span class="c2">quadtree: Efficient top k spatial keyword search. In Proc. of ICDE&rsquo;13, 2013. </span></p><p class="c4"><span class="c2">[7] E. Cohen, E. Halperin, H. Kaplan, and U. Zwick. </span></p><p class="c4"><span class="c2">Reachability and distance queries via 2-hop labels. SIAM J. Comput., 32(5), 2003. </span></p><p class="c4"><span class="c41">144 </span></p></body></html>