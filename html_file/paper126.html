<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c97{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.2pt;font-family:"Arial";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Arial";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Courier New";font-style:normal}.c58{margin-left:-17.1pt;padding-top:2.2pt;text-indent:27.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.4pt}.c40{margin-left:-16.1pt;padding-top:0.7pt;text-indent:46.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:45.5pt}.c84{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.3pt;font-family:"Courier New";font-style:normal}.c15{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Arial";font-style:normal}.c73{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Arial";font-style:normal}.c80{margin-left:-17.1pt;padding-top:1.9pt;text-indent:27.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.4pt}.c51{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:6.1pt;font-family:"Times New Roman";font-style:normal}.c18{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:6pt;font-family:"Arial";font-style:normal}.c50{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.3pt;font-family:"Courier New";font-style:normal}.c23{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.2pt;font-family:"Times New Roman";font-style:normal}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Arial";font-style:normal}.c37{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.5pt;font-family:"Arial";font-style:normal}.c29{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7pt;font-family:"Arial";font-style:normal}.c49{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:3.6pt;font-family:"Arial";font-style:normal}.c14{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10.9pt;font-family:"Arial";font-style:normal}.c9{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:11.6pt;font-family:"Arial";font-style:normal}.c61{margin-left:-18.5pt;padding-top:2.2pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.8pt}.c107{margin-left:-16.9pt;padding-top:2.2pt;text-indent:27pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.4pt}.c33{margin-left:-19pt;padding-top:10.8pt;text-indent:19.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.4pt}.c74{margin-left:-16.1pt;padding-top:4.1pt;text-indent:23.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:9pt}.c11{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12.1pt;font-family:"Arial";font-style:normal}.c81{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10.4pt;font-family:"Times New Roman";font-style:normal}.c30{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:9.1pt;font-family:"Arial";font-style:normal}.c17{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7pt;font-family:"Courier New";font-style:normal}.c55{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:7.2pt;font-family:"Times New Roman";font-style:normal}.c54{margin-left:-17.1pt;padding-top:1.9pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.4pt}.c42{margin-left:-17.4pt;padding-top:118.8pt;text-indent:20.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:32.9pt}.c68{margin-left:-18.5pt;padding-top:2.2pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.2pt}.c60{margin-left:-16.9pt;padding-top:11pt;text-indent:27pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.2pt}.c20{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:7pt;font-family:"Courier New";font-style:normal}.c12{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.3pt;font-family:"Arial";font-style:normal}.c35{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c38{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.9pt;font-family:"Arial";font-style:normal}.c111{margin-left:-17.1pt;padding-top:12.2pt;text-indent:17.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19pt}.c52{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.3pt;font-family:"Arial";font-style:normal}.c22{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:6.2pt;font-family:"Times New Roman";font-style:normal}.c63{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.2pt;font-family:"Arial";font-style:normal}.c66{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:9.1pt;font-family:"Courier New";font-style:normal}.c16{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5pt;font-family:"Arial";font-style:normal}.c56{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:12.1pt;font-family:"Courier New";font-style:normal}.c91{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8.5pt;font-family:"Arial";font-style:normal}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11.6pt;font-family:"Arial";font-style:normal}.c93{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.5pt;font-family:"Courier New";font-style:normal}.c104{margin-left:-16.9pt;padding-top:2.2pt;text-indent:27pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19pt}.c92{margin-left:-18.5pt;padding-top:1.9pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.6pt}.c47{margin-left:-18.7pt;padding-top:2.2pt;text-indent:28.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.6pt}.c39{margin-left:-19pt;padding-top:2.2pt;text-indent:28.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.8pt}.c90{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Courier New";font-style:normal}.c34{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.5pt;font-family:"Arial";font-style:normal}.c45{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:9.1pt;font-family:"Arial";font-style:normal}.c114{margin-left:-16.9pt;padding-top:18.5pt;text-indent:27pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.4pt}.c13{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c53{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8.6pt;font-family:"Arial";font-style:normal}.c24{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Arial";font-style:normal}.c72{margin-left:-17.1pt;padding-top:2.2pt;text-indent:27.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.2pt}.c10{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Courier New";font-style:normal}.c27{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Courier New";font-style:normal}.c26{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.9pt;font-family:"Arial";font-style:normal}.c65{margin-left:-16.9pt;padding-top:2.2pt;text-indent:27pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18.7pt}.c28{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12.1pt;font-family:"Courier New";font-style:normal}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.1pt;font-family:"Times New Roman";font-style:normal}.c105{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:17.2pt;font-family:"Arial";font-style:normal}.c31{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:13.3pt;font-family:"Arial";font-style:normal}.c82{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.6pt;font-family:"Arial";font-style:normal}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:12.1pt;font-family:"Arial";font-style:normal}.c77{margin-left:-18.7pt;padding-top:1.9pt;text-indent:28.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.6pt}.c85{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10.2pt;font-family:"Times New Roman";font-style:normal}.c71{margin-left:-17.4pt;padding-top:5.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:18.7pt}.c32{margin-left:-18.5pt;padding-top:18.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-18.8pt}.c108{margin-left:-19.2pt;padding-top:5.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:52.7pt}.c88{margin-left:-19.2pt;padding-top:8.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:116.3pt}.c89{margin-left:-19.2pt;padding-top:5.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:138.6pt}.c70{margin-left:-18.5pt;padding-top:8.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.6pt}.c21{margin-left:-16.9pt;padding-top:50.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18.2pt}.c67{margin-left:-23.8pt;padding-top:737.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-24pt}.c86{margin-left:-16.1pt;padding-top:5.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:100.2pt}.c48{margin-left:-16.9pt;padding-top:23.5pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.4pt}.c62{margin-left:-14.2pt;padding-top:4.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:35.5pt}.c109{margin-left:-13.9pt;padding-top:31.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:100.5pt}.c87{margin-left:-18.7pt;padding-top:12.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.6pt}.c98{margin-left:-17.1pt;padding-top:17.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.4pt}.c44{margin-left:-8.6pt;padding-top:4.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:40.5pt}.c95{margin-left:-18.5pt;padding-top:13pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.9pt}.c103{margin-left:218.6pt;padding-top:53.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-35.4pt}.c96{margin-left:-18.7pt;padding-top:30pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.8pt}.c41{margin-left:-18.5pt;padding-top:22.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.6pt}.c99{margin-left:218.6pt;padding-top:612.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:218.6pt}.c110{margin-left:65.5pt;padding-top:10.6pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:64.8pt}.c112{margin-left:-16.9pt;padding-top:13.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:45.6pt}.c75{margin-left:-8.2pt;padding-top:2.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-20.4pt}.c3{margin-left:-18.5pt;padding-top:9.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.8pt}.c79{margin-left:-16.9pt;padding-top:49.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18.2pt}.c76{margin-left:-13.9pt;padding-top:10.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:95.7pt}.c59{margin-left:-18.5pt;padding-top:142.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.2pt}.c36{margin-left:218.6pt;padding-top:51.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-35.4pt}.c57{margin-left:47.2pt;padding-top:27.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:107.3pt}.c100{padding-top:1.9pt;text-indent:27pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c25{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c7{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c113{padding-top:2.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c19{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c8{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c46{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c101{margin-left:-18.5pt;text-indent:28.3pt;margin-right:-17.6pt}.c83{margin-left:239.8pt;text-indent:-232.3pt;margin-right:10.8pt}.c69{margin-left:-16.9pt;margin-right:-18pt}.c78{margin-left:107.4pt;margin-right:-18pt}.c106{margin-left:-8.5pt;margin-right:-9.6pt}.c94{margin-left:241.9pt;margin-right:-205.5pt}.c64{margin-left:-12.1pt;margin-right:102.2pt}.c102{margin-left:-14.6pt;margin-right:-13.2pt}.c43{margin-left:91.8pt;margin-right:91.4pt}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:24pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:14pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c46"><p class="c67"><span class="c13">Series ISSN: 2367-2005 313 </span><span class="c90">10.5441/002/edbt.2018.28 </span></p><p class="c8 c102"><span class="c105">TPStream: Low-Latency Temporal Pattern Matching on Event Streams </span></p><p class="c110"><span class="c35">Michael K&ouml;rber Nikolaus Glombiewski Bernhard Seeger </span><span class="c73">Database Systems Group, University of Marburg {koerberm,glombien,seeger}@mathematik.uni-marburg.de </span></p><p class="c70"><span class="c14">ABSTRACT </span><span class="c1">Complex Event Processing (CEP) has emerged as the state-of- the-art technology for continuously monitoring and analyzing streams of events in time-critical applications. The key feature in CEP is sequential pattern matching to detect a user-defined sequence of conditions on event streams. However, many CEP applications are not restricted to events only, but require native support for situations (aggregated event data lasting periods of time) and expressive temporal pattern matching among these situations. These important requirements regarding situations are not sufficiently addressed in the CEP literature so far. </span></p><p class="c61"><span class="c1">In this paper we present TPStream, a novel event-processing operator for both deriving situations from event streams and detecting temporal patterns among situations. First, we provide a formal foundation of situations and TPStream. Then, we propose a low-latency algorithm for TPStream that delivers situations and temporal matches at the earliest possible point in time. Further- more, we utilize a simple, yet effective cost model in order to adapt to changing workloads on the fly and with negligible cost for migrating operator states. The results of our experimental evalu- ation show that TPStream is capable of processing high-volume event streams with low latency and outperforms applicable CEP solutions from academia and industry. </span></p><p class="c32"><span class="c14">1 INTRODUCTION </span><span class="c1">During the last decade, Complex Event Processing (CEP) has emerged to the technology of choice for analyzing massive streams of events in near real time. Typically, CEP systems detect com- posite (complex) events by combining, aggregating and filtering streams of simple or other composite events and report matches to registered event sinks. In turn, these sinks react to the detected event by triggering appropriate actions in a timely manner. CEP can be applied to a wide variety of application domains, including IT infrastructure monitoring, traffic monitoring, health care and financial applications. </span></p><p class="c47"><span class="c1">Problem Statement: A noticeable fraction of currently avail- able CEP systems is build upon point based temporal semantics. That is, each event is associated with a timestamp (e.g., the mo- ment a measurement was made) and event streams are ordered accordingly. With only a single timestamp the expressible tem- poral relations between two events are limited to before/after/at the same time relationships. However, many real-world scenar- ios comprise the detection of complex temporal patterns among situations lasting for periods of time. Consider the following traffic-monitoring application: </span></p><p class="c101 c113"><span class="c1">Example: A traffic monitoring system is continuously receiv- ing sensor data from connected cars (i.e., position, speed, accelera- tion). One of the systems goals is to notify drivers about potential </span></p><p class="c95"><span class="c17">&copy; </span><span class="c29">2018 Copyright held by the owner/author(s). Published in Proceedings of the 21st International Conference on Extending Database Technology (EDBT), March 26-29, 2018, ISBN 978-3-89318-078-3 on OpenProceedings.org. Distribution of this paper is permitted under the terms of the Creative Commons license CC-by-nc-nd 4.0. </span></p><p class="c7 c106"><span class="c1">Figure 1: Detecting aggressive driving with situations </span></p><p class="c48"><span class="c1">dangers around their locations, such as an aggressively driving car. Among others, the American Automobile Association has identified the following two actions being indicators for aggres- sive driving</span><span class="c0">1</span><span class="c1">: &ldquo;Operating the vehicle in an erratic, reckless, careless, or negligent manner or suddenly changing speeds&quot; and &ldquo;Driving too fast for conditions or in excess of posted speed limit&quot;. From these definitions, a pattern to detect aggressive drivers could be stated as: &ldquo;A sharp acceleration followed by hard braking, both accompanied by a period of speeding.&quot; </span></p><p class="c80"><span class="c1">Challenges: This example illustrates three key-features a so- lution for temporal pattern matching on instantaneous events should provide: (i) Situations are derived from point events on- the fly, by identifying subsequences of the input stream for which the defined condition holds true (e.g., </span><span class="c5">speed </span><span class="c1">&#261; 70 </span><span class="c5">mph</span><span class="c1">). Optional constraints can be applied to restrict the duration of situations. In addition to its validity (expressed as a time interval), a situation is enriched with meaningful summarizations of underlying events (e.g., the average speed of the speeding phase). (ii) The pattern language offers support for alternatives. That is, the order of the situations&rsquo; start and end points is not required to be fully fixed. Consider, for example, the two matches sketched in Figure 1: In the first match, the three defined situations overlap, while in the second match deceleration happens during the speeding situation. (iii) The pattern should be detected with the lowest possible latency. As depicted in Figure 1, both matches may be concluded at the beginning of the deceleration situation, since at this point in time speeding still holds true and the pattern allows any combination of their endpoints. Technically, this means the system should be able to conclude a successful match without exact knowledge about the validity of all situations. </span></p><p class="c58"><span class="c1">State-of-the-Art:To the best of our knowledge, the only work on complex temporal relations in event stream pattern matching is the ISEQ operator [20]. However, ISEQ has several shortcom- ings concerning the desired features: First, the operator expects interval-events (i.e., situations) as input, leaving all aspects of (i) to an unspecified external entity. Being unaware of the origin of interval-events severally limits the operator in processing power (in terms of plan optimization) and most importantly renders a detection with the lowest possible latency (iii) impossible since there is no way to directly access an incomplete situation or indi- rectly manipulate the building of a situation through constraints. </span></p><p class="c112"><span class="c34">1</span><span class="c31">http://www.iii.org/fact-statistic/aggressive-driving </span></p><p class="c87"><span class="c1">Second, a temporal pattern is specified using a conjunction of endpoint relationships (i.e., an ordering on start (ts) and end (te) of intervals). This way, alternatives are expressed by omitting one or more endpoints. For example, the pattern </span><span class="c5">A.ts </span><span class="c1">&#259; </span><span class="c5">B.ts </span><span class="c1">&#259; </span><span class="c5">A.te </span><span class="c1">&#271; </span><span class="c5">B.te </span><span class="c1">_ </span><span class="c5">A.ts </span><span class="c1">&#259; </span><span class="c5">B.ts </span><span class="c1">&#259; </span><span class="c5">B.te </span><span class="c1">&#259; </span><span class="c5">A.te </span><span class="c1">on two situations </span><span class="c5">A </span><span class="c1">and </span><span class="c5">B </span><span class="c1">is expressed as </span><span class="c5">A.ts </span><span class="c1">&#259; </span><span class="c5">B.ts </span><span class="c1">&#259; </span><span class="c5">A.te</span><span class="c1">. Hence, disjunctions like </span><span class="c5">A.ts </span><span class="c1">&#259; </span><span class="c5">B.ts </span><span class="c1">&#259; </span><span class="c5">A.te </span><span class="c1">&#259; </span><span class="c5">B.te </span><span class="c1">_ </span><span class="c5">B.ts </span><span class="c1">&#259; </span><span class="c5">A.ts </span><span class="c1">&#259; </span><span class="c5">B.te </span><span class="c1">&#259; </span><span class="c5">A.te </span><span class="c1">are not expressible in a single query. Instead, they require multi- ple queries in an approach without any specified optimization component to detect shared processing opportunities. Finally, ISEQ relies on auxiliary index structures and punctuation mecha- nisms for efficient query execution, complicating the integration into existing systems. </span></p><p class="c47"><span class="c1">Straw Man&rsquo;s Approach: Besides ISEQ, we identified two ap- proaches to solve the task of temporal pattern matching with point event streams. Thus, we can provide a point of comparison to CEP systems featuring pattern matching via regular expres- sions or equivalent techniques. The first approach works in two phases: In the first phase, a pattern matcher is deployed for each defined situation, computing its duration (start/end timestamp) and the desired aggregates. Technically, this means matching pat- terns of the form </span><span class="c5">!S S+ !S </span><span class="c1">with S being derived from the input stream using the situation&rsquo;s condition (e.g., </span><span class="c5">speed </span><span class="c1">&#261; </span><span class="c5">70 mph</span><span class="c1">). This results in a dedicated stream per defined situation. Each of these streams is ordered according to the end timestamp, which allows to map the temporal pattern to a sequence of situations (reflecting the order of end timestamps, possibly containing al- ternatives). In the second phase, a dedicated pattern matching operator is used to find all matching sequences, whereby the proper ordering of start timestamps is checked via additional predicates. Even though this approach satisfies requirements (i) and (ii), it fails to produce early results (iii), because, just like in ISEQ, situations are fully derived before they are available for pattern matching. </span></p><p class="c47"><span class="c1">The second approach uses a single pattern matching opera- tor and expresses the temporal pattern as a single sequence of point events. To express temporal overlaps, the conditions of all involved situations must be connected via a logical </span><span class="c5">AND</span><span class="c1">. For example, </span><span class="c5">Acceleration overlaps Speeding </span><span class="c1">is expressed as </span><span class="c5">A B+ C </span><span class="c1">with the following conditions: </span><span class="c5">A </span><span class="c1">: </span><span class="c5">accel </span><span class="c1">&#261; </span><span class="c5">8 m</span><span class="c1">{</span><span class="c5">s</span><span class="c56">2</span><span class="c1">, </span><span class="c5">C </span><span class="c1">: </span><span class="c5">speed </span><span class="c1">&#261; </span><span class="c5">70 mph </span><span class="c1">and </span><span class="c5">B </span><span class="c1">: </span><span class="c5">A </span><span class="c1">^ </span><span class="c5">C</span><span class="c1">. Since patterns are expressed on the granularity of events, early results (iii) are achieved, by simply omitting the last portion of the pattern. At the same time summarizations of single situations and the validation of duration constraints (i) are left to a post-processing step, since situations are disassembled to express temporal overlaps. </span></p><p class="c92"><span class="c1">Solution: We present TPStream, a holistic operator for com- plex temporal pattern matching on point event streams. Com- pared to the presented approaches, our contributions are: </span></p><p class="c3"><span class="c1">&sbquo; TPStream is the first CEP operator to closely couple derivation of situations with pattern matching, enabling match detection at the earliest possible point in time. &sbquo; We also improve upon existing work on temporal pattern matching (e.g. ISEQ) by allowing arbitrary alternatives and duration constraints in pattern definitions. &sbquo; We introduce an optimizer component for interval-based pat- tern matching which continuously adapts its execution strat- egy to deal with fluctuating data rates and changes in the data distribution of incoming streams. &sbquo; TPStream provides native query support for temporal pattern matching, making it easier to formulate and read temporal </span></p><p class="c7 c69"><span class="c1">patterns in comparison to most existing CEP solutions relying on a straw man&rsquo;s approach. &sbquo; Unlike ISEQ, the operator and its low latency optimizations can easily be implemented in commonly available point-based systems, because time-intervals are used only internally and results are again point event streams. &sbquo; In experiments, we show our latency improvements and the </span></p><p class="c75"><span class="c1">performance limits of two existing CEP solutions from academia and industry when handling situations. We present that TP- Stream can outperform these systems by an order of magnitude and that alternatives, which have great impact on the perfor- mance of sequential pattern matching, influence TPStream&rsquo;s matching performance only marginally. </span></p><p class="c60"><span class="c1">The rest of the paper is organized as follows. Section 2 reviews related work, before we introduce TPStream&rsquo;s query language in section 3. In section 4 we model all aspects of TPStream in an algebra. Efficient evaluation strategies, the algorithm for low- latency matching and our optimization techniques are presented in section 5. We evaluate the performance of TPStream in section 6 and conclude this paper in section 7. </span></p><p class="c98"><span class="c14">2 RELATED WORK </span><span class="c1">So far, native ways to work with situations in systems capable of CEP have not been sufficiently addressed. Nevertheless, the concept can be related to working with time intervals, aggre- gating information and performing temporal joins, all of which have seen recent contributions. Since these are broad areas, we will loosely group the most relevant approaches under three headlines: Event Pattern Matching, Context/State in CEP and Spatio-Temporal Database Systems. </span></p><p class="c72"><span class="c1">Event Pattern Matching: Systems capable of CEP (e.g. [3, 9]) are generally closely associated with a pattern matching operator. [27] features a discussion on the several different semantics of the operator and a recent survey [12] covers several implementations, that employ different techniques such as NFAs or Graphs, each featuring their own unique optimization techniques. Regardless of specific details, most approaches focus on data referring to points in time and thus lack native capabilities to query complex relations between time intervals as stated in [2] - a crucial aspect for dealing with long-lasting situations. Cayuga [8], ZStream [22] and Microsoft StreamInsight [1] are well-known approaches that associate time intervals with data, showcasing the interest in working with interval-based events. ZStream in particular shares similarities with our join-based, adaptive processing approach for pattern matching. However, each of the respective pattern languages is based around a strictly sequential relation (intervali ends before interval j begins) and/or explicitly order-independent relations (conjunction, disjunction). Not only does this limit their respective algorithmic support for complex temporal relations, but, just like point-based systems, formulating derivation queries naturally leads to the straw man&rsquo;s approach mentioned above using Kleene Operators (or FOLDS in [8]). As we will show in our experiments, this approach results in significant performance deficiencies. </span></p><p class="c107"><span class="c1">Context/State in CEP: There has been recent work on intro- ducing contexts into a CEP environment. CAESAR [23] associates queries to long-lasting context windows, detects them from in- coming events as soon as they start and suspends queries of inactive contexts. Similarly, contexts in [11] are used to group up event types to process them together. While contexts and </span></p><p class="c36"><span class="c13">314 </span></p><p class="c7"><span class="c23">Relation (R) Equivalent (R) Visualization </span></p><p class="c7"><span class="c23">A before B B after A </span></p><p class="c8"><span class="c23">A starts B B started-by A A meets B B met-by A A overlaps B B overlapped-by A </span></p><p class="c8"><span class="c23">A during B B contains A A finishes B B finished-by A </span></p><p class="c7"><span class="c23">A equals B </span></p><p class="c19"><span class="c2">Definition (?</span><span class="c55">R</span><span class="c85">) </span><span class="c23">A.ts &lt; A.te &lt; B.ts &lt; B.te A.ts = B.ts &lt; A.te &lt; B.te A.ts &lt; A.te = B.ts &lt; B.te A.ts &lt; B.ts &lt; A.te &lt; B.te B.ts &lt; A.ts &lt; A.te &lt; B.te A.ts &lt; B.ts &lt; A.te = B.te A.ts = B.ts &lt; A.te = B.te </span><span class="c1">Table 1: Allen&rsquo;s Interval Algebra </span></p><p class="c25"><span class="c1">situations are related concepts, the key difference is that con- texts are purposefully decoupled from events. Therefore, it is not possible to query the relation of different contexts to each other. In contrast, TPStream focuses on efficient, adaptive and low-latency implementations of those temporal relations. Like- wise, work on states [18] and on aggregating windows [14, 17] focuses on derivation, but lacks interval relations [2] or pattern matching. </span></p><p class="c25"><span class="c1">Spatio-Temporal Database Systems: The spatial databases community studied the problem of spatio-temporal pattern queries (STPQ) in trajectory databases [10]. In general, these approaches cannot be directly applied to an event processing environment, because they are built on top of a persistent trajectory database model, where movement histories are already stored and indexed in the database. However, the design of [25] in particular served as a foundation for our proposed TPStream operator as TPStream adapts similar concepts of temporal predicates and constraints. Furthermore, our evaluation method is related to temporal joins (see [13] for an excellent survey), but as most of the work is not based in stream processing, unique and important issues such as continuously arriving data, continuous query optimization and early result detection are overlooked. In comparison to join algorithms on streams [6, 15] as well as adaptive approaches [5], TPStream combines both the derivation of situations and the detection of patterns. Thus, the operator can offer new techniques for early result detection unique to CEP-style pattern matching. </span></p><p class="c7"><span class="c14">3 QUERY LANGUAGE </span><span class="c1">In order to express temporal relations between situations, we adopt Allen&rsquo;s Interval Algebra [2] depicted in Table 1 for two generic intervals </span><span class="c5">A </span><span class="c1">and </span><span class="c5">B</span><span class="c1">. Each interval has a starting point (</span><span class="c5">ts</span><span class="c1">) and an ending point (</span><span class="c5">te</span><span class="c1">), resulting in a total of four points. </span><span class="c5">te </span><span class="c1">is the first point in time when the interval is not valid, i.e. the interval is half-open. The relation (R) between </span><span class="c5">A </span><span class="c1">and </span><span class="c5">B </span><span class="c1">is represented through the relation between these four points as given by the definition (&delta;</span><span class="c11">R</span><span class="c1">). As an example depicted in Table 1 </span><span class="c5">A before B </span><span class="c1">means the interval </span><span class="c5">A </span><span class="c1">ends before the interval </span><span class="c5">B </span><span class="c1">begins. Similarly, </span><span class="c5">A during B </span><span class="c1">means </span><span class="c5">A </span><span class="c1">happens during </span><span class="c5">B</span><span class="c1">, because </span><span class="c5">A.ts </span><span class="c1">and </span><span class="c5">A.te </span><span class="c1">are between both points of </span><span class="c5">B</span><span class="c1">. We introduce the TPStream query language by formulating and explaining the query to detect aggressively driving cars from the introductory example in Listing 1. </span></p><p class="c25"><span class="c1">The operator works on streams containing data referring to points in time. In the case of aggressive drivers, we work on a singular stream </span><span class="c5">CS</span><span class="c1">, providing sensor data from cars, which is specified as an input (</span><span class="c5">FROM</span><span class="c1">). This stream is partitioned by the </span><span class="c5">car_id </span><span class="c1">to evaluate each driver individually (</span><span class="c5">PARTITION BY</span><span class="c1">). The important aspect of deriving situations from the stream is handled in the </span><span class="c5">DEFINE </span><span class="c1">clause: The acceleration situation is represented with the symbol </span><span class="c5">A</span><span class="c1">, the condition </span><span class="c5">CS.accel </span><span class="c1">&#261; </span><span class="c5">8 m</span><span class="c1">{</span><span class="c5">s</span><span class="c56">2 </span><span class="c1">and the </span></p><p class="c7"><span class="c20">FROM </span><span class="c17">CarSensors CS </span><span class="c20">PARTITION BY </span><span class="c17">CS.car_id </span><span class="c20">DEFINE </span><span class="c17">A </span><span class="c20">AS </span><span class="c17">CS.accel &gt; 8m/s</span><span class="c66">2 </span><span class="c20">at least </span><span class="c17">5s, </span></p><p class="c8"><span class="c17">B </span><span class="c20">AS </span><span class="c17">CS.speed &gt; 70 mph </span><span class="c20">between </span><span class="c17">4s </span><span class="c20">AND </span><span class="c17">30s, C </span><span class="c20">AS </span><span class="c17">CS.accel &lt; -9m/s</span><span class="c66">2 </span><span class="c20">at least </span><span class="c17">3s </span><span class="c20">PATTERN </span><span class="c17">A </span><span class="c20">meets </span><span class="c17">B;A </span><span class="c20">overlaps </span><span class="c17">B;A </span><span class="c20">starts </span><span class="c17">B;A </span><span class="c20">during </span><span class="c17">B </span></p><p class="c7"><span class="c20">AND </span><span class="c17">C </span><span class="c20">during </span><span class="c17">B;B </span><span class="c20">finishes </span><span class="c17">C;B </span><span class="c20">overlaps </span><span class="c17">C;B </span><span class="c20">meets </span><span class="c17">C </span><span class="c20">AND </span><span class="c17">A </span><span class="c20">before </span><span class="c17">C </span><span class="c20">WITHIN </span><span class="c17">5 MINUTES </span><span class="c20">RETURN first</span><span class="c17">(B.car_id) </span><span class="c20">AS </span><span class="c17">id, </span></p><p class="c7"><span class="c20">avg</span><span class="c17">(B.speed) </span><span class="c20">AS </span><span class="c17">avg_speed; </span></p><p class="c7"><span class="c1">Listing 1: Agressive drivers query </span></p><p class="c25"><span class="c1">(optional) duration constraint </span><span class="c5">AT LEAST 5s</span><span class="c1">, while speeding and deceleration are defined by </span><span class="c5">B </span><span class="c1">and </span><span class="c5">C </span><span class="c1">respectively. The derived situations are analyzed with a </span><span class="c5">PATTERN</span><span class="c1">. For aggressive drivers, an acceleration (</span><span class="c5">A</span><span class="c1">) may </span><span class="c5">meet</span><span class="c1">, </span><span class="c5">overlap</span><span class="c1">, </span><span class="c5">start </span><span class="c1">or occur </span><span class="c5">during </span><span class="c1">a phase of speeding (</span><span class="c5">B</span><span class="c1">). These are alternatives in the pattern definition, separated with semicolons in the query language. The same applies for deceleration (</span><span class="c5">C</span><span class="c1">) and speeding (</span><span class="c5">B</span><span class="c1">). The pattern is fulfilled if at least one of each alternatives is true. We apply a window condition on the evaluation period (</span><span class="c5">WITHIN</span><span class="c1">), specifying that the pattern should only be searched within situations derived in the past 5 minutes. Finally, in case of a match, we </span><span class="c5">RETURN </span><span class="c1">aggregated results from each situation, in this case the </span><span class="c5">car_id </span><span class="c1">and the average </span><span class="c5">speed</span><span class="c1">. </span></p><p class="c7"><span class="c14">3.1 Expressiveness </span><span class="c1">Most common CEP systems define patterns based on symbols connected via regular expressions. Specific extensions, like ag- gregations, put the expressiveness of those languages between regular and context-free grammars [27]. However, only ISEQ pro- vides a native way to process patterns based on temporal relations. This deficit is also reflected in the respective languages. </span></p><p class="c25"><span class="c1">By design, TPStream can express all temporal relations (and un- like ISEQ alternatives among them) in a single query. In contrast, a single pattern matching query in CEP systems is designed to detect a sequence, i.e., a </span><span class="c5">before </span><span class="c1">relation. Nevertheless, as shown by both straw man&rsquo;s approaches in our introduction, in a system supporting Kleene-closure it is possible to express other temporal relations through either multiple queries (decoupling derivation and detection) or a single query (without aggregation capabilities and the validation of duration constraints). Thus, our language does not express more than the full language of other systems. </span></p><p class="c25"><span class="c1">Instead, we focus on enabling the user to express complex temporal patterns in a single, readable and maintainable query via the widely-known interval algebra (Table 1). For this pur- pose, we made two notable design choices that differ from some sequence-based approaches. First, some languages [27] allow to skip events while matching. In contrast, we derive the longest possible contiguous sequence of events, because this aligns well with the idea of long lasting situations and avoids ambiguity whether a situations is still ongoing during other events. Second, some languages [9] allow symbols to access aggregates of other symbols. Due to ambiguity in the expected results when dealing with situations, we do not allow this. For example, consider mod- ifying the definition for symbol </span><span class="c5">B </span><span class="c1">in Listing 1 to </span><span class="c5">B AS CS.speed &gt; max(A.speed)</span><span class="c1">. Then, for </span><span class="c5">A overlaps B </span><span class="c1">it is unclear whether </span><span class="c5">max(A.speed) </span><span class="c1">is accessed when </span><span class="c5">A </span><span class="c1">finishes, when </span><span class="c5">B </span><span class="c1">starts or is continuously monitored for each </span><span class="c5">B</span><span class="c1">. For a precise presentation of our approach, we chose those two concessions and will work on mitigating them in the future. </span></p><p class="c7"><span class="c13">315 </span></p><p class="c25"><span class="c1">We would also like to sketch that, apart from those concessions, it is possible to express a purely sequence-based pattern with TPStream: A sequence can be expressed with a </span><span class="c5">before </span><span class="c1">relation and the implicit ongoing nature of situations can be eliminated with a duration constraint. Nevertheless, the basis for our im- plementation [19] features a standard sequence-based pattern matching operator that is optimized and thus preferable for this purpose. Similarly, our implementation can be easily integrated into other systems, because TPStream consumes and produces point-based event streams. In conclusion, this means that we do not change the expressiveness of other approaches, but by extending a query language with Allen&rsquo;s Interval Algebra, our benefits can be almost universally adopted. </span></p><p class="c7"><span class="c14">4 ALGEBRA </span><span class="c1">The goal in designing TPStream is to develop an operator capable of continuously deriving situations from a stream of events and relate those situations to each other. To achieve this, we need to be able to express both the derivation and relation. For this purpose, we will formally model those aspects (streams, data, deriving situations and temporal pattern matching) in an algebra. </span></p><p class="c7"><span class="c14">4.1 Stream Model </span><span class="c1">Definition 1 (Data Stream). A data stream D is a potentially unbounded sequence of data items xd</span><span class="c12">1</span><span class="c5">,</span><span class="c1">d</span><span class="c12">2</span><span class="c5">, ...</span><span class="c1">y totally ordered by a relation &#259;</span><span class="c11">D</span><span class="c1">. d</span><span class="c11">i </span><span class="c24">P D refers to the i-th data item in the stream </span><span class="c1">according to that order and all data items are from the same domain D. xy refers to an empty data stream. </span></p><p class="c25"><span class="c1">In order to refer to multiple data streams, we will utilize the notation D</span><span class="c0">1</span><span class="c5">, </span><span class="c1">D</span><span class="c0">2</span><span class="c5">, </span><span class="c1">D</span><span class="c0">3</span><span class="c5">,... </span><span class="c1">with D</span><span class="c0">i </span><span class="c1">&ldquo; xd</span><span class="c0">i</span><span class="c12">1</span><span class="c27">,</span><span class="c4">d</span><span class="c0">i</span><span class="c12">2</span><span class="c27">,...</span><span class="c4">y, i.e. a superscript </span><span class="c1">labels separate streams, while a subscript refers to the order within a stream. For the sake of simplicity and legibility, we will generally assume that each item in a data stream is unique and refer to previous work on the matter of handling potentially equal elements [8]. xy is mainly used to specify the case of no output in upcoming definitions. </span></p><p class="c25"><span class="c1">Definition 2 (Continuous Subsequence). Based on a data stream D, D</span><span class="c6">r</span><span class="c11">i,j</span><span class="c6">s </span><span class="c1">&ldquo; xd</span><span class="c12">i</span><span class="c5">,...,</span><span class="c1">d</span><span class="c12">j</span><span class="c1">y with i &#259; j refers to a continuous subse- quence containing every data item as it pertains to &#259;</span><span class="c11">D</span><span class="c24">. </span></p><p class="c25"><span class="c1">Definition 3 (Union). The union Z of two data streams D</span><span class="c0">1 </span><span class="c1">and D</span><span class="c0">2 </span><span class="c1">both totally ordered with &#259;</span><span class="c11">D </span><span class="c24">results in a data stream D</span><span class="c29">1 </span><span class="c24">with </span><span class="c1">the same order &#259;</span><span class="c11">D</span><span class="c1">: </span></p><p class="c7"><span class="c1">ZpD</span><span class="c0">1</span><span class="c5">,</span><span class="c1">D</span><span class="c0">2</span><span class="c1">q :&ldquo; D</span><span class="c9">1 </span><span class="c1">&ldquo; xd</span><span class="c9">1</span><span class="c12">1</span><span class="c27">,</span><span class="c4">d</span><span class="c9">1</span><span class="c12">2</span><span class="c27">,...</span><span class="c4">y </span></p><p class="c25"><span class="c1">such that D</span><span class="c9">1 </span><span class="c1">contains each element from both D</span><span class="c0">1 </span><span class="c1">and D</span><span class="c0">2</span><span class="c1">. Anal- ogous to set theory, the union of n data streams D</span><span class="c0">1</span><span class="c5">,... </span><span class="c1">D</span><span class="c0">n </span><span class="c1">is abbreviated with the notation </span><span class="c4">&#354;</span><span class="c12">n</span><span class="c11">i</span><span class="c6">&ldquo;</span><span class="c11">1 </span><span class="c1">D</span><span class="c0">i</span><span class="c1">. </span></p><p class="c7"><span class="c14">4.2 Data Model </span><span class="c1">Our operator involves two kinds of data which we need to define: events and situations. In general, events refer to a notification that something happened instantaneously at exactly one point in time while situations span multiple points in time and contain aggregated information for that time period. </span></p><p class="c25"><span class="c1">Definition 4 (Event). An event e is a pair pp</span><span class="c5">,</span><span class="c1">tq consisting of a payload p and an event timestamp t. p is from some domain D and t is from a discrete and totally ordered time domain T. The validity of p is the instant t. </span></p><p class="c25"><span class="c1">Definition 5 (Situation). A situation s is a triple pp</span><span class="c5">,</span><span class="c1">ts</span><span class="c5">,</span><span class="c1">teq con- sisting of a payload p and two timestamps: ts (start timestamp) and te (end timestamp). p is from some domain D. ts and te are from a discrete and totally ordered time domain T with ts &#259; te. The half-open time interval rts</span><span class="c5">,</span><span class="c1">teq specifies the validity of p. </span></p><p class="c25"><span class="c1">Event streams are ordered by the event timestamp and will be represented with E. Situation streams are ordered by the end timestamp of situations and will be represented with S. We focus our efforts on presenting algorithms for streams with data arriving in-order and leave the adjustment to out-of-order data by adapting previous research on out-of-order pattern matching [7, 21] for future work. </span></p><p class="c7"><span class="c14">4.3 Derivation </span><span class="c1">Situations are derived from event streams through aggregation and predicate evaluation. We will first formally define aggrega- tion on continuous event subsequences before deliberating on predicates and how to derive situation streams. Definition 6 (Aggregated Event Subsequence). An aggregate &gamma;</span><span class="c12">a&#1076;&#1076; </span><span class="c1">is applied to an event stream subsequence E</span><span class="c6">r</span><span class="c11">i,j</span><span class="c6">s </span><span class="c1">by applying the aggregate a&#1076;&#1076; to the events in the subsequence: </span></p><p class="c7"><span class="c1">&gamma;</span><span class="c11">a&#1076;&#1076;</span><span class="c24">pE</span><span class="c6">r</span><span class="c11">i,j</span><span class="c6">s</span><span class="c1">q :&ldquo; pa&#1076;&#1076;pe</span><span class="c11">i</span><span class="c10">,...,</span><span class="c24">e</span><span class="c11">j</span><span class="c24">q</span><span class="c10">,</span><span class="c24">e</span><span class="c11">i</span><span class="c10">.</span><span class="c24">ts</span><span class="c10">,</span><span class="c24">e</span><span class="c11">j</span><span class="c6">`</span><span class="c11">1</span><span class="c10">.</span><span class="c24">tsq </span><span class="c1">When obvious from context, we abbreviate &gamma;</span><span class="c11">a&#1076;&#1076; </span><span class="c24">with &gamma;. </span></p><p class="c7"><span class="c1">The result in Definition 6 technically already is a situation. However, for the derivation process as a whole, we want to discover situations for which a set of circumstances hold true. In order to provide an unambiguous process to identify these situations we are looking for the longest possible sequences for which these circumstances apply. Definition 7 (Derived Situation). Situations are derived with a function derive</span><span class="c11">&phi;,&tau;,&gamma; </span><span class="c1">which aggregates information of a con- tinuous event subsequence E</span><span class="c6">r</span><span class="c11">i,j</span><span class="c6">s </span><span class="c1">by applying &gamma; iff the events in E</span><span class="c6">r</span><span class="c11">i,j</span><span class="c6">s </span><span class="c1">are the longest possible sequence of events to fulfill a given predicate &phi; and the covered timespan is within the given duration constraint &tau; :&ldquo; rd</span><span class="c12">min</span><span class="c5">,</span><span class="c1">d</span><span class="c12">max</span><span class="c1">s: </span></p><p class="c7"><span class="c1">derive</span><span class="c11">&phi;,&gamma;,&tau; </span><span class="c1">pE</span><span class="c6">r</span><span class="c11">i,j</span><span class="c6">s</span><span class="c1">q &ldquo; </span></p><p class="c7"><span class="c1">$</span><span class="c24">&rsquo;&rsquo;&rsquo;&amp;</span><span class="c1">&gamma;pE</span><span class="c6">r</span><span class="c11">i,j</span><span class="c6">s</span><span class="c1">q if </span><span class="c24">&rsquo;&rsquo;&rsquo;%</span><span class="c1">@l P ri</span><span class="c5">, </span><span class="c1">js : &phi;pe</span><span class="c11">l</span><span class="c1">q^ </span></p><p class="c19"><span class="c1">!&phi;pe</span><span class="c11">i</span><span class="c6">&nbsp;&#769;</span><span class="c11">1</span><span class="c24">q^!&phi;pe</span><span class="c11">j</span><span class="c6">`</span><span class="c11">1</span><span class="c24">q^ </span><span class="c1">pe</span><span class="c11">j</span><span class="c6">`</span><span class="c11">1</span><span class="c10">.</span><span class="c24">ts &nbsp;&#769; e</span><span class="c11">i</span><span class="c10">.</span><span class="c24">tsq P &tau; </span><span class="c1">xy otherwise </span></p><p class="c7"><span class="c1">Example. Assume the query in Listing 1 derives a speeding situation for a car with the time interval r2</span><span class="c5">, </span><span class="c1">10q. This means </span><span class="c5">CS.speed </span><span class="c1">&#271; </span><span class="c5">70 mph </span><span class="c1">at t &ldquo; 1 and t &ldquo; 10 and in between those timestamps </span><span class="c5">CS.speed </span><span class="c1">&#261; </span><span class="c5">70 mph</span><span class="c1">. From an algebraic standpoint, assuming knowledge about the whole event stream, this aligns well with a natural interpretation: There are not multiple situa- tions (e.g. r2</span><span class="c5">, </span><span class="c1">3q</span><span class="c5">, </span><span class="c1">r2</span><span class="c5">, </span><span class="c1">4q</span><span class="c5">,...</span><span class="c1">) but rather one continuous speeding phase which fulfills the duration constraint (d</span><span class="c11">min </span><span class="c24">&ldquo; 4s and </span><span class="c1">d</span><span class="c12">max </span><span class="c1">&ldquo; 30s). For that reason and because it results in unique situations, we choose to derive the longest possible subsequence in Definition 7. Definition 8 (Derived Situation Stream). ThederiveStream</span><span class="c11">&phi;,&gamma;,&tau; </span><span class="c24">function derives a stream of situations from a given event stream </span><span class="c1">E by applying the function derive</span><span class="c11">&phi;,&gamma;,&tau; </span><span class="c1">to all possible subse- quences and unifying the results: </span></p><p class="c7"><span class="c1">deriveStream</span><span class="c11">&phi;,&gamma;,&tau; </span><span class="c1">pEq &ldquo; </span><span class="c4">&#283;</span><span class="c12">j </span></p><p class="c7"><span class="c24">&#283;</span><span class="c12">j</span><span class="c11">i</span><span class="c6">&ldquo;</span><span class="c11">1</span><span class="c1">derive</span><span class="c11">&phi;,&gamma;,&tau; </span><span class="c1">pE</span><span class="c6">r</span><span class="c11">i,j</span><span class="c6">s</span><span class="c1">q </span></p><p class="c7"><span class="c13">316 </span></p><p class="c25"><span class="c1">Note that, due to assumption that each event in an event stream has a unique timestamp and the fact that derive</span><span class="c11">&phi;,&gamma;,&tau; </span><span class="c24">derives the longest situations possible, it is easy to show that </span><span class="c1">deriveStream</span><span class="c11">&phi;,&gamma;,&tau; </span><span class="c1">produces a stream of situations with disjoint time intervals. This implies, that the order of situations using start timestamps is the same as the order using end timestamps, resulting in a beneficial pattern for query processing [16]. Due to space limitations, we omit a formal proof here. </span></p><p class="c7"><span class="c14">4.4 Pattern Matching </span><span class="c1">TPStream matches multiple situation streams to a temporal pat- ternand produces a result event stream according to the given def- initions. A temporal pattern is composed of temporal constraints between situation streams, which in turn comprise multiple tem- poral relations between exactly two streams. In this section, we present formal definitions of these terms, the output of a success- ful match and ultimately the TPStream operator. </span></p><p class="c25"><span class="c1">Definition 9 (Temporal Relation). Given two situation streams S</span><span class="c0">A</span><span class="c5">,</span><span class="c1">S</span><span class="c0">B</span><span class="c1">, a temporal relation R</span><span class="c0">A,B</span><span class="c1">, defines a valid relationship be- tween two situations s</span><span class="c0">A </span><span class="c1">P S</span><span class="c0">A </span><span class="c1">and s</span><span class="c0">B </span><span class="c1">P S</span><span class="c0">B </span><span class="c1">according to Allen&rsquo;s Interval Algebra (cf. Table 1).s</span><span class="c0">A </span><span class="c1">ands</span><span class="c0">B </span><span class="c1">fulfillR</span><span class="c0">A,B</span><span class="c1">, iff they satisfy the corresponding algebraic definition (&delta;</span><span class="c11">R</span><span class="c1">). </span></p><p class="c25"><span class="c1">Definition 10 (Temporal Constraint). A temporal constraint C</span><span class="c0">A,B </span><span class="c1">between two situation streams S</span><span class="c0">A</span><span class="c5">,</span><span class="c1">S</span><span class="c0">B </span><span class="c1">is a set of temporal relations tR</span><span class="c0">A,B </span><span class="c12">1 </span><span class="c27">, ...,</span><span class="c4">R</span><span class="c0">A,B </span><span class="c12">m </span><span class="c4">u. Two situations s</span><span class="c0">A </span><span class="c1">P S</span><span class="c0">A </span><span class="c1">and s</span><span class="c0">B </span><span class="c1">P S</span><span class="c0">B </span><span class="c1">fulfill C</span><span class="c0">A,B</span><span class="c1">, iff they at least fulfill one of the temporal relations. </span></p><p class="c25"><span class="c1">In other words, temporal constraints allow to specify multi- ple valid relations between two situation streams, providing the desired flexibility in expressing alternatives. </span></p><p class="c25"><span class="c1">Definition 11 (Temporal Pattern). For any number of situation streams pS</span><span class="c0">1</span><span class="c5">, ...,</span><span class="c1">S</span><span class="c0">m</span><span class="c1">q, a temporal pattern (P) is a set of temporal constraints tC</span><span class="c0">i,j</span><span class="c1">|1 &#271; i &#259; j &#271; mu. A temporal pattern is matched by a temporal configuration s &ldquo; ps</span><span class="c0">1 </span><span class="c1">P S</span><span class="c0">1</span><span class="c5">, ...,</span><span class="c1">s</span><span class="c0">m </span><span class="c1">P S</span><span class="c0">m</span><span class="c1">q, iff s satisfies every temporal constraint: </span></p><p class="c7"><span class="c1">match</span><span class="c11">P</span><span class="c1">psq :&ocirc; @C</span><span class="c0">i,j </span><span class="c1">P P : DR</span><span class="c0">i,j </span><span class="c1">P C</span><span class="c0">i,j </span><span class="c1">: &delta;</span><span class="c11">R</span><span class="c34">i</span><span class="c93">, </span><span class="c34">j</span><span class="c1">ps</span><span class="c0">i</span><span class="c5">,</span><span class="c1">s</span><span class="c0">j</span><span class="c1">q </span></p><p class="c25"><span class="c1">Example. Consider the example query of Listing 1 and lets</span><span class="c0">A </span><span class="c1">be an acceleration situation as defined by </span><span class="c5">A </span><span class="c1">and s</span><span class="c0">B</span><span class="c5">,</span><span class="c1">s</span><span class="c0">C </span><span class="c1">be a speed- ing (</span><span class="c5">B</span><span class="c1">) and deceleration (</span><span class="c5">C</span><span class="c1">) situation respectively. The </span><span class="c5">PATTERN </span><span class="c1">describes how pairs of situations in s &ldquo; ps</span><span class="c0">A</span><span class="c5">,</span><span class="c1">s</span><span class="c0">B</span><span class="c5">,</span><span class="c1">s</span><span class="c0">C</span><span class="c1">q can relate to each other via temporal constraints: For s</span><span class="c0">A </span><span class="c1">and s</span><span class="c0">B </span><span class="c1">the temporal relation can be either </span><span class="c5">A meets B</span><span class="c1">, </span><span class="c5">A overlaps B</span><span class="c1">, </span><span class="c5">A starts B </span><span class="c1">or </span><span class="c5">A during B</span><span class="c1">. It does not matter if acceleration overlaps speeding or if speeding contains acceleration. Both cases may lead to the result of detecting aggressive drivers. The temporal pattern on the other hand is a conjunction of temporal constraints: In order to match the pattern, each temporal constraint must be fulfilled. </span></p><p class="c25"><span class="c1">Definition 12 (Pattern Matching Output). A temporal pattern matching operator PM</span><span class="c11">w, &circ;&gamma; </span><span class="c1">matches a temporal configuration s &ldquo; ps</span><span class="c0">1</span><span class="c5">,</span><span class="c1">s</span><span class="c0">2</span><span class="c5">,...,</span><span class="c1">s</span><span class="c0">m</span><span class="c1">qto a temporal pattern P. It aggregates the informa- tion of s with some suitable aggregate &circ;&gamma; and checks the window condition (cf. </span><span class="c5">WITHIN </span><span class="c1">clause): </span></p><p class="c7"><span class="c1">windowps</span><span class="c5">,</span><span class="c1">wq &ldquo; w &#271; max </span><span class="c11">s</span><span class="c6">P</span><span class="c11">s </span><span class="c1">ps</span><span class="c5">.</span><span class="c1">teq &nbsp;&#769; min </span><span class="c11">s</span><span class="c6">P</span><span class="c11">s </span><span class="c1">ps</span><span class="c5">.</span><span class="c1">tsq </span></p><p class="c7"><span class="c1">Figure 2: TPStream Architecture </span></p><p class="c7"><span class="c1">The operator produces an output, if the temporal configuration matches the pattern during the specified window, i.e.: </span></p><p class="c7"><span class="c1">PM</span><span class="c11">w, &circ;&gamma; </span><span class="c1">ps</span><span class="c5">, </span><span class="c1">Pq :&ldquo; </span></p><p class="c19"><span class="c1">$</span><span class="c24">&rsquo;&amp;</span><span class="c1">p&circ;&gamma;psq</span><span class="c5">,</span><span class="c1">max </span><span class="c24">&rsquo;%</span><span class="c1">xy </span><span class="c11">s</span><span class="c6">P</span><span class="c11">s </span><span class="c1">ps</span><span class="c5">.</span><span class="c1">teqq if </span><span class="c4">match</span><span class="c12">P</span><span class="c4">psq^ </span><span class="c1">windowps</span><span class="c5">,</span><span class="c1">wq otherwise </span></p><p class="c25"><span class="c1">Similarly to how we extended derived situations to derived situation streams (Definition 7 to 8), we can extend Definition 12 to situation streams: </span></p><p class="c25"><span class="c1">Definition 13 (TPStream). TPStream</span><span class="c11">w, &circ;&gamma; </span><span class="c1">matches multiple sit- uation streams S</span><span class="c0">1</span><span class="c5">,...,</span><span class="c1">S</span><span class="c0">m </span><span class="c1">to a temporal pattern P by applying the corresponding pattern matching operatorPM</span><span class="c11">w, &circ;&gamma; </span><span class="c1">to the cross product of the situation streams and TPStream</span><span class="c11">w, &circ;&gamma; </span><span class="c1">pS</span><span class="c0">1</span><span class="c5">,...,</span><span class="c1">S</span><span class="c0">m</span><span class="c5">, </span><span class="c1">Pq :&ldquo; unifying </span><span class="c4">&#283; </span></p><p class="c7"><span class="c1">the results: </span></p><p class="c7"><span class="c12">s</span><span class="c29">P</span><span class="c9">&#346;</span><span class="c34">m</span><span class="c30">i</span><span class="c84">&ldquo;</span><span class="c30">1 </span><span class="c12">S</span><span class="c45">i </span></p><p class="c7"><span class="c1">PM</span><span class="c11">w, &circ;&gamma; </span><span class="c1">ps</span><span class="c5">, </span><span class="c1">Pq </span></p><p class="c7"><span class="c1">Note that TPStream</span><span class="c11">w, &circ;&gamma; </span><span class="c1">results in an event stream and can thus easily be integrated into common CEP processing pipelines. </span></p><p class="c7"><span class="c14">5 ALGORITHMS &amp; IMPLEMENTATION </span><span class="c1">In this section, we present our algorithms and implementation details for detecting temporal patterns among streams of point events. Following the definitions from the previous section, the general architecture consists of two main components, as de- picted in Figure 2. The deriver-component consumes events from the input stream and derives the defined situation streams. Then, those streams are passed to the matcher-component, which per- forms the actual pattern matching. In the following two subsec- tions we will explain both components in detail. For the sake of simplicity we defer low latency detection to section 5.3 and initially wait for the end timestamp of derived situations before invoking the matcher. The last part of this section describes how TPStream computes efficient execution plans and dynamically adapts to changing workloads. </span></p><p class="c7"><span class="c14">5.1 Deriving Situations </span><span class="c1">Definition 8 introduced derived situation streams, using knowl- edge about the whole input-stream. To compute situation streams incrementally as new events arrive the deriver-component man- ages a buffer for ongoing situations (B) and the situation stream definitions (D). Algorithm 1 shows how they are used to de- rive situations on-the-fly. For each defined situation, 3 cases are checked: If there is no started situation on the buffer, but the predicate holds true, a new situation is started. Therefore, we compute initial values for all defined aggregates (e.g., </span><span class="c5">p.speed </span><span class="c1">for an </span><span class="c5">max</span><span class="c1">p</span><span class="c5">speed</span><span class="c1">q aggregate). Those values are bundled with the event&rsquo;s timestamp and stored on the buffer (Lines 4,5). The </span></p><p class="c7"><span class="c13">317 </span></p><p class="c76"><span class="c1">Algorithm 1: DeriveSituations </span></p><p class="c44"><span class="c1">Input: pp</span><span class="c5">,</span><span class="c1">tq: event Data: B :&ldquo; rpp</span><span class="c9">1</span><span class="c5">,</span><span class="c1">tsq</span><span class="c12">i</span><span class="c1">s: active situation buffer, </span></p><p class="c40"><span class="c1">D :&ldquo; rp&phi;</span><span class="c5">,</span><span class="c1">&gamma;</span><span class="c5">,</span><span class="c1">&tau;q</span><span class="c11">i</span><span class="c24">s: situation definitions </span><span class="c15">1 </span><span class="c1">R &ETH; H; </span><span class="c15">2 </span><span class="c1">foreach i P |D| do </span><span class="c15">3 </span><span class="c1">p&phi;</span><span class="c5">,</span><span class="c1">&gamma;</span><span class="c5">,</span><span class="c1">&tau;q &ETH; Dris; </span><span class="c15">4 </span><span class="c1">if Bris&ldquo;H^ &phi;ppq then </span><span class="c15">5 </span><span class="c1">Bris&ETH;pinitA&#1076;&#1076;pp</span><span class="c5">,</span><span class="c1">&gamma;q</span><span class="c5">,</span><span class="c1">tq; </span></p><p class="c86"><span class="c15">6 </span><span class="c1">else if &phi;ppq then </span><span class="c15">7 </span><span class="c1">updateAgg(p</span><span class="c5">,</span><span class="c1">Bris</span><span class="c5">,</span><span class="c1">&gamma;); </span></p><p class="c108"><span class="c15">8 </span><span class="c1">else if Bris&permil;H then </span><span class="c15">9 </span><span class="c1">if pt &nbsp;&#769; Bris</span><span class="c5">.</span><span class="c1">tsq P &tau; then </span><span class="c15">10 </span><span class="c1">R &ETH; R Y tpBris</span><span class="c5">.</span><span class="c1">p</span><span class="c9">1</span><span class="c5">,</span><span class="c1">Bris</span><span class="c5">.</span><span class="c1">ts</span><span class="c5">,</span><span class="c1">tqu; </span></p><p class="c89"><span class="c15">11 </span><span class="c1">Bris&ETH;H; </span></p><p class="c88"><span class="c15">12 </span><span class="c1">if R &permil; H then </span><span class="c15">13 </span><span class="c1">updateMatcher(R, t); </span></p><p class="c109"><span class="c1">Algorithm 2: UpdateMatcher </span></p><p class="c74"><span class="c1">Input: S: set of finished situations, t: the current time </span><span class="c15">1 </span><span class="c1">purgeBuffers(t); </span><span class="c15">2 </span><span class="c1">foreach s P S do </span><span class="c15">3 </span><span class="c1">addToBuffer(s); </span><span class="c15">4 </span><span class="c1">performMatch(tsu, 0); </span></p><p class="c96"><span class="c1">temporal validity of a started situation is prolonged, if the current event fulfills the predicate. In this case, the buffered aggregates are updated using the event&rsquo;s payload (p) (Lines 6,7). Finally, a situation is finished on the first event not satisfying the defined predicate. In this case, the situation&rsquo;s end timestamp is fixed to the current time, it is added to the result-set R (provided it satis- fies the duration constraint &tau;) and the corresponding buffer slot is cleared (Lines 8-11). After updating the state of each situation stream, the result-set is passed to the matcher-component (Lines 12,13). </span></p><p class="c33"><span class="c14">5.2 Matching the Pattern </span><span class="c1">The matcher implements an incremental version of Definition 13 (TPStream</span><span class="c11">w, &circ;&gamma; </span><span class="c1">). In other words, it detects matches on-the-fly as new situations are handed over from the deriver-component. The general idea is to employ a buffer for each situation stream and perform the pattern detection via a multi-way join between those buffers, using the temporal constraints as join-conditions. Recap that all situations within a stream are disjoint and thus imply the same order on both the start and end timestamps (Definition 8). We will use this fact to ensure efficient execution of the matcher component. </span></p><p class="c77"><span class="c1">Each time the deriver distills new situations, Algorithm 2 is invoked: At first, expired situations are purged from the buffers (Line 1). That is, removing all situations </span><span class="c5">s</span><span class="c1">with</span><span class="c5">s.ts </span><span class="c1">&#259; </span><span class="c5">t</span><span class="c1">&nbsp;&#769;</span><span class="c5">window</span><span class="c1">. Because of the mentioned ordering, this effectively means, finding the first situation </span><span class="c5">s</span><span class="c9">1 </span><span class="c1">with </span><span class="c5">s</span><span class="c9">1</span><span class="c5">.ts </span><span class="c1">&#283; </span><span class="c5">t </span><span class="c1">&nbsp;&#769; </span><span class="c5">window </span><span class="c1">and discarding all previous events. The buffers are implemented via array-backed ring buffers, which efficiently support these operations. </span></p><p class="c68"><span class="c1">After purging outdated situations, each new situation is first added to its corresponding buffer, before the actual matching </span></p><p class="c7 c64"><span class="c1">Algorithm 3: PerformMatch </span></p><p class="c62"><span class="c1">Input: ws: working-set, sc: current step count Data: order: evaluation order </span><span class="c15">1 </span><span class="c1">if sc &ldquo; order.getNumSteps() then </span><span class="c15">2 </span><span class="c1">publishResult(ws); </span><span class="c15">3 </span><span class="c1">return; </span></p><p class="c71"><span class="c15">4 </span><span class="c1">step &ETH; order.getSteppscq; </span><span class="c15">5 </span><span class="c1">if step.isSet(ws) ^ step.checkConstraints(ws) then </span><span class="c15">6 </span><span class="c1">performMatch(ws,sc ` 1); </span><span class="c15">7 </span><span class="c1">else if !step.isSet(ws) then </span><span class="c15">8 </span><span class="c1">foreach pp</span><span class="c5">,</span><span class="c1">t</span><span class="c11">s</span><span class="c10">,</span><span class="c24">t</span><span class="c11">e</span><span class="c24">q P findMatches(step, ws) do </span><span class="c15">9 </span><span class="c1">ws &ETH; ws Y tpp</span><span class="c5">,</span><span class="c1">t</span><span class="c12">s</span><span class="c5">,</span><span class="c1">t</span><span class="c12">e</span><span class="c1">qu; </span><span class="c15">10 </span><span class="c1">performMatch(ws, sc ` 1); </span><span class="c15">11 </span><span class="c1">ws &ETH; wsz tpp</span><span class="c5">,</span><span class="c1">t</span><span class="c11">s</span><span class="c10">,</span><span class="c24">t</span><span class="c11">e</span><span class="c24">qu; </span></p><p class="c21"><span class="c1">algorithm (Algorithm 3) is invoked (Lines 2-4). We force the new situation to be part of any successful match, by passing it as a parameter. This ensures the desired incremental creation of results, because we pass a new, not yet considered situation on every invocation. </span></p><p class="c54"><span class="c1">The matching algorithm relies on a so called evaluation order, which we describe briefly upfront. An evaluation order deter- mines the order in which situation buffers are joined and provides the required information for each processing step (a reference to the situation buffer and the set of temporal constraints to be ful- filled). Using this information and a partial temporal configuration (working-set), Algorithm 3 matches the temporal pattern as fol- lows: In each step, the corresponding situation buffer is searched for situations satisfying all applicable temporal constraints (Line 8). Applicable means, that the counterpart of the constraint is already present in the working-set. Then, all returned situations are successively added to the working-set and for each of the new partial temporal configurations, the algorithm proceeds to the next step (Lines 9-11). Lines 5 and 6 intercept the evaluation, if the working-set already contains a situation for the current step, which accounts for situations passed as a parameter from Algorithm 2. In this case, the corresponding buffer is ignored and the step&rsquo;s temporal constraints are checked directly. Finally, a match is detected if the working-set contains a situation from ev- ery buffer (Lines 1-3). The publishResult function consumes this working-set, assembles the result and pushes it into the output stream. </span></p><p class="c65"><span class="c1">Obviously, the evaluation performance of Algorithm 3 mainly depends on the efficiency of the findMatches function. A na&iuml;ve approach would be, to scan the entire buffer and check the tem- poral constraints for each situation separately. With R</span><span class="c11">i </span><span class="c24">denoting </span><span class="c1">the i-th intermediate result, B</span><span class="c12">i </span><span class="c1">the buffer traversed in step i and |R</span><span class="c11">1</span><span class="c24">|&ldquo;|B</span><span class="c11">1</span><span class="c24">|, the costs (C) of performMatch following this </span><span class="c1">approach can be estimated with: </span></p><p class="c57"><span class="c1">C &ldquo; |R</span><span class="c12">n</span><span class="c1">| ` </span></p><p class="c7 c43"><span class="c12">n</span><span class="c29">&nbsp;&#769;</span><span class="c12">1</span><span class="c24">&yuml;</span><span class="c11">i</span><span class="c6">&ldquo;</span><span class="c11">1 </span></p><p class="c7 c43"><span class="c12">n</span><span class="c29">&nbsp;&#769;</span><span class="c12">1</span><span class="c24">&yuml;</span><span class="c11">i</span><span class="c6">&ldquo;</span><span class="c11">1 </span></p><p class="c7 c78"><span class="c1">|R</span><span class="c12">i</span><span class="c1">| &#776;|B</span><span class="c12">i</span><span class="c29">`</span><span class="c12">1</span><span class="c1">| (1) </span></p><p class="c7 c78"><span class="c1">|R</span><span class="c12">i</span><span class="c1">| &#776;|B</span><span class="c12">i</span><span class="c29">`</span><span class="c12">1</span><span class="c1">| (1) </span></p><p class="c7 c78"><span class="c1">|R</span><span class="c12">i</span><span class="c1">| &#776;|B</span><span class="c12">i</span><span class="c29">`</span><span class="c12">1</span><span class="c1">| (1) </span></p><p class="c114"><span class="c1">To speed up the computation, we again use the order of situ- ation streams: Because the order is reflected on the buffers, we are able to find all matching situations using binary searches. </span></p><p class="c103"><span class="c13">318 </span></p><p class="c7"><span class="c1">Figure 3: Temporal Matching via Range Queries </span></p><p class="c25"><span class="c1">We first discuss how this is done for a single temporal rela- tion before extending it to (multiple) temporal constraints. Re- call that a temporal relation explicitly defines a relationship be- tween all four endpoints of two situations. For instance, this is </span><span class="c5">A.ts </span><span class="c1">&#259; </span><span class="c5">B.ts </span><span class="c1">&#259; </span><span class="c5">A.te </span><span class="c1">&#259; </span><span class="c5">B.te </span><span class="c1">for </span><span class="c5">A overlaps B</span><span class="c1">. Now, given an instance of situation </span><span class="c5">A</span><span class="c1">, we can obtain matching instances of </span><span class="c5">B </span><span class="c1">by (i) issuing two range-queries on the buffer of </span><span class="c5">B</span><span class="c1">, using the timestamps of </span><span class="c5">A </span><span class="c1">as boundaries and (ii) intersecting the results of those queries. For the example relation, these queries are: </span></p><p class="c7"><span class="c1">(1) </span><span class="c5">A.ts </span><span class="c1">&#259; </span><span class="c5">ts </span><span class="c1">&#259; </span><span class="c5">A.te </span><span class="c1">for the start-timestamp and (2) </span><span class="c5">A.te </span><span class="c1">&#259; </span><span class="c5">te </span><span class="c1">&#259; 8 for the end timestamp. It is easy to see, that each situation falling into both ranges fulfills the given temporal relation. Figure 3 illustrates this using 3 situations: Situation </span><span class="c5">A</span><span class="c28">1 </span><span class="c24">in combination with the temporal relation </span><span class="c1">is used to build the two search ranges. After intersecting the results (t</span><span class="c5">B</span><span class="c28">1</span><span class="c24">u for the start range and t</span><span class="c10">B</span><span class="c28">1</span><span class="c10">, B</span><span class="c28">2</span><span class="c24">u for the end range), </span><span class="c1">we receive our final result </span><span class="c5">B</span><span class="c28">1</span><span class="c24">. Note that for temporal relations </span><span class="c1">allowing more than one result (e.g., </span><span class="c5">A before B</span><span class="c1">), this strategy additionally eliminates the need for checking each combination individually. </span></p><p class="c25"><span class="c1">Typically, a temporal constraint contains more than one tempo- ral relation, stating each of them as a valid relationship between two situations. This can be easily integrated by executing the search separately for each of the defined relations and subse- quently building the union of the obtained results. The conjunc- tion of multiple temporal constraints can be implemented as an intersection of the results from the respective individual queries. Because the buffers are backed by a contiguous array, we can represent the search results as index-ranges and thus efficiently compute the required unifications and intersections. This ap- proach reduces the estimated costs of performMatch to: </span></p><p class="c7"><span class="c1">C &ldquo; </span></p><p class="c7"><span class="c24">&yuml;</span><span class="c12">n</span><span class="c11">i</span><span class="c6">&ldquo;</span><span class="c11">2</span><span class="c1">&nbsp;&#769; &#772; </span></p><p class="c7"><span class="c24">|R</span><span class="c11">i</span><span class="c6">&nbsp;&#769;</span><span class="c11">1</span><span class="c24">| &#776;|R</span><span class="c11">i</span><span class="c24">| `C</span><span class="c11">f indMatches</span><span class="c1">p|B</span><span class="c11">i</span><span class="c24">|q</span><span class="c1">(2) </span></p><p class="c7"><span class="c1">The withCconstant </span><span class="c11">f indMatches</span><span class="c1">factors 13 p|Band </span><span class="c11">i</span><span class="c24">|qbeing </span><span class="c1">4 arise </span><span class="c24">bounded </span><span class="c1">from the </span><span class="c24">by|P| &#776;13 &#776;4 &#776;log</span><span class="c1">possible temporal </span></p><p class="c7"><span class="c11">2</span><span class="c1">p|B</span><span class="c11">i</span><span class="c24">|q. </span></p><p class="c7"><span class="c1">relations per constraint and the binary searches to execute for each of them, respectively. </span></p><p class="c7"><span class="c14">5.3 Low-Latency Matching </span><span class="c1">In this section, we will determine the earliest points in time (t</span><span class="c11">d</span><span class="c1">) to detect a temporal relation (t</span><span class="c11">d</span><span class="c1">pRq), temporal constraint (t</span><span class="c11">d</span><span class="c1">pCq) and temporal pattern (t</span><span class="c11">d</span><span class="c1">pPq). Then, we adjust our algorithms from the previous section to deliver matches as early as possible. </span></p><p class="c25"><span class="c1">5.3.1 Analysis. Two situations </span><span class="c5">A,B </span><span class="c1">can only be related once we know they exist, making maxp</span><span class="c5">A.ts, B.ts</span><span class="c1">q &#271; t</span><span class="c11">d</span><span class="c1">pRq a trivial lower bound for all relations. For exactt</span><span class="c11">d</span><span class="c1">pRq consider a relation&rsquo;s definition &delta;</span><span class="c11">R </span><span class="c1">depicted in Table 2. Let </span><span class="c5">t</span><span class="c28">1 </span><span class="c24">&#271; </span><span class="c10">t</span><span class="c28">2 </span><span class="c24">&#271; </span><span class="c10">t</span><span class="c28">3 </span><span class="c24">&#271; </span><span class="c10">t</span><span class="c28">4 </span><span class="c24">be </span><span class="c1">the timestamps in the order they appear in &delta;</span><span class="c11">R</span><span class="c1">. It is easy to see </span></p><p class="c25"><span class="c23">Relation (R) </span><span class="c2">Definition (?</span><span class="c55">R</span><span class="c85">) t</span><span class="c55">d</span><span class="c81">(R) </span><span class="c23">A befor e B A.ts &lt; A.te &lt; B.ts &lt; B.te B.ts A meets B A.ts &lt; A.te = B.ts &lt; B.te B.ts </span></p><p class="c7"><span class="c2">Prefix-Group (G) t</span><span class="c55">d</span><span class="c81">(G) </span></p><p class="c7"><span class="c23">A.ts &lt; A.te ? B.ts </span><span class="c2">B.ts </span></p><p class="c7"><span class="c23">A star ts B A.ts = B.ts &lt; A.te &lt; B.te A.te A equal B A.ts = B.ts &lt; A.te = B.te A.te = B.te A.ts = B.ts </span><span class="c2">B.ts </span><span class="c23">A star ted-by B A.ts = B.ts &lt; B.te &lt; A.te B.te </span></p><p class="c8"><span class="c23">A overlaps B A.ts &lt; B.ts &lt; A.te &lt; B.te A.te A finishes B A.ts &lt; B.ts &lt; A.te = B.te A.te = B.te A.ts &lt; B.ts </span><span class="c2">B.ts </span><span class="c23">A contains B A.ts &lt; B.ts &lt; B.te &lt; A.te B.te </span><span class="c1">Table 2: Low-Latency Analysis </span></p><p class="c25"><span class="c1">that the ordering of </span><span class="c5">t</span><span class="c28">4 </span><span class="c24">can implicitly be derived at </span><span class="c10">t</span><span class="c28">3</span><span class="c24">, because </span><span class="c5">t</span><span class="c28">3 </span><span class="c24">&#271; </span><span class="c10">t</span><span class="c28">4 </span><span class="c24">and there are no timestamps beyond that. Furthermore, </span><span class="c1">at </span><span class="c5">t</span><span class="c50">1 </span><span class="c1">and </span><span class="c5">t</span><span class="c50">2 </span><span class="c1">there are other relations sharing the same definitions up to that point, i.e., it is not possible to distinguish them from each other. To show this, we have grouped relations starting with </span><span class="c5">A.ts </span><span class="c1">as prefix groups in Table 2 (</span><span class="c5">B.ts </span><span class="c1">groups are analogous). For those reasons we can conclude t</span><span class="c11">d</span><span class="c1">pRq &ldquo; </span><span class="c5">t</span><span class="c28">3</span><span class="c24">. </span></p><p class="c25"><span class="c1">A temporal constraint C &ldquo; pR</span><span class="c11">1</span><span class="c10">,...,</span><span class="c24">R</span><span class="c11">n</span><span class="c24">q for </span><span class="c10">A,B </span><span class="c24">matches if at </span><span class="c1">least one relation matches. Therefore, the earliest detection time is t</span><span class="c11">d</span><span class="c1">pCq&ldquo;tt</span><span class="c11">d</span><span class="c1">pR</span><span class="c11">1</span><span class="c24">q</span><span class="c10">,...,</span><span class="c24">t</span><span class="c11">d</span><span class="c1">pR</span><span class="c11">n</span><span class="c24">qu. Note that t</span><span class="c11">d</span><span class="c1">pCq is a set and the actual detection time of two situations depends on the fulfilled relation. Further, ifC contains all relations of a prefix group (cf. Table 2), the detection time of these relations is shifted to the trivial lower bound (t</span><span class="c11">d</span><span class="c1">pGq). </span></p><p class="c25"><span class="c1">Finally, for a pattern P &ldquo; pC</span><span class="c12">1</span><span class="c5">, ...,</span><span class="c1">C</span><span class="c12">m</span><span class="c1">q, each constraint must be matched. However, a single temporal configuration matching P fulfills exactly one temporal relation (R) from each constraint, making t</span><span class="c11">d</span><span class="c1">pPq &ldquo; maxpt</span><span class="c11">d</span><span class="c1">pR P C</span><span class="c11">1</span><span class="c24">q</span><span class="c10">,...,</span><span class="c24">t</span><span class="c11">d</span><span class="c1">pR P C</span><span class="c11">m</span><span class="c24">qq. In gen- </span><span class="c1">eral, </span><span class="c24">&#356;</span><span class="c11">i</span><span class="c6">&ldquo;</span><span class="c11">1...m </span><span class="c1">t</span><span class="c11">d</span><span class="c1">pPq t</span><span class="c11">d</span><span class="c1">is pCamong </span><span class="c11">i</span><span class="c24">q. </span></p><p class="c19"><span class="c1">the constraint detection points: t</span><span class="c11">d</span><span class="c1">pPq &#270; 5.3.2 Implementation. For the ease of presentation, we ignore the optional duration constraints on situations as well as prefix groups during the development and discuss the required changes at the end of this section. We gained two implementation-relevant insights from the low-latency analysis. First, new matches can only be detected if a new situation starts or a situation ends. Sec- ond, only a subset of the defined situations can possibly produce a match at t</span><span class="c11">d</span><span class="c1">pPq. Thus, the matching process can be delayed until a situation with at least one endpoint in t</span><span class="c11">d</span><span class="c1">pPq occurs without affecting the latency. We call those situations trigger situations since only they should trigger a performMatch call. These insights affect our algorithms in the following ways. Situations must be available for matching from their start on, which can easily be achieved by adjusting the deriver. Additionally, we need to de- termine for each situation stream if the derived situations are trigger situations. For trigger situations we need to identify the point in time to execute performMatch (at its start, end or both). However, the following cases must be considered during the matching process. If a situation requires matching on both end- points, care must be taken not to produce duplicate results. Fur- ther, started situations must not be visible to the matcher in all cases: If two situations are related via </span><span class="c5">finishes </span><span class="c1">or </span><span class="c5">equals</span><span class="c1">, they could be mistakenly matched, because their temporary end timestamps (i.e., the current time) are equal. On the other hand, if two situations are not explicitly related via a temporal con- straint they may participate in a successful match, even if both end timestamps are unknown. To illustrate this, consider the following pattern on four situations (</span><span class="c5">A, B, C, D</span><span class="c1">): </span><span class="c5">A before B AND A before C AND A before D AND (D during C OR C </span></p><p class="c7"><span class="c13">319 </span></p><p class="c59"><span class="c1">Figure 4: Earliest detection time (t</span><span class="c11">d</span><span class="c1">) of different temporal configurations for the same pattern </span></p><p class="c41"><span class="c5">finishes D OR C meets D)</span><span class="c1">. It defines situation </span><span class="c5">A </span><span class="c1">as starting point of every match. </span><span class="c5">B </span><span class="c1">is not explicitly related to </span><span class="c5">C </span><span class="c1">and </span><span class="c5">D </span><span class="c1">and required to happen after </span><span class="c5">A</span><span class="c1">. Consequently, </span><span class="c5">B </span><span class="c1">is a trigger situation and </span><span class="c5">B.ts </span><span class="c1">is in t</span><span class="c11">d</span><span class="c1">pPq. For </span><span class="c5">D </span><span class="c1">both </span><span class="c5">D.ts </span><span class="c1">(via </span><span class="c5">meets</span><span class="c1">) and </span><span class="c5">D.te </span><span class="c1">(via </span><span class="c5">during,finishes</span><span class="c1">) are in t</span><span class="c11">d</span><span class="c1">pPq. Figure 4 shows four represen- tative temporal configurations for this pattern, highlighting the earliest point of detection (t</span><span class="c11">d</span><span class="c1">). Configuration 1 showcases </span><span class="c5">B </span><span class="c1">as a trigger situation with t</span><span class="c11">d </span><span class="c1">&ldquo; </span><span class="c5">B.ts</span><span class="c1">. For the second configura- tion, </span><span class="c5">D </span><span class="c1">is the trigger with t</span><span class="c11">d </span><span class="c1">&ldquo; </span><span class="c5">D.ts</span><span class="c1">. This case also shows that two started relations may participate in a match if their end is unknown (</span><span class="c5">B,D</span><span class="c1">). The remaining configurations highlight </span><span class="c5">D </span><span class="c1">as a trigger, but with t</span><span class="c11">d </span><span class="c1">&ldquo; </span><span class="c5">D.te</span><span class="c1">. </span></p><p class="c25 c101"><span class="c1">Instead of handling these cases explicitly, our low latency algorithm avoids them by ensuring a unique combination of situations in the working-set, before passing it to the matching algorithm. In particular, this means started situations are man- aged in a separate buffer, inaccessible for the matching algorithm, and all valid combinations among them (i.e., all combinations of started situations, not explicitly related to the current one) are built upfront inside the working-set. Furthermore, to avoid du- plicate results, the following fact is exploited: temporal relations enforcing matching on a situation&rsquo;s start require its counterpart to be finished in the past. On the other hand, temporal relations triggering matching on a situation&rsquo;s end require its counterpart to be either started (and not yet finished) or finished at the same time (cf. Table 2). Consequently, manually adding the started counterpart to the working-set, before executing the matching al- gorithm on a situation&rsquo;s end ensures uniqueness of the produced results. </span></p><p class="c39"><span class="c1">The details are presented in Algorithm 4. After purging out- dated situations from the buffers (Line 1), each started situation (s) is added to the additional buffer and if s</span><span class="c5">.</span><span class="c1">ts P t</span><span class="c11">d</span><span class="c1">pPq, the algo- rithm performs a regular match with s being the only constant in the working-set (Lines 2-5). Furthermore, if there are started and unrelated situations, we perform matches with s and each combination of them (Lines 6-8). This accounts for configurations as seen in Figure 4.2. All finished situations are migrated from the separate to the regular buffer (Lines 9-11) and if s</span><span class="c5">.</span><span class="c1">te P t</span><span class="c11">d</span><span class="c1">pPq, the matching process is triggered. This time with combinations of s and all started and related situations (Lines 15-16), further combined with all started and unrelated situations (Lines 17-18), which fuses the avoidance of duplicate results and false positives. An example for this case is shown in Figure 4.3. Note that, the actual constraint-checking among the created combinations is performed by the call to performMatch (Algorithm 3), since it is aware of pre-set situations in the working-set. As we will show </span></p><p class="c7 c94"><span class="c1">Algorithm 4: Low-Latency MatcherUpdate </span></p><p class="c42"><span class="c15">9 </span><span class="c1">foreach s P S</span><span class="c11">f </span><span class="c1">do </span><span class="c15">10 </span><span class="c1">startedBuffer.remove(s); </span><span class="c15">11 </span><span class="c1">addToBuffer(s); </span><span class="c15">12 </span><span class="c1">if matchOnEnd(s) then </span><span class="c15">13 </span><span class="c1">R &ETH; getRelatedStarted(s); </span><span class="c15">14 </span><span class="c1">U &ETH; getUnrelatedStarted(s); </span><span class="c15">15 </span><span class="c1">foreach r P powersetpRqzH do </span><span class="c15">16 </span><span class="c1">performMatch( r Y tsu, 0 ); </span><span class="c15">17 </span><span class="c1">foreach u P powersetpUqzH do </span><span class="c15">18 </span><span class="c1">performMatch( r Yu Y tsu, 0 ); </span></p><p class="c79"><span class="c1">in section 6, the extensive building of combinations has only minimal impact on the runtime-performance, because it shifts load from joining to the update algorithm and does not introduce additional computation steps. </span></p><p class="c104"><span class="c1">Duration constraints on situations are incorporated into low latency-matching with only a few modifications: First, if a maximum duration constraint is defined (regardless of a possibly specified minimum duration), the corresponding situation must not be included in the matching process until its end is known &ndash; and the constraint is fulfilled. Hence, these situations are excluded from the set of started situations (S</span><span class="c12">s</span><span class="c1">) and if their start timestamp is in t</span><span class="c11">d</span><span class="c1">pPq, matching is deferred to their end timestamp. Second, if a minimum but no maximum duration is defined, the inclusion into the set of started situations is deferred until the constraint is satisfied. This possibly implies the inclusion of its deferred start timestamp (</span><span class="c5">ts</span><span class="c1">) into t</span><span class="c11">d</span><span class="c1">pPq. As an example, consider the pattern </span><span class="c5">A during B </span><span class="c1">and the following order of timestamps: </span><span class="c5">B.ts </span><span class="c1">&#259; </span><span class="c5">A.ts </span><span class="c1">&#259; </span><span class="c5">A.te </span><span class="c1">&#259; </span><span class="c5">B.ts </span><span class="c1">&#259; </span><span class="c5">B.te</span><span class="c1">. This match can not be detected at </span><span class="c5">A.te</span><span class="c1">, because </span><span class="c5">B</span><span class="c1">&rsquo;s duration does not exceed the lower bound at this point. Hence </span><span class="c5">B.ts </span><span class="c1">requires a matcher invocation. </span></p><p class="c69 c100"><span class="c1">To handle prefix groups the restriction that two started and explicitly related situations must not be matched is relaxed. That is, matching is performed if the corresponding temporal constraint contains one or more prefix groups. However, for still being able to omit false positives, the matcher must distinguish between prefix group and regular detection. Technically this means splitting the temporal constraint into two disjoint sets (one containing all temporal relations forming a prefix group and another one holding the remaining relations) and use the first set, when matching on a situation&rsquo;s start and the second one on its end. </span></p><p class="c111"><span class="c14">5.4 Computing the Evaluation Order </span><span class="c1">The matcher component maps the problem of temporal pattern matching to a multi-way join between situation buffers. Like multi-join processing in traditional relational database systems, </span></p><p class="c7 c83"><span class="c1">Input: S</span><span class="c11">f </span><span class="c1">, S</span><span class="c12">s</span><span class="c1">: sets of finished/started, t: current time </span><span class="c15">1 </span><span class="c1">purgeBuffers(t); </span><span class="c15">2 </span><span class="c1">foreach s P S</span><span class="c11">s </span><span class="c24">do </span><span class="c15">3 </span><span class="c1">startedBuffer.add(s); </span><span class="c15">4 </span><span class="c1">if matchOnStart(s) then </span><span class="c15">5 </span><span class="c1">performMatch( tsu, 0 ); </span><span class="c15">6 </span><span class="c1">U &ETH; getUnrelatedStarted(s); </span><span class="c15">7 </span><span class="c1">foreach u P powersetpUqzH do </span><span class="c15">8 </span><span class="c1">performMatch( u Y tsu, 0 ); </span></p><p class="c99"><span class="c13">320 </span></p><p class="c7"><span class="c2">starts, </span><span class="c23">Relation before during </span></p><p class="c7"><span class="c2">overlaps </span></p><p class="c7"><span class="c2">finishes, meets </span></p><p class="c7"><span class="c23">Selectivity </span><span class="c22">0.445 0.03 </span></p><p class="c7"><span class="c22">0.01 </span></p><p class="c7"><span class="c51">0.0049 </span></p><p class="c7"><span class="c2">equal </span></p><p class="c7"><span class="c51">0.0006 </span><span class="c1">Table 3: Initial estimates for the selectivity of temporal re- lations. Mirror relations are equivalent. </span></p><p class="c25"><span class="c1">the performance of joining heavily depends on the order in which the join operations are executed. In this section, we discuss how the matcher&rsquo;s evaluation order is computed and present the cost- model used during this process. </span></p><p class="c25"><span class="c1">Analogous to classical join processing we implemented an optimizer that enumerates possible execution plans, computes the expected computational costs for each of them and suggests the most efficient plan for execution. We do not provide multi- ple implementations of the join operator, so that enumerating possible plans reduces to the enumeration of possible evaluation orders. To further reduce the number of plans to consider, we exclude orderings joining a situation buffer without an appli- cable temporal constraint. In other words: Plans involving the calculation of a cross product are omitted. </span></p><p class="c7"><span class="c1">According to Equation 2, estimating the costs for a given plan boils down to estimating the size of intermediate results: </span></p><p class="c7"><span class="c1">|R</span><span class="c12">i</span><span class="c1">| :&ldquo; </span></p><p class="c7"><span class="c1">#</span><span class="c24">|B</span><span class="c11">1</span><span class="c24">| if i &ldquo; 1 </span></p><p class="c19"><span class="c1">|R</span><span class="c11">i</span><span class="c6">&nbsp;&#769;</span><span class="c11">1</span><span class="c24">| &#776;|B</span><span class="c11">i</span><span class="c24">| &nbsp;&#776;s</span><span class="c11">i </span><span class="c24">otherwise </span><span class="c1">(3) s</span><span class="c11">i </span><span class="c24">denotes the selectivity of the applicable temporal constraints </span><span class="c1">in step i (C</span><span class="c11">i</span><span class="c24">), which can be composed from the selectivities of </span><span class="c1">the contained temporal relations as follows: </span></p><p class="c7"><span class="c1">s</span><span class="c11">i </span><span class="c24">:&ldquo; </span><span class="c1">&#378;</span><span class="c11">C</span><span class="c6">P</span><span class="c11">C</span><span class="c30">i </span></p><p class="c7"><span class="c1">&nbsp;&#771; </span><span class="c24">&yuml;</span><span class="c11">R</span><span class="c6">P</span><span class="c11">C </span></p><p class="c7"><span class="c1">s</span><span class="c11">R</span><span class="c1">&nbsp;&#807; </span></p><p class="c7"><span class="c1">(4) </span></p><p class="c25"><span class="c1">When a query is initially deployed into the system, the situ- ation buffers are empty and we have no estimation on the se- lectivity of the temporal constraints. Hence, we initially assume the selectivities depicted in Table 3. These values are backed by the following back-of-the-envelope calculation: The combined selectivity of all possible relations should be 100%. Assuming equal sized buffers and an equal temporal distribution of the situations, the selectivity of a </span><span class="c5">before </span><span class="c1">relation will be around 50%. For </span><span class="c5">during</span><span class="c1">, the number of results is limited by the maximum of both buffer sizes, because a situation </span><span class="c5">A </span><span class="c1">can happen during at most one other situation (</span><span class="c5">B</span><span class="c1">), but </span><span class="c5">B </span><span class="c1">may contain multiple </span><span class="c5">A </span><span class="c1">situations. All other temporal relations define a 1:1 relationship, which limits the worst case to the minimum of both buffer sizes. As seen in Table 3, we additionally separate the last case by the number of stated equalities. Note that even though this is an initial estimate, the resulting plans prove to work well in most cases (cf. section 6.4.2). </span></p><p class="c25"><span class="c1">5.4.1 Adaptivity. Once a query is deployed in a CEP-system, it is typically active for a long time. Hence, more important than the quality of an initial execution plan is the ability to tune this plan and adapt it to changing workloads. To do so, we keep track of the buffer sizes and selectivities imposed by temporal constraints during execution. The buffer-sizes are available at any point in time and at no cost, since they are tracked by the underlying data structure. However, to smooth out (potential) spikes, we monitor the buffer size using an exponential moving average, which is adjusted after each call to the matcher&rsquo;s update method as follows: </span></p><p class="c7"><span class="c1">EMA</span><span class="c11">i </span><span class="c24">&ldquo; &alpha; &nbsp;&#778; |B</span><span class="c11">i</span><span class="c24">|`p1 &nbsp;&#769; &alpha;q &nbsp;&#778; EMA</span><span class="c11">i</span><span class="c6">&nbsp;&#769;</span><span class="c11">1 </span></p><p class="c25"><span class="c1">EMA</span><span class="c11">i </span><span class="c24">holds after the i-th update. |B</span><span class="c11">i</span><span class="c24">| denotes the size of the </span><span class="c1">considered buffer at update i and the smoothing factor &alpha; P p0</span><span class="c5">, </span><span class="c1">1q determines how much weight is given to previous values. For ex- ample, a value close to 1 assigns almost no weight to older values, while a value close to 0 decreases the influence of new values. The selectivities of the temporal constraints are also managed with EMAs using one EMA-value per constraint. </span></p><p class="c25"><span class="c1">To check if a re-computation of the evaluation order is re- quired, the active plan stores a snapshot of the statistics it is based on. After each update, we compare them to the current val- ues and if any of them differs by more than the defined threshold (t), we trigger a re-computation. </span></p><p class="c25"><span class="c1">Finally, if a migration is required, we are able to migrate to the new plan between any two invocations of the matcher com- ponent. Because the matcher does not store any intermediate results, but solely relies on the situation buffers this switch comes without any additional migration costs. As we will show in sec- tion 6.4.2, the total costs for adaptivity are negligible. </span></p><p class="c7"><span class="c14">6 EXPERIMENTAL EVALUATION </span><span class="c1">In this section we present the results from our experimental evaluation of TPStream</span><span class="c0">2</span><span class="c1">. First, we study TPStream&rsquo;s evaluation performance in comparison to ISEQ and point based CEP systems. Then, we analyze the latency improvement of our approach in comparison to ISEQ. Finally, we prove the validity of our opti- mization techniques. </span></p><p class="c7"><span class="c14">6.1 Setup </span><span class="c1">All experiments were conducted on a workstation equipped with an Intel i7-2600 3.4 GHz processor and 8GB of memory, running a Debian Linux (kernel version 4.11.11-1). The results presented for each experiment are averaged values from a total of 10 runs, whereby every run was preceded by a warm-up phase of evaluat- ing at least 100,000 events before the measurement was started. The main goal of this section is to compare TPStream&rsquo;s process- ing performance and our low latency approach to the state-of-the art solution for temporal pattern matching (ISEQ). There is no publicly available implementation of ISEQ, so we implemented it based on the available description in [20]. As required by the design of ISEQ, the input consists of interval streams ordered by endpoint. These streams are again generated with our deriver component. </span></p><p class="c25"><span class="c1">In order to provide a comparison with point based systems, we also included CEP-solutions from the open-source community (Esper</span><span class="c0">3 </span><span class="c1">6.0.1) and academia (SASE+ </span><span class="c0">4</span><span class="c1">), when applicable. While Esper is a production ready CEP system, highly optimized for efficient query execution, SASE+ is one of the most popular CEP languages in the research community and served as foundation for the ISEQ operator. The rich query language of Esper allowed us to express both straw man&rsquo;s approaches as sketched in the introduction. We refer to the first approach (2 phase pattern matching) with Esper-1 and the low latency approach is denoted as Esper-2. Because the SASE+ implementation does not feature chaining of queries, we only implemented the low-latency ap- proach. TPStream and all its competitors are implemented in the JAVA programming language, whereby TPStream and ISEQ are based on JEPC [19] &ndash; an event processing middleware. We used </span></p><p class="c7"><span class="c34">2</span><span class="c6">Datasets and source code available at http://uni-marburg.de/oaCPk </span><span class="c34">3</span><span class="c31">http://www.espertech.com </span><span class="c34">4</span><span class="c31">https://github.com/haopeng/sase </span></p><p class="c7"><span class="c13">321 </span></p><p class="c7"><span class="c16">1,250 300 </span></p><p class="c7"><span class="c16">300 TPStream </span></p><p class="c7"><span class="c16">TPStream </span></p><p class="c7"><span class="c82">TPStream </span></p><p class="c7"><span class="c16">250 </span></p><p class="c7"><span class="c16">ISEQ Esper-1 </span></p><p class="c7"><span class="c16">250 </span></p><p class="c7"><span class="c16">ISEQ Esper-1 </span></p><p class="c7"><span class="c82">ISEQ </span><span class="c16">1,000 </span></p><p class="c7"><span class="c82">Esper-1 </span><span class="c16">Esper-2 </span></p><p class="c7"><span class="c16">Esper-2 </span></p><p class="c7"><span class="c82">Esper-2 </span><span class="c52">)s(emiTgnissecor</span><span class="c16">P200 </span></p><p class="c7"><span class="c16">SASE+ </span></p><p class="c7"><span class="c52">) s(emiTgnissecor</span><span class="c16">P200 </span></p><p class="c7"><span class="c52">) s(emiTgnissecor</span><span class="c16">P</span><span class="c53">(a) </span><span class="c16">0 25 50 75 Processed Events (x10^6) </span></p><p class="c7"><span class="c16">100 </span></p><p class="c7"><span class="c53">(b) </span><span class="c16">Processed Events (x10^6) </span></p><p class="c7"><span class="c53">(c) </span></p><p class="c7"><span class="c16">Window Size (s) </span></p><p class="c7"><span class="c1">Figure 5: Processing time for aggressive driver detection as a function of the input size: (a) simplified pattern, (b) full pattern and processing time for disconnected pattern detection as a function of the window size (c) </span></p><p class="c7"><span class="c1">Figure 6: Processing time for various query patterns </span></p><p class="c7"><span class="c1">Oracle JDK 1.8.0.144 compile the systems and ran all experiments on that JVM with 6GB of heap space. </span></p><p class="c25"><span class="c1">During the evaluation two data sources were used. The first source comprises trip data generated with the Linear Road Bench- mark [4]. Besides other attributes, each event consists of a unique car id, its location, the current speed and acceleration. We gen- erated data simulating 5 hours of traffic on a single expressway with 1000 active cars per hour. Each active car reports its state every second, leading to 887 million events (36 GB of data). The second source is a random event generator, tuned to pose high load on the system. It generates event streams with a config- urable number of boolean attributes, each representing a single situation stream. The generated situations last between 10 and 100 seconds, while the gaps between two consecutive situations span 10 to 50 seconds (both uniformly distributed). Events are generated with a frequency of 1Hz, so that for a situation lasting n seconds, the corresponding attribute&rsquo;s value is </span><span class="c5">true </span><span class="c1">for exactly n consecutive events. </span></p><p class="c7"><span class="c1">Independent of the data-source, we used a single thread for both, reading/generating the data and evaluating the query. For each experiment, we measured the reading/generation time up- front and removed it from the presented results. The most im- portant parameters throughout all experiments are as follows: Event Rate The rate (events/s) with which events are pushed </span></p><p class="c7"><span class="c1">into the systems. Window Size The size of the time window (s) during which a </span></p><p class="c8"><span class="c1">pattern must occur completely. Event Count The total number of events to process. </span></p><p class="c7"><span class="c16">750 </span></p><p class="c7"><span class="c16">150 </span></p><p class="c7"><span class="c16">150 </span></p><p class="c7"><span class="c16">500 100 </span></p><p class="c7"><span class="c16">100 </span></p><p class="c7"><span class="c52">50 </span></p><p class="c7"><span class="c52">50 </span></p><p class="c7"><span class="c16">250 </span></p><p class="c7"><span class="c16">000 </span></p><p class="c7"><span class="c16">0 25 50 75 100 </span></p><p class="c7"><span class="c16">500 5,000 50,000 </span></p><p class="c7"><span class="c14">6.2 Processing Time </span><span class="c1">This set of experiments compares the processing performance of TPStream with its competitors using various queries and pa- rameter settings. The events were pushed into the system at the maximum possible rate and we used the processing time as main measure. </span></p><p class="c25"><span class="c1">6.2.1 Aggressive Drivers. We injected different fractions (1M to 100M events) of the Linear Road dataset into the system and executed the example query of Listing 1 (without duration con- straints). The thresholds for speeding, acceleration and decel- eration were the 99th, 90th and 90th percentiles for the speed and positive/negative acceleration values of a 50M event sample. Besides chaining of queries, the SASE+ implementation also lacks support for disjunctions. Nevertheless, to include SASE+ in this experiment, we also evaluated a simplified query version which restricts the used temporal relations to </span><span class="c5">meets </span><span class="c1">and </span><span class="c5">overlaps</span><span class="c1">. </span></p><p class="c25"><span class="c1">The results of this experiment are shown in Figure 5 (a &ndash; simplified pattern, b &ndash; full pattern). The x-axis shows the num- ber of processed events, the processing time is shown on the y-axis.TPStream and ISEQ are head to head and their process- ing times increase linearly with the number of processed events. Further, they are insensitive to alternatives, resulting in almost identical processing times for both query variants. TPStream was not able to outperform ISEQ in this experiment, because in the given pattern all situations overlap which in turn allows to break the buffer scan early. Esper benefits from the simplified version of the pattern, but its evaluation performance is inferior to TP- Stream and ISEQ (up to 30x for the full query and 15x for the simplified version). When evaluating the full query, Esper hit the memory limit of 6GB and the system crashed if more than 30M (Esper-1) and 40M (Esper-2) events were processed. For the simplified version, the processing time of Esper-1 increases dras- tically when processing more than 50M events &ndash; Esper-2 runs out of memory and crashes. SASE+ managed the evaluation, but was clearly outperformed by TPStream and ISEQ. </span></p><p class="c25"><span class="c1">6.2.2 Disconnected Pattern. The second experiment compares processing time and memory consumption of the systems using a pattern with high selectivity: </span><span class="c5">A before B overlaps C</span><span class="c1">. The difference to the first experiment is, that each </span><span class="c5">A </span><span class="c1">situation may be related to many </span><span class="c5">B overlaps C </span><span class="c1">sub-matches instead of con- tributing to at most one match. Hence, we expected the number of results and consequently the processing time/memory con- sumption to depend on the size of the configured time window. We injected 300M synthetic events into the systems and executed </span></p><p class="c7"><span class="c13">322 </span></p><p class="c7"><span class="c26">1E+12 120 200,000 </span></p><p class="c7"><span class="c97">Before </span><span class="c26">Meets </span></p><p class="c7"><span class="c26">TPStream &ndash; Event Lateny </span></p><p class="c7"><span class="c26">100 </span></p><p class="c7"><span class="c26">Overlaps </span></p><p class="c7"><span class="c26">TPStream &ndash; Processing Latency </span><span class="c63">) s(tnemevorpmIycneta</span><span class="c26">LStarts During B-Duration </span></p><p class="c7"><span class="c26">180,000 </span></p><p class="c19"><span class="c37">TPStream ISEQ </span><span class="c26">160,000 </span></p><p class="c7"><span class="c26">1E+10 </span></p><p class="c7"><span class="c26">ISEQ &ndash; Event Lateny </span></p><p class="c7"><span class="c63">80 </span></p><p class="c7"><span class="c26">140,000 </span></p><p class="c7"><span class="c26">1E+08 </span></p><p class="c7"><span class="c26">ISEQ &ndash; Processing Latency </span><span class="c63">6040) </span></p><p class="c7"><span class="c63">sn(ycneta</span><span class="c26">L</span><span class="c63">) sn(ycneta</span><span class="c26">L</span><span class="c63">20</span><span class="c26">0</span><span class="c91">(a) </span><span class="c26">2:1 4:3 1:1 2:3 1:2 </span></p><p class="c7"><span class="c26">Situation Duration Ratio (A:B) </span></p><p class="c7"><span class="c91">(b) </span><span class="c26">500 1K 2K 5K 10K 20K 50K 100K </span></p><p class="c7"><span class="c26">Window Size (s) </span></p><p class="c7"><span class="c91">(c) </span></p><p class="c7"><span class="c26">Events/s </span></p><p class="c7"><span class="c1">Figure 7: (a) application time latency gain per temporal relationand comparison of result latency (b) under maximum possible throughput as a function of the window size, (c) under varying event rates with a fixed size window </span></p><p class="c7"><span class="c1">the query with window sizes varying from 500s (8:20 minutes) to 100,000s (slightly more than one day). </span></p><p class="c25"><span class="c1">Figure 5 (c) shows the processing time of all systems as a func- tion of the window size (note the log-scale). In this experiment, TPStream is able to outperform ISEQ by a factor of 14 using a window of 100,000s. This is because ISEQ does not make use of the order on the situations&rsquo; start timestamp and requires addi- tional computational steps during result construction and buffer pruning. SASE+ did not finish this experiment in a reasonable time for none of the window sizes and Esper barely managed window sizes up to 20,000s. To measure the average memory con- sumption, we monitored the used heap space with a frequency of 20Hz during each run and averaged these values. Both, TPStream and ISEQ require only very little additional memory for increased window sizes: TPStream 911 - 1018 MB, ISEQ 903 - 1027 MB. Esper stays stable at 1 GB up to a window size of 10,000s but afterwards suffers from buffering single events rather than a compact rep- resentation like situations. For the last evaluable query (20,000s window) Esper already consumed 1,7 GB of memory. </span></p><p class="c25"><span class="c1">6.2.3 Query Patterns. To give a comprehensive overview of TPStream&rsquo;s processing performance, we evaluated 5 different query patterns and varied the number of situation streams from 4 to 10. Queries 1-3 (Equal, Meets, Chain) are of the formS</span><span class="c11">1 </span><span class="c24">&lsquo;</span><span class="c11">1 </span><span class="c1">S</span><span class="c11">2 </span><span class="c24">&lsquo;</span><span class="c11">2 </span><span class="c10">... </span><span class="c24">&lsquo;</span><span class="c11">n</span><span class="c6">&nbsp;&#769;</span><span class="c11">1 </span><span class="c24">S</span><span class="c11">n</span><span class="c24">, with &lsquo;</span><span class="c11">i </span><span class="c24">&ldquo; </span><span class="c10">equals</span><span class="c24">, &lsquo;</span><span class="c11">i </span><span class="c24">&ldquo; </span><span class="c10">meets </span><span class="c24">and &lsquo;</span><span class="c11">i </span><span class="c1">a randomly drawn temporal relation, respectively. In query 4 (Star), S</span><span class="c11">1 </span><span class="c24">is connected with every other situation, via a random </span><span class="c1">temporal relation (i.e. S</span><span class="c11">1 </span><span class="c24">&lsquo;</span><span class="c11">1 </span><span class="c24">S</span><span class="c11">2</span><span class="c10">,</span><span class="c24">S</span><span class="c11">1 </span><span class="c24">&lsquo;</span><span class="c11">2 </span><span class="c24">S</span><span class="c11">3</span><span class="c10">,...,</span><span class="c24">S</span><span class="c11">1 </span><span class="c24">&lsquo;</span><span class="c11">n</span><span class="c6">&nbsp;&#769;</span><span class="c11">1 </span><span class="c24">S</span><span class="c11">n</span><span class="c24">). Query </span><span class="c1">5 (Combined) combines the two generic patterns by connecting the first n{2 situations via the Chain pattern and the remaining situations according to the Star pattern. Each query-type was executed 100 times, using 50M synthetic events and a window size of 2,000s. </span></p><p class="c25"><span class="c1">The box plots in Figure 6 provide the median as well as the 25th and 75th percentiles of the processing time. For all query types, the median processing time increases linearly with the number of situations. The generic Chain pattern incurs higher maximum values than Equal and Meets, because the possible temporal relations include </span><span class="c5">before</span><span class="c1">, which is highly selective. This forces the matcher to build many partial results &ndash; especially if three or more consecutive situations are in a </span><span class="c5">before </span><span class="c1">relationship. Star queries are more sensitive to the concrete pattern instance, because in the worst case every situation triggers the matching process. This effect can also be observed for the Combined pattern, but to a smaller degree, because only half of the situations are connected via a Star pattern. </span></p><p class="c7"><span class="c26">120,000 </span></p><p class="c7"><span class="c26">100,000 </span></p><p class="c7"><span class="c26">1E+06 </span></p><p class="c7"><span class="c26">80,000 </span></p><p class="c7"><span class="c26">60,000 </span></p><p class="c7"><span class="c26">1E+04 </span></p><p class="c7"><span class="c26">40,000 </span></p><p class="c7"><span class="c26">1E+02 20,000 </span></p><p class="c7"><span class="c26">0 </span></p><p class="c7"><span class="c26">1E+00 </span></p><p class="c7"><span class="c26">1M 100K 10K 1K 100 10 1 </span></p><p class="c7"><span class="c14">6.3 Low Latency </span><span class="c1">This set of experiments compares the result latency of our ap- proach with the state-of-the art solution for temporal pattern matching, ISEQ. </span></p><p class="c25"><span class="c1">6.3.1 Application Time. At first, we measure the latency im- provement of TPStream compared to ISEQ in terms of application time. That is, we compare the timestamps of the events that pro- duced a result in both approaches and calculate their difference. We evaluated each temporal relation independently using two synthetic situation streams (</span><span class="c5">A,B</span><span class="c1">). We varied the average duration ratio from 2:1 to 1:2, keeping </span><span class="c5">A</span><span class="c1">&rsquo;s average duration fixed at 55 seconds. Note that the window size has no impact here (as long as it is not too small to hold a match), so it was set to 1,000s. </span></p><p class="c25"><span class="c1">Figure 7 (a) shows the average latency improvements per tem- poral relation. For sequential relations (</span><span class="c5">before, meets</span><span class="c1">), the gain in latency is equal to the average duration of </span><span class="c5">B </span><span class="c1">situations, be- cause matches are detected at </span><span class="c5">B.ts</span><span class="c1">. For the remaining relations, the detection time is </span><span class="c5">A.te </span><span class="c1">and the average improvement depends on the concrete temporal relation. In the worst case (</span><span class="c5">during</span><span class="c1">) this is </span><span class="c5">B.duration</span><span class="c1">{</span><span class="c5">2</span><span class="c1">. Note that, </span><span class="c5">equals </span><span class="c1">and </span><span class="c5">finishes </span><span class="c1">were not included, because no latency improvements can be achieved. </span></p><p class="c25"><span class="c1">6.3.2 Wall Clock Latency. We conducted two experiments, showing that TPStream&rsquo;s processing techniques significantly re- duce the result latency in terms of wall clock time which is a critical aspect in a streaming scenario. Therefore, we repeat the experiment from section 6.2.2 twice: first, we measure the time passed between the arrival of the first event that could produce a result and the receipt of that result. We varied the window size and pushed events with the maximum possible rate. For the second experiment we fixed the window size at 100,000s and varied the event rate from 1M to 1 events/s. This time, we split the measured latency in (i) processing latency: the time passed between arrival of the event that triggered the result and the actual receipt of that result and (ii) event latency: the time passed between arrival of the first event that could trigger the result and the arrival of the event that actually triggered that result. </span></p><p class="c25"><span class="c1">The results are shown in Figure 7 (b,c). Both figures show the average latency per result (y-axis, note the log-scale for c). While (b) shows, that TPStream&rsquo;s evaluation techniques provide latency savings through reduced processing time, (c) highlights the sav- ings achieved with our low-latency matcher. Especially when the rate is in sync with application time (1 event/s), the event latency of ISEQ dominates the processing latency and almost reaches the application time savings (~35s, cf. Figure 7 a, 1:1, </span><span class="c5">overlaps</span><span class="c1">), while TPStream introduces no event latency at all. </span></p><p class="c7"><span class="c13">323 </span></p><p class="c7"><span class="c49">0</span><span class="c18">15 </span></p><p class="c7"><span class="c18">35 </span><span class="c49">Best </span></p><p class="c7"><span class="c49">TPS-O Worst </span></p><p class="c7"><span class="c18">30</span><span class="c49">TPS-A </span><span class="c18">6 ^01x)s/stneve(tuphguorh</span><span class="c49">T</span><span class="c18">105</span><span class="c49">Suggest </span></p><p class="c7"><span class="c18">6 ^01x)s/stneve(tuphguorh</span><span class="c49">T01:1:1 1:50:50 50:1:50 </span><span class="c18">252015105</span><span class="c49">TPS-1 TPS-2 </span></p><p class="c7"><span class="c38">(a) </span><span class="c49">Q1 Q2 Q3 </span></p><p class="c7"><span class="c38">(b) </span></p><p class="c7"><span class="c49">Occurence Ratio </span></p><p class="c25"><span class="c1">Figure 8: (a) Quality of the initial plans for Q1 &ndash; Q3, (b) Throughput comparison: dynamic plan adaption vs. best initial plans </span></p><p class="c7"><span class="c14">6.4 Plan Quality &amp; Adaption </span><span class="c1">Finally, we evaluate the optimization techniques presented in section 5.4. Like in section 6.2, events were pushed with the maximum possible rate. </span></p><p class="c25"><span class="c1">6.4.1 Initial Plan Quality. To evaluate the quality of the gener- ated initial plans, we used the following queries on three situation streams: Q1: </span><span class="c5">A overlaps B AND A overlaps C AND B starts C</span><span class="c1">, Q2: </span><span class="c5">A overlaps B AND A before C AND B overlaps C </span><span class="c1">and Q3: </span><span class="c5">A before B AND A before C AND B before C</span><span class="c1">. For each query, we generated all 6 valid plans and measured the through- put (processed events/s) by evaluating synthetic events with a window size of 5,000s. </span></p><p class="c25"><span class="c1">Figure 8 (a) shows the results for the best, worst and suggested plans and clearly confirms our approach. For queries Q1 and Q2 the best plan was suggested. The initial plan for Q3 was </span><span class="c5">C </span><span class="c1">&Ntilde; </span><span class="c5">B </span><span class="c1">&Ntilde; </span><span class="c5">A </span><span class="c1">even though the estimated costs for </span><span class="c5">C </span><span class="c1">&Ntilde; </span><span class="c5">A </span><span class="c1">&Ntilde; </span><span class="c5">B </span><span class="c1">are the same. The experiments show, that </span><span class="c5">C </span><span class="c1">&Ntilde; </span><span class="c5">A </span><span class="c1">&Ntilde; </span><span class="c5">B </span><span class="c1">would have been a slightly better choice, but the difference is negligible. </span></p><p class="c25"><span class="c1">6.4.2 Dynamic Plan Adaption. To analyze the plan adaption capabilities of TPStream, we executed Q3 again and processed 300M events. The occurrence ratio of situations </span><span class="c5">A,B</span><span class="c1">and</span><span class="c5">C</span><span class="c1">changed from 1:1:1 to 1:50:50 after 100M events and finally to 50:1:50 af- ter 200M events. The window size, smoothing-factor (&alpha;) and threshold for plan migration (t) were set to 10,000s, 0.01 and 0.2, respectively. Besides the adaptive implementation (TPS-A), we ran the experiment with both best initial plans </span><span class="c5">C </span><span class="c1">&Ntilde; </span><span class="c5">B </span><span class="c1">&Ntilde; </span><span class="c5">A </span><span class="c1">(TPS- 1), </span><span class="c5">C </span><span class="c1">&Ntilde; </span><span class="c5">A </span><span class="c1">&Ntilde; </span><span class="c5">B </span><span class="c1">(TPS-2), and an implementation, doing a hard coded switch to the best plan exactly when the characteristics of the stream changes (TPS-O). </span></p><p class="c25"><span class="c1">Figure 8 (b) shows the throughput for all four configurations and the three different stream-characteristics: TPS-1 and TPS-2 both have drawbacks in either one of the skewed phases, while our adaptive approach is very close to the optimal solution TPS-O (suffering slightly from dynamic adaption). However, the total runtime of TPS-O (63,523ms) compared to TPS-A (64,612ms) reveals only a negligible overhead of 1,089ms (less than 2%) for plan adaption. </span></p><p class="c7"><span class="c14">7 CONCLUSION </span><span class="c1">We presented TPStream, a novel event processing operator for detecting complex temporal patterns among event streams. We en- abled TPStream to derive lasting situations directly from streams of events and developed new techniques for detecting temporal patterns at the earliest possible point in time. Furthermore, we demonstrated low-cost adaptive approaches suitable for a stream- ing scenario. We proved the potential of TPStream by comparing it to industrial and academic solutions for CEP in experiments. </span></p><p class="c25"><span class="c1">Since research on situations in CEP is scarce, we focused our efforts on presenting a fundamental solution suited for this sce- nario and equipped it with the capabilities to handle the adaptive, low-latency nature of stream processing. For future work, we intend to extend TPStream to tackle out-of-order arrivals [7, 21] and parallel processing [24, 26]. </span></p><p class="c7"><span class="c14">ACKNOWLEDGMENTS </span><span class="c1">This work has been supported by the German Research Founda- tion (DFG) under grant no. SE 553/9-1. </span></p><p class="c7"><span class="c14">REFERENCES </span></p><p class="c7"><span class="c29">[1] Mohamed H. Ali and others. 2009. Microsoft CEP Server and Online Behavioral </span></p><p class="c7"><span class="c29">Targeting. Proc. of the VLDB Endowment 2, 2 (2009), 1558&ndash;1561. [2] James F. Allen. 1983. Maintaining knowledge about temporal intervals. Comm. </span></p><p class="c7"><span class="c29">of the ACM 26, 11 (1983), 832&ndash;843. [3] H.-J&uuml;rgen Appelrath and others. 2012. Odysseus: a highly customizable frame- work for creating efficient event stream management systems. In DEBS&rsquo;12. 367&ndash;368. [4] Arvind Arasu, Mitch Cherniack, Eduardo Galvez, David Maier, and Anurag Maskey. 2004. Linear road: a stream data management benchmark. In VLDB&rsquo;04. 480 &ndash; 491. [5] Ron Avnur and Joseph M. Hellerstein. 2000. Eddies: Continuously Adaptive </span></p><p class="c7"><span class="c29">Query Processing. In SIGMOD&rsquo;00. 261&ndash;272. [6] Shivnath Babu, Rajeev Motwani, Kamesh Munagala, Itaru Nishizawa, and Jennifer Widom. 2004. Adaptive ordering of pipelined stream filters. In SIG- MOD&rsquo;04. ACM, 407&ndash;418. [7] Badrish Chandramouli, Jonathan Goldstein, and David Maier. 2010. High- performance dynamic pattern matching over disordered streams. Proc. of the VLDB Endowment 3, 1 (2010), 220&ndash;231. [8] Alan J. Demers, Johannes Gehrke, Biswanath Panda, Mirek Riedewald, Varun Sharma, and Walker M. White. 2007. Cayuga: A General Purpose Event Monitoring System. In CIDR&rsquo;07. 412&ndash;422. [9] Yanlei Diao, Neil Immerman, and Daniel Gyllstrom. 2007. Sase+: An agile language for kleene closure over event streams. Technical Report. University of Massachusetts. [10] Martin Erwig. 2004. Toward Spatio-Temporal Patterns. In Spatio-Temporal </span></p><p class="c7"><span class="c29">Databases: Flexible Querying and Reasoning. Springer Berlin Heidelberg, 29&ndash;53. [11] Opher Etzion, Fabiana Fournier, Inna Skarbovsky, and Barbara von Halle. 2016. A model driven approach for event processing applications. In DEBS&rsquo;16. 81&ndash;92. [12] Ioannis Flouris, Nikos Giatrakos, Antonios Deligiannakis, Minos Garofalakis, Michael Kamp, and Michael Mock. 2016. Issues in complex event processing: Status and prospects in the Big Data era. Journal of Systems and Software (2016). [13] Dengfeng Gao, Christian S. Jensen, Richard T. Snodgrass, and Michael D. Soo. </span></p><p class="c7"><span class="c29">2005. Join operations in temporal databases. VLDB Journal 14, 1 (2005), 2&ndash;29. [14] Thanaa M. Ghanem, Walid G. Aref, and Ahmed K. Elmagarmid. 2006. Ex- ploiting predicate-window semantics over data streams. SIGMOD Record 35, 1 (2006), 3&ndash;8. [15] Lukasz Golab and M Tamer &Ouml;zsu. 2003. Processing sliding window multi-joins </span></p><p class="c8"><span class="c29">in continuous queries over data streams. In VLDB&rsquo;03. 500&ndash;511. [16] Lukasz Golab and M. Tamer &Ouml;zsu. 2005. Update-pattern-aware modeling and </span></p><p class="c7"><span class="c29">processing of continuous queries. In SIGMOD&rsquo;05. 658&ndash;669. [17] Michael Grossniklaus, David Maier, James Miller, Sharmadha Moorthy, and </span></p><p class="c8"><span class="c29">Kristin Tufte. 2016. Frames: Data-driven windows. In DEBS&rsquo;16. 13&ndash;24. [18] Annika Hinze and Agn&egrave;s Voisard. 2015. EVA: An event algebra supporting </span></p><p class="c7"><span class="c29">complex event specification. Information Systems 48 (2015), 1 &ndash; 25. [19] Bastian Ho&szlig;bach, Nikolaus Glombiewski, Andreas Morgen, Franz Ritter, and Bernhard Seeger. 2013. JEPC: The Java Event Processing Connectivity. Datenbank-Spektrum 13, 3 (2013), 167&ndash;178. [20] Ming Li, Murali Mani, Elke A. Rundensteiner, and Tao Lin. 2011. Complex event pattern detection over streams with interval-based temporal semantics. In DEBS&rsquo;11. 291&ndash;302. [21] Mo Liu, Ming Li, Denis Golovnya, Elke A. Rundensteiner, and Kajal Claypool. 2009. Sequence Pattern Query Processing over Out-of-Order Event Streams. In ICDE&rsquo;09. 784&ndash;795. [22] Yuan Mei and Samuel Madden. 2009. ZStream: a cost-based query processor </span></p><p class="c8"><span class="c29">for adaptively detecting composite events. In SIGMOD&rsquo;09. 193&ndash;206. [23] Olga Poppe, Chuan Lei, Elke A. Rundensteiner, and Daniel J. Dougherty. 2016. </span></p><p class="c8"><span class="c29">Context-Aware Event Stream Analytics. In EDBT 2016. 413&ndash;424. [24] Medhabi Ray, Chuan Lei, and Elke A Rundensteiner. 2016. Scalable pattern </span></p><p class="c7"><span class="c29">sharing on event streams. In SIGMOD&rsquo;16. 495&ndash;510. [25] Mahmoud Attia Sakr and Ralf Hartmut G&uuml;ting. 2011. Spatiotemporal pattern </span></p><p class="c7"><span class="c29">queries. GeoInformatica 15, 3 (2011), 497&ndash;540. [26] Nicholas Poul Schultz-M&oslash;ller, Matteo Migliavacca, and Peter Pietzuch. 2009. </span></p><p class="c19"><span class="c29">Distributed complex event processing with query rewriting. In DEBS&rsquo;09. 1&ndash;12. [27] Haopeng Zhang, Yanlei Diao, and Neil Immerman. 2014. On complexity and optimization of expensive queries in complex event processing. In SIGMOD&rsquo;14. ACM Press, 217&ndash;228. </span></p><p class="c7"><span class="c13">324 </span></p></body></html>