<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10pt;font-family:"Arial";font-style:normal}.c51{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Courier New";font-style:normal}.c28{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c84{margin-left:-16.2pt;padding-top:1.7pt;text-indent:35.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.3pt}.c40{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:19.9pt;font-family:"Arial";font-style:normal}.c39{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:12.9pt;font-family:"Arial";font-style:normal}.c90{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:17.9pt;font-family:"Arial";font-style:normal}.c55{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Arial";font-style:normal}.c35{margin-left:-16.2pt;padding-top:1.4pt;text-indent:35.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:17.5pt}.c52{margin-left:-20.4pt;padding-top:1.4pt;text-indent:34.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:12.9pt}.c86{margin-left:-25pt;padding-top:3.8pt;text-indent:33.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.9pt}.c19{margin-left:-16.2pt;padding-top:1.4pt;text-indent:25.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-25.9pt}.c26{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:12.8pt;font-family:"Arial";font-style:normal}.c23{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.8pt;font-family:"Arial";font-style:normal}.c30{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5pt;font-family:"Arial";font-style:normal}.c22{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c32{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.3pt;font-family:"Arial";font-style:normal}.c41{margin-left:-16.2pt;padding-top:1.7pt;text-indent:25.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-25.9pt}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Arial";font-style:normal}.c16{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12.9pt;font-family:"Arial";font-style:normal}.c49{margin-left:-25pt;padding-top:1.7pt;text-indent:33.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.9pt}.c12{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:9pt;font-family:"Arial";font-style:normal}.c75{margin-left:-25pt;padding-top:4.1pt;text-indent:33.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-22.4pt}.c69{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12.8pt;font-family:"Arial";font-style:normal}.c11{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10pt;font-family:"Arial";font-style:normal}.c58{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:9pt;font-family:"Arial";font-style:normal}.c68{margin-left:-25pt;padding-top:1.7pt;text-indent:33.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19pt}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Arial";font-style:normal}.c72{margin-left:-16.2pt;padding-top:3.8pt;text-indent:25.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-28.6pt}.c13{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Arial";font-style:normal}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.4pt;font-family:"Arial";font-style:normal}.c60{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.7pt;font-family:"Arial";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.4pt;font-family:"Times New Roman";font-style:normal}.c37{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:11.3pt;font-family:"Arial";font-style:normal}.c66{margin-left:-25pt;padding-top:3.8pt;text-indent:33.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18.3pt}.c62{margin-left:-16.2pt;padding-top:1.4pt;text-indent:35.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-23.3pt}.c14{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.3pt;font-family:"Arial";font-style:normal}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c27{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.8pt;font-family:"Arial";font-style:normal}.c18{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Arial";font-style:normal}.c33{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:11.4pt;font-family:"Arial";font-style:normal}.c44{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Courier New";font-style:normal}.c54{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:7.2pt;font-family:"Arial";font-style:normal}.c20{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:16.6pt;font-family:"Arial";font-style:normal}.c64{margin-left:-20.4pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-16.9pt}.c65{margin-left:-20.4pt;padding-top:3.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-4.6pt}.c45{margin-left:-11.4pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.2pt}.c78{margin-left:-22.3pt;padding-top:9.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:127.8pt}.c81{margin-left:-16.2pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-23.3pt}.c88{margin-left:-25pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-16.9pt}.c57{margin-left:-16.2pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-25.7pt}.c89{margin-left:-25pt;padding-top:11.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:63.3pt}.c59{margin-left:-20.4pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:0.2pt}.c47{margin-left:-16.2pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.4pt}.c87{margin-left:-16.2pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-18.5pt}.c73{margin-left:-16.2pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-24.5pt}.c36{margin-left:-25pt;padding-top:8.9pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.9pt}.c7{margin-left:-2.7pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-25.9pt}.c70{margin-left:-25pt;padding-top:8.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:6.9pt}.c61{margin-left:-22.3pt;padding-top:7.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:126.6pt}.c63{margin-left:-6.2pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-4.6pt}.c80{margin-left:-25pt;padding-top:11.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:113.7pt}.c67{margin-left:-16.2pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-2.6pt}.c38{margin-left:-16.2pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-24pt}.c24{margin-left:-2.7pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-25.7pt}.c74{margin-left:-16.2pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.8pt}.c42{margin-left:-16.2pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-25.9pt}.c77{margin-left:-16.2pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-25.7pt}.c15{margin-left:-16.2pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-25.4pt}.c53{margin-left:-16.2pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-22.3pt}.c17{margin-left:-2.7pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-25.9pt}.c85{margin-left:-16.2pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-21.8pt}.c79{margin-left:-16.2pt;padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:157pt}.c8{margin-left:220.6pt;padding-top:66.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-33.4pt}.c21{margin-left:-20.4pt;padding-top:0.5pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-16.9pt}.c34{margin-left:220.6pt;padding-top:70.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-33.4pt}.c29{margin-left:-25pt;padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:114.9pt}.c31{margin-left:-25pt;padding-top:8.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.9pt}.c48{margin-left:-20.4pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-9.4pt}.c82{padding-top:8.9pt;text-indent:26.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c56{padding-top:9.1pt;text-indent:25.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c76{padding-top:9.1pt;text-indent:25.3pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c71{padding-top:8.9pt;text-indent:26.2pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c83{padding-top:11.3pt;text-indent:26.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c10{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c9{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c25{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c43{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c46{margin-left:-16.2pt;margin-right:-25.9pt}.c50{margin-left:-11.4pt;margin-right:-1.7pt}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:24pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:14pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c43"><p class="c9"><span class="c90">Subgraph Querying with Parallel Use of Query Rewritings and Alternative Algorithms </span></p><p class="c2"><span class="c22">Foteini Katsarou </span><span class="c20">School of Computing Science University </span><span class="c40">research.gla.ac.uk </span></p><p class="c2"><span class="c40">f.katsarou.1@ </span><span class="c20">of Glasgow, UK </span><span class="c22">Nikos Ntarmos </span><span class="c20">School of Computing Science University </span><span class="c40">nikos.ntarmos@ glasgow.ac.uk </span></p><p class="c2"><span class="c20">of Glasgow, UK </span><span class="c22">Peter Triantafillou </span><span class="c20">School of Computing Science University </span><span class="c40">peter.triantafillou@ </span><span class="c20">of Glasgow, UK </span><span class="c40">glasgow.ac.uk </span></p><p class="c2"><span class="c22">ABSTRACT </span><span class="c1">Subgraph queries are central to graph analytics and graph DBs. We analyze this problem and present key novel discov- eries and observations on the nature of the problem which hold across query sizes, datasets, and top-performing algo- rithms. Firstly, we show that algorithms (for both the de- cision and matching versions of the problem) suffer from straggler queries, which dominate query workload times. As related research caps query times not reporting results for queries exceeding the cap, this can lead to erroneous con- clusions of the methods&rsquo; relative performance. Secondly, we study and show the dramatic effect that isomorphic graph queries can have on query times. Thirdly, we show that for each query, isomorphic queries based on proposed query rewritings can introduce large performance benefits. Fourthly, that straggler queries are largely algorithm-specific: many challenging queries to one algorithm can be executed effi- ciently by another. Finally, the above discoveries naturally lead to the derivation of a novel framework for subgraph query processing. The central idea is to employ parallelism in a novel way, whereby parallel matching/decision attempts are initiated, each using a query rewriting and/or an alter- nate algorithm. The framework is shown to be highly ben- eficial across algorithms and datasets. </span></p><p class="c2"><span class="c22">CCS Concepts </span></p><p class="c2"><span class="c1">&bull;Information systems &rarr; Database query processing; </span></p><p class="c2"><span class="c1">&bull;Mathematics of computing &rarr; Graph algorithms; </span></p><p class="c2"><span class="c22">Keywords </span><span class="c1">Graph databases, graph query processing, subgraph isomor- phism </span></p><p class="c2"><span class="c22">1. INTRODUCTION </span></p><p class="c10"><span class="c1">Graphs are ideal for representing complex entities and their relationships/interactions and subgraph querying is es- sential to graph analytics. In subgraph querying, given a </span></p><p class="c10"><span class="c1">c </span><span class="c55">2017, Copyright is with the authors. Published in Proc. 20th Inter- national Conference on Extending Database Technology (EDBT), March 21-24, 2017 - Venice, Italy: ISBN 978-3-89318-073-8, on OpenProceed- ings.org. Distribution of this paper is permitted under the terms of the Cre- ative Commons license CC-by-nc-nd 4.0 </span></p><p class="c10"><span class="c1">pattern graph (query) and a graph DB, we want to know whether it is contained in each DB graph (the decision prob- lem) and/or find all its occurrences within it (the match- ing problem). Subgraph querying entails the subgraph iso- morphism problem (abbreviated as sub-iso), which is NP- complete. Subgraph querying has received a lot of atten- tion. Related work is categorized in two major categories: the filter-then-verify (FTV) and the no-filter, verify (NFV) methods. Numerous methods have been proposed for the problem and three recent experimental analysis papers ([7, 9, 12]) compare and stress-test proposed methods. </span></p><p class="c10"><span class="c1">In this work, we conduct a comprehensive analysis of this problem. Our analysis aims to (i) lead to interesting novel findings about the nature of the problem and existing solu- tions, (ii) analyse and quantify said discoveries and their ef- fect on well-established existing solutions, and (iii) show that the findings can be used to develop a framework that can offer large performance gains. Specifically, we first recognize the existence of &ldquo;straggler&rdquo; queries; i.e., queries whose execu- tion time is dramatically higher than the rest. This holds for all query workloads and all datasets examined and across all tested FTV and NFV algorithms. Subsequently, we reveal and quantify the interesting fact that isomorphic instances of queries can have a wild variation in querying times. Then we generate isomorphic instances of the original query using statistics on vertex-label frequencies and/or vertex degrees and we investigate their performance. Moreover, for NFV methods in particular, we additionally show that challeng- ing queries are algorithm-specific, with a straggler query for one algorithm possibly being easy for others. Finally, we incorporate these findings in a novel framework, coined the &Psi;-framework, that exploits parallelism for both FTV and NFV methods, achieving large performance gains. Specifi- cally, instead of trying to come up with new algorithms for sub-iso testing, we utilize isomorphic query rewritings and existing alternative algorithms in parallel. Extensive experi- mentation shows that our framework can be highly beneficial across datasets and workloads, and for both FTV and NFV methods. </span></p><p class="c2"><span class="c22">2. BACKGROUND </span></p><p class="c2"><span class="c22">2.1 Related work </span></p><p class="c10"><span class="c1">Related work is categorized in two major categories. In the first category, proposed methods typically address a de- cision problem, where given a dataset of many (typically small) graphs and a query/pattern graph q, the method de- cides whether q is contained in any graph in the dataset. </span></p><p class="c2"><span class="c4">Series ISSN: 2367-2005 25 </span><span class="c51">10.5441/002/edbt.2017.04 </span></p><p class="c36"><span class="c1">Most of the so-called filter-then-verify (FTV) or indexed sub- graph query processing methods solve this decision problem, and work in 2 stages. In the index construction phase, stored graphs are decomposed into features which are then indexed, along with graph-id lists; i.e., lists of graphs that contain the feature. During query processing, query graphs are similarly decomposed into features; graphs from the dataset that do not contain one or more of these features definitely do not contain the query and are thus pruned away. The remaining graphs form the candidate set. At the verification stage, the query graph is tested for subgraph isomorphism against each graph in the candidate set to produce the final answer. The target of all these methods is to prune the candidate set and thus to reduce the number of sub-iso tests performed. Re- lated works can be classified along 4 major dimensions: (i) type of indexed features (where &ldquo;feature&rdquo; refers to substruc- tures of indexed graphs used to produce the index, indepen- dently of whether these are actually stored in the index or not): paths [1, 5, 30], trees [15, 25], simple cycles, or graphs [3, 20, 21, 22, 24, 29]; (ii) approach for extracting said fea- tures from indexed graphs: i.e., exhaustive enumeration [1, 10, 20, 30] or frequent subgraph mining techniques [3, 21, 22, 24, 25, 29]; (iii) index data structure: hash table, tree, trie; and (iv) whether the index stores location information or not. FTV methods are extensively discussed in [7, 9]. In [9] we concluded that Grapes[5] and GGSX[1] are the best solutions in terms of index construction and query process- ing time, and scalability limitations. </span></p><p class="c68"><span class="c1">In the second category, proposed methods address a match- ing problem, whereby sub-iso testing is performed to find all the embeddings of the query graph q in a given large, stored graph g without performing any graph filtering in advance. We will call them the no-filter, verify (NFV) methods. Pro- posed methods, apart from the sub-iso test, additionally comprise of a pre-processing step where they maintain a feature-based index consisting of: (i) vertices and edges [15, 18], (ii) shortest paths [28] or (iii) subgraphs [8, 26] up to a certain size. The algorithms store vertex label lists along with additional information to facilitate the sub-iso test. A number of such methods were presented and compared in [12], concluding that (i) although there was no single algo- rithm to outperform all others in all occasions, GraphQL[8] was the only one that managed to complete all the tested query workloads; (ii) all three of GraphQL, sPath[28] and QuickSI[15] showed very good performance; but also that (iii) all existing algorithms have weaknesses in the way they apply their join selection and pruning heuristics, leading to the need for new graph matching algorithms. </span></p><p class="c88"><span class="c1">There is nothing obstructing the NFV methods being ap- plied for the decision problem and the FTV methods for the matching problem. FTV methods were originally pro- posed to work with datasets consisting of numerous, rela- tively small graphs, and their effectiveness relies on their achieved filtering, whereas NFV methods construct an in- dex primarily to locate candidate vertices of the query in a large stored graph. For the current work, we opt to utilize all proposed methods for the originally proposed problems. TwinTwig[11] and sTwig[16] deal with very large graphs, stored in a distributed infrastructure, and rely on parallel computing to perform sub-iso testing. Within FTV meth- ods, iGQ[19] is a recent approach that employs caching on top of any proposed FTV method to improve performance. Semertzidis et al. [14] considered pattern queries over time- </span></p><p class="c10 c46"><span class="c1">evolving graphs, which are beyond the scope of this study. Finally, there has been considerable work on the subject of approximate graph pattern matching. Related techniques (e.g. [10, 17, 20, 23, 27]) perform subgraph matching, but with the support for wildcards and/or approximate matches. All of these algorithms are not directly related to our work as we focus on exact subgraph matching. </span></p><p class="c19"><span class="c1">As subgraph querying is an important problem, we expect that many researchers will keep focusing on trying to im- prove upon existing algorithms in the future. Indeed, since the publication just a few years ago of [12], comprehensively comparing the then state of art, newer algorithms have been proposed [6] with better performance. Nonetheless all al- gorithms show exponential execution times even at small query sizes (up to 10 edges)[13]. Our contributions aim to help this process in two ways. First, by revealing key in- sights, based on comprehensive experimentation, about the problem itself and how they affect well-known algorithms. Second, by shedding light onto a novel overall approach to the problem and its benefits. Namely, instead of focusing solely on developing new solutions by improving earlier al- gorithms, try to benefit from the wealth of ideas already existing within previous algorithms! Specifically, our find- ings show that different algorithms are appropriate for dif- ferent queries. Furthermore, they show that different query rewritings are appropriate for different queries and for dif- ferent algorithms! Finally, the existence of straggler queries poses new challenges for the performance comparison of dif- ferent algorithms, needing more detailed performance met- rics and experimenting with more challenging queries. All current works miss the above points: (i) they only consider one query rewriting, if at all, for all queries, (ii) they use only one algorithm for all workload queries, and (iii) they do not stress-test their algorithms with more challenging queries (e.g., larger sizes). Our framework shows that such misses also lead to misses of dramatic performance improvements. </span><span class="c22">2.2 Definitions </span></p><p class="c46 c83"><span class="c1">Definition 1 (Graph). A graph G = (V,E,L) is de- fined as the triplet consisting of the set V = {v</span><span class="c3">i</span><span class="c18">},i = 1, ..., n </span><span class="c1">of vertices of the graph, the set E &sube; {(v, u) : v, u &isin; V } of edges between vertices in the graph, and a function L : V |E &rarr; L assigning a label l &isin; L (L being the set of all possible labels) to each vertex v &isin; V and each edge e &isin; E. </span></p><p class="c46 c56"><span class="c1">We assume that each node in a graph is assigned an integer in the interval [1,n], so that no two nodes in a graph have the same number; we call this the node ID. </span></p><p class="c46 c82"><span class="c1">Definition 2 (Graph Isomorphism). Two graphs G = (V,E,L) and G = (V ,E ,L ) are isomorphic iff there exists a bijection I : V &rarr; V that maps each vertex of G to a vertex of G , such that if (u, v) &isin; E then (I(u),I(v)) &isin; E , L(u) = L (I(u)), L(v) = L (I(v)), and vice versa. </span></p><p class="c46 c76"><span class="c1">Note that, given a graph G, a graph G isomorphic to G can be trivially produced by permuting the node IDs in G. </span></p><p class="c46 c71"><span class="c1">Definition 3 (Subgraph Isomorphism). A graph G = (V,E,L) is subgraph isomorphic to a graph G = (V ,E , L ), denoted by G &sube; G , iff there exists an injective function I : V &rarr; V such that if (u, v) &isin; E then (I(u),I(v)) &isin; E and L(u) = L (I(u)) and L(v) = L (I(v)). Graph G is then called a subgraph of G . </span></p><p class="c8"><span class="c4">26 </span></p><p class="c31"><span class="c1">Much like all of the works mentioned earlier, we focus on non-induced subgraph isomorphism. </span></p><p class="c89"><span class="c22">3. EXPERIMENTAL SETUP </span></p><p class="c70"><span class="c22">3.1 Short description of used Algorithms </span></p><p class="c78"><span class="c28">3.1.1 FTV methods </span></p><p class="c66"><span class="c1">Both Grapes[5] and GGSX[1] index the simplest form of features &ndash; i.e., paths &ndash; up to a maximum length. Paths are searched in a DFS manner and indexed in a trie or suf- fix tree respectively. Compared to GGSX, Grapes takes an additional step and maintains location information. Also, Grapes features multi-threaded design for both indexing and query processing. In query processing, maximal paths of the query are extracted to form the query index which is matched with the dataset index, pruning away unmatched branches. Subsequently, the search space is further pruned by the frequencies of indexed features. After this step, GGSX forms its candidate set of graphs that will undergo sub-iso testing. Grapes further exploits the maintained location in- formation to extract relevant connected components of the dataset graphs, against which sub-iso testing is performed. </span></p><p class="c49"><span class="c1">The underlying isomorphism algorithm for both Grapes and GGSX is VF2[4]. VF2 does not define any order in which query vertices are selected. Given a query graph q and a dataset graph g, the algorithm chooses a vertex from q to match to vertices in g, and proceeds by then trying to match still unmatched vertices adjacent to the matched ones in q. Given an unmatched vertex in q, the set of can- didate vertices of g is defined as the set of all vertices in g with the same label as the unmatched vertex in q. VF2 then employs 3 pruning rules to reduce the number of can- didate vertices. The first rule removes candidates that are not directly connected to the already matched vertices of g. The second rule removes all candidates for which the num- ber of adjacent unmatched nodes which are also adjacent to matched nodes of g, is smaller than the corresponding fig- ure for the matched vertex of q. The final rule removes all g candidates with less adjacent (matched/candidate) nodes than the corresponding figure in q. </span></p><p class="c61"><span class="c28">3.1.2 NFV methods </span></p><p class="c86"><span class="c1">In the sub-iso test of QuickSI[15] (QSI for short), priority is given to the vertices with infrequent labels and infrequent adjacent edge labels. In the indexing phase, QuickSI pre- computes the frequencies of labels and edges and uses them to compute the &ldquo;average inner support&rdquo; of a vertex or an edge; i.e., the average number of possible mappings of the vertex or edge in the graph. The inner support is later used in the graph matching process to assign weights on the edges of the query graph and construct a rooted minimum span- ning tree (MST). In case of symmetries, edges are added in such a way that will make the MST denser. The order in which vertices are inserted to the MST defines the order in which they are then matched in the sub-iso test. </span></p><p class="c49"><span class="c1">In the indexing phase of GraphQL[8] (GQL for short), the labels of all vertices along with the neighbourhood sig- natures, which capture the labels of neighbouring nodes in a radius i in lexicographical order, are indexed. In the sub- graph matching phase, the algorithm starts by retrieving all possible matches for each node in the pattern. Subsequently, 3 rules are applied in order to prune the search space. First, </span></p><p class="c10 c46"><span class="c1">the indexed vertex labels and neighbourhood signatures are used to infeasible matches. Then a pseudo subgraph iso- morphism algorithm is applied to the problem iteratively up to level l; i.e., for every pair of possible graph-query ver- tex matches, the nodes adjacent to the query node should be matched to the corresponding neighbours of the graph. Finally, the algorithm needs to optimize the search order in the query before proceeding with the actual sub-iso test, which in turn consists of a number of joins of the candidate node lists. This optimization is based on an estimation of the result-set size of intermediate joins, and as it would be very expensive to enumerate all possible search orders, only left-deep query plans are considered. </span></p><p class="c41"><span class="c1">sPath[28] (SPA for short), similarly to GraphQL, also maintains a neighbourhood signature comprised of shortest paths organized in a compact indexing structure. Specifi- cally, in order to reduce the storing space, shortest paths are not really maintained, but they are decomposed in a distance-wise structure. In the query processing, the query is initially decomposed in shortest paths that are then matched to the candidate shortest paths from the stored graph. From all possible candidate shortest paths, those that (i) can cover the query and (ii) provide good selectivity, i.e. minimize the estimated result-set size of each join operation, are selected as candidates. For each one of the selected paths, an edge- by-edge verification is then used to perform the sub-iso test. </span></p><p class="c79"><span class="c22">3.2 Setup </span></p><p class="c72"><span class="c1">Experiments with Grapes and GGSX were conducted on a small cluster consisting of 5 nodes, each featuring an Intel Core i5-3570 CPU (3.4GHz, 4 physical cores, 6MB cache), 16GB of RAM, 500GB disk per node, and running Ubuntu Linux 14.04. Experiments with QuickSI, GraphQL and sPath (i.e., the NFV methods) were conducted on a Windows 7 SP1 host, with 2 Intel Xeon E5-2660 CPUs (2.20GHz, 20MB cache) with 8 cores/16 vcores per CPU, 128GB of RAM, and 3.5TB disk. For practical purposes, we allowed a maximum limit of 10 mins for each query to be processed. Beyond that time, the execution is terminated and we proceed with the next query in the workload. Please note that this 10&rsquo; limit does not apply in the indexing phases of the algorithms. </span></p><p class="c41"><span class="c1">For Grapes and GGSX we used the implementations pro- vided by their respective authors. However, in the case of Grapes, we had to alter the source code so that the VF2 verification step returns after the first match of the query graph, as opposed to the original implementation which was returning all possible matches. The reason for this is that FTV methods are mainly designed to retrieve the graphs that contain the query as an answer. For QuickSI, GraphQL and sPath, we used the implementation provided by [12]. </span></p><p class="c19"><span class="c1">We used the default values for the input parameters of the compared algorithms, as they were defined by their re- spective authors in the relevant publications and/or in their implementation code. More specifically: </span></p><p class="c17"><span class="c1">&bull; For GGSX and Grapes, we enumerated paths of up to size of 4. </span></p><p class="c7"><span class="c1">&bull; We ran Grapes with 1 and 4 threads; results for execu- tions with 1 (resp. 4) threads are denoted by Grapes/1 (resp. Grapes/4). </span></p><p class="c17"><span class="c1">&bull; For GraphQL, we used a refined level of iterations of pseudo-subgraph isomorphism r = 4. </span></p><p class="c24"><span class="c1">&bull; For sPath, we used a neighbourhood radius of 4 and maximum path length 4. </span></p><p class="c8"><span class="c4">27 </span></p><p class="c2"><span class="c1">PPI Synthetic </span><span class="c13">t esata</span><span class="c1">D# graphs #disconnected #labels 20 graphs 20 46 1000 </span></p><p class="c25"><span class="c1">0 20 </span><span class="c13">h parGre</span><span class="c1">P</span><span class="c13">Avg #nodes </span><span class="c1">StdDev #nodes Avg #edges Avg density Avg degree Avg #labels </span><span class="c13">4942 1100 </span><span class="c1">2648 483 26667 12487 0.0022 0.020 10.87 24.5 28.5 20 </span></p><p class="c2"><span class="c1">Table 1: Dataset characteristics for FTV methods </span></p><p class="c2"><span class="c1">yeast human wordnet #nodes 3112 4674 82670 #edges 12519 86282 120399 Avg degree 8.04 36.91 2.912 StdDev degree #nodes 14.50 54.16 7.74 Density 0.00258 0.0079 0.000035 #labels 184 90 5 Avg frequency labels 127 240 16534 StdDev frequency labels 322.5 430 152 </span></p><p class="c2"><span class="c1">Table 2: Dataset characteristics for NFV methods </span></p><p class="c2"><span class="c1">&bull; For QuickSI, GraphQL and sPath the number of searched embeddings of the pattern graph on the stored graph is capped at 1000; i.e., after finding the first 1000 matches, the algorithms terminate. </span><span class="c22">3.3 Datasets </span></p><p class="c10"><span class="c1">We have chosen datasets which (a) have also been used by other studies, so as to enable possible direct comparisons, and (b) have key characteristics covering a large part of the design space (e.g., regarding graph size and density). </span></p><p class="c10"><span class="c1">Table 1 summarizes the characteristics of the datasets that we used for the FTV methods. PPI (used in [5, 9]) is a real dataset representing 20 different protein-protein interaction networks. The majority of existing real datasets that were used for the FTV methods comprise of relatively small and sparse graphs. In [9] we showed that, for such datasets, both Grapes and GGSX perform adequately well. For our current study we are further interested in more challenging datasets and we thus employ an additional synthetic dataset generated with GraphGen[2], allowing various parameters of interest to be specified; namely, number of graphs, average number of nodes and density per graph, number of labels in the dataset). A more detailed description of how GraphGen constructs the dataset can be found in [9]. </span></p><p class="c10"><span class="c1">Datasets used for the NFV methods consist of only one graph as the primary task of these methods is to find all oc- currences of the pattern graph in the large stored graph. Ta- ble 2 summarizes the characteristics of the three real datasets &ndash; namely yeast, human and wordnet &mdash; that we have used for the NFV methods. Yeast and human were previously used in [12], while Wordnet</span><span class="c11">1 </span><span class="c1">was used in [16]. </span></p><p class="c2"><span class="c22">3.4 Query Workloads </span></p><p class="c2"><span class="c1">To generate each of the queries, first we select a graph from the dataset uniformly and at random, and from that </span></p><p class="c2"><span class="c6">1</span><span class="c18">http://vlado.fmf.uni-lj.si/pub/networks/data/dic/Wordnet/ Wordnet.htm </span></p><p class="c2"><span class="c44">)</span><span class="c18">. </span><span class="c1">When applied to query processing times, the QLA </span></p><p class="c2"><span class="c4">28 </span></p><p class="c10"><span class="c1">graph we select a node uniformly and at random. Starting from said node, we generate a query graph by incremen- tally adding edges chosen uniformly at random from the set of all edges adjacent to the resulting query graph, until it reaches the desired size. For the synthetic dataset, we used 100 queries of size 24, 32 and 40 edges for Grapes/1 and Grapes/4. We did not run GGSX against the synthetic dataset, because of excessive amount of time required for the experiments to complete. For the PPI dataset, we used 100 queries of size 16, 20, 24, and 32 edges. For the NFV methods, we used 200 queries of 10, 16, 20, 24 and 32 edges. Last, for QuickSI we only report results against the yeast dataset, as (i) it was the easiest NFV dataset to process, and (ii) QuickSI always had many more cases, compared to GraphQL and sPath, where query processing exceeded the 10&rsquo; cap. For all used methods, the majority of the queries completed in under 2&rdquo;. We call them easy queries. Another portion of queries had processing times in the 2&rdquo; to 600&rdquo; range; we denote these 2&rdquo;-600&rdquo; queries. We use the term completed to refer to all queries that finished within the 10&rsquo; limit; those that did not are called hard or killed. </span></p><p class="c2"><span class="c22">3.5 Performance Metrics </span></p><p class="c10"><span class="c1">For every query against a stored graph, we measure the Execution Time, denoted exec time, for both FTV and NFV methods, while avg exec time denotes the average execution time. Specifically for FTV methods, this is the pure sub-iso time; i.e., excluding the index loading and filtering times, which add only a trivial overhead. For FTV methods re- ported times are in seconds, while for NFV methods times are in milliseconds, unless stated otherwise. </span></p><p class="c25"><span class="c1">Let q</span><span class="c3">i </span><span class="c18">be a given query and t</span><span class="c6">M</span><span class="c3">i </span><span class="c1">the exec time of q</span><span class="c3">i </span><span class="c18">over </span><span class="c1">method and </span><span class="c18">be the </span><span class="c1">t</span><span class="c11">M</span><span class="c6">i,j </span><span class="c18">exec </span><span class="c13">the </span><span class="c1">M. </span><span class="c18">time </span><span class="c13">exec </span><span class="c1">Let also </span><span class="c13">time </span><span class="c18">of q</span><span class="c3">i,j </span><span class="c1">q</span><span class="c6">i,j </span><span class="c13">of </span><span class="c18">over </span><span class="c1">be </span><span class="c13">q</span><span class="c6">i,j </span><span class="c1">the </span><span class="c18">our </span><span class="c1">over j-th </span><span class="c18">proposed </span><span class="c1">method isomorphic M. </span><span class="c18">&Psi;-framework. </span><span class="c1">Finally, instance let of </span><span class="c18">We </span><span class="c1">t</span><span class="c11">&Psi;</span><span class="c6">i,j </span><span class="c1">q</span><span class="c6">i </span></p><p class="c2"><span class="c1">define the (max/min) metric as: value of this metric is 1, indicating </span><span class="c11">max</span><span class="c6">min</span><span class="c1">that </span><span class="c14">j</span><span class="c30">j</span><span class="c6">(t</span><span class="c11">(t</span><span class="c32">M</span><span class="c30">i,j</span><span class="c32">M</span><span class="c30">i,j</span><span class="c1">there </span><span class="c11">) ) </span></p><p class="c25"><span class="c13">. The minimum </span><span class="c1">are no varia- tions between the min and max exec time. The higher the value of this metric, the higher the differences between the min and max exec time achieved by the isomorphic query in- stances. We also define the speedup</span><span class="c11">&lowast; </span><span class="c1">metric as: is set to: (i) min</span><span class="c3">j</span><span class="c18">(t</span><span class="c6">M</span><span class="c3">i,j</span><span class="c1">), when comparing against </span><span class="c11">t</span><span class="c3">T </span><span class="c32">M</span><span class="c30">i</span><span class="c1">the , where various T </span></p><p class="c25"><span class="c1">isomorphic instances of q</span><span class="c3">i</span><span class="c18">, (ii) min</span><span class="c3">M</span><span class="c18">(t</span><span class="c6">M</span><span class="c3">i,j</span><span class="c1">), when compar- ing against against our different &Psi;-framework. methods, speedupand </span><span class="c11">&lowast; </span><span class="c1">(iii) represents t</span><span class="c11">&Psi;</span><span class="c6">i </span><span class="c13">, when comparing </span><span class="c1">what we lose in performance if we choose the original method over the various alternatives; i.e., speedup</span><span class="c11">&lowast; </span><span class="c1">equals the maximum at- tainable speedup over the original method, if we chose the best of the examined alternatives. For comparison purposes, for queries that were killed at the 10&rsquo; limit we use this time (i.e., 600&rdquo;) as their minimum execution time. </span></p><p class="c2"><span class="c1">When comparing two sets of measurements A = {A</span><span class="c6">i</span><span class="c1">} and B = {B</span><span class="c3">i</span><span class="c18">}, we can compute their average ratio in two ways: </span></p><p class="c2"><span class="c1">&bull; Workload-Level When A and B contain Aggregation query (WLA), response given times, by the </span><span class="c11">avg</span><span class="c6">avg</span><span class="c1">WLA </span><span class="c30">i</span><span class="c14">i</span><span class="c11">(B</span><span class="c6">(A</span><span class="c30">i</span><span class="c14">i</span><span class="c6">)</span><span class="c11">) </span></p><p class="c2"><span class="c13">. </span></p><p class="c10"><span class="c1">computation would give the improvement in the overall average execution time. This metric is important from the system perspective as it encapsulates the overall performance change. </span></p><p class="c2"><span class="c1">&bull; Query-Level Average (QLA), computed as avg</span><span class="c3">i </span></p><p class="c2"><span class="c44">( </span><span class="c3">BA</span><span class="c14">ii </span></p><p class="c2"><span class="c0">PPI synthetic </span></p><p class="c2"><span class="c1">(c) Percentages of easy, 2&rdquo;-600&rdquo;, and hard queries </span></p><p class="c2"><span class="c1">Figure 1: Stragglers in FTV methods </span></p><p class="c2"><span class="c1">computation would give the average of per-query im- provements. This metric is user-centric in the sense that each user cares what the performance improve- ment for his query is using different methods. In both cases, avg</span><span class="c6">i</span><span class="c1">(X</span><span class="c6">i</span><span class="c1">) is the average over all items X</span><span class="c6">i </span><span class="c1">in the set X. Based on this distinction, the aforementioned (max/min) and speedup</span><span class="c11">&lowast; </span><span class="c1">metrics can have a QLA or WLA version, denoted with a matching subscript; e.g., speedup</span><span class="c11">&lowast;</span><span class="c6">QLA</span><span class="c1">. These two variants also carry over to other computations; for example, the standard deviation of the ratio of A and B would be computed as </span><span class="c11">stdDev</span><span class="c30">i</span><span class="c11">(B</span><span class="c30">i</span><span class="c11">) </span></p><p class="c10"><span class="c6">stdDev</span><span class="c14">i</span><span class="c6">(A</span><span class="c14">i</span><span class="c6">) </span><span class="c13">under WLA, and as </span><span class="c1">stdDev</span><span class="c6">i</span><span class="c1">(B</span><span class="c6">i</span><span class="c1">/A</span><span class="c6">i</span><span class="c1">) under QLA. However, unless stated other- wise, we shall use QLA and WLA to denote averages. </span></p><p class="c2"><span class="c22">4. STRAGGLER QUERIES </span></p><p class="c10"><span class="c1">We know that as the dataset grows in terms of the size of graphs, query processing becomes harder; ditto as the size of the query graph increases [9]. But do these statements hold across all queries-dataset graph combinations? Run- ning many queries against the whole dataset can hide the details of how much time is required per individual query- graph pair. In the case that a small portion of such pairs dominates the whole execution time, then by just looking at the whole query workload execution times it is easy to draw wrong conclusions about the algorithms&rsquo; performance. Also, several related works choose to ignore queries whose execution is much higher compared to the rest. To inves- tigate the above, in this study we execute each individual query against a single stored graph at a time. </span></p><p class="c2"><span class="c0">W</span><span class="c12">LA-Avg exec time (s) </span></p><p class="c2"><span class="c0">easy </span></p><p class="c2"><span class="c0">W</span><span class="c12">LA-Avg exec time (s) </span></p><p class="c2"><span class="c0">easy </span></p><p class="c2"><span class="c0">% </span><span class="c12">of queries </span></p><p class="c2"><span class="c0">easy </span></p><p class="c2"><span class="c1">(a) Synthetic dataset, WLA-Avg exec time (s) </span></p><p class="c2"><span class="c0">0.01 </span><span class="c12">0.1 1 10 100 </span></p><p class="c2"><span class="c0">Grapes/1 Grapes/4 GGSX </span></p><p class="c2"><span class="c1">(b) PPI dataset, WLA-Avg exec time (s) </span></p><p class="c2"><span class="c0">0 </span><span class="c12">20 40 60 80 100 </span></p><p class="c2"><span class="c0">Grapes/1 Grapes/4 Grapes/1 Grapes/4 GGSX </span></p><p class="c2"><span class="c0">0.01 </span><span class="c12">0.1 1 10 100 </span></p><p class="c2"><span class="c0">Grapes/1 Grapes/4 </span></p><p class="c2"><span class="c0">2&rsquo;&rsquo;-600&rsquo;&rsquo; </span></p><p class="c2"><span class="c0">2&rsquo;&rsquo;-600&rsquo;&rsquo; </span></p><p class="c2"><span class="c0">2&rsquo;&rsquo;-600&rsquo;&rsquo; </span></p><p class="c2"><span class="c0">hard </span></p><p class="c2"><span class="c0">completed </span></p><p class="c2"><span class="c0">completed </span></p><p class="c2"><span class="c0">wordnet human yeast </span></p><p class="c2"><span class="c1">(d) Percentages of easy, 2&rdquo;-600&rdquo;, and hard queries </span></p><p class="c2"><span class="c1">Figure 2: Stragglers in NFV methods </span></p><p class="c10"><span class="c1">Observation 1: In all of workloads generated by us or found in other papers, our experiments show &ldquo;stragglers&rdquo;; i.e., queries whose processing time is many orders of mag- nitude higher compared to the rest. </span></p><p class="c10"><span class="c1">In order to back our observation, we present our results from the experiments on the aforementioned datasets against both FTV and NFV methods (fig. 1 and 2). </span></p><p class="c2"><span class="c22">4.1 FTV methods </span></p><p class="c10"><span class="c1">Fig. 1 presents the results from the query workloads on the FTV methods. Specifically, 1(a) and 1(b) show the average execution times for the corresponding algorithms for the syn- thetic and the PPI dataset respectively (GGSX/synthetic results omitted; see &sect;3.4). 1(c) presents the percentage of the sub-iso tests that were easy, 2&rdquo;-600&rdquo;, and hard for both the synthetic and PPI datasets. As expected, Grapes/4 has a much smaller percentage of killed queries compared to Grapes/1 and GGSX. A notable thing here is that although for both Grapes/1 and Grapes/4 the percentage of 2&rdquo;-600&rdquo; </span></p><p class="c2"><span class="c4">29 </span></p><p class="c2"><span class="c0">W</span><span class="c12">LA-Avg exec time (ms) </span></p><p class="c2"><span class="c0">easy </span></p><p class="c2"><span class="c0">W</span><span class="c12">LA-Avg exec time (ms) </span></p><p class="c2"><span class="c0">easy </span></p><p class="c2"><span class="c0">W</span><span class="c12">LA-Avg exec time (ms) </span></p><p class="c2"><span class="c0">easy </span></p><p class="c2"><span class="c0">% </span><span class="c12">of queries </span></p><p class="c2"><span class="c1">(c) wordnet dataset, WLA-Avg exec time (ms) </span></p><p class="c2"><span class="c0">0 </span><span class="c12">20 40 60 80 100 </span></p><p class="c2"><span class="c0">GQL SPA QSI GQL SPA GQL SPA </span></p><p class="c2"><span class="c1">(b) human dataset, WLA-Avg exec time (ms) </span></p><p class="c2"><span class="c0">1 </span><span class="c12">10 100 1000 10000 100000 </span></p><p class="c2"><span class="c0">GQL SPA </span></p><p class="c2"><span class="c0">1 </span><span class="c12">10 100 1000 10000 100000 1e+06 </span></p><p class="c2"><span class="c0">GQL SPA QSI </span></p><p class="c2"><span class="c1">(a) yeast dataset, WLA-Avg exec time (ms) </span></p><p class="c2"><span class="c0">1 </span><span class="c12">10 100 1000 10000 100000 1e+06 </span></p><p class="c2"><span class="c0">GQL SPA </span></p><p class="c2"><span class="c0">easy </span></p><p class="c2"><span class="c0">2&rsquo;&rsquo;-600&rsquo;&rsquo; </span></p><p class="c2"><span class="c0">2&rsquo;&rsquo;-600&rsquo;&rsquo; </span></p><p class="c2"><span class="c0">2&rsquo;&rsquo;-600&rsquo;&rsquo; </span></p><p class="c2"><span class="c0">2&rsquo;&rsquo;-600&rsquo;&rsquo; </span></p><p class="c2"><span class="c0">hard </span></p><p class="c2"><span class="c0">completed </span></p><p class="c2"><span class="c0">completed </span></p><p class="c2"><span class="c0">completed </span></p><p class="c2"><span class="c1">GraphQL sPath QuickSI </span></p><p class="c2"><span class="c13">e gde-0</span><span class="c1">1AET easy (ms) 66.84 134.78 131.67 % of easy 100 99.5 99 AET 2&rdquo;-600&rdquo; (ms) - 2871.44 50367.40 % of 2&rdquo;-600&rdquo; 0 0.5 1 % of hard 0 0 0 </span></p><p class="c2"><span class="c13">e gde-2</span><span class="c1">3AET easy (ms) 130.66 120.71 96.62 % of easy 80 91 67.5 AET 2&rdquo;-600&rdquo; (ms) 140812 140781 78917.2 % of 2&rdquo;-600&rdquo; 6.5 3 6 % of hard 13.5 6 26.5 </span></p><p class="c2"><span class="c1">Table 3: Results for NFV methods on the yeast dataset (AET: avg exec time)</span><span class="c18">GraphQL sPath </span></p><p class="c2"><span class="c13">e gde-0</span><span class="c1">1AET easy (ms) 179.49 209.91 % of easy 100 98 AET 2&rdquo;-600&rdquo; (ms) - 182392 % of 2&rdquo;-600&rdquo; 0 1 % of hard 0 0 </span></p><p class="c2"><span class="c13">e gde-2</span><span class="c1">3AET easy (ms) 246.31 277.13 % of easy 71.5 84.5 AET 2&rdquo;-600&rdquo; (ms) 93523.7 31817 % of 2&rdquo;-600&rdquo; 4.5 4.5 % of hard 24 11 </span></p><p class="c2"><span class="c1">Table 4: Results for NFV methods on the human dataset (AET: avg exec time) </span></p><p class="c2"><span class="c1">queries is &lt; 5% in the synthetic dataset and &lt; 10% in PPI, the avg exec time across all completed queries is significantly affected; that is, the most expensive queries dominate the execution time. </span><span class="c22">4.2 NFV methods </span></p><p class="c10"><span class="c1">Fig. 2 presents the results from the query workloads on the NFV methods (QuickSI human/wordnet results omitted; see &sect;3.4), while tables 3 and 4 give results for 10- and 32- edge queries for the yeast and human datasets. We can use the 10-edge query results to compare our findings with those presented in [12]. [12] used small query sizes (up to 10 edges) and showed that the best performing algorithm is GraphQL, because it managed to complete all tested query workloads. With our experiments, we confirm this for both the yeast and human datasets and for queries of size 10 edges. GraphQL performs better compared to sPath, having also 0% of hard queries. The same holds for the easy queries of 32 edges. However, the picture is reversed when looking at the rest of the queries. In this case, the percentage of killed queries is double for GraphQL compared to sPath. </span></p><p class="c10"><span class="c1">We note that unlike yeast and human where sPath per- forms overall better than GraphQL having (i) smaller avg exec times on the completed queries and (ii) smaller percent- ages of hard queries, in wordnet this behavior is reversed. Based on our analysis, it&rsquo;s very difficult to claim that one algorithm is better than the other. In fact, in order to claim that, we need to define a performance metric of interest. Such a metric could be the percentage of killed queries, but note that it depends on the time limit imposed on query processing. For example, in wordnet, if the threshold was 2&rdquo;, then sPath would be better than GraphQL, but if we </span></p><p class="c2"><span class="c0">wordnet human yeast </span></p><p class="c2"><span class="c1">Figure 4: Avg (max/min)</span><span class="c6">QLA </span><span class="c1">for NFV methods </span></p><p class="c2"><span class="c1">change this threshold the picture changes. </span></p><p class="c10"><span class="c1">We summarize our results to the following 3 conclusions: (1) Some queries are hard. (2) Different algorithms have dif- ferent percentages of completed queries; thus, different algo- rithms find different queries hard. (3) As the most expensive queries dominate the avg exec time, one must include a suf- ficient number of hard queries in order to draw conclusions about the relative performance of the algorithms. </span></p><p class="c2"><span class="c22">5. ISOMORPHIC QUERIES </span></p><p class="c10"><span class="c1">The proposed sub-iso methods ([8, 28, 15]), as well as [12] that compares them, claim that the search order on the query can have a huge impact on query processing time. We agree with this claim. In the current study, we take a further step and instead of relying on the order that the individual method imposes, we generated our own isomor- phic query rewritings. To achieve this, we keep the structure of the query graph and the labels on the nodes unchanged, and permute the node IDs. Subsequently, we transform the query graph to an input format compatible with each in- dividual method and perform the query processing. In the following experiments, we used a total of 6 different rewrit- ings per query, leading to the following observation. </span></p><p class="c2"><span class="c1">Observation 2: Queries which are isomorphic to the orig- inal query have widely and wildly different execution times. </span></p><p class="c2"><span class="c1">We attribute this behavior to the fact that all proposed methods do not define a strict order in which the nodes of the query are matched, as computing a globally optimal join plan would be too computationally expensive. Thus, all methods rely on heuristics (see &sect;3.1) in order to minimize the search space for the join plan. </span><span class="c22">5.1 FTV methods </span></p><p class="c10"><span class="c1">Fig. 3 depicts the QLA average value of the (max/min) metric for the synthetic and PPI datasets, for the FTV methods (GGSX results omitted for the synthetic dataset; see &sect;3.4). Table 5 additionally reports the stdDev, min, max and median values of (max/min)</span><span class="c3">QLA</span><span class="c18">. In the calculations, </span></p><p class="c2"><span class="c4">30 </span></p><p class="c2"><span class="c0">1 </span><span class="c12">10 100 1000 10000 100000 1e+06 </span><span class="c0">(</span><span class="c12">max/min) </span></p><p class="c2"><span class="c0">Grapes/1 </span></p><p class="c2"><span class="c0">Grapes/4 </span></p><p class="c2"><span class="c0">GGSX </span></p><p class="c2"><span class="c0">PPI synthetic </span></p><p class="c2"><span class="c1">Figure 3: Avg (max/min)</span><span class="c6">QLA </span><span class="c1">for FTV methods </span></p><p class="c2"><span class="c12">1000 </span></p><p class="c9"><span class="c12">) nim/xam</span><span class="c0">(</span><span class="c12">100 10 </span><span class="c0">1 GQL SPA QSI </span></p><p class="c25"><span class="c1">Grapes/1 Grapes/4 GGSX s</span><span class="c13">ynthetic stdDev 86,700.40 65,988.40 - </span><span class="c1">min 1.06 1.02 - max 3,820,000.00 3,490,000.00 - median 3.90 4.45 - P</span><span class="c13">PI stdDev 469,934 395,285 1,020,000 </span><span class="c1">min 1.03 1.02 1.01 max 3,680,000 3,160,000 12,000,000 median 1,186.51 11.19 109,086.00 </span></p><p class="c2"><span class="c1">Table 5: (max/min)</span><span class="c3">QLA </span><span class="c18">statistics for FTV methods </span></p><p class="c25"><span class="c1">GraphQL sPath QuickSI y</span><span class="c13">east stdDev 287.54 533.86 1685.71 </span><span class="c1">min 1.01 1.01 1.00 max 7286.33 6695.85 15021.60 median 1.40 1.36 1.61 h</span><span class="c13">uman stdDev 440.18 662.78 - </span><span class="c1">min 1.00 1.04 - max 4115.06 4087.81 - median 1.82 1.96 - w</span><span class="c13">ordnet stdDev 20.55 396.87 - </span><span class="c1">min 1.01 1.01 - max 646.44 3081.14 - median 1.21 1.34 - </span></p><p class="c2"><span class="c1">Table 6: (max/min)</span><span class="c3">QLA </span><span class="c18">statistics for NFV methods </span></p><p class="c2"><span class="c1">we did not include queries that were not helped by any of the isomorphic instances tried; i.e., queries that were hard on all tested isomorphic instances of the query. This behav- ior occurred in 0.0036% and 1.4% of queries for Grapes/1 on the synthetic and PPI datasets respectively, and 0.37% of queries for Grapes/4 and 1.96% of queries for GGSX for the PPI dataset. We note that the &ldquo;max&rdquo; and &ldquo;average&rdquo; values of (max/min)</span><span class="c3">QLA </span><span class="c18">are only lower-bound estimations, </span><span class="c1">because of the 10&rsquo; limit that we used instead of the actual verification time. In these results, we observe that there is an at least 6 orders of magnitude difference between the min and the max value of (max/min)</span><span class="c3">QLA</span><span class="c18">, with the median </span><span class="c1">(apart from GGSX) being closer to the min value. Along with the high stdDev, we can see that isomorphic instances of the same query can indeed have widely and wildly differ- ent verification times. </span><span class="c22">5.2 NFV methods </span></p><p class="c10"><span class="c1">Fig. 4 reports the QLA-average values of the (max/min) metric for the yeast, human and wordnet datasets, for the tested NFV methods (QuickSI results omitted for the hu- man and wordnet datasets; see &sect;3.4). Table 6 reports the stdDev, min, max and median value of (max/min)</span><span class="c6">QLA</span><span class="c1">. We report that 4.2%, 8.2% and 1.5% of queries were not helped by any tested isomorphic query instances for GraphQL and for yeast, human and wordnet respectively. For sPath the corresponding values are 2.1%, 1.4% and 11.8%. Finally, for QuickSI 8.6% of the queries were not helped for yeast. </span></p><p class="c10"><span class="c1">The QLA-average (max/min) for the NFV methods is up to 3 orders of magnitude lower than that of the FTV methods. This is somewhat expected as the NFV methods define a more strict order in which the nodes of the query are matched and thus leave less space for wild variations. However, this order is still significantly affected by the ini- </span></p><p class="c25"><span class="c1">Grapes/1 Grapes/4 GGSX </span><span class="c13">c itehtny</span><span class="c1">s</span><span class="c13">stdDev </span><span class="c1">min max median </span><span class="c13">53,785.70 24,267.60 </span><span class="c1">1.00 1.00 3,820,000 2,110,000 1.36 1.24 </span><span class="c13">- </span><span class="c1">- - - </span><span class="c13">stdDev 302,250 237,573 758,668 I P</span><span class="c1">Pmin 1.00 1.00 1.00 max 3,370,000 2,910,000 9,390,000 median 3.71 1.67 1,751.22 </span></p><p class="c2"><span class="c1">Table 7: speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">statistics for FTV methods across rewritings </span></p><p class="c25"><span class="c1">GraphQL sPath QuickSI </span><span class="c13">t sae</span><span class="c1">y</span><span class="c13">stdDev </span><span class="c1">min max median </span><span class="c13">235.61 422.56 1193.03 </span><span class="c1">1.00 1.00 1.00 7286.33 6695.85 15021.60 1.10 1.08 1.30 </span><span class="c13">n amu</span><span class="c1">h</span><span class="c13">stdDev </span><span class="c1">min max median </span><span class="c13">259.93 492.45 </span><span class="c1">1.00 1.00 4115.06 4087.81 1.09 1.08 </span><span class="c13">- </span><span class="c1">- - - </span><span class="c13">t endro</span><span class="c1">w</span><span class="c13">stdDev </span><span class="c1">min max median </span><span class="c13">20.55 244.66 </span><span class="c1">1.00 1.00 646.44 3081.14 1.13 1.08 </span><span class="c13">- </span><span class="c1">- - - </span></p><p class="c2"><span class="c1">Table 8: speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">statistics for NFV methods across rewritings </span></p><p class="c2"><span class="c1">tial node ids of the query, and thus we still see per-query (max/min) values of up to 2 orders of magnitude. </span></p><p class="c10"><span class="c1">We summarize our overall results to the following conclu- sions: (1) For every isomorphic test to be executed, given a query graph q and a stored graph, there is an isomor- phic version of q that can take anywhere from 2 to 6 orders of magnitude more time to execute compared to the least expensive version of the query. This holds across all algo- rithms and datasets tested. (2) Although the presented fig- ures hide the details of the individual query sizes, we report that the harder the queries (higher query sizes), the higher these number are. </span></p><p class="c2"><span class="c60">4 </span><span class="c23">A </span><span class="c26">5 </span></p><p class="c2"><span class="c23">A </span></p><p class="c2"><span class="c23">A </span><span class="c37">B</span><span class="c60">6 </span></p><p class="c2"><span class="c23">B </span></p><p class="c2"><span class="c1">(a) Original </span></p><p class="c2"><span class="c27">5 </span><span class="c39">6 </span></p><p class="c2"><span class="c1">(b) ILF </span></p><p class="c2"><span class="c27">60 </span></p><p class="c2"><span class="c27">4 </span></p><p class="c2"><span class="c27">15 </span></p><p class="c2"><span class="c16">2 </span></p><p class="c2"><span class="c18">(c) IND </span></p><p class="c2"><span class="c27">6 </span></p><p class="c2"><span class="c1">(d) ILF+IND </span></p><p class="c10"><span class="c1">Figure 5: Isomorphic queries generated with differ- ent rewritings (assuming the label frequencies in the stored graph are: &ldquo;A&rdquo;=20, &ldquo;B&rdquo;=15, &ldquo;C&rdquo;=10) </span></p><p class="c2"><span class="c22">6. GRAPH QUERY REWRITING </span></p><p class="c2"><span class="c1">Having established that isomorphic versions of a query can have dramatically different execution times, we set out </span></p><p class="c2"><span class="c4">31 </span></p><p class="c2"><span class="c23">A A </span></p><p class="c2"><span class="c23">A </span><span class="c33">B</span><span class="c23">B </span></p><p class="c2"><span class="c23">A A </span></p><p class="c2"><span class="c23">A </span><span class="c33">B</span><span class="c23">B </span></p><p class="c2"><span class="c23">A A </span></p><p class="c2"><span class="c69">3 </span></p><p class="c2"><span class="c26">1 </span><span class="c23">C </span></p><p class="c2"><span class="c60">2 </span><span class="c27">4 </span></p><p class="c2"><span class="c39">3 </span><span class="c27">1 </span><span class="c23">A </span><span class="c33">B</span><span class="c39">2</span><span class="c27">1 23 </span></p><p class="c2"><span class="c23">B </span><span class="c23">C </span><span class="c26">0</span><span class="c23">C </span></p><p class="c2"><span class="c27">3 </span><span class="c39">4 </span></p><p class="c2"><span class="c27">5 </span></p><p class="c2"><span class="c23">C </span><span class="c39">0 </span></p><p class="c2"><span class="c23">C </span></p><p class="c2"><span class="c23">C </span></p><p class="c2"><span class="c23">C </span></p><p class="c2"><span class="c23">C </span><span class="c39">0 </span></p><p class="c2"><span class="c0">PPI synthetic </span></p><p class="c2"><span class="c1">Figure 7: Avg speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">for FTV methods across rewritings </span><span class="c12">1000 </span></p><p class="c2"><span class="c12">100 * pudeep</span><span class="c0">s10 </span><span class="c58">1 </span><span class="c0">GQL </span></p><p class="c2"><span class="c0">yeast human wordnet </span><span class="c1">Figure 8: Avg speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">for NFV methods across rewritings </span></p><p class="c10"><span class="c1">to construct specific rewritings, constructing graphs isomor- phic to the original queries, with the aim to capture these benefits. We have developed and experimented with several such query rewritings. We outline below five such rewrit- ings, all performed by carefully permuting the node IDs in the query graph: </span></p><p class="c2"><span class="c1">&bull; </span><span class="c44">Query Rewriting ILF (Increasing Label Frequency)</span><span class="c1">: In a preprocessing step, we compute the frequencies of node labels in the stored graph, sorted in increas- ing frequency order. Given this order, we produce a rewriting of the query graph so if i, j are the node IDs of query graph nodes n</span><span class="c3">i</span><span class="c18">,n</span><span class="c3">j</span><span class="c18">, L(n</span><span class="c3">i</span><span class="c18">),L(n</span><span class="c3">j</span><span class="c18">) are their la- </span><span class="c1">bels, and f(L(&middot;)) is the frequency of a label L(&middot;) in the stored graph, then f(L(n</span><span class="c3">i</span><span class="c18">)) &lt; f(L(n</span><span class="c3">j</span><span class="c18">)) &rArr; i&lt;j. Ties </span></p><p class="c2"><span class="c1">(d) yeast dataset, percentage of hard queries </span></p><p class="c2"><span class="c1">Figure 6: Results for individual query rewrtings for both FTV and NFV methods </span></p><p class="c2"><span class="c0">1 </span><span class="c12">10 100 1000 10000 100000 1e+06 </span><span class="c0">s</span><span class="c12">peedup* </span></p><p class="c2"><span class="c0">W</span><span class="c12">LA-Avg exec time (s) </span></p><p class="c2"><span class="c0">Orig </span></p><p class="c2"><span class="c0">W</span><span class="c12">LA-Avg exec time (ms) </span></p><p class="c2"><span class="c0">Orig </span></p><p class="c2"><span class="c0">0 </span><span class="c12">50 100 150 200 250 300 </span></p><p class="c2"><span class="c0">Grapes/1 Grapes/4 GGSX </span></p><p class="c2"><span class="c1">(b) PPI dataset, percentage of hard queries </span></p><p class="c2"><span class="c0">10000 </span><span class="c12">20000 30000 40000 50000 60000 70000 80000 </span></p><p class="c2"><span class="c0">GQL SPA QSI </span></p><p class="c2"><span class="c1">(c) yeast dataset, WLA-Avg exec time (ms) </span></p><p class="c2"><span class="c1">(a) PPI dataset, WLA-Avg exec time (s) </span></p><p class="c2"><span class="c0">Grapes/1 </span></p><p class="c2"><span class="c0">Grapes/4 </span></p><p class="c2"><span class="c0">GGSX </span></p><p class="c2"><span class="c0">ILF </span></p><p class="c2"><span class="c0">ILF </span></p><p class="c2"><span class="c0">DND </span></p><p class="c2"><span class="c0">IND </span></p><p class="c2"><span class="c0">DND </span></p><p class="c2"><span class="c0">IND </span></p><p class="c2"><span class="c0">ILF+DND </span></p><p class="c2"><span class="c0">ILF+IND </span></p><p class="c2"><span class="c0">ILF+DND </span></p><p class="c2"><span class="c0">ILF+IND </span></p><p class="c2"><span class="c0">SPA </span></p><p class="c2"><span class="c0">QSI </span></p><p class="c10"><span class="c1">can appear in 2 cases: (i) two or more query nodes have the same label, or (ii) two or more query nodes have different labels but with the same frequency. These ties are broken arbitrarily. </span></p><p class="c2"><span class="c1">&bull; </span><span class="c44">Query Rewriting IND (Increasing Node Degree)</span><span class="c1">: The nodes of the query are sorted in increasing node degree order; i.e., if n</span><span class="c6">i</span><span class="c1">,n</span><span class="c6">j </span><span class="c1">are two query graph nodes, and d(&middot;) is the degree (number of edges) of a node, then d(n</span><span class="c3">i</span><span class="c18">) &lt; d(n</span><span class="c3">j</span><span class="c18">) &rArr; i&lt;j. In the case of nodes with </span><span class="c1">the same number of edges, ties are broken arbitrarily. </span></p><p class="c2"><span class="c1">&bull; </span><span class="c44">Query Rewriting DND (Decreasing Node Degree)</span><span class="c1">: This rewriting is similar to the IND but the nodes of the query are sorted in decreasing node degree and the nodes ids are assigned accordingly. </span></p><p class="c10"><span class="c1">&bull; </span><span class="c44">Query Rewriting ILF+IND</span><span class="c1">: This rewriting is the same as ILF above, with ties being broken in an IND man- ner: i.e., nodes with smaller outgoing degree get a lower node id. </span></p><p class="c25"><span class="c1">&bull; </span><span class="c44">Query Rewriting ILF+DND</span><span class="c1">: This rewriting is the same as ILF+IND, with ties being broken in a DND manner. Fig. 5 presents an example of the above rewritings. Note that the ILF+IND rewriting in 5(d) is also a valid ILF rewriting. As we already mentioned, ties are (utterly) bro- ken in an arbitrary way, and thus one may compute several different isomorphic graphs for the same rewriting. </span></p><p class="c10"><span class="c1">Indicatively</span><span class="c11">2 </span><span class="c1">and because of space restrictions, in fig. 6 we report the WLA average processing times of the original query and the 5 proposed query rewritings for the PPI and yeast datasets, as well as the corresponding percentages of the hard queries. For the FTV methods, the best perform- ing rewritings are ILF and ILF+DND, with the percentage of hard queries being significantly improved. For the NFV methods, the picture is slightly different. GraphQL shows no considerable improvement with any individual rewriting; as a matter of fact, there are rewritings leading to higher </span></p><p class="c2"><span class="c6">2</span><span class="c18">We obtained similar results for the synthetic dataset for the FTV methods and the human dataset for the NFV meth- ods. The sole exception was sPath, whose percentage of hard queries increased slightly for the wordnet dataset. </span></p><p class="c2"><span class="c4">32 </span></p><p class="c2"><span class="c0">% </span><span class="c12">of hard queries </span></p><p class="c2"><span class="c0">Orig </span></p><p class="c2"><span class="c0">% </span><span class="c12">of hard queries </span></p><p class="c2"><span class="c0">Orig </span></p><p class="c2"><span class="c0">0 </span><span class="c12">5 10 15 20 25 30 35 40 45 </span></p><p class="c2"><span class="c0">Grapes/1 Grapes/4 GGSX </span></p><p class="c2"><span class="c0">0 </span><span class="c12">2 4 6 8 10 12 </span></p><p class="c2"><span class="c0">GQL SPA QSI </span></p><p class="c2"><span class="c0">ILF </span></p><p class="c2"><span class="c0">ILF </span></p><p class="c2"><span class="c0">DND </span></p><p class="c2"><span class="c0">DND </span></p><p class="c2"><span class="c0">IND </span></p><p class="c2"><span class="c0">IND </span></p><p class="c2"><span class="c0">ILF+DND </span></p><p class="c2"><span class="c0">ILF+DND </span></p><p class="c2"><span class="c0">ILF+IND </span></p><p class="c2"><span class="c0">ILF+IND </span></p><p class="c10"><span class="c1">avg exec times than the original query. For sPath, the DND and ILF+DND rewritings reduced the percentage of killed queries from 2.8% to 2.4%. For QuickSI, ILF+DND reduced the percentage of killed queries from 11.3% to 10.2%, but DND only brought it down to 10.9%. More importantly, note that there is no single rewriting that manages to im- prove all algorithms across all datasets and workloads. </span></p><p class="c2"><span class="c1">Observation 4: &ldquo;Stragglers&rdquo; can have isomorphic coun- terparts which are not stragglers. </span></p><p class="c2"><span class="c1">Please note that the max and average reported speedup</span><span class="c11">&lowast; </span><span class="c1">represent a lower-bound estimation because of the value 600&rdquo; that we use for the hard queries that were killed. Addition- ally, in our calculations we do not include the few queries that were killed for both the original instance and with all the rewritings of the query (see &sect;5.1 and &sect;5.2). </span><span class="c22">6.1 FTV methods </span></p><p class="c2"><span class="c1">Fig. 7 presents the average speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">for the FTV methods for the synthetic and PPI datasets (GGSX/synthetic results omitted; see &sect;3.4). Additionally, table 7 reports the QLA stdDev, min, max and median of speedup</span><span class="c11">&lowast;</span><span class="c6">QLA</span><span class="c1">. More- over, as we increased the size of the queries, speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">increased by up to 3 orders of magnitude (not visible in the figure as results are aggregated). For the presented results, median speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">is close to min speedup</span><span class="c11">&lowast;</span><span class="c6">QLA</span><span class="c1">, evidenc- ing again a wide variation in the benefits of the isomorphic query rewritings. Keeping in mind that the majority of the queries are easy (fig. 1), we conclude that large performance gains can come from improving the hard queries. </span><span class="c22">6.2 NFV methods </span></p><p class="c10"><span class="c1">Fig. 8 presents the average speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">for the NFV methods for the yeast, human and wordnet datasets (QuickSI human/wordnet results omitted; see &sect;3.4). Table 8 reports the stdDev, min, max and median of the speedup</span><span class="c11">&lowast;</span><span class="c6">QLA</span><span class="c1">. The performance of sPath could seemingly be improved by one to two orders of magnitude across all datasets. The same holds for QuickSI on yeast. GraphQL could also be im- proved by more than a factor of 10&times; on the yeast and human datasets. However, no significant improvement was possi- ble for GraphQL on wordnet. The reason why this is so, is somewhat subtle. Apart from what the algorithms are doing internally to match the query, other culprits are the characteristics of the actual stored graphs and the gener- ated queries. Looking at the statistics of the graphs (table 2), yeast and especially wordnet are very sparse graphs with small average node degree. Thus, the majority of the gen- erated queries are paths and the rewritings based on node degrees are not effective in this case. Additionally for word- net, the small number of labels (only 5) and distribution of the frequencies of the labels being highly skewed leads to the generation of queries that in their majority contain only 1 or 2 labels, with the second label appearing only once. As a result, the rewritings are of little use in these cases. </span></p><p class="c25"><span class="c22">7. ALGORITHM-SPECIFIC STRAGGLERS </span><span class="c1">As we already mentioned in section 4, we notice that for the NFV methods, different algorithms have different per- centages of hard queries, leading to the conclusion that dif- ferent algorithms find different queries hard. In this section we elaborate on this observation. </span></p><p class="c2"><span class="c0">wordnet yeast</span><span class="c54">2alg </span><span class="c0">yeast</span><span class="c54">3alg </span><span class="c0">human </span><span class="c1">Figure 9: Avg speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">when utilising different algorithms on NFV methods </span></p><p class="c2"><span class="c1">GraphQL sPath QuickSI </span></p><p class="c2"><span class="c13">t sae</span><span class="c1">ystdDev 1094.57 1051.65 - min 1.00 1.00 - max 9189.36 9129.60 - median 1.00 1.80 - </span></p><p class="c25"><span class="c13">t sae</span><span class="c1">ystdDev 1596.47 1255.34 2162.97 min 1.00 1.00 1.00 max 13060.10 12403.70 12312.70 median 1.00 1.88 1.32 </span><span class="c13">n amu</span><span class="c1">h</span><span class="c13">stdDev </span><span class="c1">min max median </span><span class="c13">1394.34 570.83 </span><span class="c1">1.00 1.00 30873.80 4341.44 1.00 1.04 </span><span class="c13">- </span><span class="c1">- - - </span><span class="c13">t endro</span><span class="c1">w</span><span class="c13">stdDev </span><span class="c1">min max median </span><span class="c13">253.56 104.42 </span><span class="c1">1.00 1.00 3733.78 932.58 2.47 1.00 </span><span class="c13">- </span><span class="c1">- - - </span></p><p class="c2"><span class="c1">Table 9: speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">statistics when utilizing differ- ent algorithms on NFV methods </span></p><p class="c10"><span class="c1">Observation 5: &ldquo;Stragglers&rdquo; are algorithm-specific; i.e., by evaluating the same query workloads with various algo- rithms, we have seen that a &ldquo;straggler&rdquo;-query for one algo- rithm can be a typical query for the other algorithms. </span></p><p class="c10"><span class="c1">Fig. 9 presents the average speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">for the yeast, human and wordnet datasets and for the tested algorithms. In table 9, we additionally report the stdDev, min, max and median of speedup</span><span class="c11">&lowast;</span><span class="c6">QLA</span><span class="c1">. For the yeast dataset, we present the results with utilizing all 3 algorithms (noted as yeast</span><span class="c6">3alg</span><span class="c1">), as well as with the pair of algorithms (GraphQL and sPath) that we utilize for the remaining datasets (noted as yeast</span><span class="c3">2alg</span><span class="c18">). For the yeast dataset, all tested queries were </span><span class="c1">helped by the use of different algorithms. In the human and wordnet datasets, only 0.8% and 0.1% of the queries were not helped by this scheme. Note that the speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">val- ues for using multiple algorithms are higher compared to the speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">values achievable with multiple query rewrit- ings (see &sect;6.2). This leads to the conclusion that the use of multiple algorithms could be way more beneficial compared to the rewritings, which are not always effective (&sect;6.2). </span></p><p class="c2"><span class="c22">8. THE </span><span class="c1">&Psi;</span><span class="c22">-FRAMEWORK </span></p><p class="c10"><span class="c1">In this section we present how we incorporate our findings in a novel framework that exploits parallelism. The pro- posed framework is called &Psi;-framework (Parallel Subgraph Isomorphism framework). Unlike recent related work [11, 16], by having different threads/machines working on differ- ent versions of the problem our &Psi;-framework exploits par- </span></p><p class="c2"><span class="c4">33 </span></p><p class="c2"><span class="c0">1 </span><span class="c12">10 100 1000 </span><span class="c0">s</span><span class="c12">peedup* </span></p><p class="c2"><span class="c0">GQL </span></p><p class="c2"><span class="c0">SPA </span></p><p class="c2"><span class="c0">QSI </span></p><p class="c10"><span class="c1">allelism in a novel way. We utilize Grapes and GGSX (as well as GraphQL and sPath) as well-established FTV (resp. NFV) methods. Within our &Psi;-framework we have incorpo- rated the original implementations of Grapes and GGSX as provided by their authors, and of GraphQL and sPath as found in [12]. </span></p><p class="c25"><span class="c1">In the FTV methods we leave intact the index construc- tion and the filtering stages during query processing. In the verification stage, for every graph in the candidate set, we instantiate a number of threads equal to the number of the isomorphic-query rewritings we utilize. These threads run in parallel with each being assigned one rewriting of the ini- tial query, and the first thread to finish is the &ldquo;winner&rdquo;; i.e., the rest of the threads are killed and the algorithm proceeds with the verification of the next graph in the candidate set. &Psi;-framework for the NFV methods works similarly to the verification stage of the FTV methods. However, we men- tioned in observation 5 that stragglers disappear when us- ing an alternative matching algorithm. We incorporate this finding in our &Psi;-framework by running simultaneously two threads: one for sPath and one for GraphQL with the origi- nal query. Again after the completion of the fastest thread, the rest of them are killed. </span></p><p class="c10"><span class="c1">On one hand we have seen that the more the isomorphic instances we use, the better the speedup we gain in the graph matching process. On the other hand, the instantiation and synchronization of many threads come with a non-trivial overhead, impacting the overall speedup. To this end, in our performance evaluation we report on the speedup achieved by several beneficial combinations of rewritings. We note that our &Psi;-framework is of course not the only solution to the straggler-queries&rsquo; problem. Undoubtedly, it would be preferable to choose the right isomorphic query instance and/or algorithm to use to minimize the query execution time. However, given the complex nature of the sub-iso problem, we leave such design decisions for future work. </span></p><p class="c10"><span class="c1">The cost of producing the query rewritings was measured from a few tens (for smaller query sizes) to a few hundreds (for the biggest query sizes) of &mu;secs; being a negligible over- head to the overall query processing time, we ignore it in the figures and omit any further discussion of this cost factor. </span></p><p class="c2"><span class="c22">8.1 FTV methods </span></p><p class="c2"><span class="c1">Fig. 10 and 11 present the avg speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">and avg speedup</span><span class="c11">&lowast;</span><span class="c6">W LA </span><span class="c1">respectively for utilizing different versions of &Psi;-framework on the FTV methods. Specifically, we present the avg speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">and avg speedup</span><span class="c11">&lowast;</span><span class="c6">W LA </span><span class="c1">of the following versions of &Psi;-framework: (a) ILF/ ILF+IND (2 threads), (b) ILF/ ILF+DND (2 threads), (c) ILF/ IND/ DND (3 threads), (d) ILF/ IND/ DND/ ILF+IND (4 threads) and (e) all 5 possible rewritings (5 threads). Our framework proves highly beneficial for all algorithms and datasets. Al- though not depicted in the figure, but as it was expected, by increasing the number of threads running multiple rewritings on the &Psi;-framework, not only the avg execution time is sig- nificantly improved but also the percentage of hard queries is decreased, even leading to straggler-free executions. How- ever, note that the &Psi;-framework(ILF/ IND/ DND) (3 threads) is only 3-8% worse compared to &Psi;-framework(ILF/ IND/ DND/ ILF+IND) (4 threads) for Grapes/1 and Grapes/4. </span></p><p class="c10"><span class="c1">As Grapes is designed as a multi-threaded application, we additionally compare Grapes/4 against our &Psi;-framework running Grapes/1 with the following four rewritings (for to- </span></p><p class="c2"><span class="c0">GGSX Grapes/4 Grapes/1</span><span class="c18">(b) PPI dataset </span></p><p class="c2"><span class="c1">Figure 10: Avg speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">across different versions of our framework on the FTV methods </span></p><p class="c2"><span class="c0">0 </span><span class="c12">5 10 15 20 25 30 35 40 </span><span class="c0">s</span><span class="c12">peedup* </span></p><p class="c2"><span class="c0">GGSX Grapes/1 </span></p><p class="c2"><span class="c0">Grapes/4 </span><span class="c1">(b) PPI dataset </span></p><p class="c2"><span class="c1">Figure 11: Avg speedup</span><span class="c11">&lowast;</span><span class="c6">W LA </span><span class="c1">across different versions of our framework on the FTV methods </span></p><p class="c2"><span class="c12">) s(e mitc exeg vA-AL</span><span class="c0">W</span><span class="c12">140 120 100 80 60 40 20 </span><span class="c0">0 16e 20e 24e 32e </span><span class="c1">Figure 12: Comparison of avg exec time over the PPI dataset, for Grapes/4 against the &Psi;-framework with 4 rewritings over Grapes/1 </span></p><p class="c2"><span class="c4">34 </span></p><p class="c10"><span class="c0">0 </span><span class="c12">3000 2500 2000 * pudeep</span><span class="c0">s</span><span class="c12">1500 1000 500 </span><span class="c0">Grapes/1 </span></p><p class="c2"><span class="c0">Grapes/4 </span><span class="c1">(a) Synthetic dataset </span></p><p class="c2"><span class="c12">300000 </span></p><p class="c2"><span class="c12">250000 200000 * pudeep</span><span class="c0">s</span><span class="c12">150000 100000 50000 </span><span class="c0">0 </span></p><p class="c2"><span class="c0">Grapes/4 Grapes/1 </span><span class="c1">(a) Synthetic dataset </span></p><p class="c2"><span class="c0">0 </span><span class="c12">5 10 15 20 </span><span class="c0">s</span><span class="c12">peedup* </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(ILF/IND/DND/ILF+IND) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(ILF/IND/DND/ILF+IND) </span></p><p class="c2"><span class="c0">Grapes/4 </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(ILF/IND/DND/ILF+IND) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(Or/all_rewritings) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(Or/all_rewritings) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(ILF/ILF+DND) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(ILF/IND/DND) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(ILF/ILF+DND) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(ILF/IND/DND) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(ILF/ILF+IND) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(ILF/ILF+IND) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(all_rewritings) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(all_rewritings) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(ILF/ILF+DND) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(ILF/IND/DND) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(ILF/ILF+IND) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(all_rewritings) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(Grapes/1) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(ILF/IND/DND/ILF+IND) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(ILF/ILF+DND) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(ILF/IND/DND) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(ILF/ILF+IND) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(all_rewritings) </span></p><p class="c2"><span class="c0">SPA GQL </span></p><p class="c2"><span class="c1">(c) wordnet dataset </span></p><p class="c2"><span class="c1">Figure 13: Avg speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">across different versions of &Psi;-framework on the NFV methods </span></p><p class="c25"><span class="c1">PPI yeast human wordnet Grapes/4 6.29% - - - GraphQL - 4.3% 10% 1.6% sPath - 2.8% 4.4% 13% &Psi;-fram 2.06% 0% 0.7% 0% </span></p><p class="c2"><span class="c1">Table 10: Percentage of killed queries of FTV meth- ods and our &Psi;-framework </span></p><p class="c10"><span class="c1">tal of 4 threads as well): ILF, IND, DND, ILF+IND. The results are presented in fig. 12 for the PPI dataset (results for the synthetic dataset were similar). Table 10 reports the percentage of killed queries for Grapes/4 and &Psi;-framework on PPI. As is obvious, although both contenders have the same level of parallelism, &Psi;-framework makes better use of its threads and leads to lower query processing times. </span></p><p class="c2"><span class="c22">8.2 NFV methods </span></p><p class="c10"><span class="c1">Fig. 13 presents the avg speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">for utilizing differ- ent versions of &Psi;-framework on the NFV methods (we omit the figures for avg speedup</span><span class="c11">&lowast;</span><span class="c6">W LA </span><span class="c1">due to space constraints). We utilize the following versions of &Psi;-framework and the corresponding number of threads: (a) Orig/ ILF/ ILF+IND (3 threads) (b) Orig/ ILF/ IND/ DND (4 threads), (c) Orig/ ILF/ IND/ DND/ ILF+IND (5 threads), and (d) Orig + all-rewritings (titled as all) (6 threads). For all tested datasets and workloads, GraphQL benefited the least by the rewritings. The biggest improvements appear in the human </span></p><p class="c2"><span class="c0">0 </span><span class="c12">20 40 60 80 100 120 140 160 </span><span class="c0">s</span><span class="c12">peedup* </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(Or/ILF/ILF+IND) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(Or/ILF/IND/DND) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(Or/ILF/IND/DND/ILF+IND) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">(all) </span></p><p class="c2"><span class="c0">QSI GQL </span></p><p class="c2"><span class="c0">SPA </span><span class="c1">(a) yeast dataset </span></p><p class="c9"><span class="c12">90 80 70 60 * pudeep</span><span class="c0">s</span><span class="c12">50 40 30 20 10 </span><span class="c0">0 </span><span class="c5">&Psi;</span><span class="c0">(Or/ILF/ILF+IND) </span><span class="c5">&Psi;</span><span class="c0">(Or/ILF/IND/DND) </span><span class="c5">&Psi;</span><span class="c0">(Or/ILF/IND/DND/ILF+IND) </span><span class="c5">&Psi;</span><span class="c0">(all) </span></p><p class="c2"><span class="c0">GQLSPA </span><span class="c18">(b) human dataset </span></p><p class="c2"><span class="c12">30 </span></p><p class="c9"><span class="c12">25 20 * pudeep</span><span class="c0">s</span><span class="c12">15 10 5 </span><span class="c0">0 </span><span class="c5">&Psi;</span><span class="c0">(Or/ILF/ILF+IND) </span><span class="c5">&Psi;</span><span class="c0">(Or/ILF/IND/DND) </span><span class="c5">&Psi;</span><span class="c0">(Or/ILF/IND/DND/ILF+IND) </span><span class="c5">&Psi;</span><span class="c0">(all) </span></p><p class="c2"><span class="c0">wordnet human yeast </span><span class="c1">(b) speedup</span><span class="c11">&lowast;</span><span class="c6">W LA </span><span class="c1">for sPath </span></p><p class="c2"><span class="c1">Figure 15: Avg speedup</span><span class="c11">&lowast;</span><span class="c6">W LA </span><span class="c1">for running multiple algorithms against NFV methods on &Psi;-framework </span></p><p class="c25"><span class="c1">dataset. We attribute this to the fact that this dataset com- prises a denser graph with more labels, thus a larger portion of &ldquo;hard&rdquo; queries benefited by our rewritings and framework. Finally, fig. 14 and 15 depict the avg speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">and the avg speedup</span><span class="c11">&lowast;</span><span class="c6">W LA </span><span class="c1">for utilizing different algorithms and dif- ferent versions of &Psi;-framework on the NFV methods and on yeast, human and wordnet, against vanilla GraphQL and sPath respectively. We instantiated the following ver- sions of our &Psi;-framework with the corresponding number of threads: (a) GraphQL-Orig/ sPath-Orig (2 threads), (b) GraphQL-ILF/ sPath-ILF (2 threads), (c) GraphQL-IND/ sPath-IND (2 threads), (d) GraphQL-DND/ sPath-DND (2 threads). (e) GraphQL-Orig /sPath-Orig/ GraphQL-DND/ sPath-DND (4 threads). For both GraphQL and sPath, we </span></p><p class="c2"><span class="c4">35 </span></p><p class="c2"><span class="c0">wordnet human yeast </span><span class="c1">(b) speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">for sPath </span></p><p class="c2"><span class="c1">Figure 14: Avg speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">for running multiple al- gorithms against NFV methods on &Psi;-framework </span></p><p class="c2"><span class="c0">0 </span><span class="c12">50 100 150 200 250 300 350 400 450 </span><span class="c0">s</span><span class="c12">peedup* </span></p><p class="c10"><span class="c0">0 </span><span class="c12">400 350 300 * pudeep</span><span class="c0">s</span><span class="c12">250 200 150 100 50 </span><span class="c0">yeast </span></p><p class="c2"><span class="c0">human wordnet </span><span class="c1">(a) speedup</span><span class="c11">&lowast;</span><span class="c6">QLA </span><span class="c1">for GraphQL </span></p><p class="c10"><span class="c12">200 180 160 140 * pudeep</span><span class="c0">s</span><span class="c12">120 100 80 60 40 </span><span class="c0">20 </span></p><p class="c9"><span class="c0">wordnet human yeast </span><span class="c1">(a) speedup</span><span class="c11">&lowast;</span><span class="c6">W LA </span><span class="c1">for GraphQL </span></p><p class="c2"><span class="c0">0 </span><span class="c12">20 40 60 80 100 120 140 160 180 </span><span class="c0">s</span><span class="c12">peedup* </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">([GQL/SPA]-[Or/DND]) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">([GQL/SPA]-[Or/DND]) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">([GQL/SPA]-[Or/DND]) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">([GQL/SPA]-[Or/DND]) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">([GQL/SPA]-[DND]) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">([GQL/SPA]-[DND]) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">([GQL/SPA]-[DND]) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">([GQL/SPA]-[DND]) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">([GQL/SPA]-[IND]) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">([GQL/SPA]-[IND]) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">([GQL/SPA]-[IND]) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">([GQL/SPA]-[IND]) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">([GQL/SPA]-[ILF]) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">([GQL/SPA]-[ILF]) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">([GQL/SPA]-[ILF]) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">([GQL/SPA]-[ILF]) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">([GQL/SPA]-[Or]) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">([GQL/SPA]-[Or]) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">([GQL/SPA]-[Or]) </span></p><p class="c2"><span class="c5">&Psi;</span><span class="c0">([GQL/SPA]-[Or]) </span></p><p class="c36"><span class="c1">were able to achieve up to 3 orders of magnitude improve- ment with our &Psi;-framework on both per-query and per- workload metrics. Also, with the &Psi;-framework, the percent- age of hard queries was reduced and, for yeast and wordnet, hard queries became extinct &ndash; see Table 10. </span></p><p class="c80"><span class="c22">9. CONCLUSIONS </span></p><p class="c75"><span class="c1">We have studied the subgraph isomorphism problem, in both its decision and matching versions, using well-established FTV and NFV methods respectively, and against several different real and synthetic datasets of various characteris- tics. Our research has revealed and quantified a number of insights, concerning (i) the existence and role of straggler queries in a method&rsquo;s overall performance, (ii) the dramat- ically varying performance of isomorphic queries, (iii) the impressive impact that query rewriting can have when used before executing the query with several algorithms, and (iv) the fact that straggler queries are algorithm-specific. We suggested and used both WLA and QLA metrics to fully appreciate the performance of algorithms in the presence of stragglers. A number of query rewritings were proposed and our results showed that in many cases there existed one rewriting that could offer great performance advantages &ndash; with different rewritings being best for different queries. We showcased that, for the NFV algorithms, when a query was proved to be very expensive with one algorithm, another al- gorithm would actually manage to compute its answer very efficiently. These findings then naturally culminated into a novel framework, which employs in parallel different threads, each using a different well-known algorithm and/or a spe- cific query rewriting, per query. This introduced dramatic improvements (up to several orders of magnitude) to FTV and NFV algorithms. We hope that our findings will open up new research directions, striving to find appropriate, per- query, isomorphic rewritings, in combination with alternate per-query sub-iso algorithms that can yield large improve- ments. Using machine learning models to predict which ver- sion of our framework (algorithms, rewritings) to employ per query is of high interest. </span></p><p class="c29"><span class="c22">10. REFERENCES </span></p><p class="c65"><span class="c1">[1] V. Bonnici, A. Ferro, R. Giugno, A. Pulvirenti, and </span></p><p class="c59"><span class="c1">D. Shasha. Enhancing graph database indexing by suffix tree structure. In Proc. IAPR PRIB, 2010. [2] J. Cheng, Y. Ke, and W. Ng. GraphGen. </span></p><p class="c52"><span class="c1">http://www.cse.ust.hk/graphgen/. [3] J. Cheng, Y. Ke, W. Ng, and A. Lu. FG-index: </span></p><p class="c48"><span class="c1">towards verification-free query processing on graph databases. In Proc. SIGMOD, pages 857&ndash;872, 2007. [4] L. P. Cordella, P. Foggia, C. Sansone, and M. Vento. </span></p><p class="c64"><span class="c1">A (sub) graph isomorphism algorithm for matching large graphs. IEEE TPAMI, 26(10):1367&ndash;1372, 2004. [5] R. Giugno, V. Bonnici, N. Bombieri, A. Pulvirenti, A. Ferro, and D. Shasha. GRAPES: A software for parallel searching on biological graphs targeting multi-core architectures. PloS One, 8(10):e76911, 2013. [6] W.-S. Han, J. Lee, and J.-H. Lee. Turbo</span><span class="c3">iso</span><span class="c18">: towards </span></p><p class="c21"><span class="c1">ultrafast and robust subgraph isomorphism search in large graph databases. In Proc. SIGMOD, 2013. [7] W.-S. Han, J. Lee, M.-D. Pham, and J. X. Yu. iGraph: </span></p><p class="c63"><span class="c1">a framework for comparisons of disk-based graph indexing techniques. PVLDB, 3(1-2):449&ndash;459, 2010. </span></p><p class="c2 c50"><span class="c1">[8] H. He and A. K. Singh. Graphs-at-a-time: query </span></p><p class="c45"><span class="c1">language and access methods for graph databases. In Proc. SIGMOD, pages 405&ndash;418, 2008. [9] F. Katsarou, N. Ntarmos, and P. Triantafillou. </span></p><p class="c77"><span class="c1">Performance and scalability of indexed subgraph query processing methods. PVLDB, 8(12):1566&ndash;1577, 2015. [10] K. Klein, N. Kriege, and P. Mutzel. CT-index: </span></p><p class="c85"><span class="c1">Fingerprint-based graph indexing combining cycles and trees. In Proc. ICDE, pages 1115&ndash;1126, 2011. [11] L. Lai, L. Qin, X. Lin, and L. Chang. Scalable subgraph enumeration in mapreduce. PVLDB, 8(10):974&ndash;985, 2015. [12] J. Lee, W.-S. Han, R. Kasperovics, and J.-H. Lee. An </span></p><p class="c38"><span class="c1">in-depth comparison of subgraph isomorphism algorithms in graph databases. PVLDB, 6(2), 2012. [13] X. Ren and J. Wang. Exploiting vertex relationships in speeding up subgraph isomorphism over large graphs. PVLDB, 8(5):617&ndash;628, 2015. [14] K. Semertzidis and E. Pitoura. Durable graph pattern queries on historical graphs. In Proc. ICDE, 2016. [15] H. Shang, Y. Zhang, X. Lin, and J. X. Yu. Taming </span></p><p class="c73"><span class="c1">verification hardness: an efficient algorithm for testing subgraph isomorphism. PVLDB, 1(1):364&ndash;375, 2008. [16] Z. Sun, H. Wang, H. Wang, B. Shao, and J. Li. </span></p><p class="c15"><span class="c1">Efficient subgraph matching on billion node graphs. PVLDB, 5(9):788&ndash;799, 2012. [17] Y. Tian and J. M. Patel. Tale: A tool for approximate </span></p><p class="c35"><span class="c1">large graph matching. In Proc. ICDE, 2008. [18] J. R. Ullmann. An algorithm for subgraph </span></p><p class="c84"><span class="c1">isomorphism. Journal of the (JACM), 23(1), 1976. [19] J. Wang, N. Ntarmos, and P. Triantafillou. Indexing query graphs to speedup graph query processing. In Proc. ACM EDBT, pages 41&ndash;52, 2016. [20] D. W. Williams, J. Huan, and W. Wang. Graph </span></p><p class="c53"><span class="c1">database indexing using structured graph decomposition. In Proc. ICDE, pages 976&ndash;985, 2007. [21] Y. Xie and P. Yu. CP-Index: on the efficient indexing </span></p><p class="c67"><span class="c1">of large graphs. In Proc. CIKM, 2011. [22] X. Yan, P. S. Yu, and J. Han. Graph indexing: a </span></p><p class="c15"><span class="c1">frequent structure-based approach. In Proc. SIGMOD, pages 335&ndash;346, 2004. [23] X. Yan, F. Zhu, P. S. Yu, and J. Han. Feature-based </span></p><p class="c74"><span class="c1">similarity search in graph structures. ACM TODS, 31(4):1418&ndash;1453, 2006. [24] D. Yuan and P. Mitra. Lindex: a lattice-based index </span></p><p class="c57"><span class="c1">for graph databases. VLDBJ, 22(2):229&ndash;252, 2013. [25] S. Zhang, M. Hu, and J. Yang. TreePi: A Novel Graph </span></p><p class="c62"><span class="c1">Indexing Method. In Proc. ICDE, 2007. [26] S. Zhang, S. Li, and J. Yang. GADDI: Distance Index </span></p><p class="c47"><span class="c1">Based Subgraph Matching in Biological Networks. In Proc. EDBT, pages 192&ndash;203, 2009. [27] S. Zhang, J. Yang, and W. Jin. SAPPER: subgraph </span></p><p class="c87"><span class="c1">indexing and approximate matching in large graphs. PVLDB, 3(1-2):1185&ndash;1194, 2010. [28] P. Zhao and J. Han. On graph query optimization in </span></p><p class="c81"><span class="c1">large networks. PVLDB, 3(1-2):340&ndash;351, 2010. [29] P. Zhao, J. X. Yu, and P. S. Yu. Graph indexing: tree </span></p><p class="c42"><span class="c1">+ delta &gt;= graph. In PVLDB, pages 938&ndash;949, 2007. [30] L. Zou, L. Chen, J. X. Yu, and Y. Lu. A novel spectral coding in a large graph database. In Proc. EDBT, pages 181&ndash;192, 2008. </span></p><p class="c34"><span class="c4">36 </span></p></body></html>