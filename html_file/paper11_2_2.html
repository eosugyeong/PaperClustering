<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c26{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.2pt;font-family:"Arial";font-style:normal}.c22{color:#0000ff;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Arial";font-style:normal}.c19{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:11pt;font-family:"Arial";font-style:normal}.c13{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Arial";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12.1pt;font-family:"Arial";font-style:normal}.c48{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11.6pt;font-family:"Arial";font-style:normal}.c12{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5pt;font-family:"Arial";font-style:normal}.c49{margin-left:-15.1pt;padding-top:1pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.4pt}.c78{margin-left:-16.9pt;padding-top:1.2pt;text-indent:32.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.8pt}.c66{margin-left:-16.9pt;padding-top:1.2pt;text-indent:32.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.2pt}.c72{margin-left:-16.9pt;padding-top:2.2pt;text-indent:27pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.4pt}.c30{margin-left:-16.9pt;padding-top:1pt;text-indent:32.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19pt}.c40{margin-left:-16.9pt;padding-top:1pt;text-indent:32.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.2pt}.c47{margin-left:-17.1pt;padding-top:1.9pt;text-indent:27.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.2pt}.c62{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:11.7pt;font-family:"Arial";font-style:normal}.c64{margin-left:-18.5pt;padding-top:2.2pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.6pt}.c81{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:13.3pt;font-family:"Arial";font-style:normal}.c6{color:#0000ff;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Arial";font-style:normal}.c52{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Courier New";font-style:normal}.c21{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.5pt;font-family:"Arial";font-style:normal}.c55{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Arial";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Arial";font-style:normal}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10.9pt;font-family:"Arial";font-style:normal}.c71{margin-left:-18.7pt;padding-top:1.9pt;text-indent:28.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.2pt}.c17{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c43{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:12.1pt;font-family:"Arial";font-style:normal}.c46{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12.1pt;font-family:"Courier New";font-style:normal}.c8{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Arial";font-style:normal}.c32{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Courier New";font-style:normal}.c14{margin-left:-16.9pt;padding-top:1pt;text-indent:32.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-18pt}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Arial";font-style:normal}.c56{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.5pt;font-family:"Arial";font-style:normal}.c59{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.3pt;font-family:"Courier New";font-style:normal}.c39{margin-left:-18.5pt;padding-top:2.2pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.8pt}.c24{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Arial";font-style:normal}.c57{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.6pt;font-family:"Arial";font-style:normal}.c35{color:#009900;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Arial";font-style:normal}.c54{margin-left:-18.5pt;padding-top:1pt;text-indent:30.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.4pt}.c61{margin-left:-15.1pt;padding-top:1.2pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.4pt}.c38{margin-left:-16.9pt;padding-top:1.2pt;text-indent:32.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-18pt}.c41{margin-left:-15.1pt;padding-top:1pt;text-indent:27.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.2pt}.c58{margin-left:-19pt;padding-top:2.2pt;text-indent:28.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.8pt}.c37{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c20{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:11.6pt;font-family:"Arial";font-style:normal}.c16{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7pt;font-family:"Arial";font-style:normal}.c15{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Courier New";font-style:normal}.c42{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:17.2pt;font-family:"Arial";font-style:normal}.c11{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.6pt;font-family:"Arial";font-style:normal}.c18{color:#9400d1;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Arial";font-style:normal}.c10{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.3pt;font-family:"Arial";font-style:normal}.c83{margin-left:-19pt;padding-top:8.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.2pt}.c25{margin-left:-16.9pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-18.2pt}.c63{margin-left:-0.8pt;padding-top:5.5pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.2pt}.c36{margin-left:-16.9pt;padding-top:11.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.4pt}.c34{margin-left:-18.5pt;padding-top:10.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:95pt}.c89{margin-left:221pt;padding-top:57.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-33pt}.c53{margin-left:-16.9pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-19pt}.c85{margin-left:-19pt;padding-top:10.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.6pt}.c74{margin-left:-17.1pt;padding-top:2.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.4pt}.c3{margin-left:59.3pt;padding-top:8.4pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:43.8pt}.c75{margin-left:-18.5pt;padding-top:6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.6pt}.c27{margin-left:-18.5pt;padding-top:8.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.6pt}.c51{margin-left:-17.1pt;padding-top:12pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.4pt}.c31{margin-left:-19pt;padding-top:10.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.6pt}.c70{margin-left:-0.8pt;padding-top:2.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18.2pt}.c86{margin-left:-16.9pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-18pt}.c84{margin-left:-19pt;padding-top:16.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.8pt}.c68{margin-left:-0.8pt;padding-top:1.9pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18.2pt}.c73{margin-left:-16.9pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.8pt}.c80{margin-left:221pt;padding-top:50.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-33pt}.c44{margin-left:-15.1pt;padding-top:3.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.4pt}.c65{margin-left:-23.8pt;padding-top:737.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-24pt}.c76{margin-left:4.8pt;padding-top:181.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:7.1pt}.c77{margin-left:-18.5pt;padding-top:11.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.9pt}.c88{margin-left:57.4pt;padding-top:14.4pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:41pt}.c67{margin-left:-16.9pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-19.2pt}.c28{margin-left:-19pt;padding-top:10.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.6pt}.c87{margin-left:-0.8pt;padding-top:1.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.4pt}.c29{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c7{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c90{padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c9{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c23{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c79{margin-left:22pt;margin-right:37.7pt}.c60{margin-left:237.1pt;margin-right:-273.2pt}.c82{margin-left:-16.9pt;margin-right:-19.4pt}.c33{margin-left:10.3pt;margin-right:10.8pt}.c69{margin-left:-16.9pt;margin-right:-19.2pt}.c91{margin-left:-1.3pt;margin-right:63.4pt}.c50{margin-left:39.3pt;margin-right:56.2pt}.c45{text-indent:32.5pt}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:24pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:14pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c23"><p class="c65"><span class="c17">Series ISSN: 2367-2005 13 </span><span class="c52">10.5441/002/edbt.2018.03 </span></p><p class="c7 c33"><span class="c42">MTBase: Optimizing Cross-Tenant Database Queries </span></p><p class="c88"><span class="c37">Lucas Braun</span><span class="c57">* </span><span class="c2">Oracle Labs lucas.braun@oracle.com </span></p><p class="c29 c79"><span class="c37">Renato Marroqu&iacute;n </span><span class="c2">Systems Group, Department of Computer Science, ETH Zurich marenato@inf.ethz.ch </span></p><p class="c3"><span class="c37">Donald Kossmann</span><span class="c57">* </span><span class="c2">Microsoft Research donald@microsoft.com </span></p><p class="c29 c50"><span class="c37">Ken Tsay</span><span class="c57">* </span><span class="c2">Careem Networks GmbH ken.tsay@careem.com </span></p><p class="c27"><span class="c4">ABSTRACT </span><span class="c5">In the last decade, many business applications have moved into the cloud. In particular, the &ldquo;database-as-a-service&rdquo; paradigm has be- come mainstream. While existing multi-tenant data management systems focus on single-tenant query processing, we believe that it is time to rethink how queries can be processed across multiple tenants in such a way that we do not only gain more valuable insights, but also at minimal cost. As we will argue in this paper, standard SQL semantics are insufficient to process cross-tenant queries in an unambiguous way, which is why existing systems use other, expensive means like ETL or data integration instead. We first propose MTSQL, an extension to standard SQL, which fixes the ambiguity problem. Next, we present MTBase, a query pro- cessing middleware that efficiently processes MTSQL on top of SQL. As we will see, there is a canonical, provably correct, rewrite algorithm from MTSQL to SQL, which may however result in poor query execution performance, even on high-performance database products. We further show that with carefully-designed optimizations, execution times can be reduced in such ways that the difference to single-tenant queries becomes marginal. </span></p><p class="c84"><span class="c4">1 INTRODUCTION </span><span class="c5">Indisputably, cloud computing is one of the fastest growing busi- nesses related to the field of computer science. Cloud providers promise good elasticity, high availability and a fair pay-as-you- go pricing model to their tenants. Moreover, corporations are no longer required to rely on on-premise infrastructure which is typically costly to acquire and maintain. While it is still an open re- search question whether and how these good promises can be kept with regard to databases [19, 32], all the big players, like Google [30], Amazon [8], Microsoft [34] and recently Oracle [38], have launched their own Database-as-a-Service (DaaS) cloud products. All these products host massive amounts of data from multiple clients and are therefore multi-tenant. However, as pointed out by Chong et al. [17], the term multi-tenant database is ambiguous and can refer to a variety of DaaS schemes with different degrees of logical data sharing between tenants. On the other hand, as argued by Aulbach et al. [11], multi-tenant databases not only differ in the way how tenants logically share information, but also how information is physically separated. We conclude that the multi-tenancy spectrum consists of four different schemes: First, there are DaaS products that offer each tenant her proper data- base while relying on shared resources (SR), i.e. hardware (e.g. </span></p><p class="c34"><span class="c21">*</span><span class="c48">most of the work performed while at ETH </span></p><p class="c77"><span class="c16">&copy; 2018 Copyright held by the owner/author(s). Published in Proceedings of the 21st International Conference on Extending Database Technology (EDBT), March 26-29, 2018, ISBN 978-3-89318-078-3 on OpenProceedings.org. Distribution of this paper is permitted under the terms of the Creative Commons license CC-by-nc-nd 4.0. </span></p><p class="c0 c82"><span class="c5">CPU, network, storage) and/or software (e.g. buffer pools, system tables, system users, etc.). Examples include SAP HANA [42], SqlVM [36], RelationalCloud [35], Snowflake [18] and Oracle&rsquo;s multitenant container database (CDB) [40]. Next, there are sys- tems that share databases (SD), but each tenant gets her own set of tables within such a database, as for instance Azure SQL DB [20]. Finally, there are the two schemes where tenants not only share a database, but also the table layout (schema). Either, as for exam- ple in Apache Phoenix [9], tenants still have their private tables, but these tables share the same (logical) schema (SS), or the data of different tenants is consolidated into shared tables (ST) which is hence the layout with the highest degree of physical and logi- cal sharing. Prominent examples for ST include Oracle&rsquo;s Virtual Private Database [3] as well as different Microsoft Azure DaaS offerings [33, 34]. SS and ST layouts are not only used in DaaS, but also in Software-as-a-Service (SaaS) platforms, as for exam- ple in Salesforce [44]. The main reason why all these commercial systems prefer ST over SS is cost [11]. Moreover, if the number of tenants exceeds the number of tables a database can hold, which is typically a number in the range of ten thousands, SS becomes prohibitive. Conversely, ST databases can easily accommodate hundred thousands to even millions of tenants. </span></p><p class="c47"><span class="c5">An important feature of multi-tenant databases, which, to the best of our knowledge, no DaaS or SaaS natively supports today, is cross-tenant query processing, i.e. combining data of different tenants and query this unified data set as if it was single-tenant, using SQL. In order to illustrate that cross-tenant query processing is indeed a highly relevant requirement, let us have a look at one of the many initiatives to democratize the use of personal data, the Health Data Cooperative (HDC) [27]. In HDC, all patient data is stored in a single, multi-tenant SaaS database, each patient being a tenant managing her own data. For clinical studies, however, it is essential to be able to run queries over a cohort of patients who give their consent, or, in other words enable cross-tenant query processing. Clearly, the health data use case has also another big challenge, which is data privacy. This aspect, despite being out of the scope of this paper, is considered essential future work. </span></p><p class="c72"><span class="c5">There are several existing approaches to cross-tenant query processing which are summarized in Figure 1. The first approach is data warehousing [29] where data is extracted from several data sources (tenant databases/tables), transformed into one common format and finally loaded into a new database where it can be queried by the client. This approach has high integration trans- parency in the sense that once the data is loaded, it is in the expected format as required by the client and she can ask any query she wants, using plain SQL. Moreover, as all data is in a single place, queries can be optimized. On the down-side of this approach &ndash; well-known and argued by many [10, 14, 37] &ndash; are costs in terms of both, developing and maintaining such ETL </span></p><p class="c76"><span class="c5">Figure 1: Cross-tenant query processing systems </span></p><p class="c75"><span class="c5">pipelines, as well as maintaining a separate copy of the data. An- other disadvantage is data staleness in the presence of frequent updates. </span></p><p class="c39"><span class="c5">Federated Databases [26, 31] reduce some of these costs by integrating data on demand, i.e. there is no data copying. How- ever, maintenance costs are still significant as for every new data source, a new integrator/wrapper has to be developed. As data resides in different places (and different formats), queries can only be optimized to a very small extent (if at all), which is why the degree of integration transparency is considered sub-optimal. Fi- nally, systems like SAP HANA [42] and Salesforce [44], which are mainly tailored towards single-tenant queries, offer some degree of cross-tenant query processing, but only through their applica- tion logic, not natively. This means that the set of queries that can be asked is limited, accounting for low integration transparency. </span></p><p class="c58"><span class="c5">We believe that the reason why none of these previous works uses a native approach, i.e. SQL plus transparent rewriting, for cross-tenant query processing is that there is an ambiguity prob- lem.</span><span class="c43">1 </span><span class="c5">Consider, for instance, the ST database in Figure 2, which we are going to use as a running example throughout the paper. Further assume that we would like to query the joint dataset of tenants 0 and 1: As shown on the left, we might want to join Employees with Roles. Joining on role_id alone is not e- nough as this would also join Alice with executive, which does not correspond to the expected output because Alice is a pro- fessor, and only a professor. In this case, a rewrite algorithm would have to add the tenant-ID ttid to the join predicate. On the other hand, joining the Employees table with itself on E1.age = E2.age, as illustrated on the right, does not require ttid to be present in the join predicate because it actually makes sense to include results like (Alice, Ed) because they are indeed the same age. </span></p><p class="c64"><span class="c5">An additional challenging fact is that different tenants might store their data in different units. In our example, tenant 0 might store her employees&rsquo; salaries in a different currency than tenant 1. If this is the case, computing the average salary across all te- nants clearly involves some value conversions that should, ideally, happen without the client noticing or even worrying about. </span></p><p class="c64"><span class="c5">This paper presents MTSQL as a solution to these ambigu- ity problems, following a native approach. MTSQL extends the SQL API and provides additional data definition syntax and cor- responding semantics specifically-suited for cross-tenant query </span></p><p class="c83"><span class="c21">1</span><span class="c48">Note, however, that SQL plus transparent rewriting works for single-tenant query </span><span class="c16">processing in a multi-tenant system. Apache Phoenix [9] and Oracle&rsquo;s Virtual Private Database [3] do exactly that. </span></p><p class="c7 c60"><span class="c5">Figure 2: Multi-tenant database in basic layout (ST), illustrat- ing the ambiguity problem in cross-tenant queries </span></p><p class="c36"><span class="c5">processing. It enables high integration transparency because once the schema is defined and the database connection established, any client, with any desired data format, can ask any query at any time and do so by using nothing else but plain SQL. Moreover, as data resides in a single database (SS or ST), queries can be aggressively optimized with respect to both, standard SQL semantics and addi- tional MTSQL semantics. As MTSQL adopts the single-database layout, it is also very cost-effective, especially if used on top of ST. Also, data conversion only happens as needed, which perfectly fits the cloud&rsquo;s pay-as-you-go cost model and thus makes MT- SQL an attractive option to complement existing DaaS offerings. Specifically, the paper makes the following contributions: </span></p><p class="c63"><span class="c5">&bull; It defines the syntax and semantics of MTSQL, a database language that extends SQL and solves the ambiguity prob- lem for cross-tenant query processing. </span></p><p class="c68"><span class="c5">&bull; It presents the design and implementation of MTBase, a database middleware that executes MTSQL on top of any shared-table multi-tenant database. </span></p><p class="c87"><span class="c5">&bull; It studies MTSQL-specific optimizations for query execu- tion in MTBase. </span></p><p class="c70"><span class="c5">&bull; It extends the well-known TPC-H benchmark in order to run and evaluate MTSQL workloads, resulting in new benchmark called MT-H. </span></p><p class="c74"><span class="c5">&bull; It evaluates the performance and the implementation cor- rectness of MTBase with MT-H, concluding with satisfac- tory results. The rest of this paper is organized as follows: Section 2 defines MTSQL, while Section 3 gives an overview on MTBase. Section 4 discusses the MTSQL-specific optimizations which are validated in Section 5. Section 6 shortly summarizes lines of related work, specifically focusing on the relation of MTSQL to data integra- tion as well as data privacy, whereas the paper is concluded in Section 7. </span></p><p class="c51"><span class="c4">2 MTSQL </span><span class="c5">In order to model the specific aspects of cross-tenant query pro- cessing in multi-tenant databases, we developed MTSQL, which will be described in this section. MTSQL extends SQL in two ways: First, it extends the SQL interface with two additional pa- rameters, C and D. C is the tenant ID (or ttid for short) of the client who submits a statement and hence determines the format in which the result must be presented. The data set, D, is a set of ttids that refer to the tenants whose data the client wants to query. Secondly, MTSQL extends the syntax and semantics of SQL, as well as its Data Definition Language (DDL), Data Manipulation </span></p><p class="c80"><span class="c17">14 </span></p><p class="c9"><span class="c5">There are two types of tables in MTSQL: tables that contain common knowledge shared by everybody (like the Regions table in TPC-H [43]) and those that contain data of a specific tenant (i.e. Employees and Roles in Figure 2). More formally, we define the table generality of Regions as global and the one of Employees as tenant-specific. In order to process queries across tenants, MTSQL needs a way to distinguish whether an attribute is comparable (can be directly compared against attribute values of other tenants), convertible (can be compared against attribute values of other tenants after applying a well-defined conversion function) or tenant-specific (it does semantically not make sense to compare against attribute values of other tenants). An overview of these types of attribute comparability, together with examples from Figure 2, is shown in Table 1. </span></p><p class="c7"><span class="c16">type description examples comparable </span><span class="c20">can be directly compared to and </span></p><p class="c7"><span class="c16">aggregated with other values </span><span class="c20">E_age, R_name </span></p><p class="c7"><span class="c16">convertible </span><span class="c5">Language (DML) and Data Control Language (DCL, consists of GRANT and REVOKE statements). </span></p><p class="c9"><span class="c5">As mentioned in the introduction, there are several ways how a multi-tenant database can be laid out: Figure 2 shows an example of the ST scheme, also referred to as basic layout in related work [11] where tenants&rsquo;s data is consolidated using the same tables. Meanwhile, there also exists the SS scheme, also referred to as private table layout, where every tenant has her own set of tables. In that scheme, data ownership is defines as part of the table name (e.g. Roles_1, Roles_2, ...) while in ST, records are explicitly annotated with the ttid of their data owner, using an extra meta column in the table which is invisible to the client. </span></p><p class="c9"><span class="c5">As these two approaches are semantically equivalent, the MT- SQL semantics that we are about to define, apply to both. In the case of the SS, applying a statement s with respect to D simply means to apply s to the logical union of all private tables owned by a tenant in D. In SS, s is applied to tables filtered according to D. In order to keep the presentation simple, the rest of this paper assumes an ST scheme, but sometimes defines semantics with respect to SS if that makes the presentation easier to understand. </span></p><p class="c9"><span class="c16">other values need to be converted to the format of the current tenant before comparison or aggregation </span></p><p class="c7"><span class="c4">2.1 MTSQL API </span><span class="c5">MTSQL needs a way to incorporate the additional parameters C and D. As C is the ttid of the tenant that issues a statement, we assume it is implicitly given by the SQL connection string. ttids are not only used for identification and access control, but also for data ownership. While this paper uses integers for simplicity reasons, ttids can have any data type, in particular they can also be database user names. </span></p><p class="c7"><span class="c6">SET </span><span class="c22">SCOPE </span><span class="c8">= </span><span class="c18">&quot;IN (1,3,42)&quot;</span><span class="c8">; </span></p><p class="c7"><span class="c5">Listing 1: Simple SCOPE expression using IN </span></p><p class="c7"><span class="c6">SET </span><span class="c22">SCOPE </span><span class="c8">= </span><span class="c18">&quot;FROM Employees WHERE E_salary &gt; 180K&quot;</span><span class="c8">; </span></p><p class="c7"><span class="c5">Listing 2: Complex SCOPE expression with sub-query </span></p><p class="c9"><span class="c5">D is defined using the MTSQL-specific SCOPE runtime para- meter on the SQL connection. This parameter can be set in two different ways: Either, as shown in Listing 1, as simple scope with an IN list stating the set of ttids that should be queried, or as in Listing 2, as a sub-query with a FROM and a WHERE clause (complex scope). The semantics of the latter is that every tenant that owns at least one record in one of the tables mentioned in the FROM clause that satisfies the WHERE clause is part of D. The SCOPE variable defaults to {C}, which means that by default a client processes only her own data. Defining a simple scope with an empty IN list, on the other hand, makes D include all the tenants present in the database. </span></p><p class="c9"><span class="c5">Making C and D part of the connection allowed for a clear separation between the end users of MTSQL (for which ttids do not make much sense and hence remain invisible) and adminis- trators/programmers that manage connections (and are aware of ttids). </span></p><p class="c7"><span class="c4">2.2 Data Definition Language </span><span class="c5">DDL statements are issued by a special role called the data mod- eller. In a multi-tenant application, this would be the SaaS provider (e.g. a Salesforce administrator) or the provider of a specific ap- plication. However, the data modeller can delegate this privilege to any tenant she trusts using a GRANT statement, as will be de- scribed in Section 2.3. </span></p><p class="c7"><span class="c16">E_salary </span></p><p class="c7"><span class="c16">tenant-specific </span><span class="c20">values of different tenants cannot </span></p><p class="c7"><span class="c16">be compared with each other </span><span class="c20">E_role_id, R.role_id </span><span class="c5">Table 1: Overview on attribute comparability in MTSQL </span></p><p class="c7"><span class="c5">2.2.1 CREATE TABLE Statement. The MTSQL-specific keywords for creating (or altering) tables are GLOBAL, SPECIFIC, COMPARABLE and CONVERTIBLE. An example of how they can be used is shown in Listing 3. Note that SPECIFIC can be used for tables and attributes. Moreover, using these keywords is optional as we define that tables are global by de- fault, attributes of tenant-specific tables default to tenant-specific and those of global tables to comparable.</span><span class="c43">2 </span></p><p class="c7"><span class="c12">1 </span><span class="c6">CREATE TABLE </span><span class="c8">Employees </span><span class="c22">SPECIFIC </span><span class="c8">( </span><span class="c12">2 </span><span class="c8">E_emp_id </span><span class="c6">INTEGER NOT NULL </span><span class="c22">SPECIFIC</span><span class="c8">, </span><span class="c12">3 </span><span class="c8">E_name </span><span class="c6">VARCHAR</span><span class="c8">(25) </span><span class="c6">NOT NULL </span><span class="c22">COMPARABLE</span><span class="c8">, </span><span class="c12">4 </span><span class="c8">E_role_id </span><span class="c6">INTEGER NOT NULL </span><span class="c22">SPECIFIC</span><span class="c8">, </span><span class="c12">5 </span><span class="c8">E_salary </span><span class="c6">VARCHAR</span><span class="c8">(17) </span><span class="c6">NOT NULL </span><span class="c22">CONVERTIBLE </span></p><p class="c7"><span class="c8">@currencyToUniversal @currencyFromUniversal, </span><span class="c12">6 </span><span class="c8">E_age </span><span class="c6">INTEGER NOT NULL </span><span class="c22">COMPARABLE</span><span class="c8">, </span><span class="c12">7 </span><span class="c6">CONSTRAINT </span><span class="c8">pk_emp </span><span class="c6">PRIMARY KEY </span><span class="c8">(E_emp_id), </span><span class="c12">8 </span><span class="c6">CONSTRAINT </span><span class="c8">fk_emp </span><span class="c6">FOREIGN KEY </span><span class="c8">(E_role_id) </span><span class="c6">REFERENCES </span><span class="c8">Roles ( </span></p><p class="c7"><span class="c8">R_role_id) </span><span class="c12">9 </span><span class="c8">);</span><span class="c13">Listing 3: Exemplary MTSQL CREATE TABLE statement, </span></p><p class="c7"><span class="c5">MT-specific keywords marked in bold </span></p><p class="c9"><span class="c5">2.2.2 Conversion Functions. Cross-tenant query process- ing requires the ability to execute comparison predicates on com- parable and convertible attribute. While comparable attributes can be directly compared to each other, convertible attributes, as their name indicates, have to be converted first, using conversion functions. Each tenant has a pair of conversion functions for each attribute to translate from and to a well-defined universal format. More formally, a conversion function pair is defined as follows: </span></p><p class="c9"><span class="c5">Definition 2.1. </span><span class="c15">(</span><span class="c5">toUni ersal : X &times; T &rarr; X, f rom- Uni ersal : X &times;T &rarr; X</span><span class="c15">) </span><span class="c5">is a valid MTSQL conversion function pair for attribute A, whereT is the set of tenants in the database and X is the domain of A, if and only if: </span></p><p class="c7"><span class="c5">(i) There exists a universal format for attribute A:</span><span class="c43">3 </span></p><p class="c7"><span class="c5">ima e</span><span class="c15">(</span><span class="c5">toUni ersal</span><span class="c15">(</span><span class="c5">&middot;,t</span><span class="c10">1</span><span class="c15">)) </span><span class="c5">= ima e</span><span class="c15">(</span><span class="c5">toUni ersal</span><span class="c15">(</span><span class="c5">&middot;,t</span><span class="c10">2</span><span class="c15">)) </span><span class="c5">= ... = ima e</span><span class="c15">(</span><span class="c5">toUni ersal</span><span class="c15">(</span><span class="c5">&middot;,t</span><span class="c1">|T |</span><span class="c15">)) </span><span class="c5">(ii) For every tenant t &isin; T, the partial functions toUni ersal</span><span class="c15">(</span><span class="c5">&middot;,t</span><span class="c15">) </span></p><p class="c7"><span class="c5">and f romU ni ersal</span><span class="c15">(</span><span class="c5">&middot;,t</span><span class="c15">) </span><span class="c5">are bijective functions. </span></p><p class="c7"><span class="c21">2</span><span class="c48">Global tables (shared among all tenants!) can only have comparable attributes </span><span class="c16">anyway. </span><span class="c21">3</span><span class="c1">ima e</span><span class="c46">(</span><span class="c1">f </span><span class="c46">) </span><span class="c48">denotes the mathematical image, i.e. the range of function </span><span class="c1">f </span><span class="c48">. </span></p><p class="c7"><span class="c17">15 </span></p><p class="c7"><span class="c5">&bull; (iii) f romU ni ersal is the inverse of toUni ersal: &forall;t &isin; T, </span></p><p class="c7"><span class="c5">homomorphic with respect to tenant t and function h: x &isin; X : f romU ni ersal</span><span class="c15">(</span><span class="c5">toUni ersal</span><span class="c15">(</span><span class="c5">x,t</span><span class="c15">)</span><span class="c5">,t</span><span class="c15">) </span><span class="c5">= x </span></p><p class="c7"><span class="c5">toUni ersal</span><span class="c15">(</span><span class="c5">h</span><span class="c15">(</span><span class="c5">x</span><span class="c1">1</span><span class="c13">,x</span><span class="c1">2</span><span class="c13">, ...</span><span class="c32">)</span><span class="c13">,t</span><span class="c32">) </span><span class="c13">= </span></p><p class="c7"><span class="c5">These three properties imply the following two corollaries that we are going to need later in this paper: </span></p><p class="c0"><span class="c5">h</span><span class="c15">(</span><span class="c5">toUni ersal</span><span class="c15">(</span><span class="c5">x</span><span class="c1">1</span><span class="c13">,t</span><span class="c32">)</span><span class="c13">,toUni ersal</span><span class="c32">(</span><span class="c13">x</span><span class="c1">2</span><span class="c13">,t</span><span class="c32">)</span><span class="c13">, ...</span><span class="c32">) </span><span class="c5">We will call a conversion function pair fully-order-preserving if toUni ersal and f romU ni ersal are order-preserving with re- C</span><span class="c26">OROLLARY </span><span class="c5">1. toUni ersal and f romU ni ersal are equality </span></p><p class="c7"><span class="c5">spect to all tenants. Consequently, a conversion function pair can preserving: &forall;t &isin; T : toUni ersal</span><span class="c15">(</span><span class="c5">x,t</span><span class="c15">) </span><span class="c5">= toUni ersal</span><span class="c15">( </span><span class="c5">,t</span><span class="c15">) </span><span class="c5">&hArr; </span></p><p class="c7"><span class="c5">also be fully-h-preserving. x = &hArr; f romU ni ersal</span><span class="c15">(</span><span class="c5">x,t</span><span class="c15">) </span><span class="c5">= f romU ni ersal</span><span class="c15">( </span><span class="c5">,t</span><span class="c15">) </span></p><p class="c7"><span class="c5">Listings 6 and 7 show an exemplary conversion function pair </span></p><p class="c9"><span class="c5">C</span><span class="c26">OROLLARY </span><span class="c5">2. Values from any tenant t</span><span class="c10">i </span><span class="c5">can be converted into the representation of any other tenant t</span><span class="c1">j </span><span class="c13">by first applying </span><span class="c5">toUni ersal</span><span class="c15">(</span><span class="c5">&middot;,t</span><span class="c1">i</span><span class="c32">)</span><span class="c13">, followed by f romU ni ersal</span><span class="c32">(</span><span class="c13">&middot;,t</span><span class="c1">j</span><span class="c32">) </span><span class="c13">while </span><span class="c5">equality is preserved: </span></p><p class="c7"><span class="c5">&forall;t</span><span class="c10">i</span><span class="c5">,t</span><span class="c10">j </span><span class="c5">&isin; T : x = &hArr;f romU ni ersal</span><span class="c15">(</span><span class="c5">toUni ersal</span><span class="c15">(</span><span class="c5">x,t</span><span class="c10">i </span><span class="c15">)</span><span class="c5">,t</span><span class="c10">j</span><span class="c15">) </span></p><p class="c0"><span class="c5">used to convert currencies (with USD as universal format). These functions are not only equality-preserving, but also fully-SUM- preserving: as the currency conversion is nothing but a multipli- cation with a constant factor</span><span class="c43">5 </span><span class="c5">from CurrencyTransform, it does not matter in which format we sum up individual values (as long as they all have that same format). As we will see, such =f romU ni ersal</span><span class="c15">(</span><span class="c5">toUni ersal</span><span class="c15">( </span><span class="c5">,t</span><span class="c10">i</span><span class="c15">)</span><span class="c5">,t</span><span class="c10">j</span><span class="c15">) </span></p><p class="c7"><span class="c5">special properties of conversion functions are another crucial in- </span></p><p class="c7"><span class="c5">The reason why we opted for a two-step conversion through </span></p><p class="c7"><span class="c5">gredient for query optimization. </span></p><p class="c9"><span class="c5">universal format is that it allows each tenant t</span><span class="c10">i </span><span class="c5">to define her share of the conversion function pair, i.e. toUni ersal</span><span class="c15">(</span><span class="c5">&middot;,t</span><span class="c1">i</span><span class="c32">) </span><span class="c13">and f rom- </span><span class="c5">Uni ersal</span><span class="c15">(</span><span class="c5">&middot;,t</span><span class="c1">i</span><span class="c32">)</span><span class="c13">, individually without the need of a central author- </span><span class="c5">ity. Moreover, this design greatly reduces the overall number of </span></p><p class="c7"><span class="c12">1 </span><span class="c6">CREATE </span><span class="c8">FUNCTION currencyToUniversal (</span><span class="c6">DECIMAL</span><span class="c8">(15,2), </span><span class="c6">INTEGER</span><span class="c8">) </span></p><p class="c7"><span class="c8">RETURNS </span><span class="c6">DECIMAL</span><span class="c8">(15,2) </span><span class="c12">2 </span><span class="c6">AS </span><span class="c18">&#39;SELECT CT_to_universal*$1 FROM Tenant, CurrencyTransform </span></p><p class="c0"><span class="c18">WHERE T_tenant_key = $2 AND T_currency_key = CT_currency_key;&#39; </span><span class="c12">3 </span><span class="c8">LANGUAGE SQL IMMUTABLE; </span><span class="c5">partial conversion functions as we need at most 2 &middot; |T | partial function definitions, compared to |T |</span><span class="c43">2 </span><span class="c5">functions in the case where we would define a direct conversion for every pair of tenants. </span></p><p class="c7"><span class="c5">Listing 6: Converting a currency to universal form (USD), PostgreSQL syntax </span></p><p class="c7"><span class="c12">1 </span><span class="c6">CREATE </span><span class="c8">FUNCTION phoneToUniversal (</span><span class="c6">VARCHAR</span><span class="c8">(17), </span><span class="c6">INTEGER</span><span class="c8">) RETURNS </span></p><p class="c7"><span class="c6">VARCHAR</span><span class="c8">(17) </span><span class="c12">2 </span><span class="c6">AS </span><span class="c18">&#39;SELECT SUBSTRING($1, CHAR_LENGTH(PT_prefix)+1) FROM </span></p><p class="c7"><span class="c18">Tenant, PhoneTransform WHERE T_tenant_key = $2 AND T_phone_prefix_key = PT_phone_prefix_key;&#39; </span><span class="c12">3 </span><span class="c8">LANGUAGE SQL IMMUTABLE; </span></p><p class="c7"><span class="c12">1 </span><span class="c6">CREATE </span><span class="c8">FUNCTION currencyFromUniversal (</span><span class="c6">DECIMAL</span><span class="c8">(15,2), </span><span class="c6">INTEGER</span><span class="c8">) </span></p><p class="c7"><span class="c8">RETURNS </span><span class="c6">DECIMAL</span><span class="c8">(15,2) </span><span class="c12">2 </span><span class="c6">AS </span><span class="c18">&#39;SELECT CT_from_universal*$1 FROM Tenant, </span></p><p class="c7"><span class="c18">CurrencyTransform WHERE T_tenant_key = $2 AND T_currency_key = CT_currency_key;&#39; </span><span class="c12">3 </span><span class="c8">LANGUAGE SQL IMMUTABLE; </span></p><p class="c7"><span class="c5">Listing 4: Converting a phone number to universal form (without prefix), PostgreSQL syntax </span></p><p class="c7"><span class="c5">Listing 7: Converting from USD to a specific currency, PostgreSQL syntax </span></p><p class="c7"><span class="c5">The conversion function examples shown in Listings 4 to 7 </span></p><p class="c7"><span class="c12">1 </span><span class="c6">CREATE </span><span class="c8">FUNCTION phoneFromUniversal (</span><span class="c6">VARCHAR</span><span class="c8">(17), </span><span class="c6">INTEGER</span><span class="c8">) </span></p><p class="c7"><span class="c8">RETURNS </span><span class="c6">VARCHAR</span><span class="c8">(17) </span></p><p class="c0"><span class="c5">assume the existence of tables holding additional conversion infor- mation (CurrencyTransmform and PhoneTransform) as </span><span class="c12">2 </span><span class="c6">AS </span><span class="c18">&#39;SELECT CONCAT(PT_prefix, $1) FROM Tenant, PhoneTransform </span></p><p class="c7"><span class="c18">WHERE T_tenant_key = $2 AND T_phone_prefix_key = PT_phone_prefix_key;&#39; </span><span class="c12">3 </span><span class="c8">LANGUAGE SQL IMMUTABLE; </span></p><p class="c0"><span class="c5">well as a table with references into these tables (named Tenants table). The way how a tenant can define her portion of the con- version functions is then simply to choose a specific currency and Listing 5: Converting to a specific phone number format, </span></p><p class="c7"><span class="c5">phone format as part of an initial setup procedure. However, this PostgreSQL syntax </span></p><p class="c0"><span class="c5">is only one possible implementation. MTSQL does not make any assumptions or restrictions on the implementation of conversion Listings 4 and 5 show an example of such a conversion func- </span></p><p class="c7"><span class="c5">function pairs themselves, as long as they satisfy the properties tion pair. These functions are used to convert phone numbers with </span></p><p class="c7"><span class="c5">given in Definition 2.1. different prefixes, like &ldquo;+&rdquo;, &ldquo;00&rdquo; or any other specific county exit code</span><span class="c43">4</span><span class="c5">, and the universal format is a phone number without pre- </span></p><p class="c0"><span class="c5">MTSQL is not the first work that talks about conversion func- tions. In fact, there is an entire line of work that deals with data fix. In this example, converting phone numbers simply means to </span></p><p class="c7"><span class="c5">integration and in particular with schema mapping techniques lookup the tenant&rsquo;s prefix and then either prepend or remove it, de- </span></p><p class="c7"><span class="c5">[11, 23, 25]. These works mention and take into account conver- pending whether we convert from or to the universal format. Note </span></p><p class="c7"><span class="c5">sion functions, like for example a multiplication or a division by a that the exemplary code also contains the keyword IMMUTABLE </span></p><p class="c7"><span class="c5">constant. More complex conversion functions, including regular- to state that for a specific input the function always returns the </span></p><p class="c7"><span class="c5">expression-based substitutions and other arithmetic operations, same output, which is an important hint for the query optimizer. </span></p><p class="c7"><span class="c5">can be found in Potter&rsquo;s Wheel [41] where conversion is referred While this keyword is PostgreSQL-specific, some other vendors, </span></p><p class="c7"><span class="c5">to as value translation. All these different conversion functions but by far not all, offer a similar syntax. </span></p><p class="c7"><span class="c5">can potentially also be used in MTSQL which is, to the best of our It is important to mention that the equality-preserving property </span></p><p class="c7"><span class="c5">knowledge, the first work that formally defines and categorizes as mentioned in Corollary 1 is a minimal requirement for conver- </span></p><p class="c7"><span class="c5">conversion functions according to their properties. sion functions to make sense in terms of producing coherent query results among different clients. There are, however conversion functions that exhibit additional properties, for example: </span></p><p class="c7"><span class="c5">&bull; order-preserving with respect to tenant t: x &lt; &hArr; toUni ersal</span><span class="c15">(</span><span class="c5">x,t</span><span class="c15">) </span><span class="c5">&lt; toUni ersal</span><span class="c15">( </span><span class="c5">,t</span><span class="c15">) </span></p><p class="c9"><span class="c5">2.2.3 Integrity Constraints. MTSQL allows for global in- tegrity constraints that every tenant has to adhere to (with respect to the entirety of her data) as well as tenant-specific integrity constraints (that tenants can additionally impose on their own </span></p><p class="c7"><span class="c21">4</span><span class="c48">The country exit code is a sequence of digits that you have to dial in order to inform </span></p><p class="c0"><span class="c21">5</span><span class="c48">We are aware of the fact that currency conversion is not at all constant, but depends </span><span class="c16">on rapidly changing exchange rates. However, we want to keep the examples as the telco system that you want to call a number abroad. A full list of country exit </span></p><p class="c7"><span class="c16">simple as possible in order to illustrate the underlying concepts. However, the general codes can be found on http://www.howtocallabroad.com/codes.html. </span></p><p class="c7"><span class="c16">ideas of this paper also apply to temporal databases. </span></p><p class="c7"><span class="c17">16 </span></p><p class="c7"><span class="c5">introduction, data). An example of a global referential integrity constraint is </span></p><p class="c7"><span class="c5">this creates some new challenges that have to be shown in the end of Listing 3. This constraint means that for </span></p><p class="c7"><span class="c5">handled with special care. every tenant, for each entry of E_role_id, a corresponding entry R_role_id has to exist in Roles and must be owned by that same tenant. Consider for example employee John with R_role_id 0. The constraint implies that their must be a role 0 owned by tenant 0, which in that case is PhD student. If the con- straint were only tenant-specific for tenant 1, John would not link to roles and E_role_id 0 would just be an arbitrary numer- ical value. In order to differentiate global from tenant-specific constraints, the scope is used.</span><span class="c43">6 </span></p><p class="c9"><span class="c5">2.4.1 Client Presentation. As soon as tenants can query other tenants&rsquo; data, the MTSQL engine has to be make sure to deliver results in the proper format. For instance, looking again at Figure 2, if tenant 0 queries the average salary of all employees of tenant 1, then this should be presented in USD because tenant 0 stores her own data in USD and expects other data to be in USD as well. Consequently, if tenant 1 would ask that same query, the result would be returned as is, namely in EUR. </span></p><p class="c9"><span class="c5">2.2.4 Other DDL Statements. CREATE VIEW statements look the same as in plain SQL. As for the other DDL statements, anyone with the necessary privilege can define global views on global and tenant-specific tables. Tenants are allowed to create their own, tenant-specific views (using the default scope). The selected data has to be presented in universal format if it is a global view and in the tenant-specific format otherwise. DROP VIEW, DROP TABLE and ALTER TABLE work the same way as in plain SQL. </span></p><p class="c7"><span class="c5">2.4.2 Comparisons. Consider a join of Roles and Employees on role_id. As long as the dataset size is only one, such a join query has the same semantics as in plain SQL (or FlexScheme). However, as soon as tenant 1, for instance, asks this query with D = {0, 1}, the join has to take the ttids into account. The reason for this is that role_id is a tenant-specific attribute and should hence only be joined within the same tenant in order to prevent semantically wrong results like John being an intern (although tenant 0 does not have such a role) or Nancy being a professor (despite the fact that tenant 1 only has roles intern, </span><span class="c4">2.3 Data Control Language </span><span class="c5">Let us have a look at the MTSQL GRANT statement: </span></p><p class="c7"><span class="c5">researcher and executive). </span></p><p class="c0"><span class="c5">Comparison or join predicates containing comparable and con- vertible attributes, on the other hand, just have to make sure that </span><span class="c6">GRANT </span><span class="c8">&lt;privileges&gt; </span><span class="c6">ON </span><span class="c8">&lt;database|</span><span class="c6">table</span><span class="c8">&gt; TO &lt;ttid&gt;; </span></p><p class="c7"><span class="c5">all data is brought into universal format before being compared. Listing 8: MTSQL GRANT syntax </span></p><p class="c0"><span class="c5">For instance, if tenant 0 wants to get the list of all employees (of both tenants) that earn more than 100K USD, all employee salaries As in plain SQL, this grants some set of access privileges </span></p><p class="c7"><span class="c5">have to be converted to USD before executing the comparison. (READ, INSERT, UPDATE and/or DELETE) to the tenant iden- </span></p><p class="c7"><span class="c5">Finally, MTSQL does not allow to compare tenant-specific tified by ttid. In the context of MTSQL, however, this means </span></p><p class="c7"><span class="c5">with other attributes. For instance, we see no way how it could that the privileges are granted with respect to C. Consider the </span></p><p class="c7"><span class="c5">make sense to compare E_role_id to something like E_age or following statement: </span></p><p class="c7"><span class="c5">E_salary. </span></p><p class="c7"><span class="c6">GRANT READ ON </span><span class="c8">Employees TO 42; </span></p><p class="c7"><span class="c5">Listing 9: Example of an MTSQL GRANT statement </span></p><p class="c0"><span class="c4">2.5 Data Manipulation Language </span><span class="c5">MTSQL DML works the same way as in FlexScheme [11, 12] In the private table layout, if C is 0, then this would </span></p><p class="c7"><span class="c5">if D = {C}. Otherwise, if D {C}, the semantics of a DML grant tenant 42 read access to Employees_0, but ifC is 1, tenant </span></p><p class="c7"><span class="c5">statement are defined such that it is applied to each tenant in 42 would get read access to Employees_1 instead. If a grant </span></p><p class="c7"><span class="c5">D separately. Constants, WHERE clauses and sub-queries are in- statement grants to ALL, then the grant semantics also depend </span></p><p class="c7"><span class="c5">terpreted with respect to C, exactly the same way as for queries on D, more concretely if D = {7,11,15} the privileges would be </span></p><p class="c7"><span class="c5">(c.f. Section 2.4). This implies that executing UPDATE or INSERT granted to tenants 7, 11 and 15. </span></p><p class="c7"><span class="c5">statements might involve value conversion to the proper tenant By default, a new tenant that joins an MTSQL system is granted </span></p><p class="c7"><span class="c5">format(s). the following privileges: READ access to global tables, READ, INSERT, UPDATE, DELETE, GRANT and REVOKE on his own </span></p><p class="c7"><span class="c4">3 MTBASE </span><span class="c5">instances of tenant-specific tables. In our example, this means that a new tenant 111 can read and modify data in Employees_111 and Roles_111. Next, a tenant can start asking around to get privileges on other tenants&rsquo; tables or also on global tables. The REVOKE statement, as in plain SQL, simply revokes privileges that were granted with GRANT. </span></p><p class="c9"><span class="c5">Based on the concepts described in the previous section, we imple- mented MTBase, an open-source MTSQL engine [1]. As shown in Figure 3, the basic building block of MTBase is an MTSQL-to- SQL translation middleware sitting between a traditional DBMS and the client. In fact, as it communicates to the DBMS (and to the client) by the means of pure SQL, MTBase works in conjunc- </span></p><p class="c7"><span class="c4">2.4 Query Language </span></p><p class="c0"><span class="c5">tion with any off-the-shelve DBMS. For performance reasons, the proxy maintains a cache of MT-specific meta data, which Just as in FlexScheme [11, 12], queries themselves are written </span></p><p class="c7"><span class="c5">is persisted in the DBMS along with the actual user data. Con- in plain SQL and have to be filtered according to D. Whereas in </span></p><p class="c7"><span class="c5">version functions are implemented as UDFs that might involve FlexScheme D always equals {C} (a tenant can only query her </span></p><p class="c7"><span class="c5">additional meta tables, both of which are also persisted in the own data), MTSQL allows cross-tenant query processing, which </span></p><p class="c7"><span class="c5">DBMS. MTBase implements the basic data layout, which means means that the data set can include other tenants than C and can </span></p><p class="c7"><span class="c5">that data ownership is implemented as an additional (meta) ttid in particular contain more than one element. As mentioned in the </span></p><p class="c7"><span class="c5">column in each tenant-specific table as illustrated in Figure 2). </span></p><p class="c9"><span class="c21">6</span><span class="c48">Remembering that an empty IN list refers all tenants, this is exactly what is used to </span><span class="c16">indicate a global constraint. Additionally, all constraints created as part of a CREATE TABLE statement are global as well. </span></p><p class="c9"><span class="c5">There are some dedicated meta tables: Tenant stores each te- nant&rsquo;s privileges and conversion information and Schema stores information about table and attribute comparability. Additional </span></p><p class="c7"><span class="c17">17 </span></p><p class="c29"><span class="c12">Conversion Functions </span></p><p class="c7"><span class="c5">Figure 3: MTBase architecture </span></p><p class="c9"><span class="c5">meta tables can (but do not have to) be used to implement conver- sion function pairs, as for example CurrencyTransform and PhoneTransform shown in Listings 4 to 7. </span></p><p class="c9"><span class="c5">While the rewrite module was implemented in Haskell and compiled with GHC [6], the connection handling and the meta data cache maintenance was written in Python (and run with the Python2 interpreter) [4]. Haskell is handy because we can make full use of pattern matching and additive data types to imple- ment the rewrite algorithm in a quick and easy-to-verify way, but any other functional language, like e.g. Scala [5], would also do the job. Likewise, there is nothing fundamental in using Python, any other framework that has a good-enough abstraction of SQL connections, e.g. JDBC [7], could be used. </span></p><p class="c9"><span class="c5">Upon opening a connection at the middleware, the client&rsquo;s ttid, C, is derived from the connection string and used throughout the entire lifetime of that connection. Whenever a client sends a MTSQL statement s, first if the current scope is complex, a SQL query q</span><span class="c10">s </span><span class="c5">is derived from this scope and evaluated at the DBMS in order to determine the relevant dataset D. After that, D is compared against privileges ofC in the Tenant table and ttids in D without the corresponding privilege are pruned, resulting in D . Next,C, D and s are input into the rewrite algorithm which produces a rewritten SQL statement s which is then sent to the DBMS before relaying the result back to the client. Note that in order to guarantee correctness in the presence of updates, q</span><span class="c1">s </span><span class="c13">and </span><span class="c5">s have to be executed within the same transaction and with a consistency level at least repeatable-read [13] (even if the client does not impose any transactional guarantees). If s is a DDL statement, the middleware also updates the MT-Specific meta information in the DBMS and the cache. </span></p><p class="c9"><span class="c5">The rest of this section explains the MTSQL-to-SQL rewrite algorithm in its canonical form and proves its correctness with respect to Section 2.4, while Section 4 shows how to optimize the rewritten queries such that they can be run on the DBMS with reasonable performance. </span></p><p class="c7"><span class="c4">3.1 Canonical Query Rewrite Algorithm </span><span class="c5">Our proposed canonical MTSQL-to-SQL rewrite algorithm works top-down, starting with the outer-most SQL query and recursively rewriting sub-queries as they come along. For each sub-query, the SQL clauses are rewritten one-by-one. The algorithm makes sure that for each sub-query the following invariant holds: the result of the sub-query is filtered according to D and presented in the format required by C. Note that this invariant also helps to formally prove the correctness of the rewrite algorithm as we will show in Section 3.2. </span></p><p class="c9"><span class="c5">The pseudo code of the general rewrite algorithm for rewriting a (sub-) query is shown in Algorithm 1. Note that FROM, GROUP BY, ORDER BY and HAVING clause can be rewritten without any </span></p><p class="c9"><span class="c5">additional context while SELECT and WHERE need the whole query as an input because they might need to check the FROM for additional information, for instance they must know to which original tables certain attributes belong. </span></p><p class="c7"><span class="c16">1: </span><span class="c5">Input: C: ttid, D: set of ttids, Q: MTSQL query </span><span class="c16">2: </span><span class="c5">Output: SQL query </span><span class="c16">3: </span><span class="c5">function R</span><span class="c26">EWRITE</span><span class="c5">Q</span><span class="c26">UERY</span><span class="c5">(C,D,Q) </span><span class="c16">4: </span><span class="c5">new-select &larr; rewriteSelect(C,D,Q) </span><span class="c16">5: </span><span class="c5">new-f rom &larr; rewriteFrom(C,D,Q.from()) </span><span class="c16">6: </span><span class="c5">new-where &larr; rewriteWhere(C,D,Q) </span><span class="c16">7: </span><span class="c5">new- roup-b &larr; rewriteGroupBy(C,D,Q.groupBy()) </span><span class="c16">8: </span><span class="c5">new-order-b &larr; rewriteOrderBy(C,D,Q.orderBy()) </span><span class="c16">9: </span><span class="c5">new-ha in &larr; rewriteHaving(C,D,Q.having()) </span><span class="c16">10: </span><span class="c5">return new Query (new-select, new-f rom, new-where, </span></p><p class="c7"><span class="c5">new- roup-b , new-order-b , new-ha in ) </span></p><p class="c7"><span class="c5">Algorithm 1: Canonical Query Rewrite Algorithm </span></p><p class="c9"><span class="c5">In the following, we will look at the rewrite functions for the different SQL clauses. Because of space constraints, we only pro- vide the high-level ideas and illustrate them with suitable minimal examples. However, we strongly encourage the interested reader to check-out the Haskell code [2] which in fact almost reads like a mathematical definition of the rewrite algorithm. </span></p><p class="c9"><span class="c5">SELECT The rewritten SELECT clause has to present every attribute a in C&rsquo;s format, which, if a is convertible, is achieved by two calls to the conversion function pair of a as can be seen in the examples of Listing 10 where - -&gt; simply denotes rewriting. If a is part of compound expression (as in line 6), it has to be converted before the functions (in that case AVG) are applied. Note that in order to make a potential super-query work correctly, we also rename the result of the conversion, either by the new name that it got anyway (as in line 6) or by the name that it had before (as in line 3). Rewriting a star expression (line 9) in the uppermost query also needs special attention, in order not to provide the client with confusing information, like ttids which should stay invisible. </span></p><p class="c7"><span class="c12">1 </span><span class="c35">-- Rewriting a simple select expression: </span><span class="c12">2 </span><span class="c6">SELECT </span><span class="c8">E_salary </span><span class="c6">FROM </span><span class="c8">Employees; </span><span class="c35">--&gt; </span><span class="c12">3 </span><span class="c6">SELECT </span><span class="c8">currencyFromUniversal(currencyToUniversal(E_salary, ttid) </span></p><p class="c7"><span class="c8">, C) </span><span class="c6">as </span><span class="c8">salary </span><span class="c6">FROM </span><span class="c8">Employees; </span><span class="c12">4 </span><span class="c35">-- Rewriting an aggregated select expression </span><span class="c12">5 </span><span class="c6">SELECT AVG</span><span class="c8">(E_salary) </span><span class="c6">as </span><span class="c8">avg_sal </span><span class="c6">FROM </span><span class="c8">Employees; </span><span class="c35">--&gt; </span><span class="c12">6 </span><span class="c6">SELECT AVG</span><span class="c8">(currencyFromUniversal(currencyToUniversal(E_salary, </span></p><p class="c7"><span class="c8">ttid), C)) </span><span class="c6">as </span><span class="c8">avg_sal </span><span class="c6">FROM </span><span class="c8">Employees; </span><span class="c12">7 </span><span class="c35">-- Rewriting star expression, hiding irrelevant info </span><span class="c12">8 </span><span class="c6">SELECT </span><span class="c8">* </span><span class="c6">FROM </span><span class="c8">Employees; </span><span class="c35">--&gt; </span><span class="c12">9 </span><span class="c6">SELECT </span><span class="c8">E_name, E_salary, E_age </span><span class="c6">FROM </span><span class="c8">Employees; </span></p><p class="c7"><span class="c5">Listing 10: Examples for Rewriting SELECT clause </span></p><p class="c9"><span class="c5">WHERE There are essentially three steps that the algorithm has to perform in order to create a correctly rewritten WHERE clause (as shown in Listing 11). First, conversion functions have to be </span></p><p class="c7"><span class="c17">18 </span></p><p class="c7"><span class="c16">Client A </span></p><p class="c29"><span class="c56">MT-PROXY DBMS </span><span class="c16">MT-SQL </span><span class="c21">METADATA </span></p><p class="c7"><span class="c16">Client B </span></p><p class="c7"><span class="c55">CLIENTS </span></p><p class="c29"><span class="c55">MTBASE </span><span class="c62">SQL </span></p><p class="c7"><span class="c21">CACHE </span></p><p class="c7"><span class="c16">Client C </span></p><p class="c29"><span class="c8">REWRITE MODULE </span></p><p class="c7"><span class="c12">Meta Tables </span></p><p class="c7"><span class="c12">User Tables </span></p><p class="c7"><span class="c5">warning added to each convertible attribute in each predicate in order make </span></p><p class="c7"><span class="c5">stating that grouping by a comparable attribute a is am- sure that comparisons are executed in the correct (client) format </span></p><p class="c7"><span class="c5">biguous because the way we rewrite a in the WHERE clause and (lines 2 to 6). This happens the same way as for a SELECT clause. </span></p><p class="c7"><span class="c5">rename it back to a, we could actually group by the original or by Notably, all constants are always in C&rsquo;s format because it is C </span></p><p class="c7"><span class="c5">the converted attribute a. However, the SQL standard clearly says who asks the query. Second, for every predicate involving two or </span></p><p class="c7"><span class="c5">that in such a case, the result should be grouped by the outer-more more tenant-specific attributes, additional predicates on </span></p><p class="c7"><span class="c5">expression, which is exactly what we need. ORDER-BY clauses ttid have to be added (line 9), unless if the attributes are part of </span></p><p class="c7"><span class="c5">need not be rewritten at all. the same table, which means they are owned by the same tenant anyway. Predicates that contain tenant-specific together </span></p><p class="c7"><span class="c5">SET SCOPE Simple scopes do not have to be rewritten at all. with other attributes cause the entire query to be rejected as was </span></p><p class="c7"><span class="c5">The FROM and WHERE clause of a complex scope are rewritten required in Section 2.4.2. Last, but not least, for every base table in </span></p><p class="c7"><span class="c5">the same way as in a sub-query. In order to make it a valid SQL the FROM clause, a so-called D-filter has to be added to the WHERE </span></p><p class="c7"><span class="c5">query, the rewrite algorithm adds a SELECT clause that projects clause (line 12). This filter makes sure that only the relevant data </span></p><p class="c7"><span class="c5">on the respective ttids as shown in Listing 12. (data that is owned by a tenant in D ) gets processed. </span></p><p class="c7"><span class="c12">1 </span><span class="c6">SET </span><span class="c22">SCOPE </span><span class="c8">= </span><span class="c18">&quot;FROM Employees WHERE E_salary &gt; 180K&quot;</span><span class="c8">; </span><span class="c35">--&gt; </span></p><p class="c7"><span class="c12">1 </span><span class="c35">-- Comparison with a constant: </span><span class="c12">2 </span><span class="c8">.. </span><span class="c6">FROM </span><span class="c8">Employees </span><span class="c6">WHERE </span><span class="c8">E_salary &gt; 50K </span><span class="c35">--&gt; </span></p><p class="c7"><span class="c12">2 </span><span class="c6">SELECT </span><span class="c8">ttid </span><span class="c6">FROM </span><span class="c8">Employees </span><span class="c6">WHERE </span><span class="c8">currencyFromUniversal( </span></p><p class="c7"><span class="c8">currencyToUniversal(E_salary,ttid),C) &gt; 180K; </span></p><p class="c7"><span class="c12">3 </span><span class="c8">.. </span><span class="c6">WHERE </span><span class="c8">currencyFromUniversal(currencyToUniversal(E_salary,ttid </span></p><p class="c7"><span class="c8">),C) &gt; 50K) .. </span></p><p class="c7"><span class="c5">Listing 12: Rewriting a complex SCOPE expression </span><span class="c12">4 </span><span class="c35">-- General comparison: </span><span class="c12">5 </span><span class="c8">.. </span><span class="c6">FROM </span><span class="c8">Employees E1, Employees E2 </span><span class="c6">WHERE </span><span class="c8">E1.E_salary &gt; E2. </span></p><p class="c7"><span class="c8">E_salary </span><span class="c35">--&gt; </span><span class="c12">6 </span><span class="c8">.. </span><span class="c6">WHERE </span><span class="c8">currencyFromUniversal(currencyToUniversal(E1.E_salary, </span></p><p class="c7"><span class="c8">E1.ttid),C) &gt; currencyFromUniversal(currencyToUniversal(E1. </span></p><p class="c7"><span class="c4">3.2 Algorithm Correctness </span></p><p class="c7"><span class="c8">E_salary,E1.ttid),C) .. </span><span class="c12">7 </span><span class="c35">-- Extend with predicate on ttid </span><span class="c12">8 </span><span class="c8">.. </span><span class="c6">FROM </span><span class="c8">Employees, Roles </span><span class="c6">WHERE </span><span class="c8">E_role_id = R_role_id </span><span class="c35">--&gt; </span></p><p class="c0"><span class="c5">P</span><span class="c26">ROOF</span><span class="c5">. We prove the correctness of the canonical rewrite algo- rithm with respect to Section 2.4 by induction over the composable </span><span class="c12">9 </span><span class="c8">.. </span><span class="c6">FROM </span><span class="c8">Employees, Roles </span><span class="c6">WHERE </span><span class="c8">E_role_id = R_role_id </span><span class="c6">AND </span></p><p class="c7"><span class="c8">Employees.ttid = Roles.ttid .. </span><span class="c12">10 </span><span class="c35">-- Adding D-filters for D&#39; = {3,7} </span></p><p class="c7"><span class="c5">structure of SQL queries and by showing that the desired invariant (the result of each sub-query is filtered according to D and pre- </span><span class="c12">11 </span><span class="c8">.. </span><span class="c6">FROM </span><span class="c8">Employees E, Roles R .. </span><span class="c35">--&gt; </span><span class="c12">12 </span><span class="c8">.. </span><span class="c6">WHERE </span><span class="c8">E.ttid </span><span class="c6">IN </span><span class="c8">(3,7) </span><span class="c6">AND </span><span class="c8">R.ttid </span><span class="c6">IN </span><span class="c8">(3,7) .. </span></p><p class="c7"><span class="c5">Listing 11: Examples for Rewriting WHERE clause </span></p><p class="c9"><span class="c5">sented in the format required by C) holds: First, as a base, we state that adding the D-filters in the WHERE clause and transforming the SELECT clause to client format for every base table in each </span></p><p class="c9"><span class="c5">FROM All tables referred by the FROM clause are either base tables or temporary tables derived from a sub-query. Rewriting the FROM clause simply means to call the rewrite algorithm on each referenced sub-query as shown in Algorithm 2. A FROM table might also contain a JOIN of two tables (sub-queries). In that case, the two sub-queries are rewritten and then the join predicate is rewritten in the exact same way like any WHERE. </span></p><p class="c9"><span class="c5">lowest-level sub-query ensures that the invariant holds. Next, as an induction step, we state that the way how we rewrite the FROM clause, as it was described earlier, preserves that property. The top-most SQL query is nothing but a composition of sub-queries (and base tables) for which the invariant holds. This means that the invariant holds for the entire query, which is hence guaranteed to deliver the correct result. </span><span class="c15">D </span></p><p class="c9"><span class="c5">Notably, this algorithm preserves the desired invariant for (sub-) queries: the result of each sub-query is in client format and filtered according to D , and, due to the rewrite of the SELECT and the WHERE clause of the current query, base tables, as well as joins, are also presented in client format and filtered by D. We con- clude that the result of the current query therefore also preserves the invariant. </span></p><p class="c7"><span class="c4">3.3 Rewriting DDL and DML Statements </span><span class="c5">Rewriting DDL and DML statements is very similar to rewriting queries, in fact, predicates are rewritten in exactly the same way. The remaining questions are how to rewrite tenant-specific refe- rential integrity constraints (using check constraints) and how to apply DML statements to a dataset D {C} (by executing the proper value transformations separately for each client). While </span></p><p class="c7"><span class="c16">1: </span><span class="c5">Input: C: ttid, D: set of ttids, </span><span class="c16">2: </span><span class="c5">FromClause: MTSQL FROM clause </span><span class="c16">3: </span><span class="c5">Output: SQL FROM clause </span></p><p class="c9"><span class="c5">the semantics and the intuition how to implement them should be clear, we refer again to the extended version of this paper [15] for further examples and explanations. </span></p><p class="c7"><span class="c16">4: </span><span class="c5">function R</span><span class="c26">EWRITE</span><span class="c5">F</span><span class="c26">ROM</span><span class="c5">(C,D, FromClause) </span><span class="c16">5: </span><span class="c5">res &larr; extractBaseTables </span><span class="c15">(</span><span class="c5">FromClause</span><span class="c15">) </span><span class="c16">6: </span><span class="c5">for all q &isin; extractSubQueries </span><span class="c15">(</span><span class="c5">FromClause</span><span class="c15">) </span><span class="c5">do </span><span class="c16">7: </span><span class="c5">res &larr; res &cup; { rewriteQuery </span><span class="c15">(</span><span class="c5">C, D,q</span><span class="c15">)</span><span class="c5">} </span><span class="c16">8: </span><span class="c5">for all </span><span class="c15">(</span><span class="c5">q</span><span class="c1">1</span><span class="c13">,q</span><span class="c1">2</span><span class="c13">,cond</span><span class="c32">) </span><span class="c13">&isin; extractJoins </span><span class="c32">(</span><span class="c13">FromClause</span><span class="c32">) </span><span class="c13">do </span><span class="c16">9: 10: 11: </span><span class="c5">q q cond </span><span class="c1">1 2 </span><span class="c5">&larr; &larr; rewriteQuery rewriteQuery &larr; rewriteWhere </span><span class="c15">(</span><span class="c5">C,D,q</span><span class="c15">(</span><span class="c5">C,D,q</span><span class="c10">2</span><span class="c15">) </span></p><p class="c7"><span class="c15">(</span><span class="c5">C,D,cond</span><span class="c15">) </span></p><p class="c7"><span class="c1">1</span><span class="c32">) </span></p><p class="c7"><span class="c16">12: </span><span class="c13">return </span><span class="c5">res </span><span class="c13">res </span></p><p class="c7"><span class="c5">&larr; res &cup; { createJoin </span><span class="c15">(</span><span class="c5">q </span><span class="c1">1</span><span class="c5">,q </span><span class="c1">2</span><span class="c5">,cond </span><span class="c15">))</span><span class="c5">} </span><span class="c4">4 OPTIMIZATIONS </span></p><p class="c0"><span class="c5">As we have seen, there is a canonical rewrite algorithm that cor- rectly rewrites MTSQL to SQL. However, we will show in Sec- tion 5 that the rewritten queries often execute very slowly on the underlying DBMS. The main reason for this is that the pure rewrit- ten queries call two conversion functions on every transformable attribute of every record that is processed, which is extremely expensive. Luckily, the execution costs can be reduced dramati- cally when applying the optimization passes that we describe in this section. As we assume the underlying DBMS to optimize Algorithm 2: Rewrite Algorithm for FROM clause </span></p><p class="c0"><span class="c5">query execution anyway, we focus on optimizations that a DBMS query optimizer cannot do (because it needs MT-specific context) GROUP-BY, ORDER-BY and HAVING HAVING and </span></p><p class="c7"><span class="c5">or does not do (because an optimization is not frequent enough GROUP-BY clauses are basically rewritten the same way like the </span></p><p class="c7"><span class="c5">outside the context of MTBase). We differentiate between seman- expressions in the SELECT clause. Some DBMSs might throw a </span></p><p class="c7"><span class="c5">tic optimizations, which are always applied because they never </span></p><p class="c7"><span class="c17">19 </span></p><p class="c7"><span class="c5">more make a query slower and cost-based optimizations which are only </span></p><p class="c7"><span class="c5">filtered and therefore the overall number of (expensive) con- applied if the predicted costs are smaller than in the original query. </span></p><p class="c7"><span class="c5">version function calls becomes smaller (or, in the worst case, stays </span></p><p class="c7"><span class="c12">1 </span><span class="c35">-- dropping D-filter if D is the empty scope: </span><span class="c12">2 </span><span class="c6">SELECT </span><span class="c8">E_age </span><span class="c6">FROM </span><span class="c8">Employees </span><span class="c6">WHERE </span><span class="c8">E_ttid </span><span class="c6">IN </span><span class="c8">(1,2); </span><span class="c35">--&gt; </span></p><p class="c7"><span class="c5">the same). Naturally, if we delay conversion, this also means that we have to propagate the necessary ttids to the outer-more queries </span><span class="c12">3 </span><span class="c6">SELECT </span><span class="c8">E_age </span><span class="c6">FROM </span><span class="c8">Employees; </span><span class="c12">4 </span><span class="c35">-- dropping ttid from join predicate if |D| = 1: </span><span class="c12">5 </span><span class="c6">SELECT </span><span class="c8">E_age, R_name </span><span class="c6">FROM </span><span class="c8">Employees, Roles </span><span class="c6">WHERE </span><span class="c8">E_role_id = </span></p><p class="c7"><span class="c5">and keep track of the current data format. </span></p><p class="c7"><span class="c5">Listing 14 shows a query that ranks employees according to the </span><span class="c8">R_role_id </span><span class="c6">AND </span><span class="c8">E_ttid = R_ttid </span><span class="c6">AND </span><span class="c8">E_ttid </span><span class="c6">IN </span><span class="c8">(2) </span><span class="c6">AND </span><span class="c8">R_ttid </span><span class="c6">IN </span><span class="c8">(2); </span><span class="c35">--&gt; </span></p><p class="c7"><span class="c5">fact how many salaries of other employees their own salary domi- </span><span class="c12">6 </span><span class="c6">SELECT </span><span class="c8">E_age, R_name </span><span class="c6">FROM </span><span class="c8">Employees, Roles </span><span class="c6">WHERE </span><span class="c8">E_role_id = </span></p><p class="c7"><span class="c8">R_role_id </span><span class="c6">AND </span><span class="c8">E_ttid </span><span class="c6">IN </span><span class="c8">(2) </span><span class="c6">AND </span><span class="c8">R_ttid </span><span class="c6">IN </span><span class="c8">(2); </span><span class="c12">7 </span><span class="c35">-- dropping conversion functions if D = {C}: </span></p><p class="c0"><span class="c5">nates. With client presentation push-up, salaries are compared in universal instead of client format, which is correct because of the </span><span class="c12">8 </span><span class="c6">SELECT </span><span class="c8">currencyFromUniversal(currencyToUniversal(E_salary, </span></p><p class="c7"><span class="c8">E_ttid),0) </span><span class="c6">AS </span><span class="c8">E_salary </span><span class="c6">FROM </span><span class="c8">Employees; </span><span class="c35">--&gt; </span><span class="c12">9 </span><span class="c6">SELECT </span><span class="c8">E_salary </span><span class="c6">FROM </span><span class="c8">Employees; </span></p><p class="c7"><span class="c5">equality-preserving property (c.f. Corollary 1) and saves half of the function calls in the sub-query. </span></p><p class="c7"><span class="c5">Listing 13: Examples for trivial semantic optimizations </span></p><p class="c7"><span class="c5">Conversion push-up, as shown in Listing 15, reduces the num- ber of function calls dramatically: First, as it only converts salaries </span><span class="c4">4.1 Trivial Semantic Optimizations </span><span class="c5">There are a couple of special cases for C and D that allow to save conversion function calls, join predicates and/or D-filters. First, if D includes all tenants, that means that we want to query all data and hence D-filters are no longer required as shown in line 3 of Listing13. Second, as shown in line 6, if |D| = 1, we know that all data is from the same tenant, which means that including ttid in the join predicate is no longer necessary. Last, if we know that a </span></p><p class="c9"><span class="c5">in the end, salaries of employees aged less than 45 do not have to be considered at all. Second, the WHERE clause converts the constant (100K) instead of the attribute (E_salary). As the outcome of conversion functions is immutable (c.f. Section 2.2.2) and C is also constant, the conversion functions have to be called only once per tenant and are then cached by the DBMS for the rest of the query execution, which becomes much faster as we will see in Section 5. </span></p><p class="c7"><span class="c5">client queries her own data, i.e. D = {C} corresponds to the default scope, we know that even convertible attributes are already in the </span></p><p class="c0"><span class="c12">1 </span><span class="c35">-- before optimization </span><span class="c12">2 </span><span class="c6">SELECT AVG</span><span class="c8">(X.sal) </span><span class="c6">FROM </span><span class="c8">( </span><span class="c12">3 </span><span class="c6">SELECT </span><span class="c8">currencyFromUniversal(currencyToUniversal(E_salary, </span><span class="c5">correct format and can hence remove the conversion function calls </span></p><p class="c0"><span class="c8">E_ttid), C) </span><span class="c6">as </span><span class="c8">sal </span><span class="c12">4 </span><span class="c6">FROM </span><span class="c8">Employees </span><span class="c6">WHERE </span><span class="c8">E_age &gt;= 45 </span><span class="c6">AND </span><span class="c5">(line 9). </span></p><p class="c7"><span class="c12">5 </span><span class="c8">currencyFromUniversal(currencyToUniversal(E_salary, E_ttid), C </span></p><p class="c7"><span class="c8">) &gt; 100K) </span><span class="c6">as </span><span class="c8">X; </span><span class="c4">4.2 Other Semantic Optimizations </span></p><p class="c7"><span class="c12">6 </span><span class="c35">-- after optimization </span><span class="c12">7 </span><span class="c6">SELECT AVG</span><span class="c8">(currencyFromUniversal(currencyToUniversal(X.sal, sal_ttid),C)) </span><span class="c6">FROM </span><span class="c8">( </span></p><p class="c7"><span class="c8">X. </span></p><p class="c7"><span class="c5">There are a couple of other semantic optimizations that can be applied to rewritten queries. While client presentation push-up </span></p><p class="c0"><span class="c12">8 </span><span class="c6">SELECT </span><span class="c8">E_salary </span><span class="c6">as </span><span class="c8">sal, E_ttid </span><span class="c6">as </span><span class="c8">sal_ttid </span><span class="c12">9 </span><span class="c6">FROM </span><span class="c8">Employees </span><span class="c6">WHERE </span><span class="c8">E_age &gt;= 45 </span><span class="c6">AND </span><span class="c12">10 </span><span class="c8">E_salary &gt; currencyFromUniversal(currencyToUniversal(100K, </span><span class="c5">and conversion push-up minimize the number of conversions by </span></p><p class="c7"><span class="c8">E_ttid), C) </span><span class="c6">as </span><span class="c8">X); </span><span class="c5">delaying conversion to the latest possible moment, aggregation distribution takes into account specific properties of conversion </span></p><p class="c7"><span class="c5">Listing 15: Example for conversion push-up </span></p><p class="c7"><span class="c5">functions (as mentioned in Section 2.2.2). If conversion functions </span></p><p class="c7"><span class="c5">4.2.2 Aggregation Distribution. Many analytical queries are UDFs written in SQL it is also possible to inline them. This </span></p><p class="c7"><span class="c5">contain aggregation functions, some of which aggregate on con- typically gives queries an additional speed up. </span></p><p class="c7"><span class="c5">vertible attributes. The idea of aggregation distribution is to aggre- </span></p><p class="c7"><span class="c12">1 </span><span class="c35">-- before optimization </span><span class="c12">2 </span><span class="c6">SELECT </span><span class="c8">Dom.name1, Dom.sal1 </span><span class="c6">as </span><span class="c8">sal, </span><span class="c6">COUNT</span><span class="c8">(*) </span><span class="c6">as </span><span class="c8">cnt </span><span class="c6">FROM </span><span class="c8">( </span></p><p class="c0"><span class="c5">gate in two steps: First, aggregate per tenant in that specific tenant format (requires no conversion) and second, convert intermediary </span><span class="c12">3 </span><span class="c6">SELECT </span><span class="c8">E1.name </span><span class="c6">as </span><span class="c8">name1, currencyFromUniversal( </span></p><p class="c7"><span class="c8">currencyToUniversal(E1.E_salary, E1.E_ttid), C) </span><span class="c6">as </span><span class="c8">sal1 </span><span class="c12">4 </span><span class="c6">FROM </span><span class="c8">Employees E1, Employees E2 </span></p><p class="c0"><span class="c5">results to universal (one conversion per tenant), aggregate those and convert the final result to client format (one additional conver- </span><span class="c12">5 </span><span class="c6">WHERE </span><span class="c8">currencyFromUniversal(currencyToUniversal(E1.E_salary, </span></p><p class="c7"><span class="c8">E1.E_ttid), C) &gt; </span><span class="c12">6 </span><span class="c8">currencyFromUniversal(currencyToUniversal(E2.E_salary, </span><span class="c5">sion). This simple idea reduces the number of conversion function </span></p><p class="c7"><span class="c8">E2. </span></p><p class="c7"><span class="c5">calls for N records and T different data owners of these records </span><span class="c8">E_ttid), C) </span><span class="c12">7 </span><span class="c8">) </span><span class="c6">as </span><span class="c8">Dom </span><span class="c6">GROUP BY </span><span class="c8">Dom.name1, sal, cnt </span><span class="c6">ORDER BY </span><span class="c8">cnt; </span></p><p class="c7"><span class="c5">from </span><span class="c15">(</span><span class="c5">2N</span><span class="c15">) </span><span class="c5">to </span><span class="c15">(</span><span class="c5">T + 1</span><span class="c15">)</span><span class="c5">. This is significant because T is typically </span><span class="c12">8 </span><span class="c35">-- after optmimization </span><span class="c12">9 </span><span class="c6">SELECT </span><span class="c8">Dom.name1, currencyFromUniversal(Dom.sal1, </span><span class="c6">COUNT</span><span class="c8">(*) </span><span class="c6">as </span><span class="c8">cnt </span><span class="c6">FROM </span><span class="c8">( </span></p><p class="c7"><span class="c8">C) </span><span class="c6">as </span><span class="c8">sal, </span></p><p class="c7"><span class="c5">much smaller than N (and cannot be greater). </span></p><p class="c7"><span class="c5">Compared to pure conversion push-up, which works for any </span><span class="c12">10 </span><span class="c6">SELECT </span><span class="c8">E1.name </span><span class="c6">as </span><span class="c8">name1, currencyToUniversal(E1.E_salary, E_ttid) </span><span class="c6">as </span><span class="c8">sal1 </span><span class="c12">11 </span><span class="c6">FROM </span><span class="c8">Employees E1, Employees E2 </span></p><p class="c7"><span class="c8">E1. </span></p><p class="c0"><span class="c5">conversion function pair, the applicability of aggregation distri- bution depends on further algebraic properties of these functions. </span><span class="c12">12 </span><span class="c6">WHERE </span><span class="c8">currencyToUniversal(E1.E_salary, E1.E_ttid) &gt; </span></p><p class="c7"><span class="c8">currencyToUniversal(E2.E_salary, E2.E_ttid) </span><span class="c12">13 </span><span class="c8">) </span><span class="c6">as </span><span class="c8">Dom </span><span class="c6">GROUP BY </span><span class="c8">Dom.name1, sal, cnt </span><span class="c6">ORDER BY </span><span class="c8">cnt; </span></p><p class="c7"><span class="c5">Gray et al. [24] categorize numerical aggregation functions into three categories with regard to their ability to distribute: distribu- </span></p><p class="c7"><span class="c5">Listing 14: Example for client presentation push-up </span></p><p class="c0"><span class="c5">tive functions, like COUNT, SUM, MIN and MAX distribute with functions F (for partial) and G (for total aggregation). For COUNT 4.2.1 Client Presentation and Conversion Push-Up. As </span></p><p class="c7"><span class="c5">for instance, F is COUNT and G is SUM as the total count is the conversion function pairs are equality-preserving, it is possible </span></p><p class="c7"><span class="c5">sum of all partial counts. There are also algebraic aggregation in some cases to defer conversions to later, for example to the </span></p><p class="c7"><span class="c5">functions, e.g. AVG, where the partial results are not scalar values, outermost query in the case of nested queries. While client presen- </span></p><p class="c7"><span class="c5">but tuples. In the case of AVG, this would be the pairs of a partial tation push-up converts everything to universal format and defers </span></p><p class="c7"><span class="c5">sums and partial counts because the total average can be computed conversion to client format to the outermost SELECT clause, con- </span></p><p class="c7"><span class="c5">from the sum of all sums, divided by the sum of all counts. Finally, version push-up pushes this idea even more by also delaying the </span></p><p class="c7"><span class="c5">holistic aggregation functions cannot be distributed at all. conversion to universal format as much as possible. Both optimiza- </span></p><p class="c7"><span class="c5">We would like to extend the notion of Gray et al. [24] and tions are beneficial if the delaying of conversions allows the query </span></p><p class="c7"><span class="c5">define the distributability of an aggregation function a with respect execution engine to evaluate other (less expensive) predicates first. </span></p><p class="c7"><span class="c5">to a conversion function pair </span><span class="c15">(</span><span class="c5">f rom,to</span><span class="c15">)</span><span class="c5">. Table 2 shows some This means that, once the data has to be converted, it is already </span></p><p class="c7"><span class="c5">examples for different aggregation and conversion functions. First </span></p><p class="c7"><span class="c17">20 </span></p><p class="c7"><span class="c10">to</span><span class="c59">(</span><span class="c10">x</span><span class="c59">) </span><span class="c10">= c &middot; x to</span><span class="c59">(</span><span class="c10">x</span><span class="c59">) </span><span class="c10">= a &middot; x + b </span><span class="c20">to = order- </span><span class="c16">preserving </span></p><p class="c0"><span class="c16">to = equality- preserving COUNT / / / / MIN / / / X MAX / / / X SUM / / X X AVG / / X X Holistic X X X X </span><span class="c5">Table 2: Distributability of different aggregation functions over different categories of conversion functions </span></p><p class="c9"><span class="c5">of all, we want to state that, as all conversion functions have scalar values as input and output, they are always fully-COUNT- preserving, which means that COUNT can be distributed over all sorts of conversion functions. Next, we observe that all order- preserving functions preserve the minimum and the maximum of a given set of numbers, which is why MIN and MAX distribute over the first three categories of conversion functions displayed in Table 2. We further notice that if to (and consequently also f rom) is a multiplication with a constant (first column of Table 2), to is fully- MIN-, fully-MAX- and fully-SUM-preserving, which is why these aggregation functions distribute. As SUM and COUNT distribute, AVG, an algebraic function, distributes as well. </span></p><p class="c9"><span class="c5">Finally looking at the second column of Table 2, we see that even linear functions are SUM- and AVG-preserving. To see why, we can think about computing the average over all tenants as a weighted average of partial (per-tenant) averages for AVG and mul- tiply these partial averages with the partial counts to reconstruct the total sum [15, Appendix B]. </span></p><p class="c7"><span class="c12">1 </span><span class="c35">-- before optimization </span><span class="c12">2 </span><span class="c6">SELECT SUM</span><span class="c8">(currencyFromUniversal(currencyToUniversal(E_salary, </span></p><p class="c7"><span class="c8">E_ttid), C)) </span><span class="c6">as </span><span class="c8">sum_sal </span><span class="c6">FROM </span><span class="c8">Employees </span><span class="c12">3 </span><span class="c35">-- after optimization </span><span class="c12">4 </span><span class="c6">SELECT </span><span class="c8">currencyFromUniversal(</span><span class="c6">SUM</span><span class="c8">(t.E_partial_salary), C) </span><span class="c6">as </span></p><p class="c7"><span class="c8">sum_sal </span><span class="c6">FROM </span><span class="c8">(</span><span class="c6">SELECT </span><span class="c8">currencyToUniversal(</span><span class="c6">SUM</span><span class="c8">(E_salary), E_ttid) </span><span class="c6">as </span><span class="c8">E_partial_salary </span><span class="c6">FROM </span><span class="c8">Employees </span><span class="c6">GROUP BY </span><span class="c8">E_ttid) </span></p><p class="c7"><span class="c6">as </span><span class="c8">t; </span></p><p class="c0"><span class="c5">Listing 16: Example for conversion function distribution We conclude this subsection by observing that the conversion function pair for phone format (c.f. Listings 4 and 5) is not even order-preserving and does therefore not distribute while the pair for currency format (c.f. Listings 6 and 7) distributes over all standard SQL aggregation functions. An example of how this can be used is shown in Listing 16. </span></p><p class="c7"><span class="c12">1 </span><span class="c35">-- before optimization </span><span class="c12">2 </span><span class="c6">SELECT </span><span class="c8">currencyFromUniversal(currencyToUniversal(E_salary, </span></p><p class="c7"><span class="c8">E_ttid), C)) </span><span class="c6">as </span><span class="c8">E_salary </span><span class="c6">FROM </span><span class="c8">Employees </span><span class="c12">3 </span><span class="c35">-- after optimization </span><span class="c12">4 </span><span class="c6">SELECT </span><span class="c8">(C1.CT_from_universal * C2.CT_to_universal * E_salary) </span><span class="c6">as </span></p><p class="c7"><span class="c8">E_salary </span><span class="c12">5 </span><span class="c6">FROM </span><span class="c8">Employees, Tenant T1, Tenant T2, CurrencyTransform1, </span></p><p class="c7"><span class="c8">CurrencyTransform2 </span><span class="c12">6 </span><span class="c6">WHERE </span><span class="c8">T1.T_tenant_key = C </span><span class="c6">AND </span><span class="c8">T1.T_currency_key = </span></p><p class="c29"><span class="c8">CurrencyTransform1.CT_currency_key </span><span class="c6">AND </span><span class="c12">7 </span><span class="c8">T2.T_tenant_key = E_ttid </span><span class="c6">AND </span><span class="c8">T2.T_currency_key = </span></p><p class="c7"><span class="c8">CurrencyTransform2.CT_currency_key </span></p><p class="c7"><span class="c5">Listing 17: Example for function inlining </span></p><p class="c9"><span class="c5">4.2.3 Function Inlining. As explained in Section 2.2.2, there are several ways how to define conversion functions. However, if they are defined as a SQL statement (potentially including lookups into meta tables), they can be directly inlined into the rewritten query in order to save calls to UDFs. Function inlining typical- ly also enables the query optimizer of the underlying DBMS to optimize much more aggressively. In WHERE clauses, conversion functions could simply be inlined as sub-queries, which, however often results in sub-optimal performance as calling a sub-query on each conversion is not much cheaper than calling the correspond- ing UDF. For SELECT clauses, the SQL standard does anyway not allow to inline as a sub-query as this can result in attributes </span></p><p class="c9"><span class="c5">not being contained neither in an aggregate function nor in the GROUP BY clause, which is why most commercial DBMS reject such queries (while PostgreSQL, for instance executes them any- way). This is why the proper way to inline functions is by using a join as shown in Listing 17. Our results in Section 5 suggest that function inlining, though producing complex-looking SQL queries, results in very good query execution performance. </span></p><p class="c9"><span class="c5">It is important to mention that function inlining should only happen after the other semantic optimization passes because these other passes are able to reduce the number of required UDF calls, while function inlining can only make a UDF call faster. Further- more, it is important to understand that, while some clever query optimizers do indeed inline UDF calls already, none of the query optimizers that we looked at seems to perform client presentation and conversion push-up, let alone aggregation distribution, de- spite the fact that the foundation for these transformations [24, 28] have been established already more than 20 years ago. </span></p><p class="c7"><span class="c4">5 EXPERIMENTS AND RESULTS </span><span class="c5">This section presents the evaluation of MTBase using an extension from the well-known TPC-H benchmark [43], called MT-H [15]. We first evaluated the benefits of different optimization steps from Section 4 and found that the combination of all of these steps brings the biggest benefit. Second, we analyzed how MTBase scales with an increasing number of tenants. With all optimizations applied and for a dataset of 100 GB on a single machine, MTBase scales up to thousands of tenants with very little overhead. We also validated result correctness as explained in Section 5.1 and can report only positive results. </span></p><p class="c7"><span class="c4">5.1 MT-H Benchmark </span><span class="c5">MT-H uses the same database schema as TPC-H, but considers the Customer, Order, and Lineitem tables tenant-specific and the remaining tables global. Attributes C_acctbal, O_totalprice, and L_extendedprice are considered con- vertible with respect to the conversion functions of Listings 6 and 7 and C_phone with respect to Listings 4 and 5. While C_custkey, O_orderkey, O_custkey,L_orderkey are tenant-specific, all remaining attributes are comparable. A de- tailed description on this benchmark, including the validation of query results, can be found in our technical report [15]. </span></p><p class="c7"><span class="c4">5.2 Setup </span><span class="c5">In our experiments, we used the following two setups: The first set- up is a PostgreSQL 9.6 Beta installation, running on Debian Linux 4.1.12 on a 4x16 Core AMD Opteron 6174 processor with 256 GB of main memory. The second installation runs a commercial database (which we will call System C) on a commercial operating system and on the same processor with 512 GB of main memory. Although both machines have enough secondary storage capacity available, we decided to configure both database management systems to use in-memory backed files in order to achieve the best performance possible. Moreover, we configured the systems to use all available threads, which enabled intra-query parallelism. </span></p><p class="c7"><span class="c4">5.3 Workload and Methodology </span><span class="c5">As the MT-H benchmark has a lot of parameters and in order to make things more concrete, we worked with the following two scenarios: Scenario 1 handles the data of a business alliance of a couple of small to mid-sized enterprises, which means there are 10 tenants with sf = 1 and each of them owns more or less </span></p><p class="c7"><span class="c17">21 </span></p><p class="c29"><span class="c8">Level Q01 Q02 Q03 Q04 Q05 Q06 Q07 Q08 Q09 Q10 Q11 Q12 Q13 Q14 Q15 Q16 Q17 Q18 Q19 Q20 Q21 Q22 tpch-0.1G 2.6 0.11 0.27 0.35 0.15 0.29 0.18 0.14 0.59 0.36 0.081 0.37 0.26 0.27 0.77 0.12 0.081 0.89 0.12 0.13 0.57 0.081 canonical 84 1.0 0.55 0.65 0.32 1.0 0.29 0.36 4.9 0.91 0.37 0.55 0.63 0.98 3.1 1.2 0.49 1.7 0.3 2.8 0.66 2.0 o1 2.7 1.0 0.43 0.61 0.22 0.43 0.23 0.56 3.8 0.76 0.37 0.55 0.92 0.56 0.91 1.2 0.48 1.6 0.3 2.8 0.66 0.085 o2 2.7 1.0 0.42 0.61 0.22 0.43 0.22 0.57 3.9 0.76 0.38 0.55 0.89 0.56 0.96 1.2 0.5 1.7 0.3 2.8 0.67 0.085 o3 2.7 1.0 0.43 0.61 0.22 0.43 0.23 0.56 3.9 0.76 0.37 0.55 0.92 0.56 0.91 1.2 0.48 1.6 0.3 2.8 0.66 0.085 o4 2.7 1.0 0.43 0.62 0.22 0.43 0.23 0.61 4.1 0.78 0.39 0.56 0.9 0.57 1.0 1.2 0.51 1.7 0.31 3.1 0.67 0.085 inl-only 2.7 1.0 0.42 0.65 0.22 0.43 0.22 0.57 3.8 0.76 0.37 0.55 0.92 0.56 0.92 1.2 0.48 1.6 0.3 2.8 0.66 0.085 </span><span class="c5">Table 3: Response times [sec] of 22 TPC-H queries for MTBase-on-PostgreSQL with, sf = 1, T = 10, &rho; = uniform, C = 1, </span><span class="c15">D = {1}</span><span class="c5">, for different levels of optimizations, versus TPC-H with sf = 0.1 </span></p><p class="c29"><span class="c8">Level Q01 Q02 Q03 Q04 Q05 Q06 Q07 Q08 Q09 Q10 Q11 Q12 Q13 Q14 Q15 Q16 Q17 Q18 Q19 Q20 Q21 Q22 tpch-0.1G 2.6 0.11 0.27 0.35 0.15 0.29 0.18 0.14 0.59 0.36 0.081 0.37 0.26 0.27 0.77 0.12 0.081 0.89 0.12 0.13 0.57 0.081 canonical 87 1.0 0.5 0.6 0.28 1.0 0.26 0.37 4.9 0.89 0.37 0.56 0.65 1.0 3.2 1.2 0.49 1.6 0.31 2.8 0.66 2.0 o1 87 1.0 0.5 0.69 0.33 1.0 0.27 0.38 5.2 0.9 0.39 0.56 0.92 1.0 3.1 1.2 0.51 1.6 0.32 3.1 0.68 2.0 o2 87 1.0 0.5 0.61 0.28 1.0 0.27 0.38 5.2 0.9 0.39 0.57 0.91 1.0 3.1 1.2 0.51 1.6 0.32 3.1 0.67 1.3 o3 32 1.0 0.45 0.63 0.28 0.44 0.24 0.37 4.3 0.83 0.38 0.56 0.91 1.1 1.9 1.3 0.51 1.6 0.32 3.1 0.67 1.3 o4 14 1.0 0.48 0.62 0.22 0.44 0.23 0.57 3.9 0.93 0.38 0.56 0.89 0.73 1.3 1.2 0.49 1.6 0.3 2.8 0.66 0.27 inl-only 45 1.0 0.47 0.61 0.27 0.64 0.24 0.58 4.2 0.94 0.37 0.55 0.91 0.73 2.2 1.2 0.48 1.7 0.3 2.8 0.66 0.27 </span><span class="c5">Table 4: Response times [sec] of 22 TPC-H queries for MTBase-on-PostgreSQL with, sf = 1, T = 10, &rho; = uniform, C = 1, </span><span class="c15">D = {2}</span><span class="c5">, for different levels of optimizations, versus TPC-H with sf = 0.1 </span></p><p class="c29"><span class="c8">Level Q01 Q02 Q03 Q04 Q05 Q06 Q07 Q08 Q09 Q10 Q11 Q12 Q13 Q14 Q15 Q16 Q17 Q18 Q19 Q20 Q21 Q22 tpch-1G 26 1.2 4.5 1.4 1.5 2.9 3.7 1.3 9.5 2.2 0.38 3.9 8.4 2.7 5.9 1.2 0.54 10 0.3 2.4 4.8 0.47 canonical 870 1.1 6.5 1.5 3.4 8.7 3.7 1.7 19 11 0.36 4.1 4.9 7.3 28 1.2 0.57 12 0.32 2.6 5.8 20 o1 860 1.1 6.5 1.5 3.4 8.7 3.7 1.7 19 11 0.36 4.1 4.9 7.3 28 1.2 0.62 12 0.33 2.7 5.9 20 o2 870 1.1 6.5 1.5 3.4 8.6 3.7 1.7 19 11 0.35 4.1 4.9 7.2 28 1.2 0.57 12 0.32 2.6 5.8 13 o3 310 1.1 5.5 1.5 3.1 3.1 3.4 1.6 11 10 0.36 4.1 4.9 7.3 12 1.2 0.55 12 0.32 2.6 5.9 13 o4 130 1.1 3.7 1.5 1.7 3.1 3.4 1.4 11 4.6 0.38 4.1 4.9 4.4 9.1 1.2 0.59 12 0.32 2.6 5.7 2.2 inl-only 450 1.1 4 1.6 1.8 5.1 3.5 1.4 14 4.9 0.39 4.1 4.8 4.4 19 1.2 0.55 12 0.32 2.6 5.8 2.3 </span><span class="c5">Table 5: Response times [sec] of 22 TPC-H queries for MTBase-on-PostgreSQL with sf = 1,T = 10, &rho; = uniform, C = 1, </span><span class="c15">D = {1, 2, ...10}</span><span class="c5">, for different levels of optimizations, versus TPC-H with sf = 1 </span></p><p class="c9"><span class="c5">the same amount of data (&rho; =uniform). Scenario 2 simulates the HDC use case [27] and hence needs to be is a huge database (sf = 100) of medical records coming from thousands of tenants, like hospitals and private practices. Some of these institutions have vast amounts of data while others only handle a couple of patients (&rho;=zipf). A research institution wants to query the entire database (D={1,2,...,T}) in order to gather new insights for the development of a new treatment. We looked at this scenario for different numbers of T. </span></p><p class="c9"><span class="c5">In order to evaluate the overhead of cross-tenant query process- ing in MTBase compared to single-tenant query processing, we also measured the standard TPC-H queries with different scaling factors. When D was set to all tenants, we compared to TPC-H with the same scaling factor as MT-H. For the cases where D had only one tenant (out of ten), we compared with TPC-H with a scaling factor ten times smaller. </span></p><p class="c9"><span class="c5">Every query run was repeated three times in order to ensure stable results. We noticed that three runs are needed for the re- sponse times to converge (within 2%). Thus we always report the last measured response time for each query with two significant digits. </span></p><p class="c9"><span class="c5">All experiments were executed with both setups (PostgreSQL and System C). Whereas the major findings were the same on both systems, PostgreSQL optimizes conversion functions (UDFs) much better by caching their results. System C, on the other hand does not allow UDFs to be defined as deterministic and hence cannot cache conversion results. This eliminates the effect of con- version push-up when applied to comparison predicates where we convert the constant instead of the attribute (c.f. Listing 15). This being said, the rest of this section only reports results on Post- greSQL while we encourage the interested reader to also consult our additional results [15] to confirm that the main conclusions drawn from the PostgreSQL experiments generalize. </span></p><p class="c7"><span class="c24">opt level optimization passes canonical none o1 trivial optimizations o2 </span><span class="c81">o1 + client presentation push-up </span></p><p class="c7"><span class="c24">+ conversion push-up o3 o2 + conversion function distribution o4 o3 + conversion function inlining inl-only o1 + conversion function inlining </span><span class="c5">Table 6: Different optimization levels for evaluation </span></p><p class="c7"><span class="c4">5.4 Benefit of Optimizations </span><span class="c5">In order to test the benefit of the different combinations of opti- mizations applied, we tested Scenario 1 with different optimiza- tion levels as shown in Table 6. From o1 to o4 we added optimiza- tions incrementally, while the last optimization level (inl-only) only applied trivial optimizations and function inlining in order to test whether the other optimizations are useful at all. </span></p><p class="c9"><span class="c5">Table 3 shows the MT-H queries for different optimization lev- els and Scenario 1 (sf = 1,T = 10) where client 1 queries her own data. As we can see, in that case, applying trivial optimizations in o1 is enough because these already eliminate all conversion functions and joins and only the D-filters remain. Executing these filters seems to be very inexpensive because most response times of the optimized queries are close to the baseline, TPC-H with sf = 0.1. Queries 2, 11 and 16 however, take roughly ten times longer than the baseline. This is not surprising when taken into account that these queries only operate on shared tables which have ten times more data than in TPC-H. The same effect can be observed in Q09 where a significant part of the joined tables are shared. </span></p><p class="c7"><span class="c5">Table 4 shows similar results, but for D = 2, which means that now conversion functions can no longer be optimized away. </span></p><p class="c7"><span class="c17">22 </span></p><p class="c7"><span class="c11">TPC-H TPC-H MT-H o4 MT-H inl-only </span></p><p class="c7"><span class="c11">MT-H o4 MT-H inl-only </span></p><p class="c7"><span class="c24">(a) MT-H Query 1 </span></p><p class="c7"><span class="c24">(b) MT-H Query 6 </span></p><p class="c7"><span class="c11">TPC-H MT-H o4 MT-H inl-only </span><span class="c11">2.3 </span></p><p class="c7"><span class="c11">1.15 </span></p><p class="c7"><span class="c11">4.5 </span></p><p class="c7"><span class="c11">1.8 </span></p><p class="c7"><span class="c11">1.10 </span></p><p class="c7"><span class="c11">3.5 1.05 </span></p><p class="c7"><span class="c11">2.5 </span><span class="c11">1.3 </span></p><p class="c7"><span class="c11">1.00 </span></p><p class="c7"><span class="c11">1.5 </span><span class="c11">0.8 </span></p><p class="c7"><span class="c11">0.95 </span></p><p class="c7"><span class="c11">0.5 </span><span class="c11">1 10 100 1 000 10 000 100 000 </span></p><p class="c7"><span class="c11">1 10 100 1 000 10 000 100 000 </span></p><p class="c7"><span class="c11">1 10 100 1 000 10 000 100 000 </span></p><p class="c7"><span class="c24">(c) MT-H Query 22 </span></p><p class="c29"><span class="c5">Figure 4: Response times (relative to TPC-H) of o4 and inlining-only optimization levels for selected MT-H queries, sf = 100, T scaling from 1 to 100,000 on a log-scale, MTBase-on-PostgreSQL </span></p><p class="c9"><span class="c5">While most of the queries show a similar behaviour than in the previous experiment, for the ones that involve a lot of conversion functions (i.e. queries 1, 6 and 22), we see how the performance becomes better with each optimization pass added. We also notice that while function inlining is very beneficial in general, it is even more so when combined with the other optimizations. </span></p><p class="c9"><span class="c5">Finally, Table 5 shows the results where we query all data, i.e. D = {1, 2, ..., 10}. This experiment involves even more conversion functions from all the different tenant formats into universal. In particular, when looking again at queries 1, 6 and 22, we observe the great benefit of conversion function distribution (added with optimization level o3), which, in turn, only works as great in conjunction with client and conversion function push-up because aggregation typically happens in the outermost query while con- version happens in the sub-queries. Overall, o4, which contains all optimization passes that MTBase offers, is the clear winner. </span></p><p class="c7"><span class="c4">5.5 Cross-Tenant Query Processing at Large </span><span class="c5">In our final experiment, we evaluated the cost of cross-tenant query processing up to thousands of tenants. More concretely, we measured the response time of conversion-intensive MT-H queries (queries 1, 6 and 22) for a varying number of tenants between 1 and 100,000, for a large dataset where sf = 100 and for the best optimization level (o4) as well as for inlining-only. The obtained results were then compared to plain TPC-H with sf = 100, as shown in Figure 4. First of all, we notice that the cost overhead compared to single-tenant query-processing (TPC-H) stays below a factor of 2 and in general increases very moderately with the number of tenants. An interesting artifact can be observed for query 22 where MT-H for one tenant executes faster than plain TPC-H. The reason for this is a sub-optimal optimization decision in PostgreSQL: one of the most expensive parts of query 22, namely to find customers with a specific country code, is executed with a parallel scan in MT-H while no parallelism is used in the case of TPC-H. </span></p><p class="c7"><span class="c4">6 RELATED WORK </span><span class="c5">MTBase builds heavily on and extends a lot of related work. This section gives a brief summary of the most prominent lines of work that influenced our design. </span></p><p class="c9"><span class="c5">Data Integration Data integration (DI) is generally about find- ing schema and data mappings between the original schemas of different data sources and a target schema specified by the client application [23, 25, 41]. As such, DI techniques are applicable to the entire spectrum of multi-tenant databases because even if tenants use different schemas or databases, these techniques can identify correlations and hence extract useful information. Our work embraces and builds on top of the latest DI work, solving </span></p><p class="c0"><span class="c11">r</span><span class="c19">) ) ) </span></p><p class="c7"><span class="c19">HHH---e e e </span></p><p class="c7"><span class="c19">CCCmmmiPiPiPtttTTTe e e o o o ssstttnnne e e ooovvvpppiiisssttteeeaaa</span><span class="c11">rr</span><span class="c19">llleeerrr</span><span class="c11">(((</span><span class="c11">number of tenants </span></p><p class="c7"><span class="c11">number of tenants </span></p><p class="c7"><span class="c11">number of tenants </span></p><p class="c9"><span class="c5">the DI problem very efficiently for a specific case (SS and ST). More concretely, we automatically determine join predicates from schema meta data and optimize conversion functions similar to those used in DI by thoroughly analyzing and exploiting their algebraic properties. In addition, instead of translating data into a specific client format (and update periodically), we convert it to any required client format efficiently and just-in-time. </span></p><p class="c9"><span class="c5">Database Federation: DI is often combined with database federa- tion [26, 31], which means that there exist small program modules (called integrators, mediators or simply wrappers) to map data from different sources (possibly not all of them SQL databases) into one common format. While data federation generalizes well across the entire spectrum of multi-tenant databases, maintaining such wrapper architectures is expensive, both in terms of code maintenance and update processing. Conversely, MTSQL enables cross-tenant query processing in a more efficient and flexible way in the context of SS and ST databases. </span></p><p class="c9"><span class="c5">Data Warehousing: Another approach how data integration can happen is during extract-transform-load (ETL) operations from different (OLTP) databases into a data warehouse [29]. Data warehouses have the well-known drawbacks that there are costly to maintain and that the data is possibly outdated [10, 14, 37]. Meanwhile, MTBase was specifically designed to work well in the context of integrated OLTP/OLAP systems, also known as hybrid transaction-analytical processing (HTAP) systems, and could therefore be advocated as in-situ or just-in-time data inte- gration. Another interesting approach to just-in-time, respectively on-demand data integration, are lenses [45] which allow to speed up ETL processes by lowering the result accuracy to the specific level required by the application. </span></p><p class="c7"><span class="c5">Shared-resources (SR) systems: In related work, this approach is also often called database virtualization or database as a ser- vice (DaaS) when it is used in the cloud context. Important lines of work in this domain include (but are not limited to) SqlVM/Azure SQL DB [20, 36], RelationalCloud [35], SAP-HANA [42], Snowflake [18] and Oracle&rsquo;s multitenant container database (CDB) [40], most of which is well summarized in [22]. MTBase complements these systems by providing a platform that can accommodate more, but typically smaller tenants. </span></p><p class="c9"><span class="c5">Shared-databases (SD) systems: This approach, while appear- ing in the spectrum of multi-tenant databases by Chong et al. [17], is rare in practice. Sql Azure DB [20] seems to be the only product that has an implementation of this approach. However, even Mi- crosoft strongly advises against using SD and instead recommends to either use SR or ST [34]. </span></p><p class="c7"><span class="c17">23 </span></p><p class="c31"><span class="c5">Shared-tables (ST) systems: Work in that area includes Sales- force [44], Apache Phoenix [9], FlexScheme [11, 12] and Azure SQL Database [34]. Their common idea, as in MTSQL, is to use an invisible tenant identifier to identify which records belong to which tenant and rewrite SQL queries in order to include filters on this ttid. MTSQL extends these systems by providing the necessary features for cross-tenant query processing. </span></p><p class="c28"><span class="c5">Privacy/Confidentiality: Clearly, cross-tenant query processing almost immediately raises the question of data confidentiality. In the case of the HDC, for instance, patients might consent to their data being used in aggregated analytics, but they most certainly would not want sensitive, personal information, like their social security number, to appear in any report. While it is out of the scope of this paper to thoroughly discuss data confidentiality in a multi-tenant system, this work establishes proper syntax and se- mantics for cross-tenant query processing, which lays the ground for building appropriate encryption mechanisms [16, 21] atop as is sketched in our technical report [15]. </span></p><p class="c85"><span class="c5">UDFs and Complex Expressions: Oracle MLE [39] is a system that allows for highly-optimized execution of user-defined func- tions, which makes it a promising candidate to further investigate optimization of conversion functions. For instance, we would like to look at optimizing complex expressions, containing several nested user-defined function calls, as a whole. </span><span class="c4">7 CONCLUSION </span><span class="c5">This paper presented MTSQL, a new language to address cross- tenant query processing in multi-tenant databases. MTSQL ex- tends SQL with multi-tenancy-aware syntax and semantics, which allows to efficiently optimize and execute cross-tenant queries in MTBase. MTBase is an open-source system that implements MTSQL. At its core, it is an MTSQL-to-SQL rewrite middleware sitting between a client and any multi-tenant DBMS of choice. The performance evaluation with a benchmark adapted from TPC-H showed that MTBase (on top of PostgeSQL) can scale to thousands of tenants at very low overhead and that our proposed optimiza- tions to cross-tenant queries are highly effective. </span></p><p class="c71"><span class="c5">In the future, we plan to further analyze the interplay between the MTBase query optimizer and its counter-part in the DBMS execution engine in order to assess the potential of cost-based optimizations. We also want to study conversion functions that vary over time and investigate how MTSQL can be extended to temporal databases. Moreover, we would like to look more into the privacy issues of multi-tenant databases, in particular how to enable cross-tenant query processing if data is encrypted. </span><span class="c4">REFERENCES </span></p><p class="c44"><span class="c16">[1] 2017. MTBase project page. https://github.com/mtbase/overview. (2017). [2] 2017. MTBase Rewrite Algorithm. https://github.com/mtbase/mt-rewrite. </span></p><p class="c41"><span class="c16">(2017). [3] 2017. Oracle Virtual Private Database. http://www.oracle.com/technetwork/d </span></p><p class="c61"><span class="c16">atabase/security/index-088277.html. (2017). [4] 2017. Python 2.7.2 Release. https://www.python.org/download/releases/2.7.2. </span></p><p class="c41"><span class="c16">(2017). [5] 2017. Scala Language. http://www.scala-lang.org. (2017). [6] 2017. The Glasgow Haskell Compiler. https://www.haskell.org/ghc. (2017). [7] 2017. The Java Database Connectivity (JDBC). http://www.oracle.com/techn </span></p><p class="c49"><span class="c16">etwork/java/javase/jdbc/index.html. (2017). [8] Amazon Webservices. 2017. Amazon Relational Database Service (RDS). </span></p><p class="c54"><span class="c16">https://aws.amazon.com/rds. (2017). [9] Apache Foundation. 2017. Apache Phoenix: High performance relational database layer over HBase for low latency applicationsn - Multi-Tenancy Feature. http://phoenix.apache.org/multi-tenancy.html. (2017). [10] Joy Arulraj et al. 2016. Bridging the Archipelago between Row-Stores and Column-Stores for Hybrid Workloads. In Proceedings of the 2016 ACM SIG- MOD International Conference on Management of Data, Vol. 19. 57&ndash;63. </span></p><p class="c29 c69"><span class="c16">[11] Stefan Aulbach et al. 2008. Multi-tenant databases for software as a service: schema-mapping techniques. In Proceedings of the 2008 ACM SIGMOD inter- national conference on Management of data. ACM, 1195&ndash;1206. [12] Stefan Aulbach et al. 2011. Extensibility and data sharing in evolving multi- </span></p><p class="c25"><span class="c16">tenant databases. In Data engineering (icde), 2011 ieee 27th international conference on. IEEE, 99&ndash;110. [13] Hal Berenson et al. 1995. A Critique of ANSI SQL Isolation Levels. SIGMOD </span></p><p class="c67"><span class="c16">Rec. 24, 2 (1995), 1&ndash;10. http://doi.acm.org/10.1145/568271.223785 [14] Lucas Braun et al. 2015. Analytics in Motion: High Performance Event- </span></p><p class="c69 c90"><span class="c16">Processing AND Real-Time Analytics in the Same Database. In Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data. ACM, 251&ndash;264. [15] Lucas Braun et al. 2017. MTBase: Optimizing Cross-Tenant Database Queries. </span></p><p class="c38"><span class="c16">arXiv preprint arXiv:1703.04290 (2017). [16] Jose M Alcaraz Calero et al. 2010. Toward a Multi-Tenancy Authorization </span></p><p class="c53"><span class="c16">System for Cloud Services. IEEE Security &amp; Privacy 8, 6 (2010), 48&ndash;55. [17] Frederick Chong et al. 2006. Multi-tenant data architecture. MSDN Library, </span></p><p class="c66"><span class="c16">Microsoft Corporation (2006), 14&ndash;30. [18] Beno&icirc;t Dageville et al. 2016. The Snowflake Elastic Data Warehouse. In Proceedings of the 2016 International Conference on Management of Data, SIGMOD Conference 2016, San Francisco, CA, USA, June 26 - July 01, 2016. 215&ndash;226. http://doi.acm.org/10.1145/2882903.2903741 [19] Sudipto Das et al. 2013. ElasTraS: An elastic, scalable, and self-managing transactional database for the cloud. ACM Transactions on Database Systems (TODS) 38, 1 (2013), 5. [20] Sudipto Das et al. 2016. Automated Demand-driven Resource Scaling in Relational Database-as-a-Service. In Proceedings of the 2016 International Conference on Management of Data, SIGMOD Conference 2016, San Fran- cisco, CA, USA, June 26 - July 01, 2016. 1923&ndash;1934. http://doi.acm.org/10. 1145/2882903.2903733 [21] Sabrina De Capitani Di Vimercati et al. 2007. Over-encryption: management of access control evolution on outsourced data. In Proceedings of the 33rd in- ternational conference on Very large data bases. VLDB endowment, 123&ndash;134. [22] Aaron J Elmore et al. 2013. Towards database virtualization for database as a service. Proceedings of the VLDB Endowment 6, 11 (2013), 1194&ndash;1195. [23] Ronald Fagin et al. 2009. Clio: Schema mapping creation and data exchange. </span></p><p class="c40"><span class="c16">In Conceptual Modeling: Foundations and Applications. Springer, 198&ndash;236. [24] Jim Gray et al. 1997. Data cube: A relational aggregation operator generalizing group-by, cross-tab, and sub-totals. Data mining and knowledge discovery 1, 1 (1997), 29&ndash;53. [25] L M Haas et al. 1999. Transforming heterogeneous data with database middle- </span></p><p class="c78"><span class="c16">ware: Beyond integration. Data Engineering (1999), 31. [26] Laura M Haas et al. 2002. Data integration through database federation. IBM </span></p><p class="c73 c45"><span class="c16">Systems Journal 41, 4 (2002), 578&ndash;596. [27] E Hafen et al. 2014. Health data cooperativescitizen empowerment. Methods </span></p><p class="c45 c73"><span class="c16">Inf Med 53, 2 (2014), 82&ndash;86. [28] Joseph M Hellerstein et al. 1993. Predicate migration: Optimizing queries with </span></p><p class="c14"><span class="c16">expensive predicates. Vol. 22. ACM. [29] Ralph Kimball et al. 2002. The data warehouse toolkit: the complete guide to dimensional modelling. Nachdr.]. New York [ua]: Wiley (2002), 1&ndash;447. [30] SPT Krishnan et al. 2015. Google App Engine. In Building Your Next Big </span></p><p class="c78"><span class="c16">Thing with Google Cloud Platform. Springer, 83&ndash;122. [31] Alon Levy. 1998. The information manifold approach to data integration. IEEE </span></p><p class="c30"><span class="c16">Intelligent Systems 13, 5 (1998), 12&ndash;16. [32] Simon Manfred Loesing. 2015. Architectures for elastic database services. </span></p><p class="c30"><span class="c16">Ph.D. Dissertation. ETH Z&uuml;rich, Diss. Nr. 22441. [33] Microsoft Corporation. 2017. Microsoft Azure Multi-Tenant Architecture. </span></p><p class="c86"><span class="c16">https://msdn.microsoft.com/en-gb/library/hh534480.aspx. (2017). [34] Microsoft Corporation. 2017. Microsoft Azure SQL Database. https://azure.mi </span></p><p class="c14"><span class="c16">crosoft.com/en-us/services/sql-database. (2017). [35] Barzan Mozafari et al. 2013. DBSeer: Resource and Performance Prediction </span></p><p class="c38"><span class="c16">for Building a Next Generation Database Cloud.. In CIDR. [36] Vivek R Narasayya et al. 2013. SQLVM: Performance Isolation in Multi-Tenant </span></p><p class="c40"><span class="c16">Relational Database-as-a-Service.. In CIDR. [37] Thomas Neumann et al. 2015. Fast serializable multi-version concurrency control for main-memory database systems. In Proceedings of the 2015 ACM SIGMOD International Conference on Management of Data. ACM, 677&ndash;689. [38] Oracle Corporation. 2017. ORACLE Cloud. https://cloud.oracle.com/database. </span></p><p class="c14"><span class="c16">(2017). [39] Oracle Corporation. 2017. ORACLE Multilingual Engine. http://www.oracle.c </span></p><p class="c38"><span class="c16">om/technetwork/database/multilingual-engine. (2017). [40] Oracle Corporation. 2017. ORACLE Multitenant. http://www.oracle.com/tec </span></p><p class="c14"><span class="c16">hnetwork/database/multitenant. (2017). [41] Vijayshankar Raman et al. 2001. Potter&rsquo;s wheel: An interactive data cleaning </span></p><p class="c25 c45"><span class="c16">system. In VLDB, Vol. 1. 381&ndash;390. [42] SAP, November 2014. 2017. SAP HANA SPS 09 - What&rsquo;s New? https://hcp.sap.com/content/dam/website/saphana/en_us/Technology%20Doc uments/SPS09/SAP%20HANA%20SPS%2009%20-%20Multitenant%20Dat abase%20Cont.pdf. (2017). [43] Trasaction Processing Council. 2017. TPC-H. http://www.tpc.org/tpch. (2017). [44] Craig D Weissman et al. 2009. The design of the force. com multitenant internet </span></p><p class="c86"><span class="c16">application development platform.. In SIGMOD Conference. 889&ndash;896. [45] Ying Yang et al. 2015. Lenses: An on-demand approach to etl. Proceedings of </span></p><p class="c90 c91"><span class="c16">the VLDB Endowment 8, 12 (2015), 1578&ndash;1589. </span></p><p class="c89"><span class="c17">24 </span></p></body></html>