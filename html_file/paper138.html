<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c25{color:#13100f;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.1pt;font-family:"Times New Roman";font-style:normal}.c16{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:12.9pt;font-family:"Arial";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.5pt;font-family:"Arial";font-style:normal}.c28{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.2pt;font-family:"Arial";font-style:normal}.c102{margin-left:-19.2pt;padding-top:1pt;text-indent:32.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:4.7pt}.c57{margin-left:-23pt;padding-top:4.1pt;text-indent:31.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-12.1pt}.c33{color:#13100f;font-weight:400;text-decoration:none;vertical-align:sub;font-size:6.5pt;font-family:"Times New Roman";font-style:normal}.c52{color:#000000;font-weight:700;text-decoration:none;vertical-align:super;font-size:7pt;font-family:"Arial";font-style:normal}.c14{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10.8pt;font-family:"Times New Roman";font-style:normal}.c114{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Courier New";font-style:normal}.c26{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12.9pt;font-family:"Times New Roman";font-style:normal}.c50{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:3.5pt;font-family:"Arial";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:9.7pt;font-family:"Arial";font-style:normal}.c84{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.1pt;font-family:"Arial";font-style:normal}.c24{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.8pt;font-family:"Arial";font-style:normal}.c123{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:4.3pt;font-family:"Arial";font-style:normal}.c91{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.6pt;font-family:"Arial";font-style:normal}.c58{margin-left:-21.4pt;padding-top:1pt;text-indent:38.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:3.6pt}.c69{margin-left:4.6pt;padding-top:1pt;text-indent:43pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:10.2pt}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c27{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.2pt;font-family:"Times New Roman";font-style:normal}.c38{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.2pt;font-family:"Arial";font-style:normal}.c23{color:#13100f;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:3.9pt;font-family:"Times New Roman";font-style:normal}.c15{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11.6pt;font-family:"Arial";font-style:normal}.c51{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12pt;font-family:"Arial";font-style:normal}.c85{margin-left:-21.4pt;padding-top:1pt;text-indent:38.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:10.3pt}.c95{color:#13100f;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10.8pt;font-family:"Times New Roman";font-style:normal}.c67{margin-left:-21.4pt;padding-top:1pt;text-indent:38.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-8.6pt}.c8{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12.9pt;font-family:"Arial";font-style:normal}.c19{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.6pt;font-family:"Times New Roman";font-style:normal}.c22{color:#000000;font-weight:700;text-decoration:none;vertical-align:super;font-size:9.3pt;font-family:"Arial";font-style:normal}.c53{margin-left:-21.4pt;padding-top:1pt;text-indent:38.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-10.8pt}.c125{margin-left:-23pt;padding-top:4.1pt;text-indent:31.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-12.1pt}.c42{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11.3pt;font-family:"Arial";font-style:normal}.c61{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:16.1pt;font-family:"Arial";font-style:normal}.c12{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.5pt;font-family:"Arial";font-style:normal}.c20{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.5pt;font-family:"Times New Roman";font-style:normal}.c106{margin-left:-21.4pt;padding-top:1.4pt;text-indent:30.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-13.9pt}.c120{color:#000000;font-weight:700;text-decoration:none;vertical-align:super;font-size:10.2pt;font-family:"Arial";font-style:normal}.c7{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.8pt;font-family:"Arial";font-style:normal}.c17{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:17.4pt;font-family:"Arial";font-style:normal}.c98{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:4.2pt;font-family:"Arial";font-style:normal}.c89{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.3pt;font-family:"Arial";font-style:normal}.c59{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.5pt;font-family:"Times New Roman";font-style:normal}.c82{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:2.6pt;font-family:"Arial";font-style:normal}.c41{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:8.7pt;font-family:"Arial";font-style:normal}.c34{color:#13100f;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.5pt;font-family:"Times New Roman";font-style:normal}.c103{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.6pt;font-family:"Arial";font-style:normal}.c64{margin-left:-21.4pt;padding-top:1.2pt;text-indent:38.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:3.8pt}.c124{color:#13100e;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.6pt;font-family:"Times New Roman";font-style:normal}.c87{margin-left:-17.4pt;padding-top:1.2pt;text-indent:30.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-12.5pt}.c60{color:#13100f;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:3.1pt;font-family:"Times New Roman";font-style:normal}.c108{margin-left:-17.4pt;padding-top:1pt;text-indent:30.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:5.8pt}.c35{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10.7pt;font-family:"Arial";font-style:normal}.c77{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.6pt;font-family:"Times New Roman";font-style:normal}.c116{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:11.7pt;font-family:"Arial";font-style:normal}.c75{margin-left:-23pt;padding-top:1.4pt;text-indent:31.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-12.1pt}.c110{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:5.8pt;font-family:"Arial";font-style:normal}.c92{color:#13100e;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.7pt;font-family:"Times New Roman";font-style:normal}.c11{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:9.7pt;font-family:"Arial";font-style:normal}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.7pt;font-family:"Arial";font-style:normal}.c10{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.1pt;font-family:"Arial";font-style:normal}.c81{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.5pt;font-family:"Arial";font-style:normal}.c18{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.8pt;font-family:"Arial";font-style:normal}.c48{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:9.3pt;font-family:"Arial";font-style:normal}.c45{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:5.6pt;font-family:"Arial";font-style:normal}.c62{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:11.3pt;font-family:"Arial";font-style:normal}.c55{margin-left:-23pt;padding-top:1.7pt;text-indent:31.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-12.1pt}.c83{color:#13100f;font-weight:400;text-decoration:none;vertical-align:super;font-size:6.5pt;font-family:"Times New Roman";font-style:normal}.c37{color:#13100f;font-weight:400;text-decoration:none;vertical-align:sub;font-size:5.2pt;font-family:"Times New Roman";font-style:normal}.c122{margin-left:-23pt;padding-top:12.2pt;text-indent:31.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-12.1pt}.c29{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.1pt;font-family:"Courier New";font-style:normal}.c54{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10.5pt;font-family:"Arial";font-style:normal}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8.7pt;font-family:"Arial";font-style:normal}.c32{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.8pt;font-family:"Courier New";font-style:normal}.c65{color:#13100e;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.2pt;font-family:"Times New Roman";font-style:normal}.c109{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.5pt;font-family:"Arial";font-style:normal}.c86{color:#13100e;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:3.9pt;font-family:"Times New Roman";font-style:normal}.c107{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11.6pt;font-family:"Courier New";font-style:normal}.c115{margin-left:-21.4pt;padding-top:1.4pt;text-indent:30.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-13.9pt}.c46{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.7pt;font-family:"Times New Roman";font-style:normal}.c80{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:6.2pt;font-family:"Arial";font-style:normal}.c73{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:6.1pt;font-family:"Arial";font-style:normal}.c113{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.2pt;font-family:"Arial";font-style:normal}.c43{margin-left:-21.4pt;padding-top:1.2pt;text-indent:38.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-1.2pt}.c40{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10.8pt;font-family:"Times New Roman";font-style:normal}.c49{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11.6pt;font-family:"Times New Roman";font-style:normal}.c44{color:#13100f;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.9pt;font-family:"Times New Roman";font-style:normal}.c21{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8.7pt;font-family:"Times New Roman";font-style:normal}.c9{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7pt;font-family:"Arial";font-style:normal}.c2{margin-left:-8.6pt;padding-top:13.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:2.3pt}.c72{margin-left:-21.4pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-1pt}.c31{margin-left:-23pt;padding-top:7.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-12.1pt}.c66{margin-left:-19.2pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-7.5pt}.c112{margin-left:-17.4pt;padding-top:1.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-6.7pt}.c47{margin-left:-21.4pt;padding-top:1.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-12pt}.c128{margin-left:-23pt;padding-top:13.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-11.4pt}.c119{margin-left:-5.8pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:59.2pt}.c121{margin-left:1.6pt;padding-top:62.6pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:6.7pt}.c88{margin-left:-21.4pt;padding-top:1.2pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-9.1pt}.c94{margin-left:52.2pt;padding-top:10.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:59.8pt}.c100{margin-left:-4.2pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-11.5pt}.c71{margin-left:-23pt;padding-top:19.7pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-12.1pt}.c63{margin-left:-23pt;padding-top:15.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:103.8pt}.c96{margin-left:-21.4pt;padding-top:1.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-9.6pt}.c97{margin-left:-21.4pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-10.6pt}.c90{margin-left:218.2pt;padding-top:90.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-36.1pt}.c74{margin-left:-21.4pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-11pt}.c79{margin-left:-21.4pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-13.9pt}.c126{margin-left:-19.2pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-11.4pt}.c36{margin-left:218.2pt;padding-top:75.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-36.1pt}.c105{margin-left:-21.4pt;padding-top:1.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-13.9pt}.c117{margin-left:-21.4pt;padding-top:13.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-13.9pt}.c78{margin-left:-23pt;padding-top:7.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:121.1pt}.c68{margin-left:-21.4pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-12.2pt}.c127{margin-left:-3.8pt;padding-top:10.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:6.9pt}.c99{margin-left:-23pt;padding-top:18.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-12.1pt}.c118{margin-left:-21.4pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-9.1pt}.c111{margin-left:-21.4pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-12.5pt}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c39{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c13{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c30{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c56{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c76{margin-left:52pt;margin-right:113.5pt}.c101{margin-left:175.8pt;margin-right:-6.5pt}.c104{margin-left:-17.4pt;margin-right:-9.1pt}.c70{margin-left:-7.8pt;margin-right:-0.5pt}.c93{text-indent:38.7pt}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:24pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:14pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c56"><p class="c13"><span class="c3">Series ISSN: 2367-2005 378 </span><span class="c114">10.5441/002/edbt.2017.34 </span></p><p class="c39"><span class="c17">Efficient Motif Discovery in Spatial Trajectories Using Discrete Fr&eacute;chet Distance </span></p><p class="c39"><span class="c15">Bo Tang</span><span class="c11">&lowast; </span><span class="c15">Man Lung Yiu</span><span class="c11">&lowast; </span><span class="c15">Kyriakos Mouratidis</span><span class="c11"># </span><span class="c15">Kai Wang</span><span class="c11">$ </span><span class="c18">&lowast;</span><span class="c61">The Hong Kong Polytechnic University </span><span class="c18">#</span><span class="c61">Singapore Management University </span><span class="c18">$</span><span class="c61">Zhejiang University </span><span class="c4">{csbtang,csmlyiu}@comp.polyu.edu.hk; kyriakos@smu.edu.sg; kaelwang@zju.edu.cn </span></p><p class="c13"><span class="c49">ABSTRACT </span><span class="c4">The discrete Fr&eacute;chet distance (DFD) captures perceptual and geo- graphical similarity between discrete trajectories. It has been suc- cessfully adopted in a multitude of applications, such as signature and handwriting recognition, computer graphics, as well as ge- ographic applications. Spatial applications, e.g., sports analysis, traffic analysis, etc. require discovering the pair of most similar subtrajectories, be them parts of the same or of different input tra- jectories. The identified pair of subtrajectories is called a motif. The adoption of DFD as the similarity measure in motif discov- ery, although semantically ideal, is hindered by the high computa- tional complexity of DFD calculation. In this paper, we propose a suite of novel lower bound functions and a grouping-based solution with multi-level pruning in order to compute motifs with DFD ef- ficiently. Our techniques apply directly to motif discovery within the same or between different trajectories. An extensive empirical study on three real trajectory datasets reveals that our approach is 3 orders of magnitude faster than a baseline solution. </span></p><p class="c13"><span class="c49">1. INTRODUCTION </span></p><p class="c0"><span class="c4">Spatial trajectories are prevalent in many applications, e.g., mov- ing object analysis, traffic estimation and prediction systems. In this paper, we study motif discovery on spatial trajectories (i.e., finding the pair of most similar subtrajectories). Trajectory motifs are used in many applications, e.g., sports sense analysis [11], traf- fic analysis [15], or used as a building block for other trajectory mining and analysis methods [16, 31, 12]. As an example, Fig- ure 1(a) visualizes a pedestrian&rsquo;s GPS trajectory from the GeoLife trajectory dataset [32], by a 3D plot with timestamp number at the horizontal axis. The motif corresponds to the most similar pair of subtrajectories (in red and blue). Figure 1(b) illustrates the mo- tif (i.e., the two subtrajectories) on a map, which could be used in human behavior analysis. </span></p><p class="c0"><span class="c4">It is important to choose a suitable similarity measure for motif discovery. The Fr&eacute;chet metric is amongst the most popular mea- sures for trajectory similarity [24, 10]. Generally speaking, the Fr&eacute;chet distance between two spatial trajectories, S</span><span class="c5">a </span><span class="c12">and S</span><span class="c5">b</span><span class="c12">, is the </span><span class="c4">length of the shortest leash needed to walk a dog when the person </span></p><p class="c0"><span class="c4">c </span><span class="c6">2017, Copyright is with the authors. Published in Proc. 20th Inter- national Conference on Extending Database Technology (EDBT), March 21-24, 2017 - Venice, Italy: ISBN 978-3-89318-073-8, on OpenProceed- ings.org. Distribution of this paper is permitted under the terms of the Cre- ative Commons license CC-by-nc-nd 4.0 </span></p><p class="c13"><span class="c92">longitude </span></p><p class="c13"><span class="c92">latitude </span></p><p class="c39"><span class="c92">timestamp </span><span class="c6">(a) A pedestrian&rsquo;s trajectory (b) Discovered motif </span></p><p class="c13"><span class="c6">April 10-12, 2009 red: 07:33-7:48, April 10, 2009 </span></p><p class="c13"><span class="c6">blue: 07:33-7:50, April 12, 2009 </span></p><p class="c13"><span class="c21">Figure 1: Subtrajectory motif discovered in a trajectory from the GeoLife trajectory dataset </span></p><p class="c13"><span class="c4">walks along S</span><span class="c5">a </span><span class="c12">and the dog walks along S</span><span class="c5">b</span><span class="c12">. In the geographic </span><span class="c4">information handbook [10], the authors conclude that &ldquo;The most successful fundamental distance measure to this date is probably the Fr&eacute;chet metric, which is one of the most natural measures to calculate the similarity between two trajectories&rdquo;. The Fr&eacute;chet distance and its variants have been successfully used in a num- ber of application domains, such as handwriting recognition [22], bioinformatics [27], computational geometry [5], as well as geo- graphic applications [2]. In the literature, many recent systems have adopted the discrete Fr&eacute;chet distance (DFD) to measure the distance between discrete trajectories (or the Fr&eacute;chet distance for continuous curves) [2, 10, 3, 12, 25]. In addition, as we will elabo- rate in Section 2, DFD is particularly suitable for real-world spatial trajectories, which often exhibit the following properties: (i) non- uniform/varying sampling rate, and (ii) missing samples at some time points. For example, the GeoLife dataset [32], a real spatial trajectory dataset collected by Microsoft, has all the above proper- ties.</span><span class="c12">In this paper, we discover motifs in spatial trajectories with DFD </span><span class="c4">as the similarity measure. This problem is computationally chal- lenging for two reasons: </span><span class="c21">(I) </span><span class="c4">The computation of DFD between two subtrajectories takes O(l</span><span class="c11">2</span><span class="c4">) time [11], where l denotes the subtrajectory length. There have been attempts to speed up DFD computation by using GPUs [12] or a faster algorithm (with O(l</span><span class="c11">2 </span><span class="c4">&middot; plexity) [1]. In contrast, we take an orthogonal </span><span class="c11">log </span><span class="c4">research </span><span class="c7">log </span><span class="c11">log </span><span class="c7">l </span><span class="c11">l </span></p><p class="c13"><span class="c1">) time </span><span class="c4">direction </span><span class="c1">com- </span></p><p class="c13"><span class="c4">to reduce the number of DFD computations for motif discovery, e.g., by using various types of pruning on DFD computations and subtrajectory pairs. </span><span class="c21">(II) </span><span class="c4">The problem involves O(n</span><span class="c11">4</span><span class="c4">) pairs of subtrajectories, where n is the length of the input trajectory/ies. The fact that DFD ex- hibits non-monotonicity (cf. Section 4.1) precludes us from apply- ing efficient algorithmic paradigms (like binary search) to reduce the number of candidate pairs. </span></p><p class="c13"><span class="c4">To overcome these challenges, we exploit the properties of DFD and devise lower bound functions that incur low computation time. </span></p><p class="c99"><span class="c4">These lower bound functions serve for two purposes: first, prun- ing unpromising pairs of subtrajectories without invoking expen- sive DFD computation; second, guiding the search to discover the motif as soon as possible. Our lower bound functions are novel; nothing similar has been used in previous work. Additionally, they can be computed in amortized O(1) time. </span></p><p class="c75"><span class="c4">Furthermore, we propose a grouping-based solution with multi- level pruning. This solution (i) divides the input trajectory into groups, (ii) prunes dissimilar pairs of groups, and then (iii) ag- gressively processes the surviving pairs of groups until the result is found. At the heart of this approach lies a suite of lower bound functions to prune unpromising pairs of groups. </span></p><p class="c55"><span class="c4">All our techniques apply directly to motif discovery within the same or between different input trajectories. Importantly, besides motif discovery, they can be incorporated readily to other applica- tions [2, 3] which employ DFD as the similarity measure. </span></p><p class="c63"><span class="c49">2. RELATED WORK </span></p><p class="c57"><span class="c4">In this section, we survey previous work but, due to the strict page limit, we focus only on the most relevant pieces. First, we present alternative similarity measures and pinpoint the advantages offered by the Fr&eacute;chet metric that render it the ideal choice for (sub)trajectory similarity [10]. Next, we overview existing mo- tif discovery approaches and juxtapose them to ours. Finally, we provide an outlook of other practically relevant trajectory analysis techniques. </span><span class="c21">Trajectory similarity measures: </span><span class="c4">Several similarity measures have been proposed for trajectories, e.g., Euclidean Distance (ED), Dis- crete Fr&eacute;chet Distance (DFD) [8, 1], Dynamic Time Warping (DTW) [28], Longest Common Subsequence (LCSS) [26], Edit Distance on Real Sequence (EDR) [6]. Real-world trajectories (e.g., those in GeoLife dataset) exhibit two key characteristics, namely, non-uniform/varying sampling rate and missing samples for some time points. Thus, a desirable similarity measure would account for both these characteristics. In Table 1, we summarize the properties of the aforementioned trajectory similarity measures and their computation cost, expressed in terms of (sub)trajectory length l. Local time shifting refers to the ability of tolerating short- term discrepancies (e.g., missing samples, measurement errors) in aligning two trajectories [6]. </span></p><p class="c2"><span class="c18">Distance metric Non-uniform/varying Local Computation </span></p><p class="c69"><span class="c18">sampling rate time shifting cost ED O(l) DTW </span><span class="c62">&radic; </span><span class="c18">O(l</span><span class="c29">2</span><span class="c18">) LCSS </span><span class="c62">&radic; </span><span class="c18">O(l</span><span class="c29">2</span><span class="c18">) EDR </span><span class="c62">&radic; </span><span class="c18">O(l</span><span class="c29">2</span><span class="c18">) DFD </span><span class="c62">&radic; &radic; </span><span class="c18">O(l</span><span class="c29">2</span><span class="c18">) </span></p><p class="c127"><span class="c21">Table 1: Distance measures and their characteristics </span></p><p class="c122"><span class="c4">We will use examples to illustrate the advantages of discrete Fr&eacute;chet Distance (DFD) over typical alternatives (e.g., ED, DTW). We first apply two different measures (ED and DFD) to compute motifs on the GeoLife trajectory dataset [32]. Figures 2(a) and 2(b) show the most similar pair of subtrajectories by ED and DFD, re- spectively. Observe that the result of DFD (in Figure 2(b)) captures much better a human&rsquo;s interpretation. The reason is that ED mea- sures spatial proximity only, and dismisses the movement pattern. </span></p><p class="c75"><span class="c4">In Figure 3, we demonstrate the effect of non-uniform sam- pling in real-world data using DTW and DFD between trajecto- ries S</span><span class="c5">a</span><span class="c12">,S</span><span class="c5">b </span><span class="c12">and S</span><span class="c5">a</span><span class="c12">,S</span><span class="c5">c</span><span class="c12">. Trajectories S</span><span class="c5">a </span><span class="c12">(black color) and S</span><span class="c5">b </span><span class="c12">(blue </span><span class="c4">color) are uniformly sampled, while trajectory S</span><span class="c5">c </span><span class="c12">(red color) is </span></p><p class="c13 c70"><span class="c21">Figure 3: DTW and DFD; </span><span class="c4">S</span><span class="c5">c </span><span class="c59">is non-uniformly sampled </span></p><p class="c117"><span class="c4">non-uniformly sampled. Intuitively, trajectory S</span><span class="c5">c </span><span class="c12">is more simi- </span><span class="c4">lar to S</span><span class="c5">a </span><span class="c12">than S</span><span class="c5">b</span><span class="c12">, i.e., DFD(S</span><span class="c5">a</span><span class="c12">,S</span><span class="c5">c</span><span class="c12">) &lt; DFD(S</span><span class="c5">a</span><span class="c12">,S</span><span class="c5">b</span><span class="c12">), however, </span><span class="c4">DTW(S</span><span class="c5">a</span><span class="c12">,S</span><span class="c5">c</span><span class="c12">) &gt; DTW(S</span><span class="c5">a</span><span class="c12">,S</span><span class="c5">b</span><span class="c12">). The reason is DTW requires each </span><span class="c4">point to be matched to another (and adds up all distances between matched pairs) thus being sensitive to non-uniform sampling. </span></p><p class="c106"><span class="c4">In summary, ED is the fastest metric to compute but it is not robust to local time shifting. More robust measures, such as DTW [28], LCSS [26], EDR [6], are defined as the sum of point-to- point distances, which makes them sensitive to the sampling rate. As shown in Table 1, only DFD [8, 1], also known as the &ldquo;dog- man&rdquo; distance, can tolerate non-uniform/varying sampling rate [11, 24, 12]. Other distance measures require that points along the tra- jectories are uniformly and densely sampled, which is rarely the case in real settings [11]. For more details on trajectory similarity measures, we refer the reader to surveys [10, 24, 7]. </span></p><p class="c115"><span class="c4">The parallel computing [12] and computational geometry [1] communities have proposed some techniques to speed up DFD computation. In contrast, in our work we take an orthogonal ap- proach to accelerate DFD computations for trajectory motif dis- covery via novel pruning techniques. </span><span class="c21">Trajectory motif discovery techniques: </span><span class="c4">For spatial trajectories, most of the motif discovery techniques adopt the symbolic ap- proach [17, 11, 20]. This approach employs symbols to represent pre-defined movement patterns; some example symbols and pat- terns are illustrated in Figure 4(a). To convert a trajectory into a string of symbols, it first partitions a trajectory into fragments, and then maps each fragment to a symbol (i.e., pre-defined move- ment pattern). After that, it applies substring matching techniques to discover motifs [30, 14]. Unfortunately, this approach may pro- duce similar strings even if their original trajectories are far apart. For example, we illustrate two trajectories of Uber drivers (in two different cities) in Figures 4(b) and 4(c). Although these two tra- jectories are geographically far apart (in two different cities), both of them are mapped to string &lsquo;RVLH&rsquo;. Since this approach cannot capture the spatial distance between trajectories, we dismiss it. </span></p><p class="c115"><span class="c4">Motifs have also been studied for time series data [19, 18]. How- ever, these techniques are tailored to time series with Euclidean distance, and are not suitable for spatial trajectories with DFD. </span><span class="c21">Other trajectory analysis techniques: </span><span class="c4">Besides motif discovery, there are many other spatial trajectory analysis problems, e.g., con- voy discovery [13], outlier detection [29, 17], trajectory cluster- </span></p><p class="c36"><span class="c3">379 </span></p><p class="c13 c101"><span class="c109">Scale ratio = 14 </span></p><p class="c121"><span class="c18">(a) Most similar pair in ED (b) Most similar pair in DFD ED: 8.71 m; DFD: 0.09 m ED: 19.42 m; DFD: 0.08 m </span></p><p class="c94"><span class="c21">Figure 2: ED and DFD </span></p><p class="c13 c76"><span class="c84">Scale ratio = 15 </span></p><p class="c13 c76"><span class="c84">Scale ratio = 15 </span></p><p class="c13"><span class="c6">(b) A trajectory in Beijing; (c) A trajectory in Shenzhen; </span></p><p class="c13"><span class="c6">string: RVLH string: RVLH </span></p><p class="c13"><span class="c21">Figure 4: Example of the symbolic approach </span></p><p class="c13"><span class="c4">ing [16, 11, 12], etc. We refer the interested reader to a recent survey [31]. </span></p><p class="c13"><span class="c49">3. PROBLEM STATEMENT </span></p><p class="c13"><span class="c4">In this section, we introduce the problem and present a baseline solution, starting with several basic definitions. </span></p><p class="c13"><span class="c4">D</span><span class="c9">EFINITION </span><span class="c4">1 (S</span><span class="c9">PATIAL TRAJECTORY </span><span class="c4">&amp; </span><span class="c9">SUBTRAJECTORY</span><span class="c4">). A spatial trajectory S = &#12296;&middot; &middot; &middot; ,s</span><span class="c5">i</span><span class="c12">,&middot;&middot;&middot;&#12297; is a sequence of points. We </span><span class="c4">denote its trajectory length by n = |S|. Given a trajectory S, we S[i..i</span><span class="c5">e</span><span class="c12">] , where 0 &le; i&lt;i</span><span class="c5">e </span><span class="c12">&le; </span><span class="c4">denote </span><span class="c12">n &minus; 1. </span></p><p class="c13"><span class="c4">a subtrajectory of S as S</span><span class="c5">i,i</span><span class="c10">e </span><span class="c4">= </span></p><p class="c0"><span class="c4">Let T(S) = &#12296;&middot; &middot; &middot; ,t</span><span class="c5">i</span><span class="c12">, &middot;&middot;&middot;&#12297; be a sequence of ascending times- </span><span class="c4">tamps, where t</span><span class="c5">i </span><span class="c12">is the timestamp of location s</span><span class="c5">i </span><span class="c12">in S. The times- </span><span class="c4">tamps may be non-uniform. </span></p><p class="c0"><span class="c4">We assume each point s</span><span class="c5">i </span><span class="c12">is a latitude-longitude (&phi;</span><span class="c5">i</span><span class="c12">,&lambda;</span><span class="c5">i</span><span class="c12">) pair. We </span><span class="c4">measure the ground distance between two trajectory points s</span><span class="c5">i </span><span class="c12">= </span><span class="c4">(&phi;</span><span class="c5">i</span><span class="c12">,&lambda;</span><span class="c5">i</span><span class="c12">),s</span><span class="c5">j </span><span class="c12">= (&phi;</span><span class="c5">j</span><span class="c12">,&lambda;</span><span class="c5">j</span><span class="c12">) as the great circle distance on Earth [21]: </span></p><p class="c13"><span class="c6">d</span><span class="c5">G</span><span class="c8">(i, j)=2R arcsin</span><span class="c6">&radic;</span><span class="c8">sin</span><span class="c7">2 </span><span class="c16">(&phi;</span><span class="c7">j </span><span class="c6">&minus; 2 </span></p><p class="c13"><span class="c6">&phi;</span><span class="c5">i </span></p><p class="c13"><span class="c6">) </span></p><p class="c0"><span class="c4">where R is the radius of the earth. Nevertheless, our methods are directly applicable to higher dimensions (e.g., 3-d data points) and other types of ground distance (e.g., Euclidean). </span></p><p class="c13"><span class="c4">As discussed in Section 2, we adopt the discrete Fr&eacute;chet distance (DFD) to measure the </span><span class="c12">and S</span><span class="c5">j,j</span><span class="c10">e</span><span class="c4">, defined as: </span></p><p class="c30"><span class="c4">distance between two subtrajectories S</span><span class="c5">i,i</span><span class="c10">e </span><span class="c4">d</span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">) = max</span><span class="c4">&#63729;</span><span class="c12">&#63732;&#63732;&#63732;&#63730;</span><span class="c4">d</span><span class="c5">G</span><span class="c12">(i</span><span class="c5">e</span><span class="c12">,j</span><span class="c5">e</span><span class="c12">) &#63732;&#63732;&#63732;&#63731;</span><span class="c4">min</span><span class="c6">) </span><span class="c8">+ cos&phi;</span><span class="c5">i </span><span class="c8">cos&phi;</span><span class="c5">j </span><span class="c8">sin</span><span class="c7">2 </span><span class="c16">(&lambda;</span><span class="c7">j </span><span class="c6">&minus; 2 &lambda;</span><span class="c5">i </span></p><p class="c13"><span class="c1">&#63729;</span><span class="c4">&#63732;</span><span class="c12">&#63730;</span><span class="c4">d</span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">e </span><span class="c12">&minus; 1, j, j</span><span class="c5">e</span><span class="c12">), &#63732;&#63731;</span><span class="c4">dd</span><span class="c5">F</span><span class="c12">(i, </span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e </span><span class="c12">&minus; 1), </span></p><p class="c13"><span class="c12">i</span><span class="c5">e </span><span class="c12">&minus; 1, j, j</span><span class="c5">e </span><span class="c12">&minus; 1) </span></p><p class="c13"><span class="c4">For i</span><span class="c5">e </span><span class="c12">= i and j</span><span class="c5">e </span><span class="c12">= j, d</span><span class="c5">F</span><span class="c12">(i, i, j, j) = d</span><span class="c5">G</span><span class="c12">(i, j), and the DFD </span><span class="c4">computation recursion terminates at i</span><span class="c5">e </span><span class="c12">= i and j</span><span class="c5">e </span><span class="c12">= j. </span></p><p class="c0"><span class="c4">We study the motif discovery problem within a single input tra- jectory or between different trajectories; for simplicity, we focus presentation on single input trajectory but also elaborate on (and evaluate) the latter variant too. To produce a meaningful trajectory motif Stheir </span><span class="c5">j,j</span><span class="c10">e </span><span class="c4">timestamp are (S</span><span class="c5">i,i</span><span class="c4">sufficiently </span><span class="c10">e</span><span class="c4">, S</span><span class="c5">j,j</span><span class="c4">intervals </span><span class="c10">e</span><span class="c4">), we long require (e.g., each that: has (i) length subtrajectories at least &xi;), S</span><span class="c5">i,i</span><span class="c4">and </span><span class="c10">e </span><span class="c4">do not overlap. </span></p><p class="c13"><span class="c4">and (ii) </span></p><p class="c13"><span class="c4">P</span><span class="c9">ROBLEM </span><span class="c4">1 (T</span><span class="c9">RAJECTORY </span><span class="c4">M</span><span class="c9">OTIF </span><span class="c4">D</span><span class="c9">ISCOVERY </span><span class="c4">P</span><span class="c9">ROBLEM</span><span class="c4">). Given a trajectory S and a minimum motif length &xi;, return the pair </span></p><p class="c13"><span class="c6">symbol movement pattern </span></p><p class="c39"><span class="c6">V vertical long straight H horizontal long straight L left turn R right turn (a) Pre-defined movement patterns and symbols </span></p><p class="c0"><span class="c4">of subtrajectories S</span><span class="c5">i,i</span><span class="c10">e </span><span class="c4">and S</span><span class="c5">j,j</span><span class="c10">e </span><span class="c4">with the smallest DFD distance d</span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">) among all pairs of non-overlapping subtrajectories </span><span class="c4">(that is, i &lt; i</span><span class="c5">e </span><span class="c12">&lt; j &lt; j</span><span class="c5">e</span><span class="c12">) with length at least &xi; (that is, </span><span class="c4">i</span><span class="c5">e </span><span class="c12">&gt; i + &xi;,j</span><span class="c5">e </span><span class="c12">&gt; j + &xi;). </span></p><p class="c0"><span class="c4">As mentioned previously, a variant of Problem 1 is to discover a motif between different trajectories. I.e., considering two trajec- tories S and T , to return the pair of subtrajectories S</span><span class="c5">i,i</span><span class="c10">e </span><span class="c4">and T</span><span class="c5">j,j</span><span class="c10">e </span><span class="c12">whose DFD is the smallest among all possible pairs of their subtra- </span><span class="c4">jectories. </span></p><p class="c0"><span class="c4">With Problem 1 in mind, a straightforward solution is to enu- merate all pairs of subtrajectories (S</span><span class="c5">i,i</span><span class="c10">e</span><span class="c4">, S</span><span class="c5">j,j</span><span class="c10">e</span><span class="c4">) and then compute the DFD value for each pair. Its time complexity is O(n</span><span class="c11">6</span><span class="c4">), as there are O(n</span><span class="c11">4</span><span class="c4">) pairs of subtrajectories and each call to DFD takes O(l</span><span class="c11">2</span><span class="c4">) = O(n</span><span class="c11">2</span><span class="c4">) time. Even if we implement each call to DFD by [1], the time complexity is still O(n</span><span class="c11">6 </span><span class="c4">&middot; </span><span class="c11">log log n </span></p><p class="c13"><span class="c7">log n </span><span class="c1">). </span><span class="c4">We observe that, for all subtrajectory pairs (S</span><span class="c5">i,i</span><span class="c10">e</span><span class="c4">, S</span><span class="c5">j,j</span><span class="c10">e</span><span class="c4">) with the same start point (i, j), their DFD computation can be shared via dynamic programming. By incorporating this idea into the above solution, we obtain BruteDP (Algorithm 1) &ndash; a brute force algo- rithm that uses dynamic programming. A further optimization is to eliminate redundant calls of the ground distance function d</span><span class="c5">G</span><span class="c12">(&middot;,&middot;). </span><span class="c4">We propose to precompute all pairs of ground distances, and store them in matrix d</span><span class="c5">G</span><span class="c12">[&middot;][&middot;] for quick access. </span></p><p class="c13"><span class="c21">Algorithm 1 </span><span class="c4">BruteDP (Trajectory S, minimum length &xi;) </span></p><p class="c13"><span class="c6">Input: trajectory S, length n, minimum motif length &xi; Output: subtrajectory pair bpair = (S</span><span class="c5">i,i</span><span class="c10">e</span><span class="c6">,S</span><span class="c5">j,j</span><span class="c10">e</span><span class="c6">) </span><span class="c12">1: </span><span class="c8">bsf &larr; +&infin;; bpair &larr; &empty; </span><span class="c12">2: </span><span class="c26">for </span><span class="c8">i &larr; 0 to n &minus; 2&xi; + 1 </span><span class="c26">do </span><span class="c12">3: </span><span class="c26">for </span><span class="c8">j &larr; i + &xi; to n &minus; &xi; + 1 </span><span class="c26">do </span><span class="c12">4: </span><span class="c8">d</span><span class="c5">F </span><span class="c6">[i][j] &larr; d</span><span class="c5">G</span><span class="c6">(i, j) &#8882; initialization </span><span class="c12">5: </span><span class="c26">for </span><span class="c8">t &larr; i + 1 to n </span><span class="c26">do </span><span class="c12">6: </span><span class="c8">d</span><span class="c5">F </span><span class="c8">[i][t] &larr; max(d</span><span class="c5">G</span><span class="c8">(i, t),d</span><span class="c5">F </span><span class="c8">[i][t-1]) </span><span class="c12">7: </span><span class="c8">d</span><span class="c5">F </span><span class="c6">[t][j] &larr; max(d</span><span class="c5">G</span><span class="c6">(t, j),d</span><span class="c5">F</span><span class="c6">[t-1][j]) </span><span class="c4">8: </span><span class="c46">for </span><span class="c6">i</span><span class="c5">e </span><span class="c8">&larr; i + 1 to j &minus; 1 </span><span class="c26">do </span><span class="c8">&#8882; share DFD computation </span><span class="c12">9: </span><span class="c26">for </span><span class="c8">j</span><span class="c5">e </span><span class="c8">&larr; j + 1 to n </span><span class="c26">do </span><span class="c12">10: </span><span class="c8">tmp &larr; min(d</span><span class="c5">F </span><span class="c6">[i</span><span class="c5">e</span><span class="c8">-1][j</span><span class="c5">e</span><span class="c8">-1],d</span><span class="c5">F </span><span class="c6">[i</span><span class="c5">e</span><span class="c8">][j</span><span class="c5">e</span><span class="c8">-1],d</span><span class="c5">F</span><span class="c6">[i</span><span class="c5">e</span><span class="c8">-1][j</span><span class="c5">e</span><span class="c8">]) </span><span class="c12">11: </span><span class="c8">d</span><span class="c5">F </span><span class="c6">[i</span><span class="c5">e</span><span class="c8">][j</span><span class="c5">e</span><span class="c8">] &larr; max(d</span><span class="c5">G</span><span class="c6">(i</span><span class="c5">e</span><span class="c8">,j</span><span class="c5">e</span><span class="c8">), tmp) </span><span class="c12">12: </span><span class="c26">if </span><span class="c8">i</span><span class="c5">e </span><span class="c8">&gt; i + &xi;, j</span><span class="c5">e </span><span class="c8">&gt; j + &xi; and d</span><span class="c5">F </span><span class="c8">[i</span><span class="c5">e</span><span class="c8">][j</span><span class="c5">e</span><span class="c8">] &lt; bsf </span><span class="c26">then </span><span class="c12">13: </span><span class="c8">bsf &larr; d</span><span class="c5">F </span><span class="c6">[i</span><span class="c5">e</span><span class="c8">][j</span><span class="c5">e</span><span class="c8">];bpair &larr; (S</span><span class="c5">i,i</span><span class="c10">e</span><span class="c6">, S</span><span class="c5">j,j</span><span class="c10">e</span><span class="c6">) </span><span class="c4">14: </span><span class="c6">return bpair </span></p><p class="c13"><span class="c4">Algorithm 1 can be adapted to motif discovery between different trajectories easily, i.e., with S</span><span class="c5">j,j</span><span class="c10">e </span><span class="c4">playing the role of a subtrajectory in the second input trajectory, and by incrementing i until n&minus;&xi;+1 (instead of n &minus; 2&xi; + 1) at Line 2, and j starting from 0 (instead of i+&xi;) at Line 3 (because this variant considers separate trajectories, thus not imposing the constraint i&lt;i</span><span class="c5">e </span><span class="c12">&lt;j&lt;j</span><span class="c5">e</span><span class="c12">). </span><span class="c21">Analysis: </span><span class="c4">With all pairs of ground distances available in matrix d</span><span class="c5">G</span><span class="c12">, </span><span class="c4">the time complexity of Algorithm 1 is O(n</span><span class="c11">4</span><span class="c4">), which is attributed to the nested for-loops for variables i, j (at Lines 2-3) and vari- ables i</span><span class="c5">e</span><span class="c12">,j</span><span class="c5">e </span><span class="c12">(at Lines 8-9). The space complexity of the algorithm </span><span class="c4">is O(n</span><span class="c11">2</span><span class="c4">), as it employs two 2-dimensional matrices: (i) d</span><span class="c5">F</span><span class="c12">[&middot;][&middot;] for </span><span class="c4">implementing dynamic programming, and (ii) d</span><span class="c5">G</span><span class="c12">[&middot;][&middot;] for holding </span><span class="c4">all-pair ground distances. </span></p><p class="c13"><span class="c4">Before we proceed to our advanced techniques, we summarize frequently used notation in Table 2. </span></p><p class="c13"><span class="c49">4. BOUNDING-BASED SOLUTION </span></p><p class="c0"><span class="c4">We first analyze the properties of DFD (in Section 4.1). Then we exploit these properties to devise novel lower bound functions for DFD (in Section 4.2). Our lower bounds can be computed in amortized O(1) time, and guarantee no false negatives (in Section </span></p><p class="c13"><span class="c3">380 </span></p><p class="c13"><span class="c18">Symbol Meaning </span></p><p class="c13"><span class="c18">S input trajectory S[i] (&phi;</span><span class="c10">i</span><span class="c42">, &lambda;</span><span class="c10">i</span><span class="c42">), the i</span><span class="c24">th </span><span class="c42">point of S </span><span class="c18">S</span><span class="c10">i,i</span><span class="c18">n </span><span class="c10">e </span><span class="c18">the subtrajectory of S starting at S[i] and ending at S[i</span><span class="c10">e</span><span class="c42">] </span></p><p class="c13"><span class="c18">the length of trajectory S &xi; the minimum motif length d</span><span class="c10">G</span><span class="c42">(i, j) the ground distance between S[i] and S[j] </span><span class="c18">d</span><span class="c10">F </span><span class="c42">(i, i</span><span class="c10">e</span><span class="c42">, j, j</span><span class="c10">e</span><span class="c42">) the DFD between subtrajectories S</span><span class="c10">i,ie </span><span class="c18">and S</span><span class="c10">j,je </span></p><p class="c13"><span class="c21">Table 2: Notation </span></p><p class="c0"><span class="c4">4.3). Finally, we propose a bounding-based solution that applies our lower bound functions to prune unpromising pairs of trajecto- ries and reduce the number of DFD computations (in Section 4.4). </span><span class="c49">4.1 Properties of DFD </span></p><p class="c13"><span class="c35">4.1.1 Non-monotonicity </span></p><p class="c0"><span class="c4">Typical sequence/string mining algorithms exploit the monotone property to develop efficient Apriori-style algorithms. An example of the monotone property would be: &ldquo;given a string S, if q</span><span class="c5">&alpha; </span><span class="c12">is a </span><span class="c4">substring of q</span><span class="c5">&beta;</span><span class="c12">, then the frequency of q</span><span class="c5">&alpha; </span><span class="c12">in S cannot be smaller </span><span class="c4">than the frequency of q</span><span class="c5">&beta; </span><span class="c12">in S.&rdquo; It would be tempting to adapt such </span><span class="c4">an idea to solve our problem efficiently. Unfortunately, the DFD metric does not satisfy the monotone property. Formally: </span></p><p class="c13"><span class="c4">D</span><span class="c9">EFINITION </span><span class="c4">2 (C</span><span class="c9">ONTAINMENT </span><span class="c4">S</span><span class="c5">i</span><span class="c32">&prime;</span><span class="c5">,i</span><span class="c32">&prime;</span><span class="c10">e</span><span class="c4">, denoted as S</span><span class="c5">i</span><span class="c32">&prime;</span><span class="c5">,i</span><span class="c32">&prime;</span><span class="c10">e </span><span class="c4">&sube;). &sube; S</span><span class="c5">i,i</span><span class="c10">e</span><span class="c4">, iff i</span><span class="c11">&prime; </span><span class="c4">&ge; i and S</span><span class="c5">i,i</span><span class="c10">e </span><span class="c4">i</span><span class="c11">&prime;</span><span class="c7">e </span><span class="c4">is &le; said i</span><span class="c5">e</span><span class="c12">. </span></p><p class="c13"><span class="c4">to contain </span></p><p class="c30"><span class="c4">L</span><span class="c9">EMMA </span><span class="c4">1 (N</span><span class="c9">ON</span><span class="c4">-</span><span class="c9">MONOTONICITY</span><span class="c4">). subtrajectory pair of S. Let satisfy is neither S</span><span class="c5">i</span><span class="c32">&prime;</span><span class="c5">,i</span><span class="c4">monotone </span><span class="c32">&prime;</span><span class="c10">e </span><span class="c4">&sube; S</span><span class="c5">i,i</span><span class="c10">e</span><span class="c4">increasing , S</span><span class="c5">j</span><span class="c32">&prime;</span><span class="c5">,j</span><span class="c10">e </span><span class="c32">&prime;</span><span class="c4">Let &sube; S</span><span class="c5">i</span><span class="c4">Snor </span><span class="c32">&prime;</span><span class="c5">,ij,j</span><span class="c32">&prime;</span><span class="c10">e</span><span class="c4">, </span><span class="c10">e</span><span class="c4">monotone S. </span><span class="c5">j</span><span class="c4">It </span><span class="c32">&prime;</span><span class="c5">,j</span><span class="c4">holds </span><span class="c10">e </span><span class="c32">&prime;</span><span class="c4">be (Ssubtrajectories </span><span class="c5">i,i</span><span class="c10">e</span><span class="c4">, S</span><span class="c5">j,j</span><span class="c10">e</span><span class="c4">) be a that that, d</span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">) </span><span class="c4">decreasing with re- spect to d</span><span class="c5">F</span><span class="c12">(i</span><span class="c7">&prime;</span><span class="c12">,i</span><span class="c7">&prime;</span><span class="c5">e</span><span class="c4">,j</span><span class="c11">&prime;</span><span class="c4">,j</span><span class="c7">e</span><span class="c11">&prime;</span><span class="c1">). </span></p><p class="c13"><span class="c4">We provide a counter-example to demonstrate the non- monotonicity as follows. </span><span class="c21">Example: </span><span class="c4">We illustrate Lemma 1 using a trajectory S with length n = 12. Figure 5 shows the ground distance for each pair (S[i],S[j]). Consider three subtrajectories S</span><span class="c5">0,2 </span><span class="c12">&sube; S</span><span class="c5">0,3 </span><span class="c12">&sube; S</span><span class="c5">0,4 </span><span class="c4">and their DFD distances from S</span><span class="c5">6,9</span><span class="c12">. Using Algorithm 1, we can </span><span class="c4">compute these DFD values: d</span><span class="c5">F</span><span class="c12">(0, 2, 6,9) = 4, d</span><span class="c5">F</span><span class="c12">(0,3, 6, 9) = 1, </span><span class="c4">d</span><span class="c5">F</span><span class="c12">(0, 4, 6,9) = 7. When comparing S</span><span class="c5">0,2 </span><span class="c12">and S</span><span class="c5">0,3</span><span class="c12">, the DFD value </span><span class="c4">(from S</span><span class="c5">6,9</span><span class="c12">) decreases from 4 to 1. However, when comparing S</span><span class="c5">0,3 </span><span class="c4">and S</span><span class="c5">0,4</span><span class="c12">, the DFD value (from S</span><span class="c5">6,9</span><span class="c12">) increases from 1 to 7. I.e., </span><span class="c4">DFD does not satisfy the monotone property. </span></p><p class="c13"><span class="c120">1 10 19 8 7 6 5 4 3 2 1 </span><span class="c73">0 0 1 2 3 4 5 6 7 8 9 10 11 </span></p><p class="c13"><span class="c21">Figure 5: Example of </span><span class="c4">d</span><span class="c5">G </span><span class="c59">matrix </span></p><p class="c13"><span class="c35">4.1.2 Crucial Observation </span></p><p class="c0"><span class="c4">Non-monotonicity aside, we make a crucial observation which is quintessential to our approach. Specifically, the computation of DFD by recurrence is equivalent to a path finding problem in the d</span><span class="c5">G </span><span class="c12">matrix. </span></p><p class="c13"><span class="c4">O</span><span class="c9">BSERVATION </span><span class="c4">1. contributed by a path from The DFD (i, j) between to (i</span><span class="c5">e</span><span class="c12">,j</span><span class="c5">e</span><span class="c12">) </span><span class="c4">S</span><span class="c5">i,i</span><span class="c12">such </span><span class="c10">e </span><span class="c4">and </span><span class="c12">that: </span><span class="c4">S</span><span class="c5">j,j</span><span class="c12">(i) </span><span class="c10">e </span><span class="c12">the </span><span class="c4">must </span><span class="c12">path </span><span class="c4">be </span></p><p class="c13"><span class="c4">travels along non-decreasing positions, (ii) the worst-case ground distance along the path is minimized. </span></p><p class="c0"><span class="c4">We illustrate using two subtrajectories S</span><span class="c5">0,3 </span><span class="c12">and S</span><span class="c5">6,9</span><span class="c12">. Figure 6(a) </span><span class="c4">shows the ground distance d</span><span class="c5">G </span><span class="c12">for each pair of points from S</span><span class="c5">0,3 </span><span class="c12">and </span><span class="c4">S</span><span class="c5">6,9 </span><span class="c12">(note that only the relevant part of the d</span><span class="c5">G </span><span class="c12">matrix from Figure 5 </span><span class="c4">is shown). We compute the d</span><span class="c5">F </span><span class="c12">value for each pair of points, as </span><span class="c4">illustrated in Figure 6(b). The DFD distance is d</span><span class="c5">F</span><span class="c12">(0,3, 6, 9) = 1, </span><span class="c4">which is contributed by the path of gray cells from (0, 6) to (3, 9), that minimizes the maximum ground distance among the cells it visits. </span><span class="c51">2 2 4 1 </span></p><p class="c13"><span class="c28">3 1 1 2 </span></p><p class="c13"><span class="c28">1 3 2 3 </span></p><p class="c13"><span class="c28">1 2 3 2 </span></p><p class="c13"><span class="c38">/ </span></p><p class="c13"><span class="c80">0 1 2 3 </span><span class="c28">3 2 4 1 3 1 1 2 </span></p><p class="c13"><span class="c28">1 3 2 3 </span></p><p class="c13"><span class="c28">1 2 3 3 </span></p><p class="c39"><span class="c38">/ </span><span class="c80">0 1 2 3 </span><span class="c6">(a) Relevant part of d</span><span class="c5">G </span><span class="c8">(b) d</span><span class="c5">F </span><span class="c8">computation as a path in d</span><span class="c5">G </span></p><p class="c13"><span class="c21">Figure 6: DFD computation for </span><span class="c4">S</span><span class="c5">0,3 </span><span class="c59">and </span><span class="c12">S</span><span class="c5">6,9 </span></p><p class="c13"><span class="c49">4.2 Pattern-based Lower Bounds </span></p><p class="c0"><span class="c4">Based on Observation 1, we devise novel lower bound functions for DFD by accessing/traversing the d</span><span class="c5">G </span><span class="c12">matrix according to differ- </span><span class="c4">ent patterns (e.g., a single cell, cells in a cross, cells in a band). </span></p><p class="c0"><span class="c4">Specifically, assuming that matrix d</span><span class="c5">G </span><span class="c12">is precomputed and that </span><span class="c4">bsf is the DFD of the best subtrajectory pair encountered so far in the search process, we propose a set of lower bound functions that apply to candidate subtrajectory pairs, or entire groups of candidate pairs, such that if the bound is greater than bsf, the candidates are safe to prune, i.e., to disqualify without further consideration, because they are guaranteed not to be the motif. </span></p><p class="c30"><span class="c35">4.2.1 Cell-based Lower Bound </span><span class="c4">We refer (i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">). </span><span class="c4">to a subtrajectory </span><span class="c12">We define a candidate </span><span class="c4">pair </span><span class="c12">subset </span><span class="c4">(S</span><span class="c5">i,i</span><span class="c10">e</span><span class="c12">CS</span><span class="c4">, S</span><span class="c5">j,ji,j </span><span class="c10">e</span><span class="c4">) </span><span class="c12">to </span><span class="c4">as </span><span class="c12">represent </span><span class="c4">candidate </span><span class="c12">all </span><span class="c4">candidates with the same start positions i and j. This compact no- tation, using a pair (i, j), allows us to represent O(n</span><span class="c11">2</span><span class="c4">) candidates. </span></p><p class="c0"><span class="c4">D</span><span class="c9">EFINITION </span><span class="c4">3 (</span><span class="c9">CANDIDATE SUBSET</span><span class="c4">). Given two start po- sitions i and j, the candidate subset is defined as CS</span><span class="c5">i,j </span><span class="c12">= </span><span class="c4">{(i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">) : i</span><span class="c5">e </span><span class="c12">&gt; i &and; j</span><span class="c5">e </span><span class="c12">&gt; j}. </span></p><p class="c13"><span class="c4">The following holds for any CS</span><span class="c5">i,j</span><span class="c12">. </span></p><p class="c13"><span class="c4">O</span><span class="c9">BSERVATION </span><span class="c4">2. For every (i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">) &isin; CS</span><span class="c5">i,j</span><span class="c12">, the path </span><span class="c4">leading to d</span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">) must start from cell (i, j). </span></p><p class="c0"><span class="c4">For example, in Figure 6(a), for each candidate in CS</span><span class="c5">i,j</span><span class="c12">, the path </span><span class="c4">leading to DFD must start at cell (0,6). We thus derive our first bound, which applies to any candidate in CS</span><span class="c5">i,j</span><span class="c12">: </span></p><p class="c13"><span class="c4">LB</span><span class="c5">cell</span><span class="c12">(i, j) = d</span><span class="c5">G</span><span class="c12">(i, j) (1) </span></p><p class="c13"><span class="c3">381 </span></p><p class="c13"><span class="c4">For every (i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">) &isin; CS</span><span class="c5">i,j</span><span class="c12">, LB</span><span class="c5">cell</span><span class="c12">(i, j) &le; d</span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">). </span><span class="c21">Example: </span><span class="c4">In Figure 5, for candidate subset CS</span><span class="c5">5,9 </span><span class="c12">(i.e., for all can- </span><span class="c4">didate pairs that start at the red cell), we obtain LB</span><span class="c5">cell</span><span class="c12">(5, 9) = </span><span class="c4">d</span><span class="c5">G</span><span class="c12">(5,9) = 6. This is a lower bound for the DFD of any candi- </span><span class="c4">date pair in CS</span><span class="c5">5,9</span><span class="c12">. E.g., for pair (S</span><span class="c5">5,6</span><span class="c12">, S</span><span class="c5">9,11</span><span class="c12">), the exact DFD is </span><span class="c4">d</span><span class="c5">F</span><span class="c12">(5, 6, 9,11) = 7. </span></p><p class="c13"><span class="c35">4.2.2 Cross-based Lower Bound </span></p><p class="c13"><span class="c4">If a candidate subset is not pruned using LB</span><span class="c5">cell</span><span class="c12">, we attempt to </span><span class="c4">prune it with tighter lower bounds. </span></p><p class="c0"><span class="c4">O</span><span class="c9">BSERVATION </span><span class="c4">3. For every (i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">) &isin; CS</span><span class="c5">i,j</span><span class="c12">, the path </span><span class="c4">leading to d</span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">) must pass through the (i + 1)-th column </span><span class="c4">and (j + 1)-th row. </span></p><p class="c0"><span class="c21">Example: </span><span class="c4">In Figure 5, consider candidate (4, 6, 8,10) in the can- didate subset CS</span><span class="c5">4,8</span><span class="c12">. For this candidate, any path from the start-cell </span><span class="c4">(4,8) to the end-cell (6,10) must pass through the 5-th column and 9-th row; otherwise, the path cannot reach the end-cell (6,10). We thus define the following lower bounds. </span></p><p class="c13"><span class="c4">LB</span><span class="c5">row</span><span class="c12">(i, j) = min </span><span class="c5">i</span><span class="c32">&prime;</span><span class="c5">&isin;[i,j&minus;1]</span><span class="c4">{d</span><span class="c5">G</span><span class="c12">(i</span><span class="c7">&prime;</span><span class="c12">,j + 1)} (2) </span><span class="c4">LB</span><span class="c5">col</span><span class="c12">(i, j) = min </span><span class="c5">j</span><span class="c32">&prime;</span><span class="c5">&isin;[j,n&minus;1]</span><span class="c4">{d</span><span class="c5">G</span><span class="c12">(i + 1,j</span><span class="c7">&prime;</span><span class="c12">)} (3) </span></p><p class="c0"><span class="c4">For every (i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">) &isin; CS</span><span class="c5">i,j</span><span class="c12">, it holds that LB</span><span class="c5">row</span><span class="c12">(i, j) &le; </span><span class="c4">d</span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">) and that LB</span><span class="c5">col</span><span class="c12">(i, j) &le; d</span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">). Thus, we </span><span class="c4">combine the two into the cross-based lower bound below: </span></p><p class="c13"><span class="c4">LB</span><span class="c11">start </span><span class="c7">cross</span><span class="c1">(i, j) = max (LB</span><span class="c7">row</span><span class="c4">(i, j), LB</span><span class="c5">col</span><span class="c12">(i, j)) (4) </span><span class="c4">For every (i, i</span><span class="c5">c</span><span class="c12">, j, j</span><span class="c5">c</span><span class="c12">) &isin; CS</span><span class="c5">i,j</span><span class="c12">, LB</span><span class="c7">start </span><span class="c5">cross</span><span class="c4">(i, j) &le; d</span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">c</span><span class="c12">, j, j</span><span class="c5">c</span><span class="c12">). </span><span class="c21">Example: </span><span class="c4">Consider cell (4,8) in Figure 7(a), and assume that n = 12. LB</span><span class="c11">start </span><span class="c7">cross</span><span class="c1">(4, 8) is computed over the gray cells as follows: </span></p><p class="c13"><span class="c4">LB</span><span class="c11">start </span><span class="c7">cross</span><span class="c1">(4,8) = max(LB</span><span class="c7">row</span><span class="c4">(4,8), LB</span><span class="c5">col</span><span class="c12">(4, 8)) </span><span class="c4">= max</span><span class="c1">( </span></p><p class="c13"><span class="c4">min </span><span class="c5">i</span><span class="c32">&prime;</span><span class="c5">&isin;[4,7]</span><span class="c4">{d</span><span class="c5">G</span><span class="c12">(i</span><span class="c7">&prime;</span><span class="c12">, 9)}, min </span><span class="c5">j</span><span class="c32">&prime;</span><span class="c5">&isin;[8,11]</span><span class="c4">{d</span><span class="c5">G</span><span class="c12">(5,j</span><span class="c7">&prime;</span><span class="c12">)}</span><span class="c4">) = max(6,6) = 6 </span></p><p class="c13"><span class="c6">(a) LB</span><span class="c11">start </span><span class="c7">cross</span><span class="c16">(4,8) (b) LB</span><span class="c11">end </span><span class="c7">cross</span><span class="c16">(3,9) </span></p><p class="c13"><span class="c21">Figure 7: Examples of cross-based bounds </span></p><p class="c13"><span class="c35">4.2.3 Band-based Lower Bound </span></p><p class="c13"><span class="c4">Our problem definition considers only subtrajectories with length at least &xi;. Based on that, we extend Observation 3 to: </span></p><p class="c0"><span class="c4">O</span><span class="c9">BSERVATION </span><span class="c4">4. For every (i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">) &isin; CS</span><span class="c5">i,j </span><span class="c12">that satisfies </span><span class="c4">the constraint i</span><span class="c5">e </span><span class="c12">&gt; i + &xi; and j</span><span class="c5">e </span><span class="c12">&gt; j + &xi;, the path leading to </span><span class="c4">d</span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">) must pass through columns i+1 to i+&xi; and through </span><span class="c4">rows j + 1 to j + &xi;. </span></p><p class="c13"><span class="c6">(a) LB</span><span class="c11">row </span><span class="c7">band</span><span class="c16">(1,6) (b) LB</span><span class="c11">col </span><span class="c7">band</span><span class="c16">(1,8) </span></p><p class="c13"><span class="c21">Figure 8: Example of band-based bound </span></p><p class="c0"><span class="c21">Example: </span><span class="c4">Consider candidate subset CS</span><span class="c5">1,6 </span><span class="c12">in Figure 8(a). Sup- </span><span class="c4">pose the minimum motif length is &xi; = 4 and n = 12. By the definition of LB</span><span class="c5">row</span><span class="c12">(i, j), the minimum values in the 7-th, </span><span class="c4">8-th, 9-th and 10-th row are 2, 1, 1 and 6, respectively. Hence, LB</span><span class="c11">row </span><span class="c7">band</span><span class="c1">(1, 6) = max(2, 1,1,6) = 6. Similarly, consider candi- </span><span class="c4">date subset CS</span><span class="c5">1,8 </span><span class="c12">in Figure 8(b). By the definition of LB</span><span class="c5">col</span><span class="c12">(i, j), </span><span class="c4">the minimum value of the 2-nd, 3-rd, 4-th and 5-th column are 1, 1, 5 and 6, respectively, as shown in Figure 8(b). Hence, LB</span><span class="c11">col </span><span class="c7">band</span><span class="c1">(1, 8) = max(1, 1, 5,6) = 6. </span></p><p class="c13"><span class="c35">4.2.4 Pruning within Candidate Subset </span></p><p class="c0"><span class="c4">The bounds presented so far prune entire candidate subsets. If a candidate subset CS</span><span class="c5">i,j </span><span class="c12">survives these bounds, we need to consider </span><span class="c4">candidate pairs inside of it. To avoid considering all candidate pairs in CS</span><span class="c5">i,j</span><span class="c12">, here we introduce a cross-based bound that prunes candi- </span><span class="c4">date pairs within CS</span><span class="c5">i,j</span><span class="c12">. </span></p><p class="c0"><span class="c4">As introduced in Section 3, for all candidate pairs (i.e., S</span><span class="c5">i,i</span><span class="c10">e</span><span class="c4">, S</span><span class="c5">j,j</span><span class="c10">e</span><span class="c4">) in candidate set CS</span><span class="c5">i,j</span><span class="c12">, their DFD computation can be </span><span class="c4">shared via dynamic programming. Assume that at some point, the dynamic programming reaches end-cell (i</span><span class="c5">e</span><span class="c12">,j</span><span class="c5">e</span><span class="c12">), where i</span><span class="c5">e </span><span class="c12">&minus; i&gt;&xi;, </span><span class="c4">j</span><span class="c5">e </span><span class="c12">&minus; j &gt; &xi; and bsf = d</span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">). We define the following </span><span class="c4">cross-based lower bound for the end-cell: </span></p><p class="c13"><span class="c4">LB</span><span class="c11">end </span><span class="c7">cross</span><span class="c1">(i</span><span class="c7">e</span><span class="c4">,j</span><span class="c5">e</span><span class="c12">) = max (LB</span><span class="c5">row</span><span class="c12">(i</span><span class="c5">e</span><span class="c12">,j</span><span class="c5">e</span><span class="c12">), LB</span><span class="c5">col</span><span class="c12">(i</span><span class="c5">e</span><span class="c12">,j</span><span class="c5">e</span><span class="c12">)) (9) </span></p><p class="c0"><span class="c4">If (i, i</span><span class="c5">c</span><span class="c12">, j, j</span><span class="c5">c</span><span class="c12">) is a candidate in CS</span><span class="c5">i,j </span><span class="c12">where i</span><span class="c5">c </span><span class="c12">&gt; i</span><span class="c5">e </span><span class="c12">and j</span><span class="c5">c </span><span class="c12">&gt; </span><span class="c4">j</span><span class="c5">e</span><span class="c12">, it holds that LB</span><span class="c7">end </span><span class="c5">cross</span><span class="c12">(i</span><span class="c5">e</span><span class="c12">,j</span><span class="c5">e</span><span class="c12">) &le; d</span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">c</span><span class="c12">, j, j</span><span class="c5">c</span><span class="c12">). Hence, if </span><span class="c4">LB</span><span class="c11">end </span><span class="c7">cross</span><span class="c1">(i</span><span class="c7">e</span><span class="c4">,j</span><span class="c5">e</span><span class="c12">) &ge; bsf, we can safely avoid expanding cell </span><span class="c4">(i</span><span class="c5">e</span><span class="c12">,j</span><span class="c5">e</span><span class="c12">), i.e., eliminate paths within CS</span><span class="c5">i,j </span><span class="c12">that pass via cell (i</span><span class="c5">e</span><span class="c12">,j</span><span class="c5">e</span><span class="c12">). </span><span class="c21">Example: </span><span class="c4">In Figure 7(b), suppose &xi; = 2, i = 0, j = 6, i</span><span class="c5">e </span><span class="c12">= 3 </span></p><p class="c13"><span class="c3">382 </span></p><p class="c13"><span class="c4">Hence, we define the following band-based lower bounds: </span></p><p class="c13"><span class="c4">LB</span><span class="c11">row </span><span class="c7">band</span><span class="c1">(i, j) = max </span><span class="c7">j</span><span class="c29">&prime;</span><span class="c7">&isin;[j,j+&xi;&minus;1]</span><span class="c1">{LB</span><span class="c7">row</span><span class="c4">(i, j</span><span class="c11">&prime;</span><span class="c4">)} (5) LB</span><span class="c11">col </span><span class="c7">band</span><span class="c4">(i, j) = max </span><span class="c5">i</span><span class="c32">&prime;</span><span class="c5">&isin;[i,i+&xi;&minus;1]</span><span class="c4">{LB</span><span class="c5">col</span><span class="c12">(i</span><span class="c7">&prime;</span><span class="c12">,j)} (6) </span></p><p class="c13"><span class="c4">For every (i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">)&isin; CS</span><span class="c5">i,j </span><span class="c12">where i</span><span class="c5">e </span><span class="c12">&gt; i + &xi; and j</span><span class="c5">e </span><span class="c12">&gt; j + &xi; it </span><span class="c4">holds that: </span></p><p class="c13"><span class="c4">LB</span><span class="c11">row </span><span class="c7">band</span><span class="c4">(i, j) &le; d</span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">) (7) </span><span class="c4">and LB</span><span class="c11">col </span><span class="c7">band</span><span class="c4">(i, j) &le; d</span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">) (8) </span></p><p class="c13"><span class="c4">If LB</span><span class="c11">row </span><span class="c7">band</span><span class="c1">(i, j) &ge; bsf or LB</span><span class="c11">col </span><span class="c7">band</span><span class="c1">(i, j) &ge; bsf we can safely prune </span><span class="c4">CS</span><span class="c5">i,j</span><span class="c12">. </span></p><p class="c13"><span class="c4">and j</span><span class="c5">e </span><span class="c12">= 9. LB</span><span class="c7">end </span><span class="c5">cross</span><span class="c12">(i</span><span class="c5">e</span><span class="c12">,j</span><span class="c5">e</span><span class="c12">) is computed over the gray cells: </span></p><p class="c13"><span class="c4">LB</span><span class="c11">end </span><span class="c7">cross</span><span class="c4">(3,9) = max(LB</span><span class="c5">row</span><span class="c12">(3, 9), LB</span><span class="c5">col</span><span class="c12">(3, 9)) </span><span class="c4">= max</span><span class="c1">( </span></p><p class="c13"><span class="c4">min </span><span class="c5">i</span><span class="c32">&prime;</span><span class="c10">e</span><span class="c7">&isin;[3,8]</span><span class="c1">{d</span><span class="c7">G</span><span class="c4">(i</span><span class="c11">&prime;</span><span class="c7">e</span><span class="c4">,10)}, min </span><span class="c5">j</span><span class="c32">&prime;</span><span class="c10">e</span><span class="c7">&isin;[9,11]</span><span class="c1">{d</span><span class="c7">G</span><span class="c4">(4,j</span><span class="c11">&prime;</span><span class="c7">e</span><span class="c4">)}</span><span class="c1">) </span><span class="c4">= max(6,7) = 7 </span></p><p class="c13"><span class="c4">If LB</span><span class="c11">end </span><span class="c7">cross</span><span class="c1">(3,9) &ge; bsf, we prune the candidates (i.e., subtrajec- </span><span class="c4">tory pairs) in CS</span><span class="c5">0,6 </span><span class="c12">whose end-cells fall in the red dotted box. </span><span class="c49">4.3 Relaxed Lower Bounds </span></p><p class="c0"><span class="c4">If we follow the aforementioned equations directly, a cross-based bound takes O(n) time to compute and a band-based bound takes O(&xi;n) time. Although both of them are more efficient than raw DFD computation (i.e., O(n</span><span class="c11">2</span><span class="c4">)), in this section, we drop their amor- tized time complexity to O(1) by relaxing them slightly. These relaxed bounds incur no false negatives, i.e., they are guaranteed not to miss the motif. Due to the space limit, we illustrate our re- laxation approach for band-based bounds only. The relaxation of cross-based bounds follows the same lines. </span></p><p class="c0"><span class="c4">The key idea is to employ one parameter per bound, and keep them in matrices for rapid access. First, we compute the minimum value for each column i and each row j: </span></p><p class="c13"><span class="c4">C</span><span class="c5">min</span><span class="c12">[i] = min </span><span class="c5">j</span><span class="c32">&prime;</span><span class="c5">&isin;[0,j&minus;1]</span><span class="c4">(d</span><span class="c5">G</span><span class="c12">(i + 1,j</span><span class="c7">&prime;</span><span class="c12">)) (10) </span><span class="c4">R</span><span class="c5">min</span><span class="c12">[j] = min </span><span class="c5">i</span><span class="c32">&prime;</span><span class="c5">&isin;[i,n&minus;1]</span><span class="c4">(d</span><span class="c5">G</span><span class="c12">(i</span><span class="c7">&prime;</span><span class="c12">,j + 1)) (11) </span></p><p class="c13"><span class="c4">This step takes O(2 &middot; n &middot; n) = O(n</span><span class="c11">2</span><span class="c4">) time. </span></p><p class="c13"><span class="c4">We define the relaxed version of cross-based bounds as: </span></p><p class="c13"><span class="c4">rLB</span><span class="c11">start </span><span class="c7">cross</span><span class="c1">(i, j) = max{C</span><span class="c7">min</span><span class="c4">[i],R</span><span class="c5">min</span><span class="c12">[j]} (12) </span><span class="c4">rLB</span><span class="c11">end </span><span class="c7">cross</span><span class="c4">(i</span><span class="c5">e</span><span class="c12">,j</span><span class="c5">e</span><span class="c12">) = max{C</span><span class="c5">min</span><span class="c12">[i</span><span class="c5">e</span><span class="c12">],R</span><span class="c5">min</span><span class="c12">[j</span><span class="c5">e</span><span class="c12">]} (13) </span></p><p class="c13"><span class="c4">In turn, the relaxed band-based bounds are defined as: </span></p><p class="c13"><span class="c4">rLB</span><span class="c11">row </span><span class="c7">band</span><span class="c1">(j) = max </span><span class="c7">j</span><span class="c29">&prime;</span><span class="c7">&isin;[j,j+&xi;&minus;1]</span><span class="c1">{R</span><span class="c7">min</span><span class="c4">[j</span><span class="c11">&prime;</span><span class="c4">]} (14) rLB</span><span class="c11">col </span><span class="c7">band</span><span class="c1">(i) = max </span><span class="c7">i</span><span class="c29">&prime;</span><span class="c7">&isin;[i,i+&xi;&minus;1]</span><span class="c1">{C</span><span class="c7">min</span><span class="c4">[i</span><span class="c11">&prime;</span><span class="c4">]} (15) </span></p><p class="c0"><span class="c4">We compute the relaxed version of cross-based bounds by com- puting C</span><span class="c5">min</span><span class="c12">[i] and R</span><span class="c5">min</span><span class="c12">[j] for each column i and each row j. </span><span class="c4">This step takes O(n) time per column/row. Similarly, we com- pute relaxed band-based bounds for each column i and each row j. This step takes O(&xi;n) time per row/column. Thus, the total computation time of cross-based and band-based lower bounds is O(n&middot;n) = O(n</span><span class="c11">2</span><span class="c4">) and O(&xi;n&middot;n) = O(n</span><span class="c11">2</span><span class="c4">), respectively. By amor- tizing the computation time over all candidate subsets CS</span><span class="c5">i,j </span><span class="c12">(i.e., </span><span class="c4">O(n</span><span class="c11">2</span><span class="c4">) of them), the computation time per CS</span><span class="c5">i,j </span><span class="c12">for each relaxed </span><span class="c4">bound is only O(n</span><span class="c11">2</span><span class="c4">/n</span><span class="c11">2</span><span class="c4">) = O(1). </span></p><p class="c0"><span class="c4">The following lemma proves the correctness of the relaxed band- based bounds. The proof for the relaxed cross-based bounds fol- lows the same lines and is omitted for brevity. </span></p><p class="c13"><span class="c4">L</span><span class="c9">EMMA </span><span class="c4">2. It holds that: </span></p><p class="c13"><span class="c4">rLB</span><span class="c11">row </span><span class="c7">band</span><span class="c1">(j) &le; LB</span><span class="c11">row </span><span class="c7">band</span><span class="c1">(i, j) and rLB</span><span class="c11">col </span><span class="c7">band</span><span class="c1">(i) &le; LB</span><span class="c11">col </span><span class="c7">band</span><span class="c1">(i, j) </span></p><p class="c13"><span class="c4">P</span><span class="c9">ROOF</span><span class="c4">. </span></p><p class="c13"><span class="c4">min </span><span class="c5">i</span><span class="c32">&prime;</span><span class="c5">&isin;[0,j&minus;1]</span><span class="c4">(d</span><span class="c5">G</span><span class="c12">(i</span><span class="c7">&prime;</span><span class="c12">,j + 1)) &le; min </span><span class="c5">i</span><span class="c32">&prime;</span><span class="c5">&isin;[i,j&minus;1]</span><span class="c4">(d</span><span class="c5">G</span><span class="c12">(i</span><span class="c7">&prime;</span><span class="c12">,j + 1)) </span><span class="c4">&rArr; R</span><span class="c5">min</span><span class="c12">[j] &le; LB</span><span class="c5">row</span><span class="c12">(i, j) </span><span class="c4">&rArr; max </span><span class="c5">j</span><span class="c32">&prime;</span><span class="c5">&isin;[j,j+&xi;&minus;1]</span><span class="c4">{R</span><span class="c5">min</span><span class="c12">[j</span><span class="c7">&prime;</span><span class="c12">]} &le; max </span><span class="c5">j</span><span class="c32">&prime;</span><span class="c5">&isin;[j,j+&xi;&minus;1]</span><span class="c4">{LB</span><span class="c5">row</span><span class="c12">(i, j</span><span class="c7">&prime;</span><span class="c12">)} </span><span class="c4">&rArr; rLB</span><span class="c11">row </span><span class="c7">band</span><span class="c4">(j) = LB</span><span class="c11">row </span><span class="c7">band</span><span class="c4">(i, j) </span></p><p class="c13"><span class="c4">Similarly, rLB</span><span class="c11">col </span><span class="c7">band</span><span class="c1">(i) &le; LB</span><span class="c11">col </span><span class="c7">band</span><span class="c1">(i, j). </span></p><p class="c0"><span class="c4">In the experiments, we compare the effectiveness of the original bounds with the relaxed ones. We summarize the time requirements of all lower bounds in Table 3. </span></p><p class="c13"><span class="c6">Lower bound Time Relaxed bound Time LB</span><span class="c5">cell</span><span class="c6">(i, j) O(1) LB</span><span class="c11">start </span><span class="c7">cross</span><span class="c16">(i, j) O(n) rLB</span><span class="c11">start </span><span class="c7">cross</span><span class="c16">(i, j) O(1) </span><span class="c6">LB</span><span class="c11">end </span><span class="c7">cross</span><span class="c16">(i</span><span class="c7">e</span><span class="c6">,j</span><span class="c5">e</span><span class="c8">) O(n) rLB</span><span class="c7">end </span><span class="c5">cross</span><span class="c6">(i</span><span class="c5">e</span><span class="c8">,j</span><span class="c5">e</span><span class="c8">) O(1) </span><span class="c6">LB</span><span class="c11">row </span><span class="c7">band</span><span class="c16">(i, j) O(&xi;n) rLB</span><span class="c11">row </span><span class="c7">band</span><span class="c16">(j) O(1) </span><span class="c6">LB</span><span class="c11">col </span><span class="c7">band</span><span class="c16">(i, j) O(&xi;n) rLB</span><span class="c11">col </span><span class="c7">band</span><span class="c16">(i) O(1) </span></p><p class="c13"><span class="c21">Table 3: Summary of lower bounds </span></p><p class="c13"><span class="c49">4.4 Optimized Solution </span></p><p class="c13"><span class="c21">Combining all bounds: </span><span class="c4">Given a candidate subset CS</span><span class="c5">i,j</span><span class="c12">, we com- </span><span class="c4">pute a tighter lower bound for CS</span><span class="c5">i,j</span><span class="c12">, denoted by CS</span><span class="c5">i,j</span><span class="c12">.LB, using: </span></p><p class="c13"><span class="c4">max{LB</span><span class="c5">cell</span><span class="c12">(i, j), rLB</span><span class="c7">start </span><span class="c5">cross</span><span class="c12">(i, j), rLB</span><span class="c7">row </span><span class="c5">band</span><span class="c12">(j), rLB</span><span class="c7">col </span><span class="c5">band</span><span class="c12">(i)}. </span><span class="c4">This lower bound takes O(1) time because each term can be ob- tained in O(1) time, as shown in Table 3. </span><span class="c21">Prioritizing search order: </span><span class="c4">To support effective pruning of CS</span><span class="c5">i,j </span><span class="c4">by lower bounds, it is desirable to obtain a small bsf (i.e., a good temporary motif) as early as possible. Intuitively, a candidate sub- set with small CS</span><span class="c5">i,j</span><span class="c12">.LB tends to contain a candidate with small </span><span class="c4">DFD value. Thus, we propose to process CS</span><span class="c5">i,j </span><span class="c12">in ascending order </span><span class="c4">of CS</span><span class="c5">i,j</span><span class="c12">.LB. </span><span class="c21">Putting it all together: </span><span class="c4">Algorithm 2 presents the pseudocode for bounding-based trajectory motif (BTM), which incorporates all above ideas to solve the trajectory motif discovery problem. </span></p><p class="c13"><span class="c21">Algorithm 2 </span><span class="c4">BTM (Trajectory S, minLength &xi;) </span></p><p class="c13"><span class="c6">Input: trajectory S, length n, minimum motif length &xi; Output: subtrajectory pair bpair = (S</span><span class="c5">i,i</span><span class="c10">e</span><span class="c6">, S</span><span class="c5">j,j</span><span class="c10">e</span><span class="c6">) </span><span class="c12">1: </span><span class="c8">bsf &larr; +&infin;; bpair &larr; &empty;; j</span><span class="c5">end </span><span class="c6">&larr; n </span><span class="c12">2: </span><span class="c8">Compute { LB</span><span class="c5">cell</span><span class="c6">, rLB</span><span class="c11">start </span><span class="c7">cross</span><span class="c16">, rLB</span><span class="c11">end </span><span class="c7">cross</span><span class="c16">, rLB</span><span class="c11">row </span><span class="c7">band</span><span class="c16">, rLB</span><span class="c11">col </span><span class="c7">band </span><span class="c16">} </span><span class="c4">3: </span><span class="c6">Construct a list A with one element a per candidate subset </span><span class="c12">4: </span><span class="c8">Sort A in ascending order of a.LB </span><span class="c12">5: </span><span class="c26">for </span><span class="c8">each a in A with bsf &gt; a.LB </span><span class="c26">do </span><span class="c12">6: </span><span class="c26">for </span><span class="c8">i</span><span class="c5">e </span><span class="c8">&larr; a.i + 1 to a.j </span><span class="c26">do </span><span class="c12">7: </span><span class="c26">for </span><span class="c8">j</span><span class="c5">e </span><span class="c8">&larr; a.j + 1 to j</span><span class="c5">end </span><span class="c46">do </span><span class="c12">8: </span><span class="c8">tmp &larr; min(d</span><span class="c5">F </span><span class="c6">[i</span><span class="c5">e</span><span class="c8">-1][j</span><span class="c5">e</span><span class="c8">-1],d</span><span class="c5">F</span><span class="c6">[i</span><span class="c5">e</span><span class="c8">][j</span><span class="c5">e</span><span class="c8">-1],d</span><span class="c5">F </span><span class="c6">[i</span><span class="c5">e</span><span class="c8">-1][j</span><span class="c5">e</span><span class="c8">]) </span><span class="c12">9: </span><span class="c8">d</span><span class="c5">F </span><span class="c8">[i</span><span class="c5">e</span><span class="c8">][j</span><span class="c5">e</span><span class="c8">] &larr; max(d</span><span class="c5">G</span><span class="c8">(i</span><span class="c5">e</span><span class="c8">,j</span><span class="c5">e</span><span class="c8">), tmp) </span><span class="c12">10: </span><span class="c26">if </span><span class="c8">i</span><span class="c5">e </span><span class="c8">&gt; a.i + &xi;, j</span><span class="c5">e </span><span class="c8">&gt; a.j + &xi; and d</span><span class="c5">F</span><span class="c8">[i</span><span class="c5">e</span><span class="c8">][j</span><span class="c5">e</span><span class="c8">] &lt; bsf </span><span class="c26">then </span><span class="c12">11: </span><span class="c8">bsf &larr; d</span><span class="c5">F </span><span class="c6">[i</span><span class="c5">e</span><span class="c8">][j</span><span class="c5">e</span><span class="c8">];bpair &larr; (S</span><span class="c5">i,i</span><span class="c10">e</span><span class="c6">,S</span><span class="c5">j,j</span><span class="c10">e</span><span class="c6">) </span><span class="c4">12: </span><span class="c46">if </span><span class="c6">bsf &le; rLB</span><span class="c11">end </span><span class="c7">cross</span><span class="c16">(bpair.i</span><span class="c7">e</span><span class="c6">, bpair.j</span><span class="c5">e</span><span class="c8">) </span><span class="c26">then </span><span class="c12">13: </span><span class="c8">j</span><span class="c5">end </span><span class="c6">&larr; bpair.j</span><span class="c5">e </span><span class="c8">&#8882; Pruning by LB</span><span class="c7">end </span><span class="c5">cross</span><span class="c6">(i</span><span class="c5">e</span><span class="c8">,j</span><span class="c5">e</span><span class="c8">) from </span></p><p class="c39"><span class="c6">Equation 9 </span><span class="c4">14: </span><span class="c6">return bpair </span></p><p class="c0"><span class="c4">At Line 2, we first compute all lower bounds (and store them in matrices). Then, we insert each candidate subset CS</span><span class="c5">i,j </span><span class="c12">with </span><span class="c4">its bound CS</span><span class="c5">i,j</span><span class="c12">.LB into a list (at Line 3), and sort that list (at </span><span class="c4">Line 4). Next, we process the elements of the list in the sorted order. For each candidate subset, we examine its candidates via nested loops (at Lines 6-7), and compute the DFD of each candi- date (at Line 8-9). Finally, we update bsf and the temporary motif pair (at Lines 10-11). Note that Lines 12-13 implement pruning by LB</span><span class="c11">end </span><span class="c7">cross</span><span class="c4">(i</span><span class="c5">e</span><span class="c12">,j</span><span class="c5">e</span><span class="c12">), as defined in Equation 9; this essentially per- </span><span class="c4">forms pruning within the candidate subset currently considered, by disqualifying some of the candidate pairs it contains. </span></p><p class="c13"><span class="c4">The lower bounds presented in this section are also applicable to motif discovery between different trajectories. Hence, similarly </span></p><p class="c13"><span class="c3">383 </span></p><p class="c13"><span class="c4">to Algorithm 1, Algorithm 2 is readily applicable to that problem variant too. </span><span class="c21">Analysis: </span><span class="c4">The time complexity of Algorithm 2 is O(n</span><span class="c11">4</span><span class="c4">) in the worst case, which is attributed to the nested for-loops for variables a [that is, O(n</span><span class="c11">2</span><span class="c4">) iterations], i</span><span class="c5">e </span><span class="c12">[that is, O(n) iterations] and j</span><span class="c5">e </span><span class="c4">[that is, O(n) iterations] at Lines 5-7. The space complexity of Algorithm 2 is O(n</span><span class="c11">2</span><span class="c4">). </span></p><p class="c0"><span class="c4">Algorithm 2 follows the best-first search paradigm with several effective lower bounds. As we will show in the experimental eval- uation, it outperforms Algorithm 1 by two orders of magnitude. </span></p><p class="c13"><span class="c49">5. GROUPING-BASED SOLUTION </span></p><p class="c0"><span class="c4">In this section, we enhance the scalability of our techniques for long trajectories. Inspired by trajectory indexing methods [4, 9], we organize trajectory points into groups, then attempt pruning un- promising pairs of groups, before applying our solution from Sec- tion 4. To enable pruning, we design novel bounding functions for DFD on groups. </span></p><p class="c13"><span class="c21">Figure 9: Grouping-based computation framework </span></p><p class="c0"><span class="c4">We outline our grouping-based computation framework in Fig- ure 9. First, we divide a trajectory into groups of &tau; samples (where &tau; is a tunable parameter), and compute a ground distance bound for each group pair (Steps 1 and 2, in Section 5.1). Next, we apply O(1)-time lower bounds (Step 3, in Section 5.2) to prune group pairs, before using tighter bounds for pruning (Step 4, in Sec- tion 5.3). For the surviving group pairs, we repeat the above steps by halving the group size, until &tau; reaches 1. Finally, we compute the exact DFD of candidates in the surviving groups (Step 5). </span></p><p class="c0"><span class="c4">By combining the advantages of all techniques in Section 4 and in the current one, our grouping based computation framework out- performs the baseline solution by over 3 orders of magnitude. Im- portantly, all our techniques conduct only safe pruning, meaning that they produce exact answers (motifs). </span></p><p class="c13"><span class="c49">5.1 Grouping Trajectory Points </span></p><p class="c0"><span class="c4">We employ a group size parameter &tau; in order to partition a long trajectory into small groups. We proceed to define a group and the ground distances between groups. </span></p><p class="c13"><span class="c4">D</span><span class="c9">EFINITION </span><span class="c4">4 (&tau;-</span><span class="c9">GROUPING</span><span class="c4">). Given the group size &tau;, we define the u-th group as the interval g</span><span class="c5">u </span><span class="c12">= [u&tau;, (u + 1)&tau; &minus; 1]. </span></p><p class="c13"><span class="c4">For two groups g</span><span class="c5">u </span><span class="c12">and g</span><span class="c5">v</span><span class="c12">, we define the minimum and the maxi- </span></p><p class="c13"><span class="c4">mum ground distance between them as: </span></p><p class="c13"><span class="c4">d</span><span class="c11">min </span><span class="c7">G </span><span class="c4">(g</span><span class="c5">u</span><span class="c12">,g</span><span class="c5">v</span><span class="c12">) = </span><span class="c5">i&isin;g</span><span class="c12">min </span><span class="c10">u</span><span class="c7">,j&isin;g</span><span class="c10">v </span><span class="c4">d</span><span class="c5">G</span><span class="c12">(i, j) (16) </span><span class="c4">d</span><span class="c11">max </span><span class="c7">G </span><span class="c1">(g</span><span class="c7">u</span><span class="c4">,g</span><span class="c5">v</span><span class="c12">) = </span><span class="c5">i&isin;g</span><span class="c12">max </span><span class="c10">u</span><span class="c7">,j&isin;g</span><span class="c10">v </span><span class="c4">d</span><span class="c5">G</span><span class="c12">(i, j) (17) </span></p><p class="c13"><span class="c4">By Definition 4, the ground distances between two groups satisfy the following property: </span></p><p class="c13"><span class="c4">C</span><span class="c9">OROLLARY </span><span class="c4">1. For every i &isin; g</span><span class="c5">u</span><span class="c12">, j &isin; g</span><span class="c5">v</span><span class="c12">, it holds that: </span></p><p class="c13"><span class="c4">d</span><span class="c11">min </span><span class="c7">G </span><span class="c4">(g</span><span class="c5">u</span><span class="c12">,g</span><span class="c5">v</span><span class="c12">) &le; d</span><span class="c5">G</span><span class="c12">(i, j) &le; d</span><span class="c7">max </span><span class="c5">G </span><span class="c12">(g</span><span class="c5">u</span><span class="c12">,g</span><span class="c5">v</span><span class="c12">) </span></p><p class="c39"><span class="c4">We utilize this property to devise lower bound functions in Sec- tions 5.2, 5.3. </span><span class="c21">Example: </span><span class="c4">Consider a trajectory S with n = 12 points. Given &tau; = 2, we obtain six groups: g</span><span class="c5">0</span><span class="c12">,g</span><span class="c5">1</span><span class="c12">,g</span><span class="c5">2</span><span class="c12">,g</span><span class="c5">3</span><span class="c12">,g</span><span class="c5">4</span><span class="c12">,g</span><span class="c5">5</span><span class="c12">, as illustrated in Fig- </span><span class="c4">ure we min(dmaximum 9. 10(a). For example, for groups compute the minimum ground We </span><span class="c5">G</span><span class="c12">(4,10),d</span><span class="c4">show ground the </span><span class="c5">G</span><span class="c12">(4, </span><span class="c4">minimum distance </span><span class="c12">11),d</span><span class="c4">as </span><span class="c5">G</span><span class="c12">(5, </span><span class="c4">and d</span><span class="c11">max </span><span class="c7">G </span><span class="c4">g</span><span class="c5">2 </span><span class="c12">= [4, </span><span class="c4">distance </span><span class="c12">10),d</span><span class="c5">G</span><span class="c12">(5,11)) </span><span class="c1">(g</span><span class="c7">2</span><span class="c4">,g</span><span class="c5">5</span><span class="c12">) </span><span class="c4">maximum </span><span class="c12">5] </span><span class="c4">as </span><span class="c12">and </span><span class="c4">d</span><span class="c11">min </span><span class="c7">G </span><span class="c12">= g</span><span class="c5">5 </span><span class="c1">(g</span><span class="c12">= 6, </span><span class="c7">2</span><span class="c4">,g</span><span class="c12">[10,11], and </span><span class="c5">5</span><span class="c12">) the = </span></p><p class="c30"><span class="c12">= max(8, 9,6, 7) = </span><span class="c4">ground distances for group pair g</span><span class="c5">2 </span><span class="c12">and g</span><span class="c5">5 </span><span class="c12">in Figure 10(b). </span></p><p class="c13"><span class="c91">, , </span></p><p class="c13"><span class="c54">5 </span></p><p class="c13"><span class="c45">5 5 6 </span></p><p class="c13"><span class="c54">4 </span><span class="c45">4 1 5 </span></p><p class="c13"><span class="c89">3 </span><span class="c45">1 4 5 </span></p><p class="c13"><span class="c103">/ </span><span class="c52">0 1 2 3 4 5 </span><span class="c45">/ </span></p><p class="c13"><span class="c89">0 1 2 </span><span class="c9">(a) Step 1 </span></p><p class="c13"><span class="c103">(6, 9) </span></p><p class="c13"><span class="c103">Step 2 </span></p><p class="c13"><span class="c9">(b) Step 3: </span><span class="c81">, </span><span class="c9">. </span><span class="c116">(c) Step 4: ( , ) </span></p><p class="c13"><span class="c21">Figure 10: Example of 2-grouped trajectory </span></p><p class="c13"><span class="c49">5.2 Pattern-based Bounds for Groups </span></p><p class="c0"><span class="c4">To enable pruning on unpromising pairs of groups, we adapt our proposed lower bounds in Section 4 to groups. We denote the corresponding GLBGLBtion. </span></p><p class="c30"><span class="c7">cross</span><span class="c4">(u, </span><span class="c7">band</span><span class="c11">start col </span><span class="c1">(u, v). </span><span class="c4">v), lower </span><span class="c1">Later, </span><span class="c4">GLBbounds </span><span class="c1">we </span><span class="c7">cross</span><span class="c4">(u</span><span class="c11">end </span><span class="c1">discuss </span><span class="c4">with </span><span class="c5">e</span><span class="c12">,v</span><span class="c4">prefix </span><span class="c5">e</span><span class="c12">), </span><span class="c1">their O(1)-time </span><span class="c4">G, </span><span class="c12">GLB</span><span class="c4">i.e., </span><span class="c5">band</span><span class="c7">row </span><span class="c4">GLB(u, </span><span class="c1">implementa- </span><span class="c4">v), </span><span class="c5">cell</span><span class="c12">(u, </span><span class="c4">and </span><span class="c12">v), </span></p><p class="c13"><span class="c21">Cell-based lower bound: </span><span class="c4">We first define the cell-based lower bound for groups, denoted by GLB</span><span class="c5">cell</span><span class="c12">, as follows: </span></p><p class="c13"><span class="c4">GLB</span><span class="c5">cell</span><span class="c12">(u, v) = d</span><span class="c7">min </span><span class="c5">G </span><span class="c4">(g</span><span class="c5">u</span><span class="c12">,g</span><span class="c5">v</span><span class="c12">) (18) </span></p><p class="c13"><span class="c4">In and Figure j &isin; v, 10(b), it holds GLBthat </span><span class="c5">cell</span><span class="c12">(2, </span><span class="c4">GLB</span><span class="c12">5) </span><span class="c5">cell</span><span class="c12">(u, = dv) </span><span class="c7">min </span><span class="c5">G </span><span class="c4">(2, 5) = 6. For any i &isin; u </span></p><p class="c13"><span class="c12">&le; d</span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">). </span><span class="c21">Cross-based lower bounds: </span><span class="c4">Next, we show that the cross- based lower bounds for groups can be expressed in terms of GLB</span><span class="c5">cell</span><span class="c12">(u, v). We demonstrate using an example, rather than pre- </span><span class="c4">senting ugly definitions and lemmas. </span></p><p class="c30"><span class="c4">We denote the row and column based lower bounds for groups as GLB</span><span class="c5">row</span><span class="c12">(u, v) and GLB</span><span class="c5">col</span><span class="c12">(u, v), respectively. In </span><span class="c4">Figure 11(a), assuming n = 16 and &tau; = 2, we obtain GLB</span><span class="c5">row</span><span class="c12">(1, 4) = min</span><span class="c5">u</span><span class="c32">&prime;</span><span class="c5">&isin;[1,3]</span><span class="c12">(GLB</span><span class="c5">cell</span><span class="c12">(u</span><span class="c7">&prime;</span><span class="c12">,5)) = min(2, 5, 7) = </span><span class="c4">2. Similarly, GLB</span><span class="c5">col</span><span class="c12">(1, 4) = </span><span class="c4">cross-based lower bound for start-cell </span><span class="c12">min(5, 5, 6,5) = 5. The </span><span class="c4">(1,4) is GLB</span><span class="c7">cross</span><span class="c11">start </span><span class="c1">(1, 4) = </span></p><p class="c13"><span class="c3">384 </span></p><p class="c13"><span class="c52">1 1</span><span class="c98">9 7 </span><span class="c52">0 1</span><span class="c98">8 6 </span><span class="c52">9 8 </span><span class="c98">6 </span><span class="c22">5 </span></p><p class="c13"><span class="c113">4 5 </span></p><p class="c13"><span class="c22">4 </span><span class="c103">4 </span><span class="c123">, </span><span class="c50">. </span><span class="c22">(1,9) </span></p><p class="c13"><span class="c52">7 </span><span class="c45">3 (1,4) </span><span class="c48">4 </span><span class="c82">, </span><span class="c110">. </span></p><p class="c13"><span class="c9">/ </span><span class="c22">0 1 2 </span></p><p class="c13"><span class="c4">max(GLB</span><span class="c5">row</span><span class="c12">(1, 4), GLB</span><span class="c5">col</span><span class="c12">(1, 4)) = max(2,5) = 5. </span><span class="c4">GLB</span><span class="c11">end </span><span class="c7">cross</span><span class="c1">(u</span><span class="c7">e</span><span class="c4">,v</span><span class="c5">e</span><span class="c12">) is defined similarly to GLB</span><span class="c7">start </span><span class="c5">cross</span><span class="c4">(u, v). </span></p><p class="c13"><span class="c6">(a) GLB</span><span class="c11">start </span><span class="c7">cross</span><span class="c16">(1,4) (b) GLB</span><span class="c11">row </span><span class="c7">band</span><span class="c16">(0,4) </span></p><p class="c13"><span class="c21">Figure 11: Grouping based lower bounds </span></p><p class="c13"><span class="c21">Band-based lower bounds: </span><span class="c4">We also present band-based lower bounds for groups using an example. In Figure 11(b), we il- lustrate GLB</span><span class="c11">row </span><span class="c7">band</span><span class="c1">(0, 4). We compute it as GLB</span><span class="c11">row </span><span class="c7">band</span><span class="c1">(0, 4) = </span><span class="c4">max</span><span class="c5">v</span><span class="c32">&prime;</span><span class="c5">&isin;[4,5]</span><span class="c12">(GLB</span><span class="c5">row</span><span class="c12">(0,v</span><span class="c7">&prime;</span><span class="c12">)) = max(2,5) = 5. GLB</span><span class="c7">col </span><span class="c5">band</span><span class="c4">(u, v) is defined similarly to GLB</span><span class="c11">row </span><span class="c7">band</span><span class="c1">(u, v). </span><span class="c21">Relaxed lower bounds for groups: </span><span class="c4">The concept of relaxed lower bounds, introduced in Section 4.3, can be adapted directly to the above pattern-based bounds for groups. This allows us to obtain relaxed lower bounds for groups in O(1) time. </span><span class="c49">5.3 Bounding by DFD Computation </span></p><p class="c0"><span class="c4">By exploiting the recurrence of DFD, we devise a tighter lower bound and a tighter upper bound for pairs of groups. While the lower bound is used to prune unpromising pairs of groups, the up- per bound can be used to tighten bsf and thus improve the effec- tiveness of pruning. </span></p><p class="c13"><span class="c4">Below we define a subtrajectory group, together with group- based DFD bounds. </span></p><p class="c0"><span class="c4">D</span><span class="c9">EFINITION </span><span class="c4">5 (G</span><span class="c9">ROUP</span><span class="c4">-</span><span class="c9">BASED </span><span class="c4">DFD). Let subtrajectory group G</span><span class="c5">t,t</span><span class="c10">e </span><span class="c4">correspond to the interval [t&tau;, (t</span><span class="c5">e </span><span class="c12">+ 1)&tau; &minus; 1], i.e., it </span><span class="c4">covers group t to group t</span><span class="c5">e</span><span class="c12">. </span></p><p class="c13"><span class="c4">Given two subtrajectory groups G</span><span class="c5">u,u</span><span class="c10">e </span><span class="c4">and G</span><span class="c5">v,v</span><span class="c10">e</span><span class="c4">, we de- fine the group-based DFD bounds d</span><span class="c5">F min</span><span class="c12">(u, u</span><span class="c5">e</span><span class="c12">, v, v</span><span class="c5">e</span><span class="c12">) and </span><span class="c4">d</span><span class="c5">F max</span><span class="c12">(u, u</span><span class="c5">e</span><span class="c12">, v, v</span><span class="c5">e</span><span class="c12">) as: </span><span class="c4">d</span><span class="c5">F min</span><span class="c12">(u, u</span><span class="c5">e</span><span class="c12">, v, v</span><span class="c5">e</span><span class="c12">) = max</span><span class="c4">&#63729;</span><span class="c12">&#63732;&#63732;&#63732;&#63730;&#63732;&#63732;&#63732;&#63731;</span><span class="c4">d</span><span class="c11">min </span><span class="c7">G </span><span class="c1">(g</span><span class="c7">u</span><span class="c10">e</span><span class="c4">,g</span><span class="c5">v</span><span class="c10">e</span><span class="c4">) </span></p><p class="c13"><span class="c4">min</span><span class="c1">&#63729;</span><span class="c4">&#63732;</span><span class="c12">&#63730;&#63732;&#63731;</span><span class="c4">d</span><span class="c5">F min</span><span class="c12">(u, u</span><span class="c5">e </span><span class="c12">&minus; 1, v, v</span><span class="c5">e</span><span class="c12">) </span></p><p class="c30"><span class="c4">d</span><span class="c5">F min</span><span class="c12">(u, u</span><span class="c5">e </span><span class="c12">&minus; 1, v, v</span><span class="c5">e </span><span class="c12">&minus; 1) </span><span class="c4">d</span><span class="c5">F min</span><span class="c12">(u, u</span><span class="c5">e</span><span class="c12">, v, v</span><span class="c5">e </span><span class="c12">&minus; 1) </span><span class="c4">d</span><span class="c5">F max</span><span class="c12">(u, u</span><span class="c5">e</span><span class="c12">, v, v</span><span class="c5">e</span><span class="c12">) = max</span><span class="c4">&#63729;</span><span class="c12">&#63732;&#63732;&#63732;&#63730;&#63732;&#63732;&#63732;&#63731;</span><span class="c4">d</span><span class="c11">max </span><span class="c7">G </span><span class="c1">(g</span><span class="c7">u</span><span class="c10">e</span><span class="c4">,g</span><span class="c5">v</span><span class="c10">e</span><span class="c4">) </span></p><p class="c13"><span class="c4">min</span><span class="c1">&#63729;</span><span class="c4">&#63732;</span><span class="c12">&#63730;&#63732;&#63731;</span><span class="c4">d</span><span class="c5">F max</span><span class="c12">(u, u</span><span class="c5">e </span><span class="c12">&minus; 1, v, v</span><span class="c5">e</span><span class="c12">) </span></p><p class="c13"><span class="c4">d</span><span class="c5">F max</span><span class="c12">(u, u</span><span class="c5">e </span><span class="c12">&minus; 1, v, v</span><span class="c5">e </span><span class="c12">&minus; 1) </span><span class="c4">d</span><span class="c5">F max</span><span class="c12">(u, u</span><span class="c5">e</span><span class="c12">, v, v</span><span class="c5">e </span><span class="c12">&minus; 1) </span></p><p class="c13"><span class="c4">The following lemma proves the bounding property of d</span><span class="c5">F min</span><span class="c12">(u, u</span><span class="c5">e</span><span class="c12">, v, v</span><span class="c5">e</span><span class="c12">) and d</span><span class="c5">F max</span><span class="c12">(u, u</span><span class="c5">e</span><span class="c12">, v, v</span><span class="c5">e</span><span class="c12">). </span></p><p class="c0"><span class="c4">L</span><span class="c9">EMMA </span><span class="c4">3. Let G</span><span class="c5">u,u</span><span class="c10">e </span><span class="c4">and G</span><span class="c5">v,v</span><span class="c10">e </span><span class="c4">be two subtrajectory groups. If a pair of subtrajectories S</span><span class="c5">i,i</span><span class="c10">e</span><span class="c4">, S</span><span class="c5">j,j</span><span class="c10">e </span><span class="c4">satisfies i &isin; g</span><span class="c5">u</span><span class="c12">,j &isin; g</span><span class="c5">v</span><span class="c12">,i</span><span class="c5">e </span><span class="c12">&isin; </span><span class="c4">g</span><span class="c5">u</span><span class="c10">e </span><span class="c4">and j</span><span class="c5">e </span><span class="c12">&isin; g</span><span class="c5">v</span><span class="c10">e</span><span class="c4">, it holds that: </span></p><p class="c39"><span class="c4">d</span><span class="c5">F min</span><span class="c12">(u, u</span><span class="c5">e</span><span class="c12">, v, v</span><span class="c5">e</span><span class="c12">) &le; d</span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">) &le; d</span><span class="c5">F max</span><span class="c12">(u, u</span><span class="c5">e</span><span class="c12">, v, v</span><span class="c5">e</span><span class="c12">) </span><span class="c4">P</span><span class="c9">ROOF</span><span class="c4">. &forall;u</span><span class="c11">&prime; </span><span class="c4">&isin; [u, u</span><span class="c5">e</span><span class="c12">],&forall;v</span><span class="c7">&prime; </span><span class="c12">&isin; [v, v</span><span class="c5">e</span><span class="c12">] and i</span><span class="c7">&prime; </span><span class="c12">&isin; g</span><span class="c5">u</span><span class="c32">&prime;</span><span class="c4">,j</span><span class="c11">&prime; </span><span class="c4">&isin; g</span><span class="c5">v</span><span class="c32">&prime;</span><span class="c4">, according to Corollary 1, we have d</span><span class="c11">min </span><span class="c7">G </span><span class="c1">(g</span><span class="c7">u</span><span class="c29">&prime;</span><span class="c1">,g</span><span class="c7">v</span><span class="c29">&prime;</span><span class="c1">) &le; </span><span class="c4">d</span><span class="c5">G</span><span class="c12">(i</span><span class="c7">&prime;</span><span class="c12">,j</span><span class="c7">&prime;</span><span class="c12">). By Observation 1, d</span><span class="c5">F min</span><span class="c4">(u, u</span><span class="c5">e</span><span class="c12">, v, v</span><span class="c5">e</span><span class="c12">) is attributed </span></p><p class="c13"><span class="c6">(a) DFD bounds on groups (b) DFD on original trajectory </span></p><p class="c13"><span class="c21">Figure 12: Illustration of DFD bounds </span></p><p class="c0"><span class="c4">Recall that our problem definition enforces a minimum motif length &xi;. To comply with it, we define the following lower and upper bounds between two groups g</span><span class="c5">u </span><span class="c12">and g</span><span class="c5">v</span><span class="c12">: </span></p><p class="c13"><span class="c4">GLB</span><span class="c5">DF D</span><span class="c12">(u, v) = min </span><span class="c5">u</span><span class="c10">e</span><span class="c7">,v</span><span class="c10">e</span><span class="c4">{d</span><span class="c5">F min</span><span class="c12">(u, u</span><span class="c5">e</span><span class="c12">, v, v</span><span class="c5">e</span><span class="c12">) : (19) </span></p><p class="c39"><span class="c4">u</span><span class="c5">e </span><span class="c12">&minus; u &gt; </span><span class="c4">&xi;</span><span class="c12">&tau; </span><span class="c4">&and; v</span><span class="c5">e </span><span class="c12">&minus; v &gt; </span><span class="c4">&xi;</span><span class="c12">&tau; </span><span class="c4">} GUB</span><span class="c5">DF D</span><span class="c12">(u, v) = min </span><span class="c5">u</span><span class="c10">e</span><span class="c7">,v</span><span class="c10">e</span><span class="c4">{d</span><span class="c5">F max</span><span class="c12">(u, u</span><span class="c5">e</span><span class="c12">, v, v</span><span class="c5">e</span><span class="c12">) : (20) </span></p><p class="c13"><span class="c4">u</span><span class="c5">e </span><span class="c12">&minus; 1 &minus; u &gt; </span><span class="c4">&xi;</span><span class="c12">&tau; </span><span class="c4">&and; v</span><span class="c5">e </span><span class="c12">&minus; 1 &minus; v &gt; </span><span class="c4">&xi;</span><span class="c12">&tau; </span><span class="c4">} The following lemma shows their correctness. It is derived by ap- plying the min</span><span class="c5">u</span><span class="c10">e</span><span class="c7">,v</span><span class="c10">e </span><span class="c4">function to both sides of Lemma 3. </span></p><p class="c13"><span class="c4">L</span><span class="c9">EMMA </span><span class="c4">4. &forall; i &isin; g</span><span class="c5">u</span><span class="c12">, &forall; i &isin; g</span><span class="c5">v</span><span class="c12">, and i</span><span class="c5">e </span><span class="c12">&gt; i + &xi;,j</span><span class="c5">e </span><span class="c12">&gt; j + &xi; it </span><span class="c4">holds that: </span></p><p class="c13"><span class="c4">GLB</span><span class="c5">DF D</span><span class="c12">(u, v) &le; d</span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">) &le; GUB</span><span class="c5">DF D</span><span class="c12">(u, v) </span></p><p class="c0"><span class="c4">GUB</span><span class="c5">DF D</span><span class="c12">(u, v) allows us to tighten bsf, which in turn </span><span class="c4">boosts the effectiveness of pruning. Both GLB</span><span class="c5">DF D</span><span class="c12">(u, v) and </span><span class="c4">GUB</span><span class="c5">DF D</span><span class="c12">(u, v) can be computed in O(( </span><span class="c7">n</span><span class="c5">&tau; </span><span class="c4">)</span><span class="c11">2</span><span class="c4">). We can re- duce their computation cost by early termination. Specifically, if at some point during the computation of GLB</span><span class="c5">DF D</span><span class="c12">(u, v), it </span><span class="c4">holds that GLB</span><span class="c11">end </span><span class="c7">cross</span><span class="c4">(u</span><span class="c5">e</span><span class="c12">,v</span><span class="c5">e</span><span class="c12">) &ge; GLB</span><span class="c5">DF D</span><span class="c12">(u, v) with u</span><span class="c5">e </span><span class="c12">&minus; </span><span class="c4">u &gt; </span><span class="c11">&xi;</span><span class="c7">&tau; </span><span class="c1">&and; v</span><span class="c7">e </span><span class="c4">&minus; v &gt; </span><span class="c11">&xi;</span><span class="c7">&tau; </span><span class="c1">, we may safely terminate the com- </span><span class="c4">putation because &forall;u</span><span class="c5">e</span><span class="c32">&prime; </span><span class="c4">&gt; u</span><span class="c5">e </span><span class="c12">and &forall;v</span><span class="c5">e</span><span class="c32">&prime; </span><span class="c4">&gt; v</span><span class="c5">e </span><span class="c12">it must be that </span><span class="c4">d</span><span class="c5">F min</span><span class="c12">(u, u</span><span class="c5">e</span><span class="c32">&prime;</span><span class="c4">, v, v</span><span class="c5">e</span><span class="c32">&prime;</span><span class="c4">) &gt; d</span><span class="c5">F min</span><span class="c12">(u, u</span><span class="c5">e</span><span class="c12">, v, v</span><span class="c5">e</span><span class="c12">) (i.e., it cannot fur- </span><span class="c4">ther tighten the bound). Similarly, early termination is possible in the calculation of GUB</span><span class="c5">DF D</span><span class="c12">(u, v) too. </span></p><p class="c13"><span class="c49">5.4 </span><span class="c15">GTM Algorithm </span></p><p class="c0"><span class="c4">Algorithm 3 presents the pseudocode for grouping-based tra- jectory motif (GTM), which implements the computation frame- work depicted in Figure 9. We first construct groups at Line 3, then we compute the pattern-based lower bounds of group pairs at Lines 4-5. Next, we insert each grouping based candidate sub- set GCS</span><span class="c5">u,v </span><span class="c12">with its bound GCS</span><span class="c5">u,v</span><span class="c12">.LB = max(GLB</span><span class="c5">cell</span><span class="c12">(u, v), </span></p><p class="c13"><span class="c3">385 </span></p><p class="c0"><span class="c4">to a path among d</span><span class="c11">min </span><span class="c7">G </span><span class="c1">(g</span><span class="c7">u</span><span class="c29">&prime;</span><span class="c1">,g</span><span class="c7">v</span><span class="c29">&prime;</span><span class="c1">) values, and d</span><span class="c7">F</span><span class="c4">(i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">) to a </span><span class="c4">path among d</span><span class="c5">G</span><span class="c12">(i</span><span class="c7">&prime;</span><span class="c12">,j</span><span class="c7">&prime;</span><span class="c12">) values. Hence, for i &isin; g</span><span class="c5">u</span><span class="c12">,j &isin; g</span><span class="c5">v</span><span class="c12">,i</span><span class="c5">e </span><span class="c12">&isin; </span><span class="c4">g</span><span class="c5">u</span><span class="c10">e</span><span class="c4">,j</span><span class="c5">e </span><span class="c12">&isin; g</span><span class="c5">v</span><span class="c10">e</span><span class="c4">, it holds that d</span><span class="c5">F min</span><span class="c12">(u, u</span><span class="c5">e</span><span class="c12">, v, v</span><span class="c5">e</span><span class="c12">) &le; d</span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">). </span><span class="c4">d</span><span class="c5">F max</span><span class="c12">(u, u</span><span class="c5">e</span><span class="c12">, v, v</span><span class="c5">e</span><span class="c12">) &ge; d</span><span class="c5">F</span><span class="c12">(i, i</span><span class="c5">e</span><span class="c12">, j, j</span><span class="c5">e</span><span class="c12">) is proven similarly. </span></p><p class="c0"><span class="c21">Example: </span><span class="c4">Consider two subtrajectory groups G</span><span class="c5">1,2 </span><span class="c12">and G</span><span class="c5">4,5 </span><span class="c12">in </span><span class="c4">Figure 12(a) and assume that n = 12. Their DFD bounds are d</span><span class="c5">F min</span><span class="c12">(1,2,4, 5) = 5 and d</span><span class="c5">F max</span><span class="c12">(1, 2, 4,5) = 8, respec- </span><span class="c4">tively. In Figure 12(b), the pair of subtrajectories S</span><span class="c5">3,5</span><span class="c12">, S</span><span class="c5">8,10 </span><span class="c12">has </span><span class="c4">d</span><span class="c5">F</span><span class="c12">(3, 5, 8, 10) = 7. In accordance with Lemma 3, this distance </span><span class="c4">falls indeed into range [5, 8]. </span></p><p class="c0"><span class="c4">rGLB</span><span class="c11">start </span><span class="c7">cross</span><span class="c4">(u, v),rGLB</span><span class="c11">row </span><span class="c7">band</span><span class="c1">(u, v),rGLB</span><span class="c11">col </span><span class="c7">band</span><span class="c1">(u, v)) into a list. </span><span class="c4">Then, we process the list in ascending order of GCS</span><span class="c5">u,v</span><span class="c12">.LB, and </span><span class="c4">apply DFD bounds for pruning (Lines 10-11) or for tightening the bsf (Lines 12-13). After that, we halve the group size and repeat the above procedure on the set of surviving groups S</span><span class="c5">survive </span><span class="c12">until </span><span class="c4">the group size drops to 1. When this happens (i.e., &tau; = 1), each element in S</span><span class="c5">survive </span><span class="c12">is a candidate subset CS</span><span class="c5">i,j</span><span class="c12">. We invoke Algo- </span><span class="c4">rithm 2 on S</span><span class="c5">survive </span><span class="c12">to obtain the final result. </span></p><p class="c13"><span class="c21">Algorithm 3 </span><span class="c4">GTM (Trajectory S, minLength &xi;, group size &tau;) </span></p><p class="c13"><span class="c6">Input: trajectory S, length n, minimum motif length &xi;, group size &tau; Output: subtrajectory pair bpair = (S</span><span class="c5">i,i</span><span class="c10">e</span><span class="c6">,S</span><span class="c5">j,j</span><span class="c10">e</span><span class="c6">) </span><span class="c12">1: </span><span class="c8">bsf &larr; +&infin;; bpair &larr; &empty; </span><span class="c12">2: </span><span class="c26">while </span><span class="c8">&tau; &gt; 1 </span><span class="c26">do </span><span class="c12">3: </span><span class="c8">Group trajectory S to G &#8882; Section 5.1 </span><span class="c12">4: </span><span class="c8">Compute GLB</span><span class="c5">cell</span><span class="c6">,rGLB</span><span class="c11">start </span><span class="c7">cross</span><span class="c16">,rGLB</span><span class="c11">end </span><span class="c7">cross </span><span class="c12">5: </span><span class="c8">and rGLB</span><span class="c7">row </span><span class="c5">band</span><span class="c6">,rGLB</span><span class="c11">col </span><span class="c7">band </span><span class="c16">&#8882; Section 5.2 </span><span class="c4">6: </span><span class="c6">Construct a list GA of candidate subsets </span><span class="c12">7: </span><span class="c8">Sort GA in ascending order of Ga.LB </span><span class="c12">8: </span><span class="c8">S</span><span class="c5">survive </span><span class="c8">&larr; &empty; &#8882; set of surviving groups </span><span class="c12">9: </span><span class="c26">for </span><span class="c8">each Ga in GA with bsf &gt; Ga.LB </span><span class="c26">do </span><span class="c8">&#8882; Section 5.3 </span><span class="c12">10: </span><span class="c26">if </span><span class="c8">bsf &gt; GLB</span><span class="c5">DF D</span><span class="c8">(Ga.u,Ga.v) </span><span class="c26">then </span><span class="c12">11: </span><span class="c8">S</span><span class="c5">survive </span><span class="c8">&larr; S</span><span class="c5">survive </span><span class="c8">&cup; Ga.u &cup; Ga.v </span><span class="c4">12: </span><span class="c46">if </span><span class="c6">bsf &gt; GUB</span><span class="c5">DF D</span><span class="c6">(Ga.u,Ga.v) </span><span class="c46">then </span><span class="c12">13: </span><span class="c8">bsf &larr; GUB</span><span class="c5">DF D</span><span class="c8">(Ga.u, Ga.v) </span><span class="c4">14: </span><span class="c6">&tau; &larr; &tau;/2, S&larr;S</span><span class="c5">survive </span><span class="c4">15: </span><span class="c6">Invoke Lines 5-13 in Alg. 2 on S</span><span class="c5">survive </span><span class="c8">to compute the result bpair </span></p><p class="c0"><span class="c21">Example: </span><span class="c4">We demonstrate the grouping-based computation frame- work in Figure 10. Assume that the minimum trajectory motif length is &xi; = 2 with bsf = 5. We first assign these subtrajectories into groups (with &tau; = 2), as illustrated in Figure 10(a). Consider two subtrajectories S</span><span class="c5">0,5 </span><span class="c12">and S</span><span class="c5">6,11</span><span class="c12">. We compute O(1)-time pattern- </span><span class="c4">based bounds to prune group pairs; the pruned pairs are shown in gray in Figure 10(b). Then, we compute GLB</span><span class="c5">DF D</span><span class="c12">, GUB</span><span class="c5">DF D </span><span class="c4">bounds for surviving pairs, as illustrated in Figure 10(c). The upper bounds allow us to tighten bsf (to 4), whereas the lower bounds are used to prune pairs (i.e., the gray region in Figure 10(c)). Finally, we process the two surviving cells with Algorithm 2. </span></p><p class="c13"><span class="c4">The group lower bounds developed in this section are directly applicable to motif discovery between different trajectories, and the adaptation of Algorithm 3 to that variant is straightforward. </span><span class="c21">Analysis: </span><span class="c4">The computation cost of the while-loop (Lines 2&ndash;14) is O(</span><span class="c1">&sum;</span><span class="c7">log(&tau;) </span></p><p class="c0"><span class="c7">i=1 </span><span class="c1">( </span><span class="c11">c</span><span class="c24">i</span><span class="c5">&tau; </span><span class="c4">)</span><span class="c11">4</span><span class="c4">), where c</span><span class="c5">1 </span><span class="c12">= n and c</span><span class="c5">i </span><span class="c12">is the number of surviving </span><span class="c4">groups in iteration i. Line 16 takes O(c&tau; </span><span class="c11">2</span><span class="c4">n</span><span class="c11">2</span><span class="c4">) time, where c is the number of surviving groups after the while-loop. In summary, the time complexity of Algorithm 3 is O(</span><span class="c1">&sum;</span><span class="c7">log(&tau;) </span></p><p class="c0"><span class="c7">i=1 </span><span class="c1">( </span><span class="c11">c</span><span class="c24">i</span><span class="c5">&tau; </span><span class="c4">)</span><span class="c11">4 </span><span class="c4">+ c&tau; </span><span class="c11">2</span><span class="c4">n</span><span class="c11">2</span><span class="c4">). In the worst case, Algorithm 3 degenerates to Algorithm 2, with time complexity O(n</span><span class="c11">4</span><span class="c4">). </span></p><p class="c0"><span class="c4">The space complexity of the algorithm is O(n</span><span class="c11">2</span><span class="c4">) as it employs two 2-dimensional matrices for precomputed ground distances (i.e., d</span><span class="c5">G</span><span class="c12">[&middot;][&middot;]) and DFD values (i.e., d</span><span class="c5">F</span><span class="c12">[&middot;][&middot;]). In addition, it takes </span><span class="c4">O(( </span><span class="c11">n</span><span class="c7">&tau; </span><span class="c1">)</span><span class="c11">2</span><span class="c4">) space for precomputed group based lower bounds in GA at Line 6. </span></p><p class="c13"><span class="c49">5.5 Space-efficient </span><span class="c15">GTM: GTM</span><span class="c16">&lowast; </span></p><p class="c0"><span class="c4">We present a space-efficient variant of GTM, called GTM</span><span class="c11">&lowast;</span><span class="c4">. It incorporates three ideas: (i) during DFD computation, we compute ground distances on-the-fly, (ii) implement DFD computation with O(n) space, and (iii) execute the while-loop only once for a given &tau;. Idea (i) eliminates the need for precomputed ground distances (i.e., d</span><span class="c5">G</span><span class="c12">[&middot;][&middot;]). Idea (ii) is feasible because, in Lines 8-9 of Algo- </span><span class="c4">rithm 2, we examine at most two rows of d</span><span class="c5">F</span><span class="c12">[&middot;][&middot;] at the same time. </span></p><p class="c13"><span class="c4">Idea (iii) requires only O(( </span><span class="c11">n</span><span class="c7">&tau; </span><span class="c1">)</span><span class="c11">2</span><span class="c4">) space. Thus, the space complexity of GTM</span><span class="c11">&lowast; </span><span class="c4">is O(max{( </span><span class="c11">n</span><span class="c7">&tau; </span><span class="c1">)</span><span class="c11">2</span><span class="c4">,n}). </span></p><p class="c0"><span class="c4">The time complexity of GTM</span><span class="c11">&lowast; </span><span class="c4">is O(( </span><span class="c11">n</span><span class="c7">&tau; </span><span class="c1">)</span><span class="c11">4 </span><span class="c4">+ c</span><span class="c11">&prime;</span><span class="c4">&tau; </span><span class="c11">2</span><span class="c4">n</span><span class="c11">2</span><span class="c4">), where c</span><span class="c11">&prime; </span><span class="c4">is the number of group pairs that survive pruning by Idea (i). Since GTM</span><span class="c11">&lowast; </span><span class="c4">executes the while-loop only once for a given &tau; (Idea iii), the value of c</span><span class="c11">&prime; </span><span class="c4">in GTM</span><span class="c11">&lowast; </span><span class="c4">is expected to be larger than c in GTM. </span></p><p class="c13"><span class="c49">6. EMPIRICAL EVALUATION </span></p><p class="c0"><span class="c4">In this section, we evaluate the performance of our solutions on real data. Section 6.1 introduces the experimental setting. Sec- tion 6.2 studies the effectiveness of our pruning techniques (e.g., lower bounds and grouping). Section 6.3 compares the perfor- mance of different methods with respect to various parameters. </span></p><p class="c13"><span class="c49">6.1 Experimental Setup </span></p><p class="c13"><span class="c4">We used three real trajectory datasets from moving people, vehi- cles and animals. We note that these datasets have different char- acteristics (such as sampling frequency and data distribution) thus helping us verify the generality of our findings. The details of each dataset are as follows. </span><span class="c21">GeoLife</span><span class="c11">1</span><span class="c21">: </span><span class="c4">This GPS trajectory dataset was collected in the Geo- Life project by Microsoft. The trajectories were recorded by differ- ent GPS loggers and GPS-phones, and therefore they have differ- ent sampling rates. Each trajectory is a sequence of time-stamped points, each with a latitude, a longitude and an altitude. This dataset contains 17,621 trajectories with a total distance of 1.2 million kilo- meters. </span><span class="c21">Truck</span><span class="c11">2</span><span class="c21">: </span><span class="c4">This dataset contains 276 trajectories of 50 trucks moving in Athens metropolitan area in Greece. The trucks were carrying concrete to several construction sites for 33 days. </span><span class="c21">Wild-Baboon</span><span class="c11">3</span><span class="c21">: </span><span class="c4">This dataset was collected from wild olive ba- boons at Mpala Research Centre in Kenya [23]. It contains 25 trajectories of baboons with a custom-designed GPS collar that recorded a location every second from 1-st August to 14-th August, 2012. </span></p><p class="c0"><span class="c4">In our experiments, we report the average measurements over 10 different trajectories of the same length. The response times reported include the precomputation time of distances and lower bounds. For each dataset, we concatenate raw trajectories in order to build longer trajectories. By default, we fix the motif length threshold &xi; to 100, and the trajectory length n to 5000. </span></p><p class="c0"><span class="c4">We used C++ for the implementation and conducted all experi- ments (with single thread) on a machine with an Intel Core i7- 4770 3.40GHz processor. We compare the following methods: </span></p><p class="c13"><span class="c4">&bull; the baseline solution BruteDP (cf. Algorithm 1) </span></p><p class="c13"><span class="c4">&bull; the bounding-based solution BTM (cf. Algorithm 2) </span></p><p class="c13"><span class="c4">&bull; the grouping-based solution GTM (cf. Algorithm 3) </span></p><p class="c13"><span class="c4">&bull; the space-efficient solution GTM</span><span class="c11">&lowast; </span><span class="c4">(cf. Section 5.5) </span></p><p class="c13"><span class="c49">6.2 Pruning Effectiveness </span></p><p class="c0"><span class="c4">We first assess the effectiveness of our pruning techniques, par- ticularly of our lower bounds and grouping. For the purposes of this subsection, we present results only on the GeoLife dataset. Results on Truck and Wild-Baboon are similar and are omitted in the inter- est of space. </span></p><p class="c13"><span class="c7">1</span><span class="c42">http://research.microsoft.com/en-us/projects/geolife/default.aspx </span><span class="c7">2</span><span class="c42">http://chorochronos.datastories.org/ </span><span class="c7">3</span><span class="c42">https://www.datarepository.movebank.org/handle/10255/move.405 </span></p><p class="c13"><span class="c3">386 </span></p><p class="c13"><span class="c27">% </span><span class="c19">d enurps etadidnacf o</span><span class="c23">Tight Relaxed </span></p><p class="c13"><span class="c23">Tight </span></p><p class="c13"><span class="c27">100% </span></p><p class="c13"><span class="c19">100 </span></p><p class="c13"><span class="c23">Relaxed </span></p><p class="c13"><span class="c27">95% </span></p><p class="c13"><span class="c27">90% </span><span class="c19">10 </span><span class="c27">85% </span></p><p class="c13"><span class="c27">1 1K 5K 10K Trajectory length </span><span class="c6">(a) Pruning ratio (b) Response time </span></p><p class="c13"><span class="c21">Figure 13: </span><span class="c41">BTM</span><span class="c21">, effect of trajectory length </span><span class="c4">n </span></p><p class="c13"><span class="c27">80% </span></p><p class="c30"><span class="c19">) ces(e mite snopse</span><span class="c27">R80% 1K 5K 10K </span></p><p class="c13"><span class="c27">Trajectory length </span></p><p class="c13"><span class="c19">d enurps etadidnacf o</span><span class="c23">Tight Relaxed </span></p><p class="c13"><span class="c19">10000 </span></p><p class="c13"><span class="c19">1000 100 10 </span><span class="c27">% 1 100 200 300 </span></p><p class="c13"><span class="c27">Minimum motif length </span></p><p class="c30"><span class="c19">) ces(e mite snopse</span><span class="c27">R</span><span class="c23">Tight </span><span class="c27">100% </span></p><p class="c13"><span class="c23">Relaxed </span></p><p class="c13"><span class="c27">95% </span></p><p class="c13"><span class="c27">90% </span></p><p class="c13"><span class="c27">85% </span></p><p class="c13"><span class="c27">100 200 300 </span></p><p class="c13"><span class="c27">Minimum motif length </span><span class="c6">(a) Pruning ratio (b) Response time </span></p><p class="c13"><span class="c21">Figure 14: </span><span class="c41">BTM</span><span class="c21">, effect of minimum motif length </span><span class="c4">&xi; </span></p><p class="c13"><span class="c35">6.2.1 Effectiveness of Relaxed Bounds </span></p><p class="c0"><span class="c4">We first compare two variants of BTM that use: (i) only the tight lower bounds from Section 4.2, and (ii) only the relaxed lower bounds from Section 4.3. </span></p><p class="c0"><span class="c4">In Figure 13, we compare the tight with the relaxed bounds by varying the trajectory length n, with &xi; fixed to 100. The pruning percentage in Figure 13(a) corresponds to the ratio of candidate pairs successfully pruned to the total number of candidate pairs. Note that because the percentage is high, and in order to show enough detail, we truncated the y-axis of the plot to start from 80%. In Figure 13(b), we show the overall response time to com- pute the motif. We observe that the relaxed bounds are only slightly weaker in pruning power, but they are orders of magnitude faster computation-wise. </span></p><p class="c0"><span class="c4">In Figure 14, we investigate the effectiveness and performance of tight and relaxed bounds as a function of the minimum motif length &xi;, with n fixed to 5000. Again, although the tight bounds have slightly higher pruning ratio (in Figure 14(a)), the relaxed bounds render motif computation 10 times faster (in Figure 14(b)). Since the relaxed bounds perform much better, we adopt them in our framework (instead of the tight ones) and use them in the sub- sequent experiments. </span></p><p class="c13"><span class="c35">6.2.2 Effectiveness of Lower Bounds </span></p><p class="c0"><span class="c4">In the next experiment, we compare the pruning effectiveness of the different lower bound functions (LB</span><span class="c5">cell</span><span class="c12">, rLB</span><span class="c5">cross</span><span class="c12">, rLB</span><span class="c5">band</span><span class="c12">) </span><span class="c4">using BTM. Each bar in Figure 15 corresponds to the total number of candidate pairs, broken down into the fraction pruned by each of the 3 types of bounds, and the fraction of the surviving pairs that required exact DFD computation (labeled as DFD in the bar charts). In Figures 15(a),(b) we vary the trajectory length n and the minimum motif length &xi;, respectively. The bars are truncated to start at ratio 50% to retain detail, because the percentage of LB</span><span class="c5">cell </span><span class="c4">hugely dominates the rest. </span></p><p class="c0"><span class="c4">Over 92% of the candidates can be collectively pruned by our lower bounds. An interesting observation is that the bounds complement each other. For instance, when &xi; increases (in Figure 15(b)), although LB</span><span class="c5">cell </span><span class="c12">deteriorates, rLB</span><span class="c5">band </span><span class="c12">becomes </span><span class="c4">stronger, thus eliminating many of the candidates that survived </span></p><p class="c13"><span class="c27">% </span><span class="c19">d enurps etadidnacf o</span><span class="c23">LB</span><span class="c37">cell </span><span class="c23">rLB</span><span class="c37">band </span><span class="c33">rLB</span><span class="c37">cross </span></p><p class="c13"><span class="c23">DFD </span></p><p class="c13"><span class="c27">% Trajectory length </span><span class="c19">d enurps etadidnacf o</span><span class="c23">LB</span><span class="c37">cell </span><span class="c23">rLB</span><span class="c37">band </span><span class="c33">rLB</span><span class="c37">cross </span></p><p class="c13"><span class="c23">DFD </span><span class="c27">100% </span></p><p class="c13"><span class="c27">50% 1K 5K 10K </span></p><p class="c13"><span class="c27">Minimum motif length </span><span class="c6">(a) Effect of trajectory length n (b) Effect of minimum motif length &xi; </span></p><p class="c13"><span class="c21">Figure 15: </span><span class="c41">BTM</span><span class="c21">, pruning ratio breakdown </span></p><p class="c13"><span class="c19">100 </span></p><p class="c13"><span class="c19">10 </span><span class="c27">1 1K 5K 10K </span></p><p class="c13"><span class="c27">100% 90% </span></p><p class="c13"><span class="c27">90% 80% </span></p><p class="c13"><span class="c27">80% 70% </span></p><p class="c13"><span class="c27">70% 60% </span></p><p class="c13"><span class="c27">60% 50% </span></p><p class="c13"><span class="c27">100 200 300 </span></p><p class="c13"><span class="c27">R</span><span class="c19">10000 ) ces(e mite snopse</span><span class="c83">LB</span><span class="c60">cell </span><span class="c33">LB</span><span class="c37">cell</span><span class="c23">+rLB</span><span class="c37">cross </span><span class="c33">LB</span><span class="c37">cell</span><span class="c23">+rLB</span><span class="c37">cross</span><span class="c23">+rLB</span><span class="c37">band </span><span class="c19">) </span></p><p class="c30"><span class="c19">ces(e mite snopse</span><span class="c27">R</span><span class="c19">1000 100 </span><span class="c27">10 </span><span class="c77">1 </span><span class="c23">LB</span><span class="c37">cell </span><span class="c33">LB</span><span class="c37">cell</span><span class="c23">+rLB</span><span class="c37">cross </span><span class="c33">LB</span><span class="c37">cell</span><span class="c23">+rLB</span><span class="c37">cross</span><span class="c23">+rLB</span><span class="c37">band </span><span class="c27">100 200 300 Trajectory lengthMinimum motif length </span><span class="c6">(a) Effect of trajectory length n (b) Effect of minimum motif length &xi; </span></p><p class="c13"><span class="c21">Figure 16: </span><span class="c41">BTM</span><span class="c21">, response time </span></p><p class="c13"><span class="c4">LB</span><span class="c5">cell</span><span class="c12">. This renders our methodology robust to different problem </span><span class="c4">settings. </span></p><p class="c0"><span class="c4">Next, we compare three variants of BTM that use: (i) LB</span><span class="c5">cell </span><span class="c12">only, (ii) LB</span><span class="c5">cell</span><span class="c12">, rLB</span><span class="c5">cross </span><span class="c12">only, and (iii) </span><span class="c4">LB</span><span class="c5">cell</span><span class="c12">, rLB</span><span class="c5">cross</span><span class="c12">, rLB</span><span class="c5">band</span><span class="c12">. We vary the trajectory length </span><span class="c4">n and the minimum motif length &xi; in Figures 16(a),(b), respec- tively. The results verify that the bounds complement each other gracefully, and that the performance gains achieved are not due to just one or some of them. </span></p><p class="c13"><span class="c35">6.2.3 Effect of Group Size </span><span class="c107">&tau; </span></p><p class="c0"><span class="c4">In GTM (Algorithm 3), the initial group size &tau; influences the pruning effectiveness and the computation cost of the algorithm. Generally, when &tau; is small, group-based pruning has a high pruning power but it requires high computation cost. In contrast, when &tau; is large, group-based pruning becomes faster but it becomes less effective. Figure 17 plots the response time of GTM for different values of &tau; (x-axis) and trajectory length n (as indicated by the label of each line). We observe that the response time is not overly sensitive to &tau;. In the following experiments, we set &tau; = 32 by default as it seems to work well in all cases. </span></p><p class="c13"><span class="c49">6.3 Performance Evaluation </span></p><p class="c0"><span class="c4">We compare the performance of our solutions (BTM, GTM, and GTM</span><span class="c11">&lowast;</span><span class="c4">) with the baseline (BruteDP) on the real datasets (GeoLife, Truck, and Wild-Baboon). Recall that GTM</span><span class="c11">&lowast; </span><span class="c4">is the space-efficient version of GTM. </span></p><p class="c13"><span class="c4">Figure 18 plots the average response time for different trajectory </span></p><p class="c13"><span class="c19">100 </span></p><p class="c13"><span class="c86">1K 5K 10K </span></p><p class="c13"><span class="c19">10 1 </span><span class="c27">0.1 8 16 32 64 128 </span></p><p class="c13"><span class="c21">Figure 17: </span><span class="c41">GTM</span><span class="c21">, effect of group size </span><span class="c4">&tau; </span></p><p class="c13"><span class="c3">387 </span></p><p class="c13"><span class="c124">) ces(e mite snopse</span><span class="c65">R&tau; </span></p><p class="c13"><span class="c20">0.01 </span><span class="c14">10000 1000 100 10 1 </span><span class="c20">R</span><span class="c14">0.1 </span><span class="c20">0.5K 1K 5K 10K </span></p><p class="c13"><span class="c14">10000 ) ces(e mite snopse1000 100 10 </span><span class="c25">GTM* </span><span class="c14">1 </span><span class="c44">GTM BTM BruteDP </span><span class="c20">R0.1 </span><span class="c40">0.01 </span><span class="c20">0.5K 1K 5K 10K Trajectory length</span><span class="c14">10000 </span></p><p class="c13"><span class="c14">) ces(e mite snopse</span><span class="c25">GTM* </span><span class="c44">GTM BTM BruteDP </span><span class="c14">) </span></p><p class="c30"><span class="c14">ces(e mite snopse</span><span class="c20">R</span><span class="c14">1000 100 10 </span><span class="c20">1 </span><span class="c40">0.1 </span><span class="c20">0.5K 1K 5K 10K Trajectory length</span><span class="c25">GTM* </span><span class="c44">GTM BTM BruteDP </span></p><p class="c13"><span class="c20">Trajectory length</span><span class="c4">(a) GeoLife (b) Truck (c) Wild-Baboon </span></p><p class="c13"><span class="c21">Figure 18: Response time vs. trajectory length </span><span class="c4">n </span></p><p class="c13"><span class="c14">) BM(n oitpmusnoce cap</span><span class="c20">S</span><span class="c14">10000 1000 100 10 </span><span class="c20">1 </span><span class="c44">GTM* GTM BTM </span></p><p class="c13"><span class="c20">0.5K 1K 5K 10K </span></p><p class="c13"><span class="c14">10000 </span></p><p class="c13"><span class="c44">GTM* </span></p><p class="c13"><span class="c14">1000 100 10 </span><span class="c20">1 0.5K 1K 5K 10K </span></p><p class="c13"><span class="c14">10000 </span></p><p class="c13"><span class="c44">GTM BTM </span></p><p class="c13"><span class="c14">1000 100 10 </span><span class="c20">1 0.5K 1K 5K 10K Trajectory length </span></p><p class="c13"><span class="c14">) BM(n oitpmusnoce cap</span><span class="c20">STrajectory length </span></p><p class="c39"><span class="c14">) BM(n oitpmusnoce cap</span><span class="c20">S</span><span class="c44">GTM* GTM BTM </span></p><p class="c13"><span class="c20">Trajectory length </span><span class="c4">(a) GeoLife (b) Truck (c) Wild-Baboon </span></p><p class="c13"><span class="c21">Figure 19: Space requirements vs. trajectory length </span><span class="c4">n </span></p><p class="c39"><span class="c14">10000 ) ces(e mite snopse</span><span class="c20">R</span><span class="c14">1000 100 10 </span><span class="c44">GTM* GTM BTM </span></p><p class="c13"><span class="c20">1 100 200 300 400 </span></p><p class="c13"><span class="c14">10000 </span></p><p class="c13"><span class="c44">GTM* </span><span class="c14">1000 100 10000 </span></p><p class="c30"><span class="c44">GTM BTM </span><span class="c14">1000 100 </span><span class="c20">10 10 100 200 300 400 </span></p><p class="c13"><span class="c20">100 200 300 400 Minimum motif length </span></p><p class="c13"><span class="c14">) ces(e mite snopse</span><span class="c20">RMinimum motif length </span></p><p class="c39"><span class="c14">) ces(e mite snopse</span><span class="c20">R</span><span class="c44">GTM* GTM BTM </span></p><p class="c13"><span class="c20">Minimum motif length </span><span class="c4">(a) GeoLife (b) Truck (c) Wild-Baboon </span></p><p class="c13"><span class="c21">Figure 20: Response time vs. minimum motif length </span><span class="c4">&xi; </span></p><p class="c13"><span class="c14">) ces(e mite snopse</span><span class="c20">R</span><span class="c14">1000 100 10 1 0.1 </span><span class="c34">GTM* </span><span class="c20">0.01 0.5K 1K 5K 10K </span></p><p class="c13"><span class="c14">1000 </span></p><p class="c13"><span class="c14">100 10 1 </span><span class="c95">GTM </span><span class="c20">0.1 </span><span class="c34">GTM* </span><span class="c95">BTM </span><span class="c40">0.01 </span><span class="c20">0.5K 1K 5K 10K </span></p><p class="c13"><span class="c14">1000 </span></p><p class="c13"><span class="c14">100 10 1 </span><span class="c95">GTM </span><span class="c20">0.1 </span><span class="c95">BTM </span><span class="c40">0.01 </span><span class="c20">0.5K 1K 5K 10K Trajectory length </span></p><p class="c13"><span class="c14">) ces(e mite snopse</span><span class="c20">RTrajectory length </span></p><p class="c13"><span class="c14">) ces(e mite snopse</span><span class="c20">R</span><span class="c34">GTM* </span><span class="c95">GTM BTM </span></p><p class="c13"><span class="c20">Trajectory length </span><span class="c4">(a) GeoLife (b) Truck (c) Wild-Baboon </span></p><p class="c13"><span class="c21">Figure 21: Response time vs. trajectory length </span><span class="c4">n</span><span class="c21">, two input trajectories </span></p><p class="c13"><span class="c3">388 </span></p><p class="c71"><span class="c4">lengths n while fixing &xi; = 100. BruteDP is prohibitively slow even for small trajectories (e.g., n = 1000), thus, we terminate it when it exceeds 2 hours. For the settings where it does terminate within reasonable time, our advanced solutions (i.e., GTM, GTM</span><span class="c11">&lowast;</span><span class="c4">) outperform it by 3 orders of magnitude. GTM is the fastest algo- rithm, with GTM</span><span class="c11">&lowast; </span><span class="c4">usually the runner-up. Due to the clear ineffi- ciency of BruteDP, we exclude it from the following experiments. In Figure 19, we plot the space requirements of BTM, GTM, and GTM</span><span class="c11">&lowast; </span><span class="c4">for the same experiment as Figure 18. All methods consume more memory as the trajectory length n increases. As anticipated analytically, the space requirements of BTM and GTM increase sharply with n, but those of GTM</span><span class="c11">&lowast; </span><span class="c4">are linear to it. Hence, we consider GTM</span><span class="c11">&lowast; </span><span class="c4">as the method of choice for very long trajec- tories, and the method that strikes the most favourable trade-off between time and space efficiency. </span></p><p class="c55"><span class="c4">In Figure 20, we measure response time as we vary the minimum trajectory motif length &xi; (with n fixed to 5000). The relative per- formance of the methods is the same as in the previous experiment. The response time of all solutions increases with &xi;. That is because a large &xi; disqualifies short motifs with small DFDs, thus making it harder to identify early a small bsf that enables aggressive pruning (see also Figure 14(a)). </span></p><p class="c75"><span class="c4">For completeness, we evaluate our algorithms for motif discov- ery between different trajectories too. In Figure 21, we randomly select 10 pairs of input trajectories (from the corresponding real dataset) and report the average response time when varying their length n (for fixed &xi; = 100). The results demonstrate the efficiency of our approaches in this problem variant too. Their performance is very similar to the case of single input trajectory (Problem 1). The same holds when we vary &xi; as well as when we measure space requirements; we omit the respective plots to avoid duplication. </span></p><p class="c78"><span class="c49">7. CONCLUSION </span></p><p class="c125"><span class="c4">In this paper, we study the trajectory motif discovery problem us- ing the discrete Fr&eacute;chet distance (DFD). Our contributions include (i) a suite of novel lower bound functions for DFD, (ii) a grouping- based solution that leverages on multi-level pruning to discover the trajectory motif, and (iii) a space-optimized approach that is both time and space efficient. Our fastest solution is over 3 orders of magnitude faster than the baseline solution. All our algorithms are exact. A promising direction for future work is to devise ap- proximate solutions that trade exactness for shorter running times. Another challenging direction is to apply similar optimizations in order to accelerate other trajectory analysis operations that rely on DFD, such as similarity join, subtrajectory clustering, etc. </span></p><p class="c31"><span class="c49">Acknowledgement </span><span class="c4">Man Lung Yiu and Bo Tang were supported by grant GRF 152043/15E from the Hong Kong RGC. Kyriakos Mouratidis was supported by the National Research Foundation, Prime Minister&rsquo;s Office, Singapore under its International Research Centres in Sin- gapore Funding Initiative. </span></p><p class="c128"><span class="c49">8. REFERENCES </span><span class="c8">[1] P. K. Agarwal, R. B. Avraham, H. Kaplan, and M. Sharir. Computing </span></p><p class="c126"><span class="c6">the discrete fr&eacute;chet distance in subquadratic time. SIAM Journal on Computing, 43(2), 2014. [2] S. Brakatsoulas, D. Pfoser, R. Salas, and C. Wenk. On map-matching </span></p><p class="c102"><span class="c6">vehicle tracking data. In VLDB, 2005. [3] K. Buchin, M. Buchin, J. Gudmundsson, M. L&ouml;ffler, and J. Luo. </span></p><p class="c66"><span class="c6">Detecting commuting patterns by clustering subtrajectories. IJCGA, 21(03), 2011. [4] V. P. Chakka, A. Everspaugh, and J. M. Patel. Indexing large </span></p><p class="c119"><span class="c6">trajectory data sets with SETI. In CIDR, 2003. </span></p><p class="c13 c104"><span class="c6">[5] E. W. Chambers and Y. Wang. Measuring similarity between curves </span></p><p class="c112"><span class="c6">on 2-manifolds via homotopy area. In Annual Symposium on Computational Geometry, 2013. [6] L. Chen, M. T. &Ouml;zsu, and V. Oria. Robust and fast similarity search </span></p><p class="c87"><span class="c6">for moving object trajectories. In SIGMOD, 2005. [7] S. Dodge. Exploring movement using similarity analysis. PhD thesis, </span></p><p class="c108"><span class="c6">2011. [8] T. Eiter and H. Mannila. Computing discrete fr&eacute;chet distance. Technical report, Information Systems Department, Technical University of Vienna, 1994. [9] E. Frentzos, K. Gratsias, and Y. Theodoridis. Index-based most </span></p><p class="c67"><span class="c6">similar trajectory search. In ICDE, 2007. [10] J. Gudmundsson, P. Laube, and T. Wolle. Computational movement </span></p><p class="c88"><span class="c6">analysis. In Springer handbook of geographic information. 2011. [11] J. Gudmundsson, A. Thom, and J. Vahrenhold. Of motifs and goals: </span></p><p class="c53"><span class="c6">mining trajectory data. In GIS, 2012. [12] J. Gudmundsson and N. Valladares. A gpu approach to subtrajectory </span></p><p class="c118"><span class="c6">clustering using the fr&eacute;chet distance. IEEE Transactions on Parallel and Distributed Systems, 26(4), 2015. [13] H. Jeung, M. L. Yiu, X. Zhou, C. S. Jensen, and H. T. Shen. </span></p><p class="c97"><span class="c6">Discovery of convoys in trajectory databases. PVLDB, 1(1), 2008. [14] C. Jia, M. B. Carson, and J. Yu. A fast weak motif-finding algorithm </span></p><p class="c105"><span class="c6">based on community detection in graphs. BMC bioinformatics, 14(1), 2013. [15] M.-P. Kwan. Interactive geovisualization of activity-travel patterns using three-dimensional geographical information systems: a methodological exploration with a large data set. Transportation Research Part C: Emerging Technologies, 8(1), 2000. [16] J.-G. Lee, J. Han, and K.-Y. Whang. Trajectory clustering: a </span></p><p class="c79 c93"><span class="c6">partition-and-group framework. In SIGMOD, 2007. [17] X. Li, J. Han, S. Kim, and H. Gonzalez. Roam: Rule-and motif-based anomaly detection in massive moving object data sets. In SDM, volume 7, 2007. [18] Y. Li, U. Leong Hou, M. L. Yiu, and Z. Gong. Quick-motif: An </span></p><p class="c96"><span class="c6">efficient and scalable framework for exact motif discovery. ICDE, 2015. [19] A. Mueen, E. J. Keogh, Q. Zhu, S. Cash, and M. B. Westover. Exact </span></p><p class="c43"><span class="c6">discovery of time series motifs. In SDM, 2009. [20] T. Oates, A. P. Boedihardjo, J. Lin, C. Chen, S. Frankenstein, and </span></p><p class="c72"><span class="c6">S. Gandhi. Motif discovery in spatial trajectories using grammar inference. In CIKM, 2013. [21] R. W. Sinnott. Virtues of the haversine. Sky and Telescope, 68(2), </span></p><p class="c85"><span class="c6">1984. [22] R. Sriraghavendra, K. Karthik, and C. Bhattacharyya. Fr&eacute;chet </span></p><p class="c79"><span class="c6">distance based approach for searching online handwritten documents. In ICDAR, volume 1. IEEE, 2007. [23] A. Strandburg-Peshkin, D. R. Farine, I. D. Couzin, and M. C. </span></p><p class="c68"><span class="c6">Crofoot. Shared decision-making drives collective movement in wild baboons. Science, 348(6241), 2015. [24] K. Toohey and M. Duckham. Trajectory similarity measures. </span></p><p class="c58"><span class="c6">SIGSPATIAL Special, 7(1), 2015. [25] G. Trajcevski, H. Ding, P. Scheuermann, R. Tamassia, and D. Vaccaro. Dynamics-aware similarity of moving objects trajectories. In GIS. ACM, 2007. [26] M. Vlachos, G. Kollios, and D. Gunopulos. Discovering similar </span></p><p class="c64"><span class="c6">multidimensional trajectories. In ICDE, 2002. [27] T. Wylie and B. Zhu. Protein chain pair simplification under the </span></p><p class="c111"><span class="c6">discrete fr&eacute;chet distance. IEEE/ACM Transactions on Computational Biology and Bioinformatics, 10(6), 2013. [28] B.-K. Yi, H. Jagadish, and C. Faloutsos. Efficient retrieval of similar </span></p><p class="c74"><span class="c6">time sequences under time warping. In ICDE, 1998. [29] Y. Yu, L. Cao, E. A. Rundensteiner, and Q. Wang. Detecting moving </span></p><p class="c79 c93"><span class="c6">object outliers in massive-scale trajectory streams. In SIGKDD, 2014. [30] F. Zambelli, G. Pesole, and G. Pavesi. Motif discovery and </span></p><p class="c47"><span class="c6">transcription factor binding sites before and after the next-generation sequencing era. Briefings in bioinformatics, 2012. [31] Y. Zheng. Trajectory data mining: an overview. TIST, 6(3), 2015. [32] Y. Zheng, L. Zhang, X. Xie, and W.-Y. Ma. Mining interesting </span></p><p class="c100"><span class="c6">locations and travel sequences from gps trajectories. In WWW, 2009. </span></p><p class="c90"><span class="c3">389 </span></p></body></html>