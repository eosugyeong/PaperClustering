<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c58{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:16.6pt;font-family:"Times New Roman";font-style:normal}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10pt;font-family:"Times New Roman";font-style:italic}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Times New Roman";font-style:italic}.c8{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10pt;font-family:"Times New Roman";font-style:italic}.c14{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:13.3pt;font-family:"Times New Roman";font-style:italic}.c16{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11.1pt;font-family:"Arial";font-style:normal}.c63{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.6pt;font-family:"Arial";font-style:normal}.c25{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7pt;font-family:"Times New Roman";font-style:normal}.c40{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:6pt;font-family:"Arial";font-style:normal}.c34{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9.2pt;font-family:"Arial";font-style:normal}.c35{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8.1pt;font-family:"Courier New";font-style:normal}.c39{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:5.8pt;font-family:"Arial";font-style:normal}.c26{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.2pt;font-family:"Times New Roman";font-style:normal}.c19{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5pt;font-family:"Arial";font-style:normal}.c55{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.4pt;font-family:"Arial";font-style:normal}.c17{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:13.3pt;font-family:"Times New Roman";font-style:normal}.c41{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:13.3pt;font-family:"Times New Roman";font-style:italic}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Times New Roman";font-style:normal}.c7{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Times New Roman";font-style:italic}.c62{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Times New Roman";font-style:italic}.c9{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7pt;font-family:"Times New Roman";font-style:italic}.c29{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Times New Roman";font-style:normal}.c30{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:9.1pt;font-family:"Arial";font-style:normal}.c66{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Courier New";font-style:normal}.c64{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Courier New";font-style:normal}.c61{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11.5pt;font-family:"Arial";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Times New Roman";font-style:normal}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.6pt;font-family:"Arial";font-style:normal}.c28{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.9pt;font-family:"Arial";font-style:normal}.c70{margin-left:-16.6pt;padding-top:6pt;text-indent:16.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-25.4pt}.c15{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.1pt;font-family:"Arial";font-style:normal}.c50{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9.1pt;font-family:"Arial";font-style:normal}.c37{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:9.4pt;font-family:"Arial";font-style:normal}.c65{margin-left:-16.6pt;padding-top:6pt;text-indent:16.9pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-25.4pt}.c22{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.5pt;font-family:"Times New Roman";font-style:normal}.c73{margin-left:-25.4pt;padding-top:3.8pt;text-indent:34.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-21.4pt}.c45{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11.2pt;font-family:"Arial";font-style:normal}.c21{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c57{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Courier New";font-style:normal}.c43{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8.3pt;font-family:"Arial";font-style:normal}.c31{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5pt;font-family:"Courier New";font-style:italic}.c23{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:17.9pt;font-family:"Times New Roman";font-style:normal}.c38{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c56{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c72{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:15.4pt;font-family:"Arial";font-style:normal}.c71{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11.6pt;font-family:"Times New Roman";font-style:italic}.c27{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10.1pt;font-family:"Arial";font-style:normal}.c49{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11.6pt;font-family:"Times New Roman";font-style:normal}.c60{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11.3pt;font-family:"Arial";font-style:normal}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c32{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.5pt;font-family:"Arial";font-style:normal}.c48{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.3pt;font-family:"Times New Roman";font-style:italic}.c52{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.3pt;font-family:"Arial";font-style:normal}.c54{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9.3pt;font-family:"Arial";font-style:normal}.c11{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Times New Roman";font-style:italic}.c13{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Times New Roman";font-style:italic}.c36{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Courier New";font-style:normal}.c46{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:9.3pt;font-family:"Arial";font-style:normal}.c20{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Times New Roman";font-style:normal}.c24{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.5pt;font-family:"Arial";font-style:normal}.c51{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Times New Roman";font-style:normal}.c33{margin-left:-23.8pt;padding-top:56.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-24pt}.c74{margin-left:-25.4pt;padding-top:15.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:106.5pt}.c67{margin-left:-16.6pt;padding-top:22.1pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-25.4pt}.c44{margin-left:-25.4pt;padding-top:37.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.4pt}.c18{margin-left:-25.4pt;padding-top:58.1pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.4pt}.c69{margin-left:5pt;padding-top:28.6pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-22.6pt}.c68{margin-left:44.6pt;padding-top:19.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:44.6pt}.c42{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c12{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c6{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c10{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c47{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c59{margin-left:25.4pt;margin-right:16.3pt}.c53{margin-left:-22.9pt;margin-right:5.3pt}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:24pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:14pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c47"><p class="c68"><span class="c23">Monitoring MaxRS in Spatial Data Streams </span></p><p class="c69"><span class="c21">Daichi Amagata </span><span class="c58">Department of Multimedia Engineering Graduate School of Information Science and Technology Osaka University </span><span class="c1">amagata.daichi@ist.osaka-u.ac.jp </span></p><p class="c12 c53"><span class="c21">Takahiro Hara </span><span class="c58">Department of Multimedia Engineering Graduate School of Information Science and Technology Osaka University </span><span class="c1">hara@ist.osaka-u.ac.jp </span></p><p class="c44"><span class="c21">ABSTRACT </span><span class="c1">Due to the increase of GPS enabled devices and a lot of location- based services, spatial objects are continuously generated. This pa- per addresses a problem of monitoring MaxRS (Maximizing Range Sum) in spatial data streams. Given a set of weighted spatial (2- dimensional) objects, this problem is to monitor a location of a given user-specified sized rectangle where the sum of the weights of the objects covered by the rectangle is maximized. Many real life applications obtain a benefit from monitoring MaxRS, e.g., traffic analysis and event detection in urban sensing, but this problem has not yet been addressed so far. Although some algorithms for static objects have been proposed, executing such an algorithm whenever new objects are generated is computationally expensive. These mo- tivate us to develop an efficient algorithm that can monitor MaxRS efficiently. In this paper, we first design a basic algorithm that is based on an index framework and incrementally updates the result. We then enhance the algorithm and show that the enhanced algo- rithm can deal with error-guaranteed approximation and monitor- ing top-k MaxRS. Our experimental results confirm the efficiency of our approach. </span></p><p class="c74"><span class="c21">1. INTRODUCTION </span></p><p class="c73"><span class="c1">Due to the increase of GPS enabled devices such as smartphones and tablet machines, a lot of location-based services are used in many real life applications. From this fact, spatio-temporal databases have been receiving significant attention recently. Supporting spa- tial queries is therefore becoming more important, and many stud- ies developed techniques for efficient spatial query processing [13, 15]. These studies can be classified into spatial objects retrieval problems [3, 24] and location finding problems [10, 32, 33]. For ex- ample, </span><span class="c2">k</span><span class="c1">NN query processing, which retrieves the </span><span class="c2">k </span><span class="c1">nearest neigh- bor objects w.r.t. a given query point, is the representative of the spatial objects retrieval problems. In the location finding problems, on the other hand, some queries have been proposed, for exam- ple, optimal location queries [10, 33], bichromatic reverse nearest neighbor queries [14, 35], and MaxRS (Maximizing Range Sum) queries [6, 8, 9, 25]. This paper focuses on a kind of MaxRS prob- lem. </span></p><p class="c18"><span class="c1">c</span><span class="c2">&#8413;</span><span class="c20">2016, Copyright is with the authors. Published in Proc. 19th Inter- national Conference on Extending Database Technology (EDBT), March 15-18, 2016 - Bordeaux, France: ISBN 978-3-89318-070-7, on OpenPro- ceedings.org. Distribution of this paper is permitted under the terms of the Creative Commons license CC-by-nc-nd 4.0 </span></p><p class="c10 c59"><span class="c1">Figure 1: An example of a MaxRS query </span></p><p class="c67"><span class="c1">Motivation. Given a set of weighted spatial (2-dimensional) ob- jects and a user-specified sized rectangle, a MaxRS query finds a location of the rectangle where the sum of the weights of the ob- jects covered by the rectangle is maximized. </span></p><p class="c70"><span class="c1">E</span><span class="c26">XAMPLE </span><span class="c1">1.1. </span><span class="c2">Figure 1 shows an example of a MaxRS query. In Figure 1, the rectangle with dashed line, the black points, and the rectangles with solid line show a general monitoring space, spatial objects with weight 1, and user-specified sized rectangles, respectively. The MaxRS query identifies the location of the shaded rectangle as one of the optimal results because it covers the largest number of objects, i.e., the sum of the weights of objects covered by the rectangle is the maximum. </span><span class="c1">This query is useful because it can automatically find an impor- tant place without specifying any query points [8, 9]. In this pa- per, we address a novel problem of monitoring MaxRS in spatial data streams. In other words, we address a problem of continu- ous MaxRS query processing over sliding-window. Since a large amount of spatio-temporal objects are </span><span class="c2">continuously generated </span><span class="c1">[2, 5], e.g., in the context of location-based service usages, one-time finding an important location does not make sense but continuously monitoring an important location is required. A continuous MaxRS query can achieve this and has the following real life applications. </span></p><p class="c65"><span class="c1">E</span><span class="c26">XAMPLE </span><span class="c1">1.2. </span><span class="c2">Consider urban sensing. A system, e.g., base- station, continuously collects spatio-temporal objects, e.g., gener- ated by devices with GPS, in an urban city. Such objects can be represented as &lt; x,y,w &gt; where x, y, and w are latitude, lon- gitude, and weight, respectively. If w is communication traffic, a continuous MaxRS query can monitor an area where traffic is con- centrated. In this case, the system can notify the users holding mobile devices in the area of warning about communication delay. </span><span class="c1">Example 1.2 shows that continuous MaxRS queries can help to ana- lyze communication errors and also support decision making, e.g., where to place Wi-Fi access points. We next consider location- </span></p><p class="c33"><span class="c38">Series ISSN: 2367-2005 317 </span><span class="c57">10.5441/002/edbt.2016.30 </span></p><p class="c10"><span class="c1">based games in which continuous MaxRS queries are useful for decision making. E</span><span class="c26">XAMPLE </span><span class="c1">1.3. </span><span class="c2">In BotFighters, players try not to be attacked by other players [4], and in Ingress, players try to occupy places. Let w in Example 1.2 represent the strength or level of a given player, and players keep checking the area monitored by a contin- uous MaxRS query. This can detect an event, e.g., a competition by many and/or high-level players, and support to plan a strategy. </span></p><p class="c6"><span class="c1">Other examples include mobile sensor networks [27] that a base- station continuously collects sensor readings. By employing con- tinuous MaxRS queries, the base-station may be able to detect sen- sor failures and over-concentration of mobile sensor nodes. </span></p><p class="c6"><span class="c1">Technical challenge and overview. Some techniques for exact MaxRS query processing on static objects have been developed in the past. [12, 18] proposed in-memory algorithms while [8, 9] pro- posed an external-memory algorithm. The computation (I/O) com- plexity of the in-memory (external-memory) algorithm is shown to be optimal. These algorithms however focus on </span><span class="c2">one-time </span><span class="c1">computa- tion, so they are not efficient for continuous MaxRS queries. This is because computing the result from scratch whenever new ob- jects are generated is obviously computationally expensive, mean- ing that an approach which can incrementally update the result is required. </span></p><p class="c6"><span class="c1">In this paper, we first propose a basic algorithm that exploits a graph in grid index, namely G2. G2 integrates graph and grid struc- tures, thus its storage cost is </span><span class="c2">O</span><span class="c1">(</span><span class="c2">|V |</span><span class="c1">+</span><span class="c2">|E|</span><span class="c1">), where </span><span class="c2">V </span><span class="c1">corresponds to a set of objects on a given sliding-window and </span><span class="c2">E </span><span class="c1">is a set of edges. (The details are described in Section 4). One of the properties of G2 is that no overhead incurs when objects expire. We then en- hance both the basic algorithm and G2, and propose aggregate G2, aG2, and a branch-and-bound algorithm that exploits aG2. This algorithm eliminates unnecessary update computation as much as possible and accelerates the query processing efficiency. </span></p><p class="c10"><span class="c1">Interestingly, the branch-and-bound algorithm can deal with error- guaranteed approximation. Let </span><span class="c2">w</span><span class="c8">&lowast; </span><span class="c1">and </span><span class="c2">&epsilon; </span><span class="c1">respectively be the maxi- mum range sum and a user-tolerance error rate. Also, let </span><span class="c2">w </span><span class="c1">be the weight of the area monitored by the algorithm, and we can guaran- tee that </span><span class="c2">w &ge; </span><span class="c1">(1 </span><span class="c2">&minus; &epsilon;</span><span class="c1">)</span><span class="c2">w</span><span class="c8">&lowast;</span><span class="c1">. We show that the relationship between query processing efficiency and </span><span class="c2">&epsilon; </span><span class="c1">is trade-off but the practical er- ror rate is much less than </span><span class="c2">&epsilon;</span><span class="c1">. In addition to the approximation, we consider a problem of monitoring top-k MaxRS. For example, Ex- amples 1.2 and 1.3 may require not only a single area but </span><span class="c2">k </span><span class="c1">(e.g., 5) areas with the largest range sum. This requirement is satisfied by a simple modification of the branch-and-bound algorithm. Contributions and organization. We summarize our contribu- tions as follows. </span></p><p class="c6"><span class="c2">&bull; </span><span class="c1">We address a novel problem of continuous MaxRS query processing in spatial data streams (Section 2). To the best of our knowledge, we are the first to investigate this problem. </span></p><p class="c6"><span class="c2">&bull; </span><span class="c1">We design a basic algorithm for a continuous MaxRS query (Section 4). This algorithm incrementally updates the result by exploiting an efficient index framework. </span></p><p class="c6"><span class="c2">&bull; </span><span class="c1">We enhance the basic algorithm and propose a more efficient index and branch-and-bound algorithm (Section 5). This al- gorithm prunes unnecessary computation and accelerates the computation efficiency. </span></p><p class="c6"><span class="c2">&bull; </span><span class="c1">We show that the branch-and-bound algorithm can deal with error-guaranteed approximation and efficient continuous top- k MaxRS query processing (Section 6). </span></p><p class="c6"><span class="c2">&bull; </span><span class="c1">We conduct extensive experiments using both synthetic and real datasets that confirm the efficiency of our approach (Sec- tion 7). </span></p><p class="c10"><span class="c1">In addition to the above contents, we review some related literatures in Section 3, and Section 8 concludes this paper. </span></p><p class="c10"><span class="c21">2. PRELIMINARY </span></p><p class="c6"><span class="c1">We are given a set of spatial stream objects in a general mon- itoring space, as shown in Figure 1. A spatial object </span><span class="c2">o</span><span class="c4">i </span><span class="c5">is repre- </span><span class="c1">sented by </span><span class="c2">o</span><span class="c13">i </span><span class="c1">=</span><span class="c2">&lt; x,y,w &gt; </span><span class="c1">where </span><span class="c2">i </span><span class="c1">is its identifier, </span><span class="c2">&lt; x,y &gt; </span><span class="c1">shows the location that </span><span class="c2">o</span><span class="c4">i </span><span class="c5">is generated, and </span><span class="c7">w </span><span class="c5">is a non-negative </span><span class="c1">value (weight), i.e., </span><span class="c2">o</span><span class="c4">i</span><span class="c7">.w &isin; </span><span class="c5">R</span><span class="c29">+</span><span class="c5">. We assume a spatial stream en- </span><span class="c1">vironment, thus consider a sliding-window model [1] because it is usual that many applications are interested only in recent ob- jects. Count- and time-based sliding-window models are widely accepted. The count-based sliding-window considers the most re- cent </span><span class="c2">n </span><span class="c1">objects, and in this model, </span><span class="c2">m </span><span class="c1">new objects generations lead to the expirations of the </span><span class="c2">m </span><span class="c1">oldest objects. The time-based sliding- window, on the other hand, considers the objects generated within the last </span><span class="c2">T </span><span class="c1">time-units. Selection of a suitable sliding-window model depends on applications, and our algorithms can deal with both the models. So, without loss of generality, we assume the count-based sliding-window in this paper. Let </span><span class="c2">O </span><span class="c1">be the set of the most recent </span><span class="c2">n </span><span class="c1">objects, and </span><span class="c2">O </span><span class="c1">residents in-memory because real-time continuous query processing generally requires main memory computation [4, 17].</span><span class="c5">Let </span><span class="c7">P </span><span class="c5">be an infinite set of points in the general monitoring space. </span><span class="c1">Given a user-specified sized rectangle </span><span class="c2">r</span><span class="c1">, the weight of a point </span><span class="c2">p &isin; P</span><span class="c1">, </span><span class="c2">p.w</span><span class="c1">, is defined by </span></p><p class="c10"><span class="c2">p.w </span><span class="c1">= </span><span class="c51">&sum;</span><span class="c2">o</span><span class="c13">i</span><span class="c2">.w, </span></p><p class="c10"><span class="c1">where </span><span class="c2">o</span><span class="c4">i </span><span class="c7">&isin; O </span><span class="c5">is covered by </span><span class="c7">r </span><span class="c5">centered at </span><span class="c7">p</span><span class="c5">. We are now ready to </span><span class="c1">formally define the monitoring MaxRS problem. D</span><span class="c26">EFINITION </span><span class="c1">1 (</span><span class="c26">MONITORING </span><span class="c1">M</span><span class="c26">AX</span><span class="c1">RS </span><span class="c26">PROBLEM</span><span class="c1">). </span><span class="c2">Given a set of objects on a sliding-window O, an infinite set of points in the gen- eral monitoring space, and a user-specified sized rectangle r, the goal of the monitoring MaxRS problem is to continuously monitor a location p</span><span class="c8">&lowast; </span><span class="c2">&isin; P that satisfies. </span></p><p class="c10"><span class="c2">p</span><span class="c8">&lowast; </span><span class="c1">= argmax </span></p><p class="c10"><span class="c13">p &isin;P </span><span class="c62">p.w. </span></p><p class="c10"><span class="c1">It is infeasible to find and monitor </span><span class="c2">p</span><span class="c8">&lowast; </span><span class="c1">from such infinite points, but as the literatures [8, 9, 25] introduce, MaxRS problems can be solved by transformation to an alternative problem. Given a user-specified sized rectangle </span><span class="c2">r</span><span class="c1">, let </span><span class="c2">r</span><span class="c13">i </span><span class="c1">be the weighted rectangle of the same size of </span><span class="c2">r </span><span class="c1">centered at </span><span class="c2">&lt; o</span><span class="c4">i</span><span class="c7">.x, o</span><span class="c4">i</span><span class="c7">.y &gt; </span><span class="c5">(</span><span class="c7">o</span><span class="c4">i </span><span class="c7">&isin; O </span><span class="c5">and </span><span class="c2">r</span><span class="c13">i</span><span class="c2">.w </span><span class="c1">= </span><span class="c2">o</span><span class="c13">i</span><span class="c2">.w</span><span class="c1">). Consider </span><span class="c2">o</span><span class="c13">i</span><span class="c2">,o</span><span class="c13">j </span><span class="c2">&isin; O</span><span class="c1">, and if </span><span class="c2">r</span><span class="c13">i </span><span class="c1">overlaps with </span><span class="c2">r</span><span class="c13">j</span><span class="c1">, it is not difficult to see that the weight of the overlapped space </span><span class="c2">s </span><span class="c1">is </span><span class="c2">s.w </span><span class="c1">= </span><span class="c2">r</span><span class="c4">i</span><span class="c7">.w </span><span class="c5">+ </span><span class="c7">r</span><span class="c4">j</span><span class="c7">.w</span><span class="c5">. We formally define this </span><span class="c7">space weight</span><span class="c5">. </span><span class="c1">D</span><span class="c26">EFINITION </span><span class="c1">2 (S</span><span class="c26">PACE WEIGHT </span><span class="c1">[8]). </span><span class="c2">Given O, we have a set of rectangles each of which is centered at the location of the corre- sponding object. The weight of a space s is the sum of the weights of the rectangles covering s. </span><span class="c1">Then the alternative problem is to find </span><span class="c2">s </span><span class="c1">with the maximum weight denoted by </span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c1">. Interestingly but not surprisingly, </span><span class="c2">p</span><span class="c8">&lowast; </span><span class="c1">exists in </span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c1">, that is, any points in </span><span class="c2">s</span><span class="c8">&lowast; </span><span class="c1">can be </span><span class="c2">p</span><span class="c8">&lowast;</span><span class="c1">. E</span><span class="c26">XAMPLE </span><span class="c1">2.1. </span><span class="c2">Figure 2 shows the alternative problem of Figure 1. The center of each rectangle is at the corresponding object. Note that the size of each rectangle is the user-specified size. Recall that the weight of each object is 1, and the shaded overlapped space has </span></p><p class="c10"><span class="c38">318 </span></p><p class="c10"><span class="c1">Figure 2: An example of the alternative problem of Figure 1 </span></p><p class="c10"><span class="c2">the maximum weight. We know that the weights of other overlapped spaces are less than 4. The center of the shaded rectangle in Figure 1 exists in the shaded space. </span><span class="c1">Therefore, monitoring </span><span class="c2">s</span><span class="c8">&lowast; </span><span class="c1">is equivalent to monitoring </span><span class="c2">p</span><span class="c8">&lowast;</span><span class="c1">. We here define continuous MaxRS queries that solve the monitoring MaxRS problem. D</span><span class="c26">EFINITION </span><span class="c1">3 (</span><span class="c26">CONTINUOUS </span><span class="c1">M</span><span class="c26">AX</span><span class="c1">RS </span><span class="c26">QUERY</span><span class="c1">). </span><span class="c2">Given a set of objects on a sliding-window O and a user-specified sized rectan- gle r, each weighted object is converted to a weighted rectangle centered at the location of the object. A continuous MaxRS query monitors s</span><span class="c8">&lowast; </span><span class="c2">that satisfies</span><span class="c7">s</span><span class="c13">&lowast; </span><span class="c5">= argmax </span></p><p class="c10"><span class="c13">s &isin;S </span><span class="c62">s.w, </span><span class="c51">(1) </span></p><p class="c10"><span class="c2">where S is the set of overlapped spaces. </span></p><p class="c6"><span class="c1">We also consider a problem of monitoring top-k MaxRS to sup- port the applications that require not only a single space but also </span><span class="c2">k </span><span class="c1">spaces with the maximum weight. The definition of monitoring top-k MaxRS problem is given by extending Definition 1, thus we formally define continuous top-k MaxRS queries below. </span></p><p class="c6"><span class="c1">D</span><span class="c26">EFINITION </span><span class="c1">4 (</span><span class="c26">CONTINUOUS TOP</span><span class="c1">-</span><span class="c26">K </span><span class="c1">M</span><span class="c26">AX</span><span class="c1">RS </span><span class="c26">QUERY</span><span class="c1">). </span><span class="c2">Given a set of objects on a sliding-window O and a user-specified sized rectangle r, each weighted object is converted to a weighted rect- angle centered at the location of the object. A continuous top-k MaxRS query monitors the set S</span><span class="c8">&lowast; </span><span class="c2">that satisfies |S</span><span class="c8">&lowast;</span><span class="c2">| </span><span class="c1">= </span><span class="c2">k and &forall;s &isin; S</span><span class="c8">&lowast; </span><span class="c2">and &exist;s</span><span class="c8">&prime; </span><span class="c2">&isin; S\S</span><span class="c8">&lowast;</span><span class="c2">, s.w &ge; s</span><span class="c8">&prime;</span><span class="c2">.w where S is the set of overlapped spaces, and ties are arbitrarily broken. </span></p><p class="c6"><span class="c1">Since applications that execute continuous queries basically re- quire real-time monitoring [3, 4, 17], algorithms that process such queries have to update query results efficiently. Our objective of this paper is therefore to minimize computation time to update </span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c1">, which is incurred by generations and expirations of objects. Table 1 summarizes the symbols frequently used in this paper. </span></p><p class="c10"><span class="c21">3. RELATED WORK </span></p><p class="c6"><span class="c1">As introduced in Section 1, many spatial queries have been de- veloped. This section reviews related works of the monitoring MaxRS problem. In particular, we introduce spatial preference queries and facility location queries in which MaxRS queries are categorized. We then review the existing studies of MaxRS query processing. </span></p><p class="c6"><span class="c1">Before introducing the above queries, we should make it clear that MaxRS queries are different from range aggregation queries. The goal of range aggregation queries is to return the aggregate result (e.g., values and points) from (i) the set of points in a given rectangle with </span><span class="c2">fixed location </span><span class="c1">[19, 21, 23] or (ii) the set of values in a given interval [26]. On the other hand, the goal of MaxRS queries is </span></p><p class="c10"><span class="c1">Table 1: Overview of symbols Symbol Description </span></p><p class="c10"><span class="c2">o</span><span class="c13">i </span><span class="c1">The weighted spatial object with identifier </span><span class="c2">i m </span><span class="c1">The number of objects generated at the same time </span><span class="c2">s</span><span class="c8">&lowast; </span><span class="c1">The space with the maximum weight </span><span class="c2">r</span><span class="c4">i </span><span class="c5">The weighted rectangle centered at the location of </span><span class="c7">o</span><span class="c4">i </span><span class="c2">r</span><span class="c13">i</span><span class="c2">.E </span><span class="c1">The set of edges held by </span><span class="c2">r</span><span class="c13">i </span><span class="c2">N</span><span class="c1">(</span><span class="c2">r</span><span class="c4">i</span><span class="c5">) The set of neighboring vertices (rectangles) of </span><span class="c7">r</span><span class="c4">i </span></p><p class="c10"><span class="c2">s</span><span class="c4">i </span><span class="c5">The space with the maximum weight covered by </span><span class="c7">r</span><span class="c4">i </span><span class="c2">c</span><span class="c13">i,j </span><span class="c1">The cell with identifier (</span><span class="c2">i, j</span><span class="c1">) </span><span class="c2">G</span><span class="c4">i,j </span><span class="c5">The graph maintained by </span><span class="c7">c</span><span class="c4">i,j </span><span class="c2">V</span><span class="c13">i,j </span><span class="c1">The set of vertices (rectangles) of </span><span class="c2">G</span><span class="c13">i,j </span><span class="c2">c</span><span class="c4">i,j</span><span class="c7">.w </span><span class="c5">The upper-bound weight of </span><span class="c7">c</span><span class="c4">i,j </span></p><p class="c6"><span class="c1">to </span><span class="c2">find a location </span><span class="c1">from an infinite set of points. In the same sense, continuous spatial queries [15, 16, 17] that monitor not locations but objects are different from our problem. </span></p><p class="c10"><span class="c1">Spatial preference queries. Spatial preference query processing problem is one of location selection problems. Given a 2-dimensional point </span><span class="c2">p </span><span class="c1">and a distance constraint </span><span class="c2">d</span><span class="c1">, a top-k spatial preference query [22, 29] determines the score of </span><span class="c2">p </span><span class="c1">by the sum of the weights of the feature objects existing within </span><span class="c2">d </span><span class="c1">from </span><span class="c2">p</span><span class="c1">. [28] studies a problem of finding top-</span><span class="c2">t </span><span class="c1">most influential sites. The influential score of a given site is defined as the sum of weights of its reverse nearest neighbor objects. In the above queries, the scores of the target points are defined by a kind of range sum function. However, the locations of the target points are already known, which is different from our problem. </span></p><p class="c6"><span class="c1">Facility location queries. The objective of this problem is to find an optimal location w.r.t. a given condition. It is often the case that a set of customers (or clients) with weights and a set of facilities are given [11]. Then a facility location query retrieves a facility that maximizes the total weight of its reverse (</span><span class="c2">k</span><span class="c1">) nearest neighbor customers [35]. [10] proposed optimal location queries, and the extension version of the optimal location queries, min-dist optimal location queries, has been studied in [20, 32]. Such optimal loca- tion queries have also been studied in road networks [7]. </span></p><p class="c10"><span class="c1">The monitoring MaxRS problem is also one of the facility lo- cation problems. We are interested in continuously monitoring a location that maximizes the total weight of objects covered by a user-specified sized rectangle. As introduced in Section 1, this is useful in monitoring applications in spatial data streams. The main deference between MaxRS and the above queries is their cat- egories: </span><span class="c2">monotonic </span><span class="c1">(e.g., MaxRS queries) and </span><span class="c2">bichromatic </span><span class="c1">(e.g., optimal location queries). MaxRS queries. To the best of our knowledge, the existing works of MaxRS problems and the variants are [6, 8, 9, 12, 18, 25]. An external-memory algorithm for exact MaxRS queries has been pro- posed in [8, 9], while [25] proposed a randomized sampling algo- rithm that bounds the error with high probability. That is, given a tolerance error </span><span class="c2">&epsilon;</span><span class="c1">, the approximate algorithm returns a space with the weight </span><span class="c2">w </span><span class="c1">that satisfies </span><span class="c2">w &ge; </span><span class="c1">(1 </span><span class="c2">&minus; &epsilon;</span><span class="c1">)</span><span class="c2">w</span><span class="c8">&lowast; </span><span class="c1">with probability 1 </span><span class="c2">&minus; </span><span class="c56">1</span><span class="c13">n</span><span class="c51">. </span><span class="c1">(</span><span class="c2">w</span><span class="c8">&lowast; </span><span class="c1">is the weight of the optimal result and </span><span class="c2">n </span><span class="c1">is the number of ob- jects.) Rotating MaxRS queries have been proposed in [6]. This literature assumes that a given rectangle is rotatable, but we do not assume this case and assume the usual case, as well as [8, 9, 12, 18, 25].</span><span class="c5">We now focus on the in-memory algorithms [12, 18] because </span><span class="c1">we also consider an in-memory algorithm for continuous MaxRS queries. It is notable that the algorithm in [18] solves a max- </span></p><p class="c10"><span class="c38">319 </span></p><p class="c10"><span class="c28">r</span><span class="c28">r</span><span class="c55">2 </span></p><p class="c10"><span class="c28">r</span><span class="c55">5 </span></p><p class="c10"><span class="c55">6 </span></p><p class="c10"><span class="c28">H </span><span class="c28">I </span><span class="c28">J K L A B </span><span class="c28">r</span><span class="c55">1 </span></p><p class="c10"><span class="c61">C D E </span><span class="c28">r</span><span class="c55">3 </span><span class="c61">F G </span></p><p class="c10"><span class="c28">r</span><span class="c55">4 </span></p><p class="c10"><span class="c1">Figure 3: An example of processing a plane-sweep algorithm </span></p><p class="c6"><span class="c1">enclosing rectangle problem, to which the MaxRS problem can be converted, based on well-known </span><span class="c2">plane-sweep </span><span class="c1">strategy, and actually the external-memory and the approximate algorithms [8, 25] also employ this strategy. (The algorithm proposed in [12] also em- ploys the same strategy and the computation cost is the same as [18].) The plane-sweep algorithm [18] employs a horizontal line, and given a set of rectangles, this line is swept from bottom to top of the rectangles while counting the weights of intersecting intervals on the sweeping line. Figure 3 shows an instance when sweeping the dashed line. Let the weight of each rectangle in Figure 3 be 1, and we can see that the weights of intervals AB, BC, and CD are 1, 2, and 3, respectively. In the plane-sweep algorithm, when a sweep- ing line reaches the bottom edge of a rectangle, a newly generated interval is inserted into a binary-tree, while when reaching the top of the rectangle, the expired interval is deleted from the binary-tree. During these procedures, the counts of intervals are also updated. This algorithm returns the interval with the maximum weight, and the complexity of this algorithm is </span><span class="c2">O</span><span class="c1">(</span><span class="c2">n</span><span class="c1">log </span><span class="c2">n</span><span class="c1">) [18], where </span><span class="c2">n </span><span class="c1">is the number of objects (rectangles). This is because the algorithm ex- ecutes 2</span><span class="c2">n </span><span class="c1">binary-tree updates (</span><span class="c2">n </span><span class="c1">insertions and </span><span class="c2">n </span><span class="c1">deletions) that take </span><span class="c2">O</span><span class="c1">(log </span><span class="c2">n</span><span class="c1">) time. (This algorithm also can return a set of </span><span class="c2">k </span><span class="c1">inter- vals with the maximum weight without sacrificing its computation efficiency.) </span></p><p class="c6"><span class="c1">The above algorithm is shown to be an optimal solution for the MaxRS problem on </span><span class="c2">static objects</span><span class="c1">. However, it is inefficient to com- pute </span><span class="c2">s</span><span class="c8">&lowast; </span><span class="c1">from scratch by this algorithm even in the case where the number of newly generated objects is not large, which is shown by our experimental results. From the next section, we describe our solutions that efficiently update and monitor the result over stream data. </span></p><p class="c10"><span class="c21">4. BASIC SOLUTION </span></p><p class="c6"><span class="c1">The generations and the expirations of objects lead to additions and eliminations of overlapped spaces. This suggests that </span><span class="c2">S </span><span class="c1">in Equation (1) is dynamic, in other words, the ranking of range sum is dynamic, thereby efficient </span><span class="c2">s</span><span class="c8">&lowast; </span><span class="c1">monitoring is not trivial. In spite of this nature, our index framework enables to design a simple but efficient algorithm. </span></p><p class="c10"><span class="c21">4.1 G2: Graph in Grid Index </span></p><p class="c6"><span class="c1">We first present our index framework Graph in Grid index (or G2). Recall that our objective is to achieve real-time monitoring of MaxRS in a stream environment, meaning that unnecessary com- putations have to be avoided. A dynamic graph, where a vertex is a rectangle and an edge shows the overlap between given two ver- tices, realizes this. If the weight of each vertex (rectangle) is 1, we can see that </span><span class="c2">s</span><span class="c8">&lowast; </span><span class="c1">is a part of the vertex with the largest number of edges. To monitor </span><span class="c2">s</span><span class="c8">&lowast; </span><span class="c1">with using the dynamic graph, the basic op- eration that we have to do is just to check the updated parts of the dynamic graph. This is because only the updated parts may affect </span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c1">. Motivated by this observation, we develop G2. </span></p><p class="c10"><span class="c1">As described, the first idea is to maintain </span><span class="c2">n </span><span class="c1">rectangles on a sliding- window by a graph. Vertices of the graph are the rectangles, and if two rectangles overlap each other, there is an edge between them. </span></p><p class="c10"><span class="c43">r</span><span class="c27">6 </span></p><p class="c10"><span class="c43">r</span><span class="c27">5 </span></p><p class="c12"><span class="c1">Figure 4: The graph constructed from the rectangles in Figure 3</span><span class="c5">Table 2: Edge and neighbor sets of the vertices of the graph in </span><span class="c1">Figure 4</span><span class="c5">Vertex </span><span class="c7">r</span><span class="c4">i </span><span class="c5">Edge </span><span class="c7">r</span><span class="c4">i</span><span class="c7">.E </span><span class="c5">Neighbor set </span><span class="c7">N</span><span class="c5">(</span><span class="c7">r</span><span class="c4">i</span><span class="c5">) </span><span class="c2">r</span><span class="c29">1 </span><span class="c1">(</span><span class="c2">r</span><span class="c29">1</span><span class="c2">,r</span><span class="c29">2</span><span class="c1">), (</span><span class="c2">r</span><span class="c29">1</span><span class="c2">,r</span><span class="c29">3</span><span class="c1">) </span><span class="c2">{r</span><span class="c29">2</span><span class="c2">,r</span><span class="c29">3</span><span class="c2">} r</span><span class="c0">2 </span><span class="c5">(</span><span class="c7">r</span><span class="c0">2</span><span class="c7">,r</span><span class="c0">3</span><span class="c5">) </span><span class="c7">{r</span><span class="c0">3</span><span class="c7">} </span><span class="c2">r</span><span class="c29">3 </span><span class="c1">(</span><span class="c2">r</span><span class="c29">3</span><span class="c2">,r</span><span class="c29">4</span><span class="c1">) </span><span class="c2">{r</span><span class="c29">4</span><span class="c2">} r</span><span class="c0">4 </span><span class="c5">(</span><span class="c7">r</span><span class="c0">4</span><span class="c7">,r</span><span class="c0">5</span><span class="c5">) </span><span class="c7">{r</span><span class="c0">5</span><span class="c7">} </span><span class="c2">r</span><span class="c0">5 </span><span class="c5">(</span><span class="c7">r</span><span class="c0">5</span><span class="c7">,r</span><span class="c0">6</span><span class="c5">) </span><span class="c7">{r</span><span class="c0">6</span><span class="c7">} </span><span class="c2">r</span><span class="c29">6 </span><span class="c2">&empty; &empty; </span></p><p class="c10"><span class="c1">We define our graph and provide a concrete example below. D</span><span class="c26">EFINITION </span><span class="c1">5 (G</span><span class="c26">RAPH </span><span class="c2">G</span><span class="c1">). </span><span class="c2">G </span><span class="c1">= (</span><span class="c2">V,E</span><span class="c1">) </span><span class="c2">is a dynamic graph. V is a set of rectangles of a given size on a sliding-window, and E is a set of direct edges. Given two vertices r</span><span class="c13">i</span><span class="c2">, r</span><span class="c13">j </span><span class="c2">&isin; V overlapping each other, where r</span><span class="c4">i </span><span class="c7">was generated earlier than r</span><span class="c4">j</span><span class="c7">, there is a direct </span><span class="c2">edge between them, </span><span class="c1">(</span><span class="c2">r</span><span class="c13">i</span><span class="c2">,r</span><span class="c13">j</span><span class="c1">)</span><span class="c2">, and this edge is held by the vertex (rectangle) that was generated earlier than the other, i.e., r</span><span class="c4">i</span><span class="c7">. (Ties </span><span class="c2">are broken by identifiers.) </span><span class="c1">E</span><span class="c26">XAMPLE </span><span class="c1">4.1. </span><span class="c2">We construct a graph G from the set of rectangles in Figure 3, and Figure 4 shows G. Assume that the rectangles are generated in order of identifiers. Since r</span><span class="c0">2 </span><span class="c7">overlaps with r</span><span class="c0">1</span><span class="c7">, there </span><span class="c2">is (r</span><span class="c0">1</span><span class="c7">, r</span><span class="c0">2</span><span class="c7">) that represents a direct edge from r</span><span class="c0">1 </span><span class="c7">to r</span><span class="c0">2</span><span class="c7">. r</span><span class="c0">1 </span><span class="c7">maintains </span><span class="c2">the edges (r</span><span class="c29">1</span><span class="c2">, r</span><span class="c29">2</span><span class="c2">) and (r</span><span class="c29">1</span><span class="c2">, r</span><span class="c29">3</span><span class="c2">). </span><span class="c1">When context is clear, we use vertices and rectangles interchange- ably since they are the same, as Definition 5 describes. We de- note </span><span class="c2">r</span><span class="c4">i</span><span class="c7">.E </span><span class="c5">the set of edges held by the vertex </span><span class="c7">r</span><span class="c4">i </span><span class="c7">&isin; V </span><span class="c5">. The set </span><span class="c1">of neighbors of a vertex </span><span class="c2">r</span><span class="c13">i </span><span class="c2">&isin; V </span><span class="c1">is also denoted by </span><span class="c2">N</span><span class="c1">(</span><span class="c2">r</span><span class="c13">i</span><span class="c1">) = </span><span class="c2">{&forall;r</span><span class="c4">j </span><span class="c7">|&exist;</span><span class="c5">(</span><span class="c7">r</span><span class="c4">i</span><span class="c7">,r</span><span class="c4">j</span><span class="c5">) </span><span class="c7">&isin; r</span><span class="c4">i</span><span class="c7">.E}</span><span class="c5">. Table 2 shows an example that uses Fig- </span><span class="c1">ure 4 in terms of </span><span class="c2">r.E </span><span class="c1">and </span><span class="c2">N</span><span class="c1">(</span><span class="c2">r</span><span class="c1">). Then we obtain the spaces on </span><span class="c2">r</span><span class="c13">i </span><span class="c1">covered by the rectangles in </span><span class="c2">N</span><span class="c1">(</span><span class="c2">r</span><span class="c4">i</span><span class="c5">). </span><span class="c7">r</span><span class="c4">i </span><span class="c5">maintains </span><span class="c7">s</span><span class="c4">i</span><span class="c5">, the space with </span><span class="c1">the maximum weight among the spaces. That is, </span><span class="c2">s</span><span class="c4">i </span><span class="c5">is definitely the </span><span class="c1">subspace on </span><span class="c2">r</span><span class="c13">i</span><span class="c1">, which provides the following property. P</span><span class="c26">ROPERTY </span><span class="c1">1. </span><span class="c2">Given r</span><span class="c4">i</span><span class="c7">,r</span><span class="c4">j </span><span class="c7">&isin; V , we have that s</span><span class="c4">i </span><span class="c5">= </span><span class="c7">s</span><span class="c4">j</span><span class="c7">. </span><span class="c1">The proof is straightforward since &#8708;</span><span class="c2">r</span><span class="c4">i </span><span class="c7">&isin; N</span><span class="c5">(</span><span class="c7">r</span><span class="c4">j</span><span class="c5">) if </span><span class="c7">&exist;r</span><span class="c4">j </span><span class="c7">&isin; N</span><span class="c5">(</span><span class="c7">r</span><span class="c4">i</span><span class="c5">). </span><span class="c1">How to obtain </span><span class="c2">s</span><span class="c13">i </span><span class="c1">is explained later, but it is not difficult to see the following property. </span></p><p class="c10"><span class="c1">P</span><span class="c26">ROPERTY </span><span class="c1">2. </span><span class="c2">Let S</span><span class="c13">G </span><span class="c2">be the set of s</span><span class="c13">i </span><span class="c2">maintained by r</span><span class="c13">i </span><span class="c2">on a sliding- window, we have that </span></p><p class="c10"><span class="c2">s</span><span class="c8">&lowast; </span><span class="c1">= argmax </span></p><p class="c10"><span class="c13">s</span><span class="c48">i</span><span class="c13">&isin;S</span><span class="c48">G </span><span class="c2">s</span><span class="c13">i</span><span class="c2">.w. </span><span class="c1">(2) </span></p><p class="c6"><span class="c1">Furthermore, even if some vertices (rectangles) expire, other ver- tices need no maintenances, because the corresponding edges are held by older vertices. </span></p><p class="c10"><span class="c1">P</span><span class="c26">ROPERTY </span><span class="c1">3. </span><span class="c2">Given r</span><span class="c4">i </span><span class="c7">&isin; V , and when the older vertices than r</span><span class="c4">i </span><span class="c2">expire, s</span><span class="c4">i </span><span class="c7">does not change. </span></p><p class="c6"><span class="c1">We next have to consider the case where </span><span class="c2">m </span><span class="c1">new rectangles (ob- jects) are generated. Due to the graph structure, we need to check whether the </span><span class="c2">m </span><span class="c1">rectangles overlap with the existing rectangles. It is obvious that simple computation takes </span><span class="c2">O</span><span class="c1">(</span><span class="c2">mn</span><span class="c1">) time. To alleviate this, we employ a grid structure like the one shown in Figure 5, </span></p><p class="c10"><span class="c38">320 </span></p><p class="c10"><span class="c43">r</span><span class="c27">2 </span></p><p class="c10"><span class="c43">r</span><span class="c27">3 </span><span class="c43">r</span><span class="c27">1 </span></p><p class="c10"><span class="c43">r</span><span class="c27">4 </span></p><p class="c10"><span class="c34">cc</span><span class="c45">0,3 </span></p><p class="c10"><span class="c45">1,3 </span></p><p class="c10"><span class="c34">c</span><span class="c45">2,3 </span><span class="c72">c</span><span class="c45">3,3 </span></p><p class="c10"><span class="c54">c</span><span class="c60">0,2 </span></p><p class="c10"><span class="c54">c</span><span class="c60">1,2 </span></p><p class="c12"><span class="c34">c</span><span class="c45">2,2 </span><span class="c54">c</span><span class="c60">3,1 </span><span class="c34">c</span><span class="c45">1,1 </span><span class="c34">c</span><span class="c45">2,1 </span></p><p class="c10"><span class="c34">c</span><span class="c45">3,2 </span></p><p class="c10"><span class="c1">Figure 5: An example of G2 </span></p><p class="c6"><span class="c1">which is the second idea. When dataset updates frequently occur, grid structure is more suitable than complex structures like R-tree and Quad-tree [4]. Each cell in the gird is assigned an identifier and its size is fixed, as shown in Figure 5. Note that each cell </span><span class="c2">c</span><span class="c4">i,j </span><span class="c5">main- </span><span class="c1">tains the graph constructed by the mapped rectangles, denoted by </span><span class="c2">G</span><span class="c13">i,j </span><span class="c1">= (</span><span class="c2">V</span><span class="c13">i,j</span><span class="c2">,E</span><span class="c13">i,j</span><span class="c1">). Therefore, Definition 5 is rewritten as follows. D</span><span class="c26">EFINITION </span><span class="c1">6 (G</span><span class="c26">RAPH </span><span class="c2">G</span><span class="c13">i,j</span><span class="c1">). </span><span class="c2">G</span><span class="c13">i,j </span><span class="c1">= (</span><span class="c2">V</span><span class="c13">i,j</span><span class="c2">,E</span><span class="c13">i,j</span><span class="c1">) </span><span class="c2">is a dynamic graph maintained by c</span><span class="c4">i,j </span><span class="c7">of a grid. V</span><span class="c4">i,j </span><span class="c7">is a set of given sized </span><span class="c2">rectangles that are mapped to c</span><span class="c4">i,j </span><span class="c7">and on a sliding-window, and </span><span class="c2">E</span><span class="c13">i,j </span><span class="c2">is a set of direct edges. The condition of direct edges follows Definition 5. </span></p><p class="c10"><span class="c1">For example, Figure 5 illustrates an example of a G2 and </span><span class="c2">G</span><span class="c29">3</span><span class="c13">,</span><span class="c29">0</span><span class="c1">. When </span><span class="c2">m </span><span class="c1">new rectangles are generated, we map them to the cells with which they overlap. (So, a new rectangle may be mapped to multiple cells.) We then update the graphs in the cells where new objects are mapped. Complexities. The time complexity of the rectangle mapping is </span><span class="c2">O</span><span class="c1">(</span><span class="c2">m</span><span class="c1">). Let </span><span class="c2">c</span><span class="c8">&prime; </span><span class="c1">and </span><span class="c2">m</span><span class="c8">&prime; </span><span class="c1">respectively be the number of cells where new objects are mapped and the average number of new objects mapped to the cells. Also, let </span><span class="c2">n</span><span class="c8">&prime; </span><span class="c1">be the average number of vertices in the cells where new objects are mapped, and the time complexity of the graph update is </span><span class="c2">O</span><span class="c1">(</span><span class="c2">c</span><span class="c8">&prime;</span><span class="c2">m</span><span class="c8">&prime;</span><span class="c2">n</span><span class="c8">&prime;</span><span class="c1">). In practice, we have that </span><span class="c2">n</span><span class="c8">&prime; </span><span class="c2">&#8810; n</span><span class="c1">. We next consider in </span><span class="c5">&sum;</span><span class="c1">the </span><span class="c7">|E</span><span class="c4">i,j</span><span class="c7">|</span><span class="c5">, </span><span class="c1">grid, </span><span class="c5">where </span><span class="c1">then we </span><span class="c7">E </span><span class="c54">c</span><span class="c45">0,1 </span><span class="c54">c</span><span class="c45">0,0 </span><span class="c34">c</span><span class="c45">1,0 </span><span class="c72">c</span><span class="c45">2,0 </span><span class="c34">c</span><span class="c45">3,0 </span></p><p class="c42"><span class="c1">storage cost. Let know that </span><span class="c2">|V | </span><span class="c1">= </span><span class="c51">&sum;</span><span class="c2">V </span><span class="c1">be the set of all vertices </span><span class="c2">|V</span><span class="c4">i,j</span><span class="c7">|</span><span class="c5">. Similarly, </span><span class="c7">|E| </span><span class="c5">= is the set of all edges in the grid. Recall that </span><span class="c1">each vertex </span><span class="c2">r</span><span class="c4">i </span><span class="c5">maintains </span><span class="c7">s</span><span class="c4">i </span><span class="c5">and its storage cost is </span><span class="c7">O</span><span class="c5">(</span><span class="c7">|V |</span><span class="c5">). We can </span><span class="c1">therefore conclude that the storage cost of G2 is </span><span class="c2">O</span><span class="c1">(</span><span class="c2">|V | </span><span class="c1">+ </span><span class="c2">|E|</span><span class="c1">). </span></p><p class="c10"><span class="c21">4.2 Monitoring Algorithm with G2 </span></p><p class="c10"><span class="c1">We design an online monitoring algorithm using G2, and Algo- rithm 1 illustrates the high level algorithm. Algorithm description. Consider an instance when </span><span class="c2">m </span><span class="c1">new rectan- gles are generated and the </span><span class="c2">m </span><span class="c1">oldest rectangles expire. As described in Section 4.1, we first update G2 (lines 1&ndash;3). Lines 4&ndash;6 are de- signed based on the following idea. Given the set </span><span class="c2">S </span><span class="c1">of the spaces each of which (i.e., </span><span class="c2">s</span><span class="c4">i</span><span class="c5">) is maintained by </span><span class="c7">r</span><span class="c4">i </span><span class="c7">&isin; V </span><span class="c5">, we know that </span><span class="c7">s</span><span class="c4">i </span><span class="c1">has to be correct due to Equation (2). In addition, if a new edge is inserted to </span><span class="c2">r</span><span class="c4">i</span><span class="c7">.E</span><span class="c5">, </span><span class="c7">s</span><span class="c4">i </span><span class="c5">may change because </span><span class="c7">N</span><span class="c5">(</span><span class="c7">r</span><span class="c4">i</span><span class="c5">) varies. We there- </span><span class="c1">fore need to compute </span><span class="c2">s</span><span class="c4">i </span><span class="c5">if </span><span class="c7">r</span><span class="c4">i</span><span class="c7">.E </span><span class="c5">is updated. The plane-sweep al- </span><span class="c1">gorithm is an optimal solution to find the space with the maximum weight covered by the given rectangles [12]. Hence, we employ the plane-sweep algorithm to compute </span><span class="c2">s</span><span class="c13">i </span><span class="c1">(line 6). Note that the input of this plane-sweep algorithm is </span><span class="c2">only N</span><span class="c1">(</span><span class="c2">r</span><span class="c4">i</span><span class="c5">) </span><span class="c7">&cup; {r</span><span class="c4">i</span><span class="c7">}</span><span class="c5">. To summa- </span><span class="c1">rize, for </span><span class="c2">&forall;r</span><span class="c13">i </span><span class="c2">&isin; V </span><span class="c1">, where </span><span class="c2">r</span><span class="c13">i</span><span class="c2">.E </span><span class="c1">has new edges and </span><span class="c2">V </span><span class="c1">is the vertex set maintained by a given cell </span><span class="c2">c </span><span class="c1">of G2, Algorithm 1 executes the plane-sweep algorithm locally, denoted by Local-Plane-Sweep(</span><span class="c2">&middot;</span><span class="c1">) (lines 4&ndash;6). After that, we can correctly monitor </span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c1">. </span></p><p class="c10"><span class="c1">Algorithm 1: Monitoring algorithm using G2 </span></p><p class="c10"><span class="c22">1 </span><span class="c20">Mapping(</span><span class="c11">R</span><span class="c20">) // </span><span class="c9">R </span><span class="c25">is the set of new rectangles </span><span class="c22">2 </span><span class="c11">C</span><span class="c8">&prime; </span><span class="c11">&larr; </span><span class="c20">the set of the cells where new objects are mapped </span><span class="c22">3 </span><span class="c20">G2-Update(</span><span class="c11">C</span><span class="c8">&prime;</span><span class="c20">) // </span><span class="c25">rectangle overlap computation </span><span class="c22">4 </span><span class="c20">for </span><span class="c11">&forall;c &isin; C</span><span class="c8">&prime; </span><span class="c20">do </span><span class="c22">5 </span><span class="c20">for </span><span class="c11">&forall;r</span><span class="c4">i </span><span class="c14">&isin; c.V where r has new edges </span><span class="c17">do </span><span class="c22">6 </span><span class="c11">s</span><span class="c4">i </span><span class="c14">&larr; </span><span class="c17">Local-Plane-Sweep(</span><span class="c14">N</span><span class="c17">(</span><span class="c14">r</span><span class="c4">i</span><span class="c17">) </span><span class="c14">&cup; {r</span><span class="c4">i</span><span class="c14">}</span><span class="c17">) </span></p><p class="c10"><span class="c22">7 </span><span class="c11">s</span><span class="c8">&lowast; </span><span class="c11">&larr; </span><span class="c20">argmax</span><span class="c4">s</span><span class="c48">i</span><span class="c13">&isin;S</span><span class="c41">s</span><span class="c13">i</span><span class="c41">.w </span><span class="c22">8 </span><span class="c20">return </span><span class="c11">s</span><span class="c8">&lowast; </span></p><p class="c6"><span class="c1">Recall that given a set of rectangles, the plane-sweep algorithm sweeps a horizontal line from the bottom to the top among the rect- angles. To obtain </span><span class="c2">s</span><span class="c4">i</span><span class="c5">, however, we only need to sweep the hori- </span><span class="c1">zontal line from the bottom to the top of </span><span class="c2">r</span><span class="c13">i</span><span class="c1">. Local-Plane-Sweep(</span><span class="c2">&middot;</span><span class="c1">) in Algorithm 1 (line 6) is optimized to do so. Although the time complexity does not vary, the practical execution time is reduced. </span></p><p class="c10"><span class="c1">The following simple example highlights the efficiency of our incremental approach. E</span><span class="c26">XAMPLE </span><span class="c1">4.2. </span><span class="c2">Assume that the graph in Figure 4 is the graph maintained by one of the cells in Figure 5. Assume further that m </span><span class="c1">= 1 </span><span class="c2">and r</span><span class="c29">6 </span><span class="c2">is the new rectangle mapped to the cell. Algo- rithm 1 checks the vertices overlapping with r</span><span class="c0">6</span><span class="c7">, and in this case, </span><span class="c2">(r</span><span class="c29">5</span><span class="c2">,r</span><span class="c29">6</span><span class="c2">) is inserted to r</span><span class="c29">5</span><span class="c2">.E. Algorithm 1 next executes Local-Plane- Sweep</span><span class="c1">(</span><span class="c2">{r</span><span class="c0">5</span><span class="c7">,r</span><span class="c0">6</span><span class="c7">}</span><span class="c5">) </span><span class="c7">and obtains s</span><span class="c0">5</span><span class="c7">. If s</span><span class="c0">5</span><span class="c7">.w &gt; s</span><span class="c13">&lowast;</span><span class="c7">.w, s</span><span class="c13">&lowast; </span><span class="c7">is replaced </span><span class="c2">by s</span><span class="c0">5</span><span class="c7">. </span><span class="c1">Time complexity. As discussed before, lines 1&ndash;3 take </span><span class="c2">O</span><span class="c1">(</span><span class="c2">c</span><span class="c8">&prime;</span><span class="c2">m</span><span class="c8">&prime;</span><span class="c2">n</span><span class="c8">&prime;</span><span class="c1">) time. Let </span><span class="c2">v </span><span class="c1">be the number of vertices to which new edges are in- serted. Also, let </span><span class="c2">e </span><span class="c1">be the average number of edges of the above vertices, then lines 4&ndash;6 take </span><span class="c2">O</span><span class="c1">(</span><span class="c2">ve</span><span class="c1">log </span><span class="c2">e</span><span class="c1">) time since Local-Plane- Sweep(</span><span class="c2">&middot;</span><span class="c1">) for a vertex takes </span><span class="c2">O</span><span class="c1">(</span><span class="c2">e</span><span class="c1">log </span><span class="c2">e</span><span class="c1">) time. Therefore, when </span><span class="c2">m </span><span class="c1">new objects are generated, Algorithm 1 takes </span><span class="c2">O</span><span class="c1">(</span><span class="c2">c</span><span class="c8">&prime;</span><span class="c2">m</span><span class="c8">&prime;</span><span class="c2">n</span><span class="c8">&prime;</span><span class="c1">+</span><span class="c2">ve</span><span class="c1">log </span><span class="c2">e</span><span class="c1">) time. </span></p><p class="c10"><span class="c21">5. ENHANCED SOLUTION </span></p><p class="c6"><span class="c1">Algorithm 1 can identify </span><span class="c2">where to update </span><span class="c1">and compute </span><span class="c2">s</span><span class="c4">i </span><span class="c5">main- </span><span class="c1">tained by </span><span class="c2">r</span><span class="c13">i </span><span class="c1">efficiently since </span><span class="c2">N</span><span class="c1">(</span><span class="c2">r</span><span class="c13">i</span><span class="c1">) is easily obtained by the graph representation. In fact, however, the most time consuming opera- tion in Algorithm 1 is Local-Plane-Sweep(</span><span class="c2">&middot;</span><span class="c1">) (line 6). Algorithm 1 executes Local-Plane-Sweep(</span><span class="c2">&middot;</span><span class="c1">) whenever </span><span class="c2">r</span><span class="c4">i</span><span class="c7">.E </span><span class="c5">is updated, thus </span><span class="c1">it is intuitively seen that the approach degrades the performance in the case where the number of </span><span class="c2">r.E </span><span class="c1">updates is large. We observe the following usual cases that motivate to enhance G2. </span></p><p class="c10"><span class="c1">1. The </span><span class="c2">r</span><span class="c13">i</span><span class="c2">.E </span><span class="c1">update increases </span><span class="c2">s</span><span class="c13">i</span><span class="c2">.w </span><span class="c1">but it is less than </span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c2">.w</span><span class="c1">. </span></p><p class="c10"><span class="c1">2. The </span><span class="c2">r</span><span class="c13">i</span><span class="c2">.E </span><span class="c1">update does not increase </span><span class="c2">s</span><span class="c13">i</span><span class="c2">.w</span><span class="c1">. </span></p><p class="c6"><span class="c1">To consider a more concrete situation, we give Example 5.1, and Table 3 shows the weights of each vertex </span><span class="c2">r</span><span class="c4">i </span><span class="c5">and </span><span class="c7">s</span><span class="c4">i </span><span class="c5">of the graph in </span><span class="c1">Figure 4. </span></p><p class="c12"><span class="c1">Table 3: Weights of vertex </span><span class="c2">r</span><span class="c4">i </span><span class="c5">and </span><span class="c7">s</span><span class="c4">i </span><span class="c5">of the graph in Figure 4 </span><span class="c1">Vertex </span><span class="c2">r</span><span class="c4">i </span><span class="c7">r</span><span class="c4">i</span><span class="c7">.w s</span><span class="c4">i</span><span class="c7">.w </span></p><p class="c6"><span class="c2">r</span><span class="c0">1 </span><span class="c5">10 55 </span><span class="c2">r</span><span class="c29">2 </span><span class="c1">30 45 </span><span class="c2">r</span><span class="c0">3 </span><span class="c5">15 40 </span><span class="c2">r</span><span class="c0">4 </span><span class="c5">25 45 </span><span class="c2">r</span><span class="c29">5 </span><span class="c1">20 25 </span><span class="c2">r</span><span class="c0">6 </span><span class="c5">5 5 </span></p><p class="c10"><span class="c38">321 </span></p><p class="c10"><span class="c50">cc</span><span class="c16">3,0</span><span class="c50">.w = 4 </span></p><p class="c10"><span class="c16">3,0</span><span class="c50">.w = 7 </span></p><p class="c10"><span class="c36">4 </span></p><p class="c10"><span class="c50">R</span><span class="c16">3,0</span><span class="c1">(b) An instance when new rectangles are </span><span class="c5">mapped to </span><span class="c7">c</span><span class="c0">3</span><span class="c4">,</span><span class="c0">0</span><span class="c5">. </span></p><p class="c10"><span class="c50">c</span><span class="c16">3,0</span><span class="c50">.w = 4 G</span><span class="c16">3,0 </span></p><p class="c10"><span class="c36">3 </span></p><p class="c10"><span class="c50">G</span><span class="c16">3,0 </span></p><p class="c10"><span class="c36">3 </span></p><p class="c10"><span class="c50">G</span><span class="c16">3,0 </span></p><p class="c10"><span class="c36">3 </span></p><p class="c10"><span class="c36">1 </span></p><p class="c10"><span class="c36">4 </span></p><p class="c10"><span class="c36">1 </span></p><p class="c10"><span class="c36">4 </span></p><p class="c10"><span class="c36">2 </span></p><p class="c10"><span class="c36">2 </span></p><p class="c10"><span class="c36">2 </span></p><p class="c10"><span class="c36">3 </span><span class="c35">2 </span></p><p class="c10"><span class="c35">2 </span></p><p class="c10"><span class="c35">3 </span></p><p class="c10"><span class="c36">2 </span></p><p class="c10"><span class="c36">2 </span></p><p class="c10"><span class="c36">2 </span></p><p class="c10"><span class="c36">2 </span></p><p class="c10"><span class="c36">2 3 1 </span></p><p class="c10"><span class="c36">1 </span><span class="c35">2 </span></p><p class="c10"><span class="c35">2 </span></p><p class="c12"><span class="c35">3 </span><span class="c50">R</span><span class="c16">3,0</span><span class="c50">R</span><span class="c16">3,0</span><span class="c1">(a) An instance when the rectangle over- (c) An instance when the rectangle over- </span><span class="c5">lap computation has been executed. </span></p><p class="c10"><span class="c5">lap in Figure computation 6(b) has between been executed. </span><span class="c7">V</span><span class="c0">3</span><span class="c4">,</span><span class="c0">0 </span><span class="c5">and </span><span class="c7">R</span><span class="c0">3</span><span class="c4">,</span><span class="c0">0 </span><span class="c1">Figure 6: An example of </span><span class="c2">G</span><span class="c29">3</span><span class="c13">,</span><span class="c29">0 </span><span class="c1">(followed by Figure 5) and </span><span class="c2">R</span><span class="c29">3</span><span class="c13">,</span><span class="c29">0 </span><span class="c1">of </span><span class="c2">c</span><span class="c29">3</span><span class="c13">,</span><span class="c29">0 </span><span class="c1">in an aG2 and its dynamic update where the weight of each vertex is 1. </span></p><p class="c42"><span class="c1">E</span><span class="c26">XAMPLE </span><span class="c1">5.1. </span><span class="c2">Assume the same situation as Example 4.2 and s</span><span class="c8">&lowast; </span><span class="c1">= </span><span class="c2">s</span><span class="c0">1</span><span class="c7">. Before </span><span class="c5">(</span><span class="c7">r</span><span class="c0">5</span><span class="c7">,r</span><span class="c0">6</span><span class="c5">) </span><span class="c7">is inserted to r</span><span class="c0">5</span><span class="c7">.E, s</span><span class="c0">5</span><span class="c7">.w </span><span class="c5">= 20</span><span class="c7">, and </span><span class="c2">after the insertion, we obtain s</span><span class="c0">5</span><span class="c7">.w </span><span class="c5">= </span><span class="c2">that the edge </span><span class="c1">(</span><span class="c2">r</span><span class="c29">5</span><span class="c2">,r</span><span class="c29">6</span><span class="c1">) </span><span class="c2">insertion to r</span><span class="c29">5</span><span class="c2">.E </span><span class="c5">25</span><span class="c7">. However, it is obvious </span><span class="c2">does not affect s</span><span class="c8">&lowast;</span><span class="c2">, which corresponds to the case 1. In addition, even if r</span><span class="c0">6 </span><span class="c7">overlaps with </span><span class="c2">r</span><span class="c29">2 </span><span class="c2">and become does s</span><span class="c8">&lowast;</span><span class="c2">. not overlap with r</span><span class="c29">3</span><span class="c2">, s</span><span class="c29">2 </span><span class="c2">keeps the same and does not </span></p><p class="c10"><span class="c2">This corresponds to the case 2. </span></p><p class="c10"><span class="c1">The observation in Example 5.1 suggests that we may not have to compute </span><span class="c2">s</span><span class="c4">i </span><span class="c5">even when </span><span class="c7">r</span><span class="c4">i</span><span class="c7">.E </span><span class="c5">is updated. Therefore, by enhancing </span><span class="c1">G2, we aim at eliminating such unnecessary computation and im- proving query processing efficiency. The enhanced solution achieves this by an upper-bounding technique. </span><span class="c21">5.1 Aggregate G2 </span></p><p class="c6"><span class="c1">It has been shown in the past that data structures considering aggregate results work well for query processing which deal with aggregate functions such as sum and count [30]. The monitoring MaxRS problem considers sum function, then we know that G2 can be extended to deal with aggregate values like aR-tree [19]. </span></p><p class="c6"><span class="c1">We propose aG2 (aggregate G2), which is essentially G2. The main difference between G2 and aG2 is that aG2 employs </span><span class="c2">upper- bound weights</span><span class="c1">. Given a graph in an aG2, each vertex </span><span class="c2">r</span><span class="c4">i </span><span class="c5">of the </span><span class="c1">graph maintains </span><span class="c2">s</span><span class="c13">i</span><span class="c2">.w</span><span class="c1">, which is the upper-bound weight of </span><span class="c2">s</span><span class="c13">i</span><span class="c1">. How to compute </span><span class="c2">s</span><span class="c4">i</span><span class="c7">.w </span><span class="c5">depends on algorithms, so we briefly introduce our </span><span class="c1">approach to compute </span><span class="c2">s</span><span class="c4">i</span><span class="c7">.w </span><span class="c5">here (the detail is described in Section </span><span class="c1">5.2). Given the graph </span><span class="c2">G</span><span class="c13">i,j </span><span class="c1">= (</span><span class="c2">V</span><span class="c13">i,j</span><span class="c2">,E</span><span class="c13">i,j</span><span class="c1">) maintained by a cell </span><span class="c2">c</span><span class="c13">i,j </span><span class="c1">in an aG2, we have a vertex </span><span class="c2">r</span><span class="c4">i</span><span class="c31">&prime; </span><span class="c2">&isin; V</span><span class="c4">i,j </span><span class="c5">and </span><span class="c7">s</span><span class="c4">i</span><span class="c31">&prime;</span><span class="c1">. Consider rectangles </span><span class="c2">r</span><span class="c4">j</span><span class="c31">&prime; </span><span class="c1">where (</span><span class="c2">r</span><span class="c4">i</span><span class="c31">&prime;</span><span class="c2">,r</span><span class="c4">j</span><span class="c31">&prime;</span><span class="c1">) is newly inserted to </span><span class="c2">r</span><span class="c4">i</span><span class="c31">&prime;</span><span class="c2">.E</span><span class="c1">, </span><span class="c2">s</span><span class="c4">i</span><span class="c31">&prime;</span><span class="c2">.w </span><span class="c1">is computed by the following Equation. </span></p><p class="c10"><span class="c2">s</span><span class="c4">i</span><span class="c31">&prime;</span><span class="c2">.w </span><span class="c1">= </span><span class="c2">s</span><span class="c4">i</span><span class="c31">&prime;</span><span class="c2">.w </span><span class="c1">+ </span><span class="c51">&sum; </span><span class="c2">r</span><span class="c4">j</span><span class="c31">&prime;</span><span class="c2">.w </span><span class="c1">(3) </span></p><p class="c6"><span class="c1">Not only the vertices but also the cells in aG2 maintain upper-bound weights. Before we introduce the upper-bound weight maintained by </span><span class="c2">c</span><span class="c13">i,j</span><span class="c1">, we have to note that in aG2, </span><span class="c2">c</span><span class="c13">i,j </span><span class="c1">maintains </span></p><p class="c10"><span class="c2">&bull; G</span><span class="c13">i,j</span><span class="c1">: the graph defined by Definition 6, and </span></p><p class="c6"><span class="c2">&bull; R</span><span class="c4">i,j</span><span class="c5">: a set of rectangles that have been mapped to </span><span class="c7">c</span><span class="c4">i,j </span><span class="c5">but </span><span class="c1">have not yet been checked whether they overlap with vertices in </span><span class="c2">V</span><span class="c4">i,j </span><span class="c5">or not (denoted by rectangle overlap computation). </span></p><p class="c6"><span class="c1">The new rectangles mapped to </span><span class="c2">c</span><span class="c4">i,j </span><span class="c5">are initially maintained in </span><span class="c7">R</span><span class="c4">i,j</span><span class="c5">. </span><span class="c1">When we execute the rectangle overlap computation, the rectan- gles in </span><span class="c2">R</span><span class="c13">i,j </span><span class="c1">are moved to </span><span class="c2">V</span><span class="c13">i,j</span><span class="c1">. Now we introduce how to compute </span></p><p class="c10"><span class="c35">1 </span><span class="c36">1 </span></p><p class="c10"><span class="c36">2 </span></p><p class="c10"><span class="c36">1 </span></p><p class="c42"><span class="c2">c</span><span class="c13">i,j</span><span class="c2">.w</span><span class="c1">, i.e., the upper-bound weight maintained by </span><span class="c2">c</span><span class="c13">i,j</span><span class="c1">. Basically, </span><span class="c2">c</span><span class="c4">i,j</span><span class="c7">.w </span><span class="c5">is set as follows.</span><span class="c7">c</span><span class="c4">i,j</span><span class="c7">.w </span><span class="c5">= </span><span class="c4">s</span><span class="c48">i</span><span class="c5">max </span><span class="c31">&prime; </span><span class="c13">&isin;S</span><span class="c48">i,j </span><span class="c2">s</span><span class="c4">i</span><span class="c31">&prime;</span><span class="c2">.w, </span><span class="c1">(4) where </span><span class="c2">S</span><span class="c13">i,j </span><span class="c1">new rectangles is the </span><span class="c2">r</span><span class="c8">&prime; </span><span class="c1">set that of are </span><span class="c2">s</span><span class="c4">i</span><span class="c31">&prime; </span><span class="c1">mapped maintained to by </span><span class="c2">r</span><span class="c4">i</span><span class="c31">&prime; </span><span class="c2">&isin; c</span><span class="c4">i,j</span><span class="c5">, </span><span class="c7">c</span><span class="c4">i,j</span><span class="c7">.w </span><span class="c2">V</span><span class="c13">i,j</span><span class="c1">. Given a set of </span><span class="c5">is updated by the </span><span class="c1">following equation.</span><span class="c7">c</span><span class="c4">i,j</span><span class="c7">.w &larr; c</span><span class="c4">i,j</span><span class="c7">.w </span><span class="c5">+ </span><span class="c1">&sum; </span><span class="c7">r</span><span class="c13">&prime;</span><span class="c7">.w </span><span class="c5">(5) </span></p><p class="c10"><span class="c1">We give a simple example of how to dynamically update upper- bound weights below. </span></p><p class="c10"><span class="c1">E</span><span class="c26">XAMPLE </span><span class="c1">5.2. </span><span class="c2">Figure 6 shows an example of G</span><span class="c29">3</span><span class="c13">,</span><span class="c29">0 </span><span class="c2">and R</span><span class="c29">3</span><span class="c13">,</span><span class="c29">0 </span><span class="c2">where c</span><span class="c0">3</span><span class="c4">,</span><span class="c0">0 </span><span class="c7">follows Figure 5. We first assume the situation of Figure 6(a), </span><span class="c2">and note that the value shown next to each vertex is the upper- bound weight. Then we see that c</span><span class="c0">3</span><span class="c4">,</span><span class="c0">0</span><span class="c7">.w </span><span class="c5">= 4</span><span class="c7">, which is the maximum </span><span class="c2">value among the upper-bound weights of V</span><span class="c0">3</span><span class="c4">,</span><span class="c0">0</span><span class="c7">. Next we assume that </span><span class="c2">three new rectangles are mapped to c</span><span class="c29">3</span><span class="c13">,</span><span class="c29">0</span><span class="c2">, which are maintained in R</span><span class="c0">3</span><span class="c4">,</span><span class="c0">0</span><span class="c7">, as shown in Figure 6(b). From Equation (5), c</span><span class="c0">3</span><span class="c4">,</span><span class="c0">0</span><span class="c7">.w is up- </span><span class="c2">dated to 7. We finally assume Figure 6(c), where the three rectan- gles in R</span><span class="c0">3</span><span class="c4">,</span><span class="c0">0 </span><span class="c7">have been checked whether they overlap with the ver- </span><span class="c2">tices (rectangles) in V</span><span class="c29">3</span><span class="c13">,</span><span class="c29">0 </span><span class="c2">or not. Note that the upper-bound weight maintained by each vertex is updated and c</span><span class="c29">3</span><span class="c13">,</span><span class="c29">0</span><span class="c2">.w is also updated to 4 as the result of the rectangle overlap computation. </span><span class="c1">From Equations (3)&ndash;(5), we have the following property. </span></p><p class="c10"><span class="c1">P</span><span class="c26">ROPERTY </span><span class="c1">4. </span><span class="c2">c</span><span class="c13">i,j</span><span class="c2">.w &ge; s</span><span class="c4">i</span><span class="c31">&prime;</span><span class="c2">.w &ge; s</span><span class="c4">i</span><span class="c31">&prime;</span><span class="c2">.w for &forall;r</span><span class="c4">i</span><span class="c31">&prime; </span><span class="c2">&isin; V</span><span class="c13">i,j</span><span class="c2">. </span><span class="c1">Because of generations and expirations of rectangles, those upper- bound weights may vary dynamically, but our branch-and-bound algorithm (introduced later) dynamically updates the upper-bound weights so that Property 4 is kept. At the same time, this property provides the correctness of our branch-and-bound algorithm. </span></p><p class="c6"><span class="c1">As well as G2, we discuss about the storage cost of an aG2 below. P</span><span class="c26">ROPERTY </span><span class="c1">5. </span><span class="c2">An aG2 has the same storage cost as a G2, i.e., O</span><span class="c1">(</span><span class="c2">|V | </span><span class="c1">+ </span><span class="c2">|E|</span><span class="c1">) </span><span class="c2">where V and E are respectively the sets of all the vertices and the edges in the (a)G2. </span></p><p class="c42"><span class="c1">P</span><span class="c26">ROOF</span><span class="c1">. To prove Property 5, we have to discuss about the storage costs </span><span class="c2">nR</span><span class="c5">&sum;</span><span class="c1">that </span><span class="c8">&prime;</span><span class="c13">i,j </span><span class="c4">i,j </span><span class="c5">(</span><span class="c7">n</span><span class="c51">be </span><span class="c1">of </span><span class="c5">= </span><span class="c13">&prime;</span><span class="c4">i,j </span><span class="c1">of </span><span class="c51">the </span><span class="c1">G2 </span><span class="c7">&empty; </span><span class="c1">+ vertices, </span><span class="c5">in </span><span class="c2">|R</span><span class="c51">size </span><span class="c1">but </span><span class="c5">aG2, </span><span class="c4">i,j</span><span class="c7">|</span><span class="c5">). </span><span class="c51">of </span><span class="c1">it </span><span class="c5">we </span><span class="c1">takes </span><span class="c62">V</span><span class="c8">i,j </span><span class="c1">edges, </span><span class="c5">The have </span><span class="c51">in </span><span class="c2">O</span><span class="c1">(</span><span class="c2">E</span><span class="c1">) </span><span class="c5">number </span><span class="c51">G2 </span><span class="c1">and </span><span class="c5">that </span><span class="c51">and </span><span class="c1">upper-bound </span><span class="c7">n</span><span class="c1">cost. </span><span class="c4">i,j </span><span class="c5">of </span><span class="c51">aG2, </span><span class="c5">= edges </span><span class="c1">Let </span><span class="c7">n</span><span class="c51">respectively. </span><span class="c13">&prime;</span><span class="c4">i,j </span><span class="c2">V </span><span class="c5">in </span><span class="c1">+ weights. </span><span class="c8">&prime; </span><span class="c5">aG2 </span><span class="c2">|R</span><span class="c1">be </span><span class="c4">i,j</span><span class="c7">|</span><span class="c5">, </span><span class="c1">the </span><span class="c5">may </span><span class="c51">Because </span><span class="c5">thereby </span><span class="c1">set Let </span><span class="c5">be </span><span class="c1">of </span><span class="c5">less </span><span class="c2">n</span><span class="c4">i,j </span><span class="c2">V</span><span class="c13">i,j </span><span class="c7">|V </span><span class="c62">V</span><span class="c8">i,j </span><span class="c5">than and </span><span class="c7">| </span><span class="c62">&cap; </span><span class="c5">= </span><span class="c1">of </span></p><p class="c10"><span class="c38">322 </span></p><p class="c6"><span class="c1">aG2, and </span><span class="c2">|V | &gt; |V </span><span class="c8">&prime;</span><span class="c2">| </span><span class="c1">= </span><span class="c51">&sum;</span><span class="c2">n</span><span class="c8">&prime;</span><span class="c13">i,j</span><span class="c51">. The storage cost of upper-bound </span><span class="c1">weights maintained by vertices is </span><span class="c2">O</span><span class="c1">(</span><span class="c2">|V </span><span class="c8">&prime;</span><span class="c2">|</span><span class="c1">). Let </span><span class="c2">C </span><span class="c1">be the set of cells of an aG2, and the storage cost of upper-bound weights maintained by the cells is </span><span class="c2">O</span><span class="c1">(</span><span class="c2">|C|</span><span class="c1">). We know that </span><span class="c2">|C| &#8810; |V </span><span class="c8">&prime;</span><span class="c2">| </span><span class="c1">in practice. Therefore we can complete the proof. </span><span class="c66">D </span></p><p class="c10"><span class="c21">5.2 Branch-and-Bound Algorithm </span></p><p class="c10"><span class="c1">As described in Section 5.1, each cell and vertex in an aG2 main- tain the upper-bound weights. This enables us to process a con- tinuous MaxRS query while pruning unnecessary computations. Specifically, we can obtain two pruning rules, which can reduce the number of executions of Local-Plane-Sweep(</span><span class="c2">&middot;</span><span class="c1">). Assume an instance when </span><span class="c2">m </span><span class="c1">new rectangles are generated, the upper-bound weight of each cell is obtained by Equation (5). Given </span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c1">, we first obtain the following pruning rule. P</span><span class="c26">RUNING RULE </span><span class="c1">1. </span><span class="c2">Given a cell c</span><span class="c13">i,j </span><span class="c2">in the aG2, and if c</span><span class="c13">i,j</span><span class="c2">.w &lt; s</span><span class="c8">&lowast;</span><span class="c2">.w, all the vertices in V</span><span class="c13">i,j </span><span class="c2">do not have s</span><span class="c8">&lowast;</span><span class="c2">. Therefore we do not need to compute the exact s</span><span class="c4">i</span><span class="c31">&prime; </span><span class="c2">of r</span><span class="c4">i</span><span class="c31">&prime; </span><span class="c2">&isin; V</span><span class="c4">i,j</span><span class="c7">. </span><span class="c1">The above case efficiently prunes the computation of the exact </span><span class="c2">s</span><span class="c4">i</span><span class="c31">&prime;</span><span class="c1">. However, we are likely to hold the case where </span><span class="c2">c</span><span class="c4">i,j</span><span class="c7">.w &ge; s</span><span class="c13">&lowast;</span><span class="c7">.w</span><span class="c5">, </span><span class="c1">since </span><span class="c2">c</span><span class="c13">i,j</span><span class="c2">.w </span><span class="c1">is the maximum value among the set of the upper- bounds maintained by vertices in </span><span class="c2">G</span><span class="c4">i,j </span><span class="c5">or more (See Equation(5)). </span><span class="c1">In this case, we focus on each vertex in </span><span class="c2">V</span><span class="c13">i,j</span><span class="c1">, and then apply the next pruning rule. </span></p><p class="c10"><span class="c1">P</span><span class="c26">RUNING RULE </span><span class="c1">2. </span><span class="c2">Given a cell c</span><span class="c13">i,j </span><span class="c2">in the aG2, and we assume that c</span><span class="c4">i,j</span><span class="c7">.w &ge; s</span><span class="c13">&lowast;</span><span class="c7">.w. Given a vertex r</span><span class="c4">i</span><span class="c31">&prime; </span><span class="c2">&isin; V</span><span class="c4">i,j</span><span class="c7">, if s</span><span class="c4">i</span><span class="c31">&prime;</span><span class="c2">.w &lt; s</span><span class="c8">&lowast;</span><span class="c2">.w, r</span><span class="c4">i</span><span class="c31">&prime; </span><span class="c2">does not have s</span><span class="c8">&lowast;</span><span class="c2">, thus we do not need to compute the exact s</span><span class="c4">i</span><span class="c31">&prime;</span><span class="c2">. </span><span class="c1">From the above pruning rules, we can focus only on cells and ver- tices with non-zero probability to have </span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c1">. Note that the above pruning rules assume that </span><span class="c2">s</span><span class="c8">&lowast; </span><span class="c1">is given, although </span><span class="c2">s</span><span class="c8">&lowast; </span><span class="c1">might expire. If </span><span class="c2">s</span><span class="c8">&lowast; </span><span class="c1">expires, we first obtain a temporal </span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c1">, and the temporal </span><span class="c2">s</span><span class="c8">&lowast; </span><span class="c1">is retrieved from the cell </span><span class="c2">c </span><span class="c1">that satisfies </span></p><p class="c10"><span class="c2">c </span><span class="c1">= argmax </span></p><p class="c10"><span class="c13">c</span><span class="c48">i,j </span><span class="c13">&isin;C </span><span class="c62">c</span><span class="c8">i,j</span><span class="c62">.w, </span><span class="c51">(6) </span></p><p class="c10"><span class="c1">where </span><span class="c2">C </span><span class="c1">is the set of cells in the aG2. To keep the efficiency of the pruning rules, the weight maintained by the temporal </span><span class="c2">s</span><span class="c8">&lowast; </span><span class="c1">should be large as much as possible. It is intuitive that a cell with large upper- bound weight probably has the space with large weight, thereby we employ this heuristic. From the above discussion, we design a branch-and-bound algorithm, which efficiently updates </span><span class="c2">s</span><span class="c8">&lowast; </span><span class="c1">and is illustrated in Algorithm 2. Algorithm description. Consider an instance when </span><span class="c2">m </span><span class="c1">new rectan- gles are generated and the </span><span class="c2">m </span><span class="c1">oldest rectangles expire. We first map the newly generated rectangles to the corresponding cells </span><span class="c2">c</span><span class="c4">i,j </span><span class="c5">while </span><span class="c1">updating the upper-bound weight </span><span class="c2">c</span><span class="c13">i,j</span><span class="c2">.w </span><span class="c1">and </span><span class="c2">R</span><span class="c13">i,j </span><span class="c1">(lines 1&ndash;5). Next, we update (or find a temporal) </span><span class="c2">s</span><span class="c8">&lowast; </span><span class="c1">to enhance the pruning efficiency (line 6&ndash;10). Let </span><span class="c2">c </span><span class="c1">is the cell holding </span><span class="c2">s</span><span class="c8">&lowast; </span><span class="c1">(if </span><span class="c2">s</span><span class="c8">&lowast; </span><span class="c1">expires, we retrieve </span><span class="c2">c </span><span class="c1">that satisfies Equation (6)), we execute OverlapComputation(</span><span class="c2">c</span><span class="c1">) (line 9), which is illustrated in Algorithm 3. OverlapComputation(</span><span class="c2">c</span><span class="c1">) updates the graph in </span><span class="c2">c </span><span class="c1">and </span><span class="c2">c.w</span><span class="c1">. More specifically, we check whether rectangles in </span><span class="c2">R </span><span class="c1">of the cell </span><span class="c2">c </span><span class="c1">overlap with the rectangles (vertices) in </span><span class="c2">V </span><span class="c1">, and if overlap, new edges are inserted while updating the upper-bound weights maintained by the vertices and </span><span class="c2">c </span><span class="c1">(lines 3&ndash;8 in Algorithm 3). After that, ExactWeightComputation(</span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c2">,c</span><span class="c1">) is ex- ecuted (line 10 in Algorithm 2), which is illustrated in Algorithm 4. In ExactWeightComputation(</span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c2">,c</span><span class="c1">), we apply Pruning rule 2 to each vertex </span><span class="c2">r</span><span class="c13">i</span><span class="c1">. If </span><span class="c2">s</span><span class="c13">i</span><span class="c2">.w &gt; s</span><span class="c8">&lowast;</span><span class="c2">.w</span><span class="c1">, we execute Local-Plane-Sweep(</span><span class="c2">&middot;</span><span class="c1">) for </span><span class="c2">r</span><span class="c4">i</span><span class="c5">, and update </span><span class="c7">s</span><span class="c13">&lowast; </span><span class="c5">if necessary (lines 6&ndash;10 in Algorithm 4). Also, </span><span class="c2">c.w </span><span class="c1">is kept so that it satisfies Equation (4). From the above proce- dures, we obtain the updated (or temporal) </span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c1">, and then a branch- </span></p><p class="c10"><span class="c1">Algorithm 2: Branch-and-bound algorithm using aG2 </span></p><p class="c10"><span class="c22">1 </span><span class="c11">R</span><span class="c4">new </span><span class="c14">&larr; </span><span class="c17">the set of newly generated rectangles </span><span class="c22">2 </span><span class="c20">for </span><span class="c11">&forall;r &isin; R</span><span class="c4">new </span><span class="c17">do </span><span class="c22">3 </span><span class="c20">if </span><span class="c11">r is mapped to c</span><span class="c4">i,j </span><span class="c17">then </span><span class="c22">4 </span><span class="c11">c</span><span class="c4">i,j</span><span class="c11">.w &larr; c</span><span class="c4">i,j</span><span class="c11">.w </span><span class="c20">+ </span><span class="c11">r.w </span><span class="c22">5 </span><span class="c11">R</span><span class="c4">i,j </span><span class="c14">&larr; R</span><span class="c4">i,j </span><span class="c14">&cup; {r} </span></p><p class="c10"><span class="c22">6 </span><span class="c11">c &larr; {c</span><span class="c4">i,j </span><span class="c14">|s</span><span class="c13">&lowast; </span><span class="c17">is in </span><span class="c14">c</span><span class="c4">i,j</span><span class="c14">} </span><span class="c22">7 </span><span class="c20">if </span><span class="c11">s</span><span class="c8">&lowast; </span><span class="c11">expired (c </span><span class="c20">= </span><span class="c11">&empty;) </span><span class="c20">then </span><span class="c22">8 </span><span class="c11">c &larr; </span><span class="c20">argmax </span></p><p class="c10"><span class="c13">c</span><span class="c48">i,j</span><span class="c13">&isin;C </span><span class="c41">c</span><span class="c13">i,j</span><span class="c11">.w </span><span class="c20">// </span><span class="c9">C </span><span class="c25">is the set of cells in aG2 </span><span class="c22">9 </span><span class="c20">OverlapComputation(</span><span class="c11">c</span><span class="c20">) </span><span class="c22">10 </span><span class="c11">s</span><span class="c8">&lowast; </span><span class="c11">&larr; </span><span class="c20">ExactWeightComputation(</span><span class="c11">s</span><span class="c8">&lowast;</span><span class="c11">,c</span><span class="c20">) </span><span class="c22">11 </span><span class="c20">for </span><span class="c11">&forall;c</span><span class="c4">i,j </span><span class="c14">&isin; C\{c} </span><span class="c17">do </span><span class="c22">12 </span><span class="c20">if </span><span class="c11">c</span><span class="c4">i,j</span><span class="c14">.w &gt; s</span><span class="c13">&lowast;</span><span class="c14">.w </span><span class="c17">then </span><span class="c22">13 </span><span class="c20">OverlapComputation(</span><span class="c11">c</span><span class="c4">i,j</span><span class="c20">) </span><span class="c22">14 </span><span class="c20">if </span><span class="c11">c</span><span class="c4">i,j</span><span class="c11">.w &gt; s</span><span class="c8">&lowast;</span><span class="c11">.w </span><span class="c20">then </span><span class="c22">15 </span><span class="c11">s</span><span class="c8">&lowast; </span><span class="c11">&larr; </span><span class="c20">ExactWeightComputation(</span><span class="c11">s</span><span class="c8">&lowast;</span><span class="c11">,c</span><span class="c4">i,j</span><span class="c17">) </span></p><p class="c10"><span class="c22">16 </span><span class="c20">return </span><span class="c11">s</span><span class="c8">&lowast; </span></p><p class="c10"><span class="c1">Algorithm 3: OverlapComputation(</span><span class="c2">c</span><span class="c13">i,j</span><span class="c1">) </span></p><p class="c10"><span class="c20">Input: </span><span class="c11">c</span><span class="c4">i,j </span><span class="c17">// </span><span class="c49">a cell in aG2 </span><span class="c22">1 </span><span class="c11">c</span><span class="c4">i,j</span><span class="c14">.w &larr; </span><span class="c17">0 </span><span class="c22">2 </span><span class="c20">for </span><span class="c11">&forall;r</span><span class="c8">&prime; </span><span class="c11">&isin; R</span><span class="c4">i,j </span><span class="c20">do </span><span class="c22">3 </span><span class="c20">for </span><span class="c11">&forall;r &isin; V</span><span class="c4">i,j </span><span class="c17">do </span><span class="c22">4 </span><span class="c20">if </span><span class="c11">r</span><span class="c8">&prime; </span><span class="c11">overlaps with r </span><span class="c20">then </span><span class="c22">5 </span><span class="c11">r.E &larr; r.E &cup; {</span><span class="c20">(</span><span class="c11">r, r</span><span class="c8">&prime;</span><span class="c20">)</span><span class="c11">} </span><span class="c22">6 </span><span class="c11">s.w &larr; s.w </span><span class="c20">+ </span><span class="c11">r</span><span class="c8">&prime;</span><span class="c11">.w </span><span class="c22">7 </span><span class="c20">if </span><span class="c11">c</span><span class="c4">i,j</span><span class="c14">.w &lt; s.w </span><span class="c17">then </span><span class="c22">8 </span><span class="c11">c</span><span class="c4">i,j</span><span class="c11">.w &larr; s.w </span></p><p class="c10"><span class="c22">9 </span><span class="c20">if </span><span class="c11">c</span><span class="c4">i,j</span><span class="c14">.w &lt; r</span><span class="c13">&prime;</span><span class="c14">.w </span><span class="c17">then </span><span class="c22">10 </span><span class="c11">c</span><span class="c4">i,j</span><span class="c14">.w &larr; r</span><span class="c13">&prime;</span><span class="c14">.w </span><span class="c22">11 </span><span class="c11">s</span><span class="c8">&prime;</span><span class="c11">.w &larr; r</span><span class="c8">&prime;</span><span class="c11">.w </span><span class="c22">12 </span><span class="c11">V</span><span class="c4">i,j </span><span class="c11">&larr; V</span><span class="c4">i,j </span><span class="c11">&cup; {r</span><span class="c8">&prime;</span><span class="c11">} </span><span class="c22">13 </span><span class="c11">R</span><span class="c4">i,j </span><span class="c14">&larr; R</span><span class="c4">i,j</span><span class="c14">\{r</span><span class="c13">&prime;</span><span class="c14">} </span></p><p class="c10"><span class="c1">and-bound approach is employed (lines 11&ndash;15 in Algorithm 2) to guarantee the correct </span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c1">. </span></p><p class="c10"><span class="c1">Given a cell </span><span class="c2">c</span><span class="c4">i,j</span><span class="c5">, we first apply Pruning rule 1, and if </span><span class="c7">c</span><span class="c4">i,j</span><span class="c7">.w &gt; </span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c2">.w</span><span class="c1">, we update (i.e., decrease) </span><span class="c2">c</span><span class="c13">i,j</span><span class="c2">.w </span><span class="c1">by OverlapComputation(</span><span class="c2">c</span><span class="c13">i,j</span><span class="c1">) (lines 12&ndash;13). Again we apply Pruning rule 1 to </span><span class="c2">c</span><span class="c4">i,j</span><span class="c5">, and if </span><span class="c7">c</span><span class="c4">i,j</span><span class="c7">.w &gt; </span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c2">.w </span><span class="c1">again, ExactWeightComputation(</span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c2">,c</span><span class="c4">i,j</span><span class="c5">), which we explained </span><span class="c1">above, is executed. In the case where we compute the exact </span><span class="c2">s</span><span class="c4">i</span><span class="c31">&prime; </span><span class="c1">maintained by </span><span class="c2">r</span><span class="c4">i</span><span class="c31">&prime; </span><span class="c2">&isin; V</span><span class="c4">i,j</span><span class="c5">, in ExactWeightComputation(</span><span class="c7">s</span><span class="c13">&lowast;</span><span class="c7">,c</span><span class="c4">i,j</span><span class="c5">), </span><span class="c1">and </span><span class="c2">s</span><span class="c4">i</span><span class="c31">&prime;</span><span class="c2">.w &gt; s</span><span class="c8">&lowast;</span><span class="c2">.w</span><span class="c1">, </span><span class="c2">s</span><span class="c8">&lowast; </span><span class="c1">is updated (line 10 in Algorithm 4). These operations are executed for </span><span class="c2">&forall;c</span><span class="c4">i,j </span><span class="c7">&isin; C\{c}</span><span class="c5">, and after that, we can </span><span class="c1">keep monitoring the correct </span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c1">. Time complexity. OverlapComputation(</span><span class="c2">c</span><span class="c4">i,j</span><span class="c5">) takes </span><span class="c7">O</span><span class="c5">(</span><span class="c7">|V</span><span class="c4">i,j</span><span class="c7">||R</span><span class="c4">i,j</span><span class="c7">|</span><span class="c5">). </span><span class="c1">Let </span><span class="c2">C</span><span class="c8">&prime; </span><span class="c1">be the set of the cells that OverlapComputation(</span><span class="c2">&middot;</span><span class="c1">) is ex- ecuted, and the amortized time to compute the rectangle overlap- ping is </span><span class="c2">O</span><span class="c1">(</span><span class="c2">|C</span><span class="c8">&prime;</span><span class="c2">||V</span><span class="c4">i,j</span><span class="c7">||R</span><span class="c4">i,j</span><span class="c7">|</span><span class="c5">). Let </span><span class="c7">v</span><span class="c13">&prime; </span><span class="c5">be the number of the vertices </span><span class="c1">that Local-Plane-Sweep(</span><span class="c2">&middot;</span><span class="c1">) is executed. Also let </span><span class="c2">e</span><span class="c8">&prime; </span><span class="c1">be the aver- age number of edges of the above vertices, and the total cost of ExactWeightComputation(</span><span class="c2">&middot;,&middot;</span><span class="c1">) is </span><span class="c2">O</span><span class="c1">(</span><span class="c2">v</span><span class="c8">&prime;</span><span class="c2">e</span><span class="c8">&prime; </span><span class="c1">log </span><span class="c2">e</span><span class="c8">&prime;</span><span class="c1">). When </span><span class="c2">m </span><span class="c1">new ob- jects are generated, Algorithm 2 takes </span><span class="c2">O</span><span class="c1">(</span><span class="c2">|C</span><span class="c8">&prime;</span><span class="c2">||V</span><span class="c4">i,j</span><span class="c7">||R</span><span class="c4">i,j</span><span class="c7">|</span><span class="c5">+</span><span class="c7">v</span><span class="c13">&prime;</span><span class="c7">e</span><span class="c13">&prime; </span><span class="c5">log </span><span class="c7">e</span><span class="c13">&prime;</span><span class="c5">) </span><span class="c1">(amortized) time. Recall the time complexity of Algorithm 1, and note that </span><span class="c2">|C</span><span class="c8">&prime;</span><span class="c2">||V</span><span class="c13">i,j</span><span class="c2">||R</span><span class="c13">i,j</span><span class="c2">| &le; c</span><span class="c8">&prime;</span><span class="c2">m</span><span class="c8">&prime;</span><span class="c2">n</span><span class="c8">&prime; </span><span class="c1">and </span><span class="c2">v</span><span class="c8">&prime;</span><span class="c2">e</span><span class="c8">&prime; </span><span class="c1">log </span><span class="c2">e</span><span class="c8">&prime; </span><span class="c2">&lt; ve</span><span class="c1">log </span><span class="c2">e</span><span class="c1">. Correctness. The correctness of Algorithm 2 is proven by Prop- erty 4. In Algorithms 2&ndash;4, we define the condition that we cannot prune OverlapComputation(</span><span class="c2">&middot;</span><span class="c1">) and ExactWeightComputation(</span><span class="c2">&middot;,&middot;</span><span class="c1">) as &ldquo;</span><span class="c2">&gt;</span><span class="c1">&rdquo; instead of &ldquo;</span><span class="c2">&ge;</span><span class="c1">,&rdquo; e.g., line 12 of Algorithm 2. This is because </span></p><p class="c10"><span class="c38">323 </span></p><p class="c10"><span class="c1">Algorithm 4: ExactWeightComputation(</span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c2">,c</span><span class="c4">i,j</span><span class="c5">) </span><span class="c22">1 2 3 </span><span class="c20">Input: </span><span class="c11">c</span><span class="c20">for </span><span class="c4">i,j</span><span class="c11">&forall;r.w &rho; </span><span class="c4">i</span><span class="c11">&larr; </span><span class="c31">&prime; </span><span class="c11">&larr; s</span><span class="c8">&lowast;</span><span class="c11">&isin; </span><span class="c20">0 , 0 </span><span class="c11">cV</span><span class="c4">i,j i,j </span><span class="c17">// do </span></p><p class="c10"><span class="c71">c</span><span class="c48">i,j </span><span class="c49">is a cell in aG2 </span></p><p class="c42"><span class="c22">4 </span><span class="c20">if </span><span class="c11">s</span><span class="c8">&lowast; </span><span class="c20">= </span><span class="c11">&empty; </span><span class="c20">then </span><span class="c22">5 </span><span class="c11">&rho; &larr; s</span><span class="c8">&lowast;</span><span class="c11">.w </span><span class="c22">6 7 8 9 10 </span><span class="c20">if </span><span class="c11">s</span><span class="c4">i</span><span class="c31">&prime;</span><span class="c11">.w ss</span><span class="c20">if </span><span class="c4">ii</span><span class="c31">&prime; &prime;</span><span class="c11">.w s</span><span class="c4">i</span><span class="c11">&larr; &gt; </span><span class="c31">&prime;</span><span class="c11">.w s</span><span class="c8">&lowast; </span><span class="c11">&larr; &rho; </span><span class="c20">Local-Plane-Sweep(</span><span class="c11">N</span><span class="c20">(</span><span class="c11">r&larr; &gt; </span><span class="c20">then </span></p><p class="c12"><span class="c11">s</span><span class="c4">i</span><span class="c11">ss</span><span class="c31">&prime;</span><span class="c11">.w </span><span class="c4">i</span><span class="c8">&lowast;</span><span class="c31">&prime; </span></p><p class="c10"><span class="c11">.w </span><span class="c20">then </span></p><p class="c10"><span class="c4">i</span><span class="c31">&prime; </span><span class="c11">&cup; {r</span><span class="c4">i</span><span class="c31">&prime;</span><span class="c11">}</span><span class="c20">)) </span></p><p class="c10"><span class="c22">11 12 </span><span class="c20">if </span><span class="c11">c</span><span class="c4">i,j</span><span class="c11">c</span><span class="c4">i,j</span><span class="c14">.w </span><span class="c11">.w &lt; </span><span class="c14">&larr; </span><span class="c11">s</span><span class="c4">i</span><span class="c31">&prime;</span><span class="c11">.w </span><span class="c14">s</span><span class="c4">i</span><span class="c31">&prime;</span><span class="c11">.w </span></p><p class="c10"><span class="c20">then </span></p><p class="c10"><span class="c22">13 </span><span class="c20">return </span><span class="c11">s</span><span class="c8">&lowast; </span></p><p class="c10"><span class="c1">we monitor one of the spaces with the maximum weight, thus if </span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c2">.w </span><span class="c1">= </span><span class="c2">c</span><span class="c4">i,j</span><span class="c7">.w </span><span class="c5">for example, we keep monitoring </span><span class="c7">s</span><span class="c13">&lowast;</span><span class="c5">, and this does </span><span class="c1">not sacrifice the correctness. If applications require all spaces with the maximum weight like the AllMaxRS problem [9], we just need to define the condition as &ldquo;</span><span class="c2">&ge;</span><span class="c1">.&rdquo; </span><span class="c21">5.3 Discussion </span></p><p class="c6"><span class="c1">To demonstrate the efficiency and practicality of Algorithm 2, we review the following conceivable approaches that can tight the upper-bound weights maintained by rectangles more than Algo- rithm 2. </span></p><p class="c10"><span class="c1">1. An approach that all rectangles </span><span class="c2">r</span><span class="c4">i </span><span class="c5">maintain </span><span class="c7">all </span><span class="c5">the overlapped </span></p><p class="c10"><span class="c1">spaces on </span><span class="c2">r</span><span class="c13">i</span><span class="c1">. </span></p><p class="c6"><span class="c1">2. An additional approach of Algorithm 2 that computes the maximum space weight among the common spaces on </span><span class="c2">r</span><span class="c4">i </span><span class="c5">and </span><span class="c2">r</span><span class="c13">j </span><span class="c1">when (</span><span class="c2">r</span><span class="c13">j</span><span class="c2">,r</span><span class="c13">i</span><span class="c1">) is inserted to </span><span class="c2">r</span><span class="c13">i</span><span class="c2">.E</span><span class="c1">. </span></p><p class="c10"><span class="c1">3. An additional approach of Algorithm 2 that tries to decrease </span></p><p class="c10"><span class="c2">s</span><span class="c4">i</span><span class="c7">.w </span><span class="c5">when </span><span class="c7">s</span><span class="c4">i</span><span class="c7">.w &gt; s</span><span class="c13">&lowast;</span><span class="c7">.w</span><span class="c5">. </span></p><p class="c6"><span class="c1">We show that these approaches do not guarantee the reduction of time complexity, rather, the worst-case time complexity becomes worse than Algorithm 2. </span></p><p class="c42"><span class="c1">Approach 1. Given a rectangle </span><span class="c2">r</span><span class="c4">i</span><span class="c5">, we assume that </span><span class="c7">S</span><span class="c4">i </span><span class="c5">is the set </span><span class="c1">of the overlapped spaces on </span><span class="c2">r</span><span class="c13">i</span><span class="c1">. Since </span><span class="c2">r</span><span class="c13">i </span><span class="c1">maintains all the over- lapped spaces on ever, given </span><span class="c2">m</span><span class="c8">&prime; </span><span class="c1">new </span><span class="c2">r</span><span class="c4">i</span><span class="c5">, </span><span class="c1">rectangles </span><span class="c5">we can compute </span><span class="c1">overlapping </span><span class="c2">O</span><span class="c1">(</span><span class="c2">m</span><span class="c8">&prime; </span><span class="c1">log </span><span class="c2">|S</span><span class="c4">i</span><span class="c7">|</span><span class="c5">) time in practice</span><span class="c29">1 </span><span class="c1">cause </span><span class="c2">|S</span><span class="c4">i</span><span class="c7">|&ge;|r</span><span class="c4">i</span><span class="c7">.E|</span><span class="c5">, we may have the tightest </span><span class="c7">s</span><span class="c4">i</span><span class="c7">.w</span><span class="c5">. How- </span><span class="c1">with </span><span class="c2">r</span><span class="c13">i</span><span class="c1">, we need at least </span><span class="c5">to that compute </span><span class="c7">O</span><span class="c5">(</span><span class="c7">m</span><span class="c13">&prime; </span><span class="c5">log the </span><span class="c7">|S</span><span class="c5">tightest </span><span class="c4">i</span><span class="c7">|</span><span class="c5">) is larger </span><span class="c7">s</span><span class="c4">i</span><span class="c7">.w</span><span class="c5">. than Be- </span></p><p class="c10"><span class="c1">the time cost of the plane-sweep algorithm, i.e., </span><span class="c2">O</span><span class="c1">(</span><span class="c2">|r</span><span class="c13">i</span><span class="c2">.E| </span><span class="c1">log </span><span class="c2">|r</span><span class="c13">i</span><span class="c2">.E|</span><span class="c1">). To bound the worst time complexity, we execute Local-Plane-Sweep(</span><span class="c2">&middot;</span><span class="c1">), if </span><span class="c2">O</span><span class="c1">(</span><span class="c2">m</span><span class="c8">&prime; </span><span class="c1">log </span><span class="c2">|S</span><span class="c13">i</span><span class="c2">|</span><span class="c1">) </span><span class="c2">&gt; O</span><span class="c1">(</span><span class="c2">|r</span><span class="c13">i</span><span class="c2">.E|</span><span class="c1">log </span><span class="c2">|r</span><span class="c13">i</span><span class="c2">.E|</span><span class="c1">) (if we can estimate this situation). Then the worst-case time complexity is the same as Al- gorithm 1, thus is worse than Algorithm 2. Note that this approach is impractical because we cannot bound the number of spaces main- tained by rectangles. Approach 2. Recall that an optimal way to compute the maximum space weight is the plane-sweep algorithm, thereby this approach is equivalent to the exact </span><span class="c2">s</span><span class="c13">i </span><span class="c1">computation. That is, this approach does not make sense. Approach 3. Given a vertex </span><span class="c2">r</span><span class="c4">i </span><span class="c5">in an aG2, and when </span><span class="c7">s</span><span class="c4">i</span><span class="c7">.w &gt; s</span><span class="c13">&lowast;</span><span class="c7">.w</span><span class="c5">, </span><span class="c1">this approach tries to decrease </span><span class="c2">s</span><span class="c4">i</span><span class="c7">.w</span><span class="c5">. This approach is illustrated </span><span class="c29">1</span><span class="c5">In the case where </span><span class="c7">S</span><span class="c4">i </span><span class="c5">is indexed by an R-tree or a Quad-tree. </span></p><p class="c10"><span class="c1">Algorithm 5: UpperboundUpdate(</span><span class="c2">r</span><span class="c13">i</span><span class="c1">) </span><span class="c22">1 </span><span class="c20">Input: </span><span class="c11">R</span><span class="c20">(</span><span class="c11">r</span><span class="c20">been </span><span class="c4">i</span><span class="c20">) executed </span><span class="c11">&larr; r</span><span class="c4">i </span><span class="c17">// </span><span class="c20">the </span><span class="c49">a </span><span class="c20">set Plane-Sweep(</span><span class="c11">&middot;</span><span class="c20">) </span></p><p class="c10"><span class="c49">vertex </span><span class="c20">of vertices </span><span class="c49">of a given cell. </span></p><p class="c10"><span class="c20">that are included in </span><span class="c11">N</span><span class="c20">(</span><span class="c11">r</span><span class="c4">i</span><span class="c20">) but have not </span></p><p class="c10"><span class="c22">2 3 4 5 </span><span class="c11">&tau; </span><span class="c20">for </span><span class="c11">&larr; &forall;r </span><span class="c20">if </span><span class="c11">sr </span><span class="c4">i</span><span class="c14">.w </span></p><p class="c10"><span class="c11">&isin; overlaps &tau; R</span><span class="c20">(</span><span class="c11">r&larr; </span><span class="c4">i</span><span class="c11">&tau; </span><span class="c20">) + do </span></p><p class="c10"><span class="c11">with r.w </span></p><p class="c10"><span class="c11">s</span><span class="c4">i </span><span class="c17">then </span></p><p class="c10"><span class="c22">6 </span><span class="c20">if </span><span class="c11">&tau;&gt;s</span><span class="c8">&lowast;</span><span class="c11">.w </span><span class="c20">then </span><span class="c22">7 8 </span><span class="c11">s</span><span class="c20">break </span></p><p class="c10"><span class="c4">i</span><span class="c14">.w &larr; &tau; </span></p><p class="c10"><span class="c22">9 </span><span class="c20">else </span><span class="c22">10 11 12 </span><span class="c11">&rho; </span><span class="c20">for </span><span class="c11">&larr; r</span><span class="c20">if </span><span class="c8">&prime; </span><span class="c11">r.w &isin; r overlaps N</span><span class="c20">(</span><span class="c11">r</span><span class="c20">+ </span><span class="c11">r</span><span class="c4">ii</span><span class="c17">)</span><span class="c14">\{r} </span><span class="c11">.w </span></p><p class="c10"><span class="c11">with </span><span class="c17">do </span></p><p class="c10"><span class="c11">r</span><span class="c8">&prime; </span><span class="c20">then </span><span class="c22">13 </span><span class="c11">&rho; &larr; &rho; </span><span class="c20">+ </span><span class="c11">r</span><span class="c8">&prime;</span><span class="c11">.w </span></p><p class="c10"><span class="c22">14 </span><span class="c20">if </span><span class="c11">&tau;&lt;&rho; </span><span class="c20">then </span><span class="c22">15 </span><span class="c11">&tau; &larr; </span><span class="c20">min(</span><span class="c11">&tau; </span><span class="c20">+ </span><span class="c11">r.w, &rho;</span><span class="c20">) </span><span class="c22">16 </span><span class="c20">if </span><span class="c11">&tau;&gt;s</span><span class="c8">&lowast;</span><span class="c11">.w </span><span class="c20">then </span><span class="c22">17 18 </span><span class="c11">s</span><span class="c20">break </span></p><p class="c10"><span class="c4">i</span><span class="c14">.w &larr; &tau; </span></p><p class="c42"><span class="c1">by Algorithm 5, which may be executed after line 6 of Algorithm 4. Assume an instance when </span><span class="c2">s</span><span class="c4">i </span><span class="c5">is computed, and let </span><span class="c7">R</span><span class="c5">(</span><span class="c7">r</span><span class="c4">i</span><span class="c5">) be the </span><span class="c1">set of vertices that are included in </span><span class="c2">N</span><span class="c1">(</span><span class="c2">r</span><span class="c13">i</span><span class="c1">) after the instance. In other words, </span><span class="c2">s</span><span class="c4">i </span><span class="c5">has been computed based on </span><span class="c7">N</span><span class="c5">(</span><span class="c7">r</span><span class="c4">i</span><span class="c5">)</span><span class="c7">\R</span><span class="c5">(</span><span class="c7">r</span><span class="c4">i</span><span class="c5">). In </span><span class="c1">a nut shell, given </span><span class="c2">r &isin; </span><span class="c1">this approach computes </span><span class="c2">R</span><span class="c1">(</span><span class="c2">r</span><span class="c13">i</span><span class="c1">) overlaps with </span><span class="c2">s</span><span class="c13">i </span><span class="c2">s</span><span class="c4">i</span><span class="c7">.w </span><span class="c5">by checking </span><span class="c1">(line 4) or the </span><span class="c5">whether </span><span class="c1">rectangle </span><span class="c2">r</span><span class="c8">&prime; </span><span class="c5">a </span><span class="c2">&isin; N</span><span class="c1">(</span><span class="c2">r</span><span class="c1">)</span><span class="c2">\{r} </span><span class="c1">(line 12). Due to the latter case, this approach does not necessarily add </span><span class="c2">r.w </span><span class="c1">to </span><span class="c2">s</span><span class="c13">i</span><span class="c2">.w</span><span class="c1">, which may result in less </span><span class="c2">s</span><span class="c13">i</span><span class="c2">.w </span><span class="c1">than the original Algorithm 4. This approach however needs an extra </span><span class="c2">O</span><span class="c1">(</span><span class="c2">|R</span><span class="c1">(</span><span class="c2">r</span><span class="c13">i</span><span class="c1">)</span><span class="c2">||N</span><span class="c1">(</span><span class="c2">r</span><span class="c13">i</span><span class="c1">)</span><span class="c2">|</span><span class="c1">) time </span><span class="c2">for each r</span><span class="c13">i </span><span class="c1">where </span><span class="c2">s</span><span class="c13">i</span><span class="c2">.w &gt; s</span><span class="c8">&lowast;</span><span class="c2">.w</span><span class="c1">. Recall that Local-Plane-Sweep(</span><span class="c2">N</span><span class="c1">(</span><span class="c2">r</span><span class="c4">i</span><span class="c5">)</span><span class="c7">&cup;{r</span><span class="c4">i</span><span class="c7">}</span><span class="c5">) takes</span><span class="c7">O</span><span class="c5">(</span><span class="c7">|N</span><span class="c5">(</span><span class="c7">r</span><span class="c4">i</span><span class="c5">)</span><span class="c7">|</span><span class="c5">log </span><span class="c7">|N</span><span class="c5">(</span><span class="c7">r</span><span class="c4">i</span><span class="c5">)</span><span class="c7">|</span><span class="c5">) </span><span class="c1">time, and we may have that </span><span class="c2">O</span><span class="c1">(</span><span class="c2">|R</span><span class="c1">(</span><span class="c2">r</span><span class="c4">i</span><span class="c5">)</span><span class="c7">||N</span><span class="c5">(</span><span class="c7">r</span><span class="c4">i</span><span class="c5">)</span><span class="c7">|</span><span class="c5">) </span><span class="c7">&gt; O</span><span class="c5">(</span><span class="c7">|N</span><span class="c5">(</span><span class="c7">r</span><span class="c4">i</span><span class="c5">)</span><span class="c7">|</span><span class="c5">log </span><span class="c7">|N</span><span class="c5">(</span><span class="c7">r</span><span class="c4">i</span><span class="c5">)</span><span class="c7">|</span><span class="c5">). </span><span class="c1">It would be better to execute Algorithm 5 only in the case where </span><span class="c2">|R</span><span class="c1">(</span><span class="c2">r</span><span class="c4">i</span><span class="c5">)</span><span class="c7">||N</span><span class="c5">(</span><span class="c7">r</span><span class="c4">i</span><span class="c5">)</span><span class="c7">| &lt; </span><span class="c5">2</span><span class="c7">|N</span><span class="c5">(</span><span class="c7">r</span><span class="c4">i</span><span class="c5">)</span><span class="c7">|</span><span class="c5">log </span><span class="c7">|N</span><span class="c5">(</span><span class="c7">r</span><span class="c4">i</span><span class="c5">)</span><span class="c7">| </span><span class="c5">(since the plane-sweep al- </span><span class="c1">gorithm needs 2</span><span class="c2">n </span><span class="c1">log </span><span class="c2">n </span><span class="c1">operations). We can therefore see that this approach does not work well if </span><span class="c2">|R</span><span class="c1">(</span><span class="c2">r</span><span class="c4">i</span><span class="c5">)</span><span class="c7">| </span><span class="c5">is large. Also, this ap- </span><span class="c1">proach increases the worst-case time complexity, which means no guarantee to reduce the time complexity of Algorithm 2. Our ex- perimental results also show that this approach does not guarantee the acceleration of query processing. </span></p><p class="c10"><span class="c1">From the above discussion, we see that more storage and non- reasonable computational costs are required to tight the upper-bound weights. The upper-bounding cost of Algorithm 2 is reasonable and the worst-case time complexity is better than the above approaches. </span></p><p class="c10"><span class="c21">6. APPLICATION TO RELATED PROBLEMS </span><span class="c1">In this section, we address two problems of approximate moni- toring MaxRS and monitoring top-k MaxRS. We solve these prob- lems efficiently by employing the branch-and-bound algorithm us- ing aG2 with simple extensions. </span><span class="c21">6.1 Approximate Monitoring MaxRS </span></p><p class="c6"><span class="c1">To improve query processing efficiency, some applications re- quire not the exact but approximate results [25]. In this case, it is important to bound the error rate, thus, given a user-tolerance error </span><span class="c2">&epsilon; </span><span class="c1">(0 </span><span class="c2">&le; &epsilon; &lt; </span><span class="c1">1), the objective of this problem is to continuously monitor a space </span><span class="c2">s </span><span class="c1">with the weight </span><span class="c2">s.w </span><span class="c1">that satisfies </span></p><p class="c10"><span class="c2">s.w &ge; </span><span class="c1">(1 </span><span class="c2">&minus; &epsilon;</span><span class="c1">)</span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c2">.w. </span></p><p class="c10"><span class="c38">324 </span></p><p class="c6"><span class="c1">Algorithm 2 can deal with this problem by respectively replacing Pruning rules 1 and 2 with Pruning rules 3 and 4, which are shown below. </span></p><p class="c10"><span class="c1">P</span><span class="c26">RUNING RULE </span><span class="c1">3. </span><span class="c2">Given a cell c</span><span class="c4">i,j </span><span class="c7">in the aG2 and the space s </span><span class="c2">monitored by our approximate algorithm, if </span><span class="c1">(1 </span><span class="c2">&minus; &epsilon;</span><span class="c1">)</span><span class="c2">c</span><span class="c13">i,j</span><span class="c2">.w &lt; s.w, we do not compute the exact s</span><span class="c4">i</span><span class="c31">&prime; </span><span class="c2">of r</span><span class="c4">i</span><span class="c31">&prime; </span><span class="c2">&isin; V</span><span class="c4">i,j</span><span class="c7">. </span><span class="c1">P</span><span class="c26">RUNING RULE </span><span class="c1">4. </span><span class="c2">Given a cell c</span><span class="c4">i,j </span><span class="c7">in the aG2 and the space </span><span class="c2">s monitored by our approximate algorithm, if </span><span class="c1">(1 </span><span class="c2">&minus; &epsilon;</span><span class="c1">)</span><span class="c2">c</span><span class="c4">i,j</span><span class="c7">.w &ge; </span><span class="c2">s.w, we cannot prune OverlapComputation</span><span class="c1">(</span><span class="c2">c</span><span class="c13">i,j</span><span class="c1">) </span><span class="c2">by Pruning rule 3. Given a vertex r</span><span class="c4">i</span><span class="c31">&prime; </span><span class="c2">&isin; V</span><span class="c4">i,j</span><span class="c7">, if </span><span class="c5">(1 </span><span class="c7">&minus; &epsilon;</span><span class="c5">)</span><span class="c7">s</span><span class="c4">i</span><span class="c31">&prime;</span><span class="c2">.w &lt; s.w, we do not compute the exact s</span><span class="c4">i</span><span class="c31">&prime;</span><span class="c2">. </span></p><p class="c12"><span class="c1">We demonstrate that our approximate algorithm (which is the approximate version of Algorithm 2) guarantees the error bound. T</span><span class="c26">HEOREM </span><span class="c1">1. </span><span class="c2">Our approximate algorithm always guarantees that s.w &ge; </span><span class="c1">(1 </span><span class="c2">&minus; &epsilon;</span><span class="c1">)</span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c2">.w. </span><span class="c1">To prove Theorem 2, we need to introduce the following lemmas. L</span><span class="c26">EMMA </span><span class="c1">1. </span><span class="c2">Assume that we are monitoring s that satisfies s.w &ge; </span><span class="c1">(1 </span><span class="c2">&minus; &epsilon;</span><span class="c1">)</span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c2">.w before applying Pruning rule 3 to a cell c</span><span class="c13">i,j</span><span class="c2">. It is guaranteed that Pruning rule 3 does not lose that s.w &ge; </span><span class="c1">(1 </span><span class="c2">&minus; &epsilon;</span><span class="c1">)</span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c2">.w. </span><span class="c1">P</span><span class="c26">ROOF</span><span class="c1">. that (1 </span><span class="c2">&minus; </span><span class="c1">If </span><span class="c2">&epsilon;</span><span class="c1">)</span><span class="c2">sc</span><span class="c4">i,j</span><span class="c7">.w </span><span class="c8">&lowast;</span><span class="c2">.w &le; </span><span class="c7">&lt; </span><span class="c2">s.w </span><span class="c7">s</span><span class="c13">&lowast;</span><span class="c7">.w </span><span class="c1">due </span><span class="c5">and </span><span class="c1">to the </span><span class="c5">(1 </span><span class="c1">assumption. </span><span class="c7">&minus; &epsilon;</span><span class="c5">)</span><span class="c7">c</span><span class="c4">i,j</span><span class="c7">.w &lt; s.w</span><span class="c5">, it is trivial </span><span class="c1">On the other hand, if </span><span class="c2">c</span><span class="c4">i,j</span><span class="c7">.w </span><span class="c1">Therefore </span><span class="c7">&ge; </span><span class="c1">if </span><span class="c2">s.w </span><span class="c7">s</span><span class="c13">&lowast;</span><span class="c7">.w</span><span class="c5">, </span><span class="c2">&gt; </span><span class="c1">(1 </span><span class="c5">we </span><span class="c2">&minus; </span><span class="c5">have </span><span class="c2">&epsilon;</span><span class="c1">)</span><span class="c2">c</span><span class="c4">i,j</span><span class="c7">.w</span><span class="c5">, that (1 </span><span class="c7">s.w &minus; &gt; &epsilon;</span><span class="c5">)</span><span class="c7">c</span><span class="c5">(1 </span><span class="c4">i,j</span><span class="c7">.w &minus; &epsilon;</span><span class="c5">)</span><span class="c7">s&ge; </span><span class="c13">&lowast;</span><span class="c7">.w</span><span class="c5">. (1 </span><span class="c7">&minus; &epsilon;</span><span class="c5">)</span><span class="c7">s</span><span class="c13">&lowast;</span><span class="c7">.w</span><span class="c5">. </span><span class="c64">D </span><span class="c1">L</span><span class="c26">EMMA </span><span class="c1">2. </span><span class="c2">Assume that we are monitoring s that satisfies s.w &ge; </span><span class="c1">(1 </span><span class="c2">&minus; &epsilon;</span><span class="c1">)</span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c2">.w before applying Pruning rule 4 to a vertex r</span><span class="c4">i</span><span class="c31">&prime;</span><span class="c2">. It is guaranteed that Pruning rule 4 does not lose that s.w &ge; </span><span class="c1">(1 </span><span class="c2">&minus; &epsilon;</span><span class="c1">)</span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c2">.w. </span><span class="c1">P</span><span class="c26">ROOF</span><span class="c1">. Essentially the same as the proof of Lemma 1. </span><span class="c66">D </span><span class="c1">Now, we are ready to prove Theorem 1. P</span><span class="c26">ROOF</span><span class="c1">. As long as we are monitoring </span><span class="c2">s </span><span class="c1">that satisfies </span><span class="c2">s.w &ge; </span><span class="c1">(1 </span><span class="c2">&minus; &epsilon;</span><span class="c1">)</span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c2">.w</span><span class="c1">, Pruning rules 3 and 4 do not lose the bound, which can be seen from Lemmas 1 and 2. We here assume that we are monitor- ing </span><span class="c2">s </span><span class="c1">that satisfies </span><span class="c2">s.w &lt; </span><span class="c1">(1 </span><span class="c2">&minus; &epsilon;</span><span class="c1">)</span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c2">.w</span><span class="c1">. Let </span><span class="c2">c</span><span class="c8">&lowast; </span><span class="c1">be the cell hold- ing </span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c1">, and we have that </span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c2">.w &le; s</span><span class="c8">&lowast;</span><span class="c2">.w &le; c</span><span class="c8">&lowast;</span><span class="c2">.w</span><span class="c1">. Therefore, in this case, we definitely cannot prune OverlapComputation(</span><span class="c2">c</span><span class="c8">&lowast;</span><span class="c1">) and ExactWeightComputation(</span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c2">,c</span><span class="c8">&lowast;</span><span class="c1">) by Pruning rules 3 and 4, and </span><span class="c2">s </span><span class="c1">is replaced by </span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c1">. This means that </span><span class="c2">s </span><span class="c1">cannot be the result, thus we conclude that Theorem 2 is true from the contradiction. </span><span class="c66">D </span></p><p class="c10"><span class="c21">6.2 Monitoring Top-k MaxRS </span></p><p class="c6"><span class="c1">If the requirement is to monitor not only a single space but multi- ple spaces with the largest weight, a continuous top-k MaxRS query is a promising solution. This query achieves the requirement while controlling the result size as Definition 4 describes. </span></p><p class="c6"><span class="c1">We know that Pruning rules 1 and 2 are based on a threshold, and the threshold is </span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c2">.w</span><span class="c1">, i.e., the (temporal) top-1 weight. It is intuitively known that the threshold is set as the </span><span class="c2">k</span><span class="c1">th largest weight in continuous top-k MaxRS queries. </span></p><p class="c10"><span class="c1">Algorithm 6 illustrates the high level algorithm. Although the algorithm for continuous top-k MaxRS queries is essentially the same as Algorithm 2, the main modification is to deal with the set </span><span class="c2">S</span><span class="c8">&lowast; </span><span class="c1">of the </span><span class="c2">k </span><span class="c1">spaces with the maximum weight. We do not show OverlapComputation(</span><span class="c2">C</span><span class="c8">&prime;</span><span class="c1">) and ExactWeightComputation(</span><span class="c2">S</span><span class="c8">&lowast;</span><span class="c2">,C</span><span class="c8">&prime;</span><span class="c1">) be- cause they are also essentially the same as Algorithms 3 and 4, re- spectively. </span></p><p class="c10"><span class="c21">7. EXPERIMENTS </span></p><p class="c10"><span class="c1">Algorithm 6: Branch-and-bound algorithm using aG2 for con- tinuous top-k MaxRS queries </span></p><p class="c10"><span class="c22">1 </span><span class="c20">Execute lines 1&ndash;5 in Algorithm 2 </span><span class="c22">2 3 </span><span class="c11">C</span><span class="c8">&prime; </span><span class="c11">&larr; </span><span class="c20">if </span><span class="c11">C</span><span class="c8">&prime; </span><span class="c20">= </span><span class="c11">{&forall;c&empty; (all </span><span class="c4">i,j </span><span class="c14">|&exist;s </span><span class="c11">spaces </span><span class="c14">&isin; S</span><span class="c11">in </span><span class="c13">&lowast; </span><span class="c11">S</span><span class="c17">is </span><span class="c8">&lowast; </span><span class="c17">in </span><span class="c11">expire) </span><span class="c14">c</span><span class="c4">i,j</span><span class="c14">} </span></p><p class="c10"><span class="c20">then </span><span class="c22">4 </span><span class="c11">C</span><span class="c8">&prime; </span><span class="c11">&larr; </span><span class="c20">argmax </span></p><p class="c10"><span class="c13">c</span><span class="c48">i,j</span><span class="c13">&isin;C </span><span class="c41">c</span><span class="c13">i,j</span><span class="c11">.w </span><span class="c20">// </span><span class="c9">C </span><span class="c25">is the set of cells in aG2 </span><span class="c22">5 </span><span class="c20">OverlapComputation(</span><span class="c11">C</span><span class="c8">&prime;</span><span class="c20">) </span><span class="c22">6 </span><span class="c11">S</span><span class="c8">&lowast; </span><span class="c11">&larr; </span><span class="c20">ExactWeightComputation(</span><span class="c11">S</span><span class="c8">&lowast;</span><span class="c11">,C</span><span class="c8">&prime;</span><span class="c20">) </span><span class="c22">7 8 </span><span class="c20">for </span><span class="c11">&forall;c</span><span class="c20">Execute </span><span class="c4">i,j </span><span class="c14">&isin; C\C</span><span class="c13">&prime; </span><span class="c17">do </span></p><p class="c10"><span class="c20">lines 12&ndash;15 in Algorithm 2 </span><span class="c22">9 </span><span class="c20">return </span><span class="c11">S</span><span class="c8">&lowast; </span></p><p class="c10"><span class="c1">Table 4: Configuration of parameters </span></p><p class="c12"><span class="c1">Parameter Values Window-size, </span><span class="c2">n </span><span class="c1">[</span><span class="c2">&times;</span><span class="c1">1000] 100, 250, 500, 750, 1000 </span></p><p class="c12"><span class="c1">Generation rate, </span><span class="c2">m </span><span class="c1">50, 100, 200, 500, 1000 Side length of a rectangle, </span><span class="c2">l </span><span class="c1">100, 500, 1000, 1500, 2000 </span></p><p class="c10"><span class="c1">Error rate, </span><span class="c2">&epsilon; </span><span class="c1">0, 0.1, 0.2, 0.3, 0.4, 0.5 </span></p><p class="c10"><span class="c2">k </span><span class="c1">1, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50 </span></p><p class="c6"><span class="c1">This section provides our experimental results on the perfor- mances of our algorithms. Recall that this is the first work of mon- itoring MaxRS problem, so there is no existing algorithm that can deal with this problem. Therefore, to show the efficiency of the incremental approach of our algorithms, we use an algorithm with non-incremental approach as comparison. That is, we evaluated naive plane-sweep [12, 18], the algorithm using G2 (Section 4), and the branch-and-bound algorithms using aG2 (Sections 5 and 6). For easy recognition, our algorithms are represented by G2 and aG2. Recall that naive plane-sweep is an optimal in-memory algo- rithm for computing </span><span class="c2">s</span><span class="c8">&lowast; </span><span class="c1">from scratch, and the algorithm proposed in [8, 9] also uses naive plane-sweep in the case where all objects fit in the main memory. All algorithms were implemented in C++, and all experiments were conducted on a PC with 3.4GHz Intel Core i7 processor and 32GB RAM. </span></p><p class="c10"><span class="c21">7.1 Setting </span><span class="c1">Datasets. We used a synthetic dataset and three real datasets. In the synthetic dataset, we generated objects under uniform distribu- tion. The cardinality of this synthetic dataset is 10,000,000, and the range of each coordinate is [0, 1000000]. The three real datasets are T-Drive [31], Geolife [34], and Roma</span><span class="c56">2</span><span class="c1">, which are the sets of con- tinuously generated GPS data. The objects in the real datasets exist over a very wide range, thus we selected the objects existing around respective main areas. The cardinalities of T-Drive, Geolife, and Roma are 5,037,794, 3,662,876, and 8,368,858, respectively. The objects in the datasets are sorted in order of generation time, and we normalized the range of each coordinate to [0, 1000000]. In the above four datasets, the weight of a given object is a real-value randomly chosen from [0, 1000]. Parameters. Table 4 summarizes the parameters used in the ex- periments and bold values are default values. Note that a given rectangle is a square in the experiments, thus the size of a rectangle is </span><span class="c2">l &times; l</span><span class="c1">, i.e., 1000 </span><span class="c2">&times; </span><span class="c1">1000 by default. </span></p><p class="c6"><span class="c1">Evaluation. In Section 7.2, we investigate the impact of Algorithm 5. In Section 7.3, to investigate the performances of the algorithms w.r.t. monitoring MaxRS, we varied three parameters, </span><span class="c2">n</span><span class="c1">, </span><span class="c2">m</span><span class="c1">, and </span><span class="c2">l</span><span class="c1">, </span></p><p class="c10"><span class="c29">2</span><span class="c5">http://crawdad.org/index.html </span></p><p class="c10"><span class="c38">325 </span></p><p class="c10"><span class="c19">naive naive plane&minus;sweep G2 aG2 </span></p><p class="c10"><span class="c19">naive plane&minus;sweep G2 aG2 </span></p><p class="c10"><span class="c19">plane&minus;sweep G2 aG2 </span></p><p class="c10"><span class="c1">(a) Synthetic </span></p><p class="c10"><span class="c1">(b) T-Drive </span></p><p class="c10"><span class="c1">(c) Geolife </span></p><p class="c10"><span class="c19">naive plane&minus;sweep G2 aG2 10</span><span class="c39">4 </span></p><p class="c10"><span class="c19">10</span><span class="c39">4 </span></p><p class="c10"><span class="c19">10</span><span class="c39">4 </span></p><p class="c10"><span class="c32">Window size [K] (Synthetic) </span></p><p class="c10"><span class="c32">Window size [K] (T&minus;Drive) </span></p><p class="c10"><span class="c32">Window size [K] (Geolife) </span></p><p class="c10"><span class="c1">(d) Roma Figure 7: Impact of </span><span class="c2">n </span></p><p class="c10"><span class="c52">10</span><span class="c39">&minus;1 </span><span class="c19">0 200 400 600 800 1000 10</span><span class="c39">5 </span><span class="c30">] cesm[e mitn oitatupmo</span><span class="c32">C</span><span class="c19">10101010</span><span class="c39">3 2 </span></p><p class="c10"><span class="c39">1 </span></p><p class="c10"><span class="c39">0 </span></p><p class="c12"><span class="c30">] cesm[e mitn oitatupmo</span><span class="c32">C</span><span class="c19">10101010</span><span class="c39">3 2 </span></p><p class="c10"><span class="c39">1 </span></p><p class="c10"><span class="c39">0 </span></p><p class="c12"><span class="c30">] cesm[e mitn oitatupmo</span><span class="c32">C</span><span class="c19">1010</span><span class="c39">3 2 </span></p><p class="c12"><span class="c30">] cesm[e mitn oitatupmo</span><span class="c32">C</span><span class="c19">10101010</span><span class="c39">4 3 </span></p><p class="c10"><span class="c39">2 </span></p><p class="c10"><span class="c39">1 </span></p><p class="c10"><span class="c52">10</span><span class="c39">&minus;1 </span></p><p class="c10"><span class="c19">100 200 300 400 500 600 700 800 9001000 </span><span class="c52">10</span><span class="c39">&minus;1 </span></p><p class="c10"><span class="c19">100 200 300 400 500 600 700 800 9001000 </span><span class="c52">10</span><span class="c19">100 </span><span class="c39">1 </span></p><p class="c10"><span class="c19">200 300 400 500 600 700 800 9001000 </span><span class="c52">10</span><span class="c19">100 </span><span class="c39">0 </span></p><p class="c10"><span class="c19">200 300 400 500 600 700 800 9001000 </span><span class="c32">Window size [K] (Roma) </span></p><p class="c10"><span class="c19">naive plane&minus;sweep G2 aG2 </span></p><p class="c10"><span class="c1">(a) Synthetic </span></p><p class="c10"><span class="c19">naive plane&minus;sweep G2 aG2 </span></p><p class="c10"><span class="c1">(b) T-Drive </span></p><p class="c10"><span class="c19">naive plane&minus;sweep G2 aG2 </span></p><p class="c10"><span class="c1">(c) Geolife </span></p><p class="c10"><span class="c19">naive plane&minus;sweep G2 aG2 10</span><span class="c39">3 </span></p><p class="c10"><span class="c19">10</span><span class="c39">3 </span></p><p class="c10"><span class="c32">Generation rate (Synthetic) </span></p><p class="c10"><span class="c32">Generation rate (T&minus;Drive) </span></p><p class="c10"><span class="c1">(d) Roma Figure 8: Impact of </span><span class="c2">m </span></p><p class="c12"><span class="c1">Table 5: Computation time [msec] Algorithm Synthetic T-Drive Geolife Roma Algo. 2 0.799 6.547 152.644 55.196 Algo. 5 with cond. 0.796 5.952 202.127 49.245 Algo. 5 0.812 6.229 217.541 54.837 </span></p><p class="c10"><span class="c1">and measured the average computation time to update </span><span class="c2">s</span><span class="c8">&lowast;</span><span class="c1">. We also measured the practical error rate and computation time of aG2 by varying </span><span class="c2">&epsilon; </span><span class="c1">to investigate the performance of our approximate algo- rithm in Section 7.4. Let </span><span class="c2">s </span><span class="c1">be the space monitored by our approxi- mate algorithm, and the practical error is defined by 1</span><span class="c2">&minus;s.w/s</span><span class="c8">&lowast;</span><span class="c2">.w</span><span class="c1">. Finally, we measured the average computation time to update </span><span class="c2">S</span><span class="c8">&lowast; </span><span class="c1">by varying </span><span class="c2">k </span><span class="c1">in Section 7.5. </span><span class="c21">7.2 Impact of Algorithm 5 </span></p><p class="c10"><span class="c1">We first study the impact of Algorithm 5 in our default setting. Table 5 shows the result. In Table 5, &ldquo;Algo. 5 with cond.&rdquo; is denoted by Algorithm 2 with Algorithm 5 in the case where the upper-bounding cost is less than the plane-sweep algorithm. We can see that Algorithm 5 provides a trivial impact for all the four datasets and does not outperform Algorithm 2. We observed that </span><span class="c2">|R</span><span class="c1">(</span><span class="c2">r</span><span class="c4">i</span><span class="c5">)</span><span class="c7">| </span><span class="c5">in Algorithm 5 is large in Geolife, thus Algorithm 5 pro- </span><span class="c1">vides a negative impact. Therefore we do not employ Algorithm 5 since it is not scalable . </span><span class="c21">7.3 Results on monitoring MaxRS </span><span class="c1">Impact of </span><span class="c2">n</span><span class="c1">. We study the impact of the number of objects on a sliding-window, and Figure 7 shows the results. All the algo- rithms need longer computation time as </span><span class="c2">n </span><span class="c1">increases. In terms of naive plane-sweep, this is intuitive since its cost is </span><span class="c2">O</span><span class="c1">(</span><span class="c2">n</span><span class="c1">log </span><span class="c2">n</span><span class="c1">). It is also intuitive that the increase of the number of overlapped spaces due to the increase of </span><span class="c2">n </span><span class="c1">is likely to lose the chances which avoid OverlapComputation(</span><span class="c2">&middot;</span><span class="c1">) and ExactWeightComputation(</span><span class="c2">&middot;,&middot;</span><span class="c1">), </span></p><p class="c10"><span class="c19">10</span><span class="c39">4 </span></p><p class="c10"><span class="c32">Generation rate (Geolife) </span></p><p class="c10"><span class="c19">10</span><span class="c39">4 </span></p><p class="c12"><span class="c30">] cesm[e mitn oitatupmo</span><span class="c32">C</span><span class="c19">101010</span><span class="c39">2 1 </span></p><p class="c10"><span class="c39">0 </span></p><p class="c12"><span class="c30">] cesm[e mitn oitatupmo</span><span class="c32">C</span><span class="c19">1010</span><span class="c39">2 1 </span></p><p class="c12"><span class="c30">] cesm[e mitn oitatupmo</span><span class="c32">C</span><span class="c19">1010</span><span class="c39">3 2 </span></p><p class="c12"><span class="c30">] cesm[e mitn oitatupmo</span><span class="c32">C</span><span class="c19">1010</span><span class="c39">3 2 </span></p><p class="c10"><span class="c52">10</span><span class="c39">0 </span></p><p class="c10"><span class="c19">0 200 400 600 800 1000 </span><span class="c52">10</span><span class="c39">1 </span></p><p class="c10"><span class="c19">0 200 400 600 800 1000 </span><span class="c52">10</span><span class="c39">1 </span></p><p class="c10"><span class="c19">0 200 400 600 800 1000 </span><span class="c32">Generation rate (Roma) </span></p><p class="c10"><span class="c1">thus our algorithms also need longer computation time. However, we can see that our algorithms are more efficient than naive plane- sweep in the four datasets, as expected. Naive plane-sweep is not scalable, which is shown in the case of large </span><span class="c2">n</span><span class="c1">. Moreover, aG2 scales better than G2 (the computation time is shown in log-scale). aG2 updates the result more than 2 times faster than G2 in the four datasets. Impact of </span><span class="c2">m</span><span class="c1">. Next, we study the impact of the generation rate, i.e., the number of objects generated at the same time. Although the practical average generation rates of the three real datasets are less than 50 objects (per second), we employ larger generation rates to investigate the scalability of our algorithms. Figure 8 shows the results. Because naive plane-sweep computes </span><span class="c2">s</span><span class="c8">&lowast; </span><span class="c1">from scratch, it is not affected by </span><span class="c2">m </span><span class="c1">basically. The computation time of our algo- rithms increases as </span><span class="c2">m </span><span class="c1">increases. When </span><span class="c2">m </span><span class="c1">is large, the upper-bound weights maintained by cells and vertices are likely to become large, which results in the same observation as large </span><span class="c2">n</span><span class="c1">. Note that even a case of large </span><span class="c2">m</span><span class="c1">, e.g., </span><span class="c2">m </span><span class="c1">= 1000, we can observe that aG2 still updates the result faster than naive plane-sweep. </span></p><p class="c6"><span class="c1">Impact of </span><span class="c2">l</span><span class="c1">. User-specified rectangle size also has impacts on the performances of continuous MaxRS query processing, because large rectangles tend to overlap with others. Figure 9 shows the re- sults. We can see that aG2 keeps outperforming naive plane-sweep, but the tendencies are different between the datasets. In the uniform distribution, i.e., Figure 9(a), G2 and aG2 are not much affected by </span><span class="c2">l</span><span class="c1">, but in the real datasets, the computation time of our algorithms (and naive plane-sweep) increase as </span><span class="c2">l </span><span class="c1">increases. We observed that the distributions of the real datasets are </span><span class="c2">skewed</span><span class="c1">. Therefore many rectangles overlap with each other, then G2 and aG2 are likely to encounter the case that Local-Plane-Sweep(</span><span class="c2">&middot;</span><span class="c1">) is not avoided. </span></p><p class="c12"><span class="c21">7.4 Results on monitoring Approximate MaxRS </span><span class="c1">We evaluated our approximate branch-and-bound algorithm us- </span></p><p class="c10"><span class="c38">326 </span></p><p class="c10"><span class="c19">naive naive plane&minus;sweep G2 aG2 </span></p><p class="c10"><span class="c19">plane&minus;sweep G2 aG2 </span></p><p class="c10"><span class="c1">(b) T-Drive </span></p><p class="c10"><span class="c1">(c) Geolife </span><span class="c19">naive plane&minus;sweep G2 aG2 </span></p><p class="c10"><span class="c19">naive plane&minus;sweep G2 aG2 10</span><span class="c39">4 </span></p><p class="c10"><span class="c19">10</span><span class="c39">4 </span></p><p class="c10"><span class="c19">10</span><span class="c39">4 </span></p><p class="c10"><span class="c19">10</span><span class="c39">4 </span></p><p class="c12"><span class="c30">] cesm[e mitn oitatupmo</span><span class="c32">C</span><span class="c19">10101010</span><span class="c39">3 2 </span></p><p class="c10"><span class="c39">1 </span></p><p class="c10"><span class="c39">0 </span></p><p class="c12"><span class="c30">] cesm[e mitn oitatupmo</span><span class="c32">C</span><span class="c19">101010</span><span class="c39">3 2 </span></p><p class="c10"><span class="c39">1 </span></p><p class="c10"><span class="c32">Side length of rectangle (T&minus;Drive) </span></p><p class="c10"><span class="c32">Side length of rectangle (Geolife) </span></p><p class="c10"><span class="c1">(d) Roma Figure 9: Impact of </span><span class="c2">l </span></p><p class="c12"><span class="c24">0 </span><span class="c15">0 0.1 0.2 0.3 0.4 0.5 </span><span class="c30">] cesm[e mitn oitatupmo</span><span class="c32">C</span><span class="c19">101010</span><span class="c39">3 2 </span></p><p class="c10"><span class="c39">1 </span></p><p class="c12"><span class="c30">] cesm[e mitn oitatupmo</span><span class="c32">C</span><span class="c19">101010</span><span class="c39">3 2 </span></p><p class="c10"><span class="c39">1 </span></p><p class="c10"><span class="c52">10</span><span class="c39">&minus;1 </span></p><p class="c10"><span class="c19">0 500 1000 1500 2000 </span><span class="c52">10</span><span class="c39">0 </span></p><p class="c10"><span class="c19">0 500 1000 1500 2000 </span><span class="c52">10</span><span class="c39">0 </span></p><p class="c12"><span class="c19">0 500 1000 1500 2000 </span><span class="c52">10</span><span class="c39">0 </span><span class="c19">0 500 1000 1500 2000 </span><span class="c32">Side length of rectangle (Synthetic) </span></p><p class="c10"><span class="c32">Side length of rectangle (Roma) </span><span class="c1">(a) Synthetic </span></p><p class="c10"><span class="c24">1 </span></p><p class="c10"><span class="c24">7 </span></p><p class="c10"><span class="c15">160 </span></p><p class="c10"><span class="c24">60 </span></p><p class="c10"><span class="c46">] cesm[e mitn oitatupmo</span><span class="c3">C</span><span class="c15">0.90.8 0.7 </span></p><p class="c10"><span class="c15">aG2 </span></p><p class="c10"><span class="c15">aG2 </span></p><p class="c10"><span class="c15">aG2 </span></p><p class="c10"><span class="c15">aG2 </span><span class="c24">650540</span><span class="c15">0.6 </span><span class="c24">4</span><span class="c15">0.5 </span><span class="c24">30</span><span class="c15">0.4 </span><span class="c24">3</span><span class="c15">0.3 </span><span class="c24">220</span><span class="c15">0.2 </span></p><p class="c12"><span class="c24">11000</span><span class="c15">0 0.1 0.2 0.3 0.4 0.5 0 0.1 0.2 0.3 0.4 0.5 </span><span class="c3">Epsilon (T&minus;Drive) Epsilon (Geolife) </span></p><p class="c10"><span class="c3">Epsilon (Roma) </span><span class="c1">(a) Comp. time (Synthetic) </span></p><p class="c10"><span class="c1">(b) Comp. time (T-Drive) </span></p><p class="c10"><span class="c1">(c) Comp. time (Geolife) </span></p><p class="c10"><span class="c1">(d) Comp. time (Roma) </span></p><p class="c10"><span class="c24">0 </span><span class="c15">0 0.1 0.2 0.3 0.4 0.5 </span><span class="c46">] </span></p><p class="c10"><span class="c46">cesm[e mitn oitatupmo</span><span class="c3">C</span><span class="c46">] cesm[e mitn oitatupmo</span><span class="c3">C</span><span class="c15">140 120 </span></p><p class="c10"><span class="c15">100 </span></p><p class="c12"><span class="c24">80 6040</span><span class="c46">] cesm[e mitn oitatupmo</span><span class="c3">C</span><span class="c15">0.1 </span><span class="c24">200</span><span class="c15">0 0.1 0.2 0.3 0.4 0.5 </span><span class="c3">Epsilon (Synthetic) </span></p><p class="c10"><span class="c15">0.5 </span></p><p class="c10"><span class="c15">0.5 </span></p><p class="c10"><span class="c15">0.5 </span></p><p class="c10"><span class="c15">0.5 aG2 </span></p><p class="c10"><span class="c15">aG2 </span></p><p class="c10"><span class="c15">aG2 </span></p><p class="c10"><span class="c15">0.4 </span></p><p class="c10"><span class="c15">0.4 </span></p><p class="c10"><span class="c15">0.4 </span></p><p class="c10"><span class="c15">0.4 </span></p><p class="c10"><span class="c15">0.3 </span></p><p class="c10"><span class="c15">0.2 </span></p><p class="c10"><span class="c46">e tarr orr</span><span class="c3">E</span><span class="c15">0.3 0.2 </span></p><p class="c10"><span class="c46">e tarr orr</span><span class="c3">E</span><span class="c15">0.3 0.2 </span></p><p class="c10"><span class="c15">0.3 </span></p><p class="c10"><span class="c3">Epsilon (Synthetic) </span></p><p class="c10"><span class="c3">Epsilon (T&minus;Drive) </span></p><p class="c10"><span class="c3">Epsilon (Geolife) </span></p><p class="c10"><span class="c3">Epsilon (Roma) </span><span class="c1">(e) Error rate (Synthetic) </span></p><p class="c10"><span class="c1">(f) Error rate (T-Drive) </span></p><p class="c10"><span class="c1">(g) Error rate (Geolife) </span></p><p class="c10"><span class="c46">e tarr orr</span><span class="c3">E</span><span class="c15">0.2 </span></p><p class="c10"><span class="c15">aG2 </span></p><p class="c10"><span class="c46">e tarr orr</span><span class="c3">E</span><span class="c15">0.1 </span></p><p class="c10"><span class="c15">0.1 </span></p><p class="c10"><span class="c15">0.1 </span></p><p class="c10"><span class="c15">0.1 </span></p><p class="c10"><span class="c1">(h) Error rate (Roma) Figure 10: Impact of </span><span class="c2">&epsilon; </span></p><p class="c10"><span class="c1">ing aG2 by varying </span><span class="c2">&epsilon;</span><span class="c1">. Although an approximate algorithm for </span><span class="c2">one- </span></p><p class="c10"><span class="c21">7.5 Results on monitoring Top-k MaxRS </span><span class="c2">time computation </span><span class="c1">of MaxRS queries has been proposed in [25], this algorithm cannot be used for comparison due to three reasons. First, this algorithm is based on randomized sampling, thus the an- swers returned by this algorithm and our algorithm are different. Second, the answer returned by this algorithm varies every time, which is not suitable as monitoring algorithm. Last, repeating such one-time computation is shown to be inefficient in Section 7.3. We therefore focus on our algorithm, and the experimental results are shown in Figure 10. </span></p><p class="c6"><span class="c1">From Figures 10(a)&ndash;10(d), although its impact is different be- tween the datasets, we can see that the computation time decreases as </span><span class="c2">&epsilon; </span><span class="c1">increases. This result satisfies the requirement that needs faster computation with an approximate answer. In the synthetic dataset, </span></p><p class="c42"><span class="c1">To evaluate our branch-and-bound algorithm for continuous top- k MaxRS queries, we conducted an experiment by varying </span><span class="c2">k</span><span class="c1">. We compare our algorithm with naive plane-sweep. Although naive plane-sweep is for one-time computation, this algorithm can deal with top-k MaxRS queries without sacrificing the computation cost. We do not evaluate G2 since its performance is not better than aG2. Figure 11 shows the results. Again, naive plane-sweep is not affected by </span><span class="c2">k </span><span class="c1">since it scans all rectangles on a sliding-window. As </span><span class="c2">k </span><span class="c1">increases, the computation time of aG2 increases, but we can see that the increase of the computation time of aG2 is slight for all the four datasets. These results confirm that the pruning rules keep efficient and avoid unnecessary computation. </span></p><p class="c6"><span class="c1">it seems that the computation time does not decrease so much (Fig- ure 10(a)), but even when </span><span class="c2">&epsilon; </span><span class="c1">= 0, the computation time is about 0.8 [msec], which is fast enough. From Figures 10(e)&ndash;10(h), we can see that as </span><span class="c2">&epsilon; </span><span class="c1">increases, the practical error also increases but is less than </span><span class="c2">&epsilon;</span><span class="c1">. The results show that the relationship between the query processing efficiency and the quality of the result is trade- off, but an interesting observation is that the practical error rates in the cases of the real datasets are very small. </span></p><p class="c10"><span class="c24">0 </span></p><p class="c10"><span class="c24">0 </span></p><p class="c12"><span class="c24">0 </span><span class="c15">0 0.1 0.2 0.3 0.4 0.5 0 0.1 0.2 0.3 0.4 0.5 0 0.1 0.2 0.3 0.4 0.5 </span><span class="c21">8. CONCLUSION </span><span class="c1">In this paper, we addressed a novel problem of monitoring MaxRS and its variants, i.e., monitoring approximate MaxRS and top-k MaxRS. In the environments where spatio-temporal objects are gen- erated frequently, monitoring and analysis of objects are often re- quired, and a continuous MaxRS query is useful to support such requirements. Unfortunately, the existing solutions [8, 25] focus on static objects, thus are not efficient in our problem. Motivated </span></p><p class="c10"><span class="c38">327 </span></p><p class="c10"><span class="c15">naive naive plane&minus;sweep aG2 </span></p><p class="c10"><span class="c15">naive plane&minus;sweep aG2 </span></p><p class="c10"><span class="c15">plane&minus;sweep aG2 </span></p><p class="c10"><span class="c1">(a) Synthetic </span></p><p class="c10"><span class="c1">(b) T-Drive </span></p><p class="c10"><span class="c1">(c) Geolife </span></p><p class="c10"><span class="c15">naive plane&minus;sweep aG2 10</span><span class="c40">4 </span></p><p class="c10"><span class="c15">10</span><span class="c40">4 </span></p><p class="c10"><span class="c15">10</span><span class="c40">4 </span></p><p class="c10"><span class="c3">k (Synthetic) </span></p><p class="c10"><span class="c3">k (T&minus;Drive) </span></p><p class="c10"><span class="c3">k (Geolife) </span></p><p class="c10"><span class="c1">(d) Roma Figure 11: Impact of </span><span class="c2">k </span></p><p class="c10"><span class="c1">by this, we proposed the first algorithm that can incrementally up- date the exact result. This algorithm incorporates our index frame- work G2 (Graph in Grid index) which supports efficient query pro- cessing. We extended G2 and proposed aG2 (aggregate G2) and a branch-and-bound algorithm using aG2. The branch-and-bound algorithm accelerates the query processing efficiency. Moreover, we showed that the branch-and-bound algorithm can deal with the monitoring approximate MaxRS and the top-k MaxRS problems with simple modifications. To demonstrate the efficiency of our al- gorithms, we conducted experiments using synthetic and real datasets. The results show that the branch-and-bound algorithm using aG2 is superior to the one-time computation approach and the algorithm using G2. </span></p><p class="c10"><span class="c1">As shown (but not theoretically) in Section 5.3, we need extra computation and storage costs to tight the upper-bound weights more. Hence, it is interesting to theoretically explore (or clarify the impossibility of) an approach that can tight the upper-bound the most without sacrificing the computational cost and storage cost. It is also interesting to develop an efficient algorithm that can deal with multiple continuous MaxRS queries at the same time. These are the works that need to be considered in the future. Acknowledgment. This research is partially supported by the Grant- in-Aid for Scientific Research (A)(26240013) of MEXT, Japan, and JST, Strategic International Collaborative Research Program, SICORP. </span></p><p class="c10"><span class="c21">9. REFERENCES </span></p><p class="c10"><span class="c25">[1] B. Babcock, S. Babu, M. Datar, R. Motwani, and J. Widom. Models and issues </span></p><p class="c10"><span class="c25">in data stream systems. In </span><span class="c9">PODS</span><span class="c25">, pages 1&ndash;16, 2002. [2] J. Bao, M. F. Mokbe, and C.-Y. Chow. Geofeed: A location aware news feed </span></p><p class="c10"><span class="c25">system. In </span><span class="c9">ICDE</span><span class="c25">, pages 54&ndash;65, 2012. [3] M. A. Cheema, L. Brankovic, X. Lin, W. Zhang, and W. Wang. Continuous </span></p><p class="c10"><span class="c25">monitoring of distance-based range queries. </span><span class="c9">IEEE TKDE</span><span class="c25">, 23(8):1182&ndash;1199, 2011. [4] M. A. Cheema, W. Zhang, X. Lin, Y. Zhang, and X. Li. Continuous reverse k </span></p><p class="c10"><span class="c25">nearest neighbors queries in euclidean space and in spatial networks. </span><span class="c9">The VLDB Journal</span><span class="c25">, 21(1):69&ndash;95, 2012. [5] L. Chen, G. Cong, X. Cao, and K.-L. Tan. Temporal spatial-keyword top-k </span></p><p class="c10"><span class="c25">publish/subscribe. In </span><span class="c9">ICDE</span><span class="c25">, pages 255&ndash;266, 2015. [6] Z. Chen, Y. Liu, R. C.-W. Wong, J. Xiong, X. Cheng, and P. Chen. Rotating </span></p><p class="c12"><span class="c25">maxrs queries. </span><span class="c9">Information Sciences, Elsevier</span><span class="c25">, 305:110&ndash;129, 2015. [7] Z. Chen, Y. Liu, R. C.-W. Wong, J. Xiong, G. Mai, and C. Long. Efficient </span></p><p class="c10"><span class="c25">algorithms for optimal location queries in road networks. In </span><span class="c9">SIGMOD</span><span class="c25">, pages 123&ndash;134, 2014. [8] D.-W. Choi, C.-W. Chung, and Y. Tao. A scalable algorithm for maximizing </span></p><p class="c12"><span class="c25">range sum in spatial databases. </span><span class="c9">PVLDB</span><span class="c25">, 5(11):1088&ndash;1099, 2012. [9] D.-W. Choi, C.-W. Chung, and Y. Tao. Maximizing range sum in external </span></p><p class="c10"><span class="c25">memory. </span><span class="c9">ACM TODS</span><span class="c25">, 39(3):21, 2014. [10] Y. Du, D. Zhang, and T. Xia. The optimal-location query. In </span><span class="c9">SSTD</span><span class="c25">, pages </span></p><p class="c10"><span class="c25">163&ndash;180. 2005. [11] J. Huang, Z. Wen, J. Qi, R. Zhang, J. Chen, and Z. He. Top-k most influential </span></p><p class="c10"><span class="c25">locations selection. In </span><span class="c9">CIKM</span><span class="c25">, pages 2377&ndash;2380, 2011. [12] H. Imai and T. Asano. Finding the connected components and a maximum </span></p><p class="c10"><span class="c15">10</span><span class="c40">4 </span></p><p class="c12"><span class="c37">] cesm[e mitn oitatupmo</span><span class="c3">C</span><span class="c15">101010</span><span class="c40">3 2 </span></p><p class="c10"><span class="c40">1 </span></p><p class="c10"><span class="c15">10</span><span class="c40">0 </span></p><p class="c12"><span class="c37">] cesm[e mitn oitatupmo</span><span class="c3">C</span><span class="c15">101010</span><span class="c40">3 2 </span></p><p class="c10"><span class="c40">1 </span></p><p class="c10"><span class="c37">] cesm[e mitn oitatupmo</span><span class="c3">C</span><span class="c15">10</span><span class="c40">3 </span></p><p class="c12"><span class="c37">] cesm[e mitn oitatupmo</span><span class="c3">C</span><span class="c15">1010</span><span class="c40">3 2 </span></p><p class="c10"><span class="c63">10</span><span class="c40">&minus;1 </span></p><p class="c10"><span class="c15">0 5 10 15 20 25 30 35 40 45 50 </span><span class="c63">10</span><span class="c40">0 </span></p><p class="c10"><span class="c15">0 5 10 15 20 25 30 35 40 45 50 </span><span class="c63">10</span><span class="c40">2 </span></p><p class="c10"><span class="c15">0 5 10 15 20 25 30 35 40 45 50 </span><span class="c63">10</span><span class="c40">1 </span></p><p class="c10"><span class="c15">0 5 10 15 20 25 30 35 40 45 50 </span><span class="c3">k (Roma) </span></p><p class="c10"><span class="c25">clique of an intersection graph of rectangles in the plane. </span><span class="c9">Journal of algorithms, Elsevier</span><span class="c25">, 4(4):310&ndash;323, 1983. [13] C. Li, Y. Gu, J. Qi, G. Yu, R. Zhang, and W. Yi. Processing moving </span><span class="c9">k</span><span class="c25">nn queries </span></p><p class="c10"><span class="c25">using influential neighbor sets. </span><span class="c9">PVLDB</span><span class="c25">, 8(2):113&ndash;124, 2014. [14] Y. Liu, R. C.-W. Wong, K. Wang, Z. Li, C. Chen, and Z. Chen. A new approach </span></p><p class="c10"><span class="c25">for maximizing bichromatic reverse nearest neighbor search. </span><span class="c9">Knowledge and Information Systems, Springer</span><span class="c25">, 36(1):23&ndash;58, 2013. [15] K. Mouratidis, S. Bakiras, and D. Papadias. Continuous monitoring of spatial </span></p><p class="c10"><span class="c25">queries in wireless broadcast environments. </span><span class="c9">IEEE TMC</span><span class="c25">, 8(10):1297&ndash;1311, 2009. [16] K. Mouratidis and D. Papadias. Continuous nearest neighbor queries over </span></p><p class="c10"><span class="c25">sliding windows. </span><span class="c9">IEEE TKDE</span><span class="c25">, 19(6):789&ndash;803, 2007. [17] K. Mouratidis, D. Papadias, and M. Hadjieleftheriou. Conceptual partitioning: </span></p><p class="c10"><span class="c25">an efficient method for continuous nearest neighbor monitoring. In </span><span class="c9">SIGMOD</span><span class="c25">, pages 634&ndash;645, 2005. [18] S. C. Nandy and B. B. Bhattacharya. A unified algorithm for finding maximum </span></p><p class="c12"><span class="c25">and minimum object enclosing rectangles and cuboids. </span><span class="c9">Computers &amp; Mathematics with Applications, Elsevier</span><span class="c25">, 29(8):45&ndash;61, 1995. [19] D. Papadias, P. Kalnis, J. Zhang, and Y. Tao. Efficient olap operations in spatial </span></p><p class="c10"><span class="c25">data warehouses. In </span><span class="c9">SSTD</span><span class="c25">, pages 443&ndash;459. 2001. [20] J. Qi, R. Zhang, L. Kulik, D. Lin, and Y. Xue. The min-dist location selection </span></p><p class="c10"><span class="c25">query. In </span><span class="c9">ICDE</span><span class="c25">, pages 366&ndash;377, 2012. [21] S. Rahul and Y. Tao. On top-k range reporting in 2d space. In </span><span class="c9">PODS</span><span class="c25">, pages </span></p><p class="c10"><span class="c25">265&ndash;275, 2015. [22] J. B. Rocha-Junior, A. Vlachou, C. Doulkeridis, and K. N&oslash;rv&aring;g. Efficient </span></p><p class="c12"><span class="c25">processing of top-k spatial preference queries. </span><span class="c9">PVLDB</span><span class="c25">, 4(2):93&ndash;104, 2010. [23] C. Sheng and Y. Tao. New results on two-dimensional orthogonal range aggregation in external memory. In </span><span class="c9">PODS</span><span class="c25">, pages 129&ndash;139, 2011. [24] Y. Sun, J. Qi, Y. Zheng, and R. Zhang. K-nearest neighbor temporal aggregate </span></p><p class="c10"><span class="c25">queries. In </span><span class="c9">EDBT</span><span class="c25">, pages 493&ndash;504, 2015. [25] Y. Tao, X. Hu, D.-W. Choi, and C.-W. Chung. Approximate maxrs in spatial </span></p><p class="c10"><span class="c25">databases. </span><span class="c9">PVLDB</span><span class="c25">, 6(13):1546&ndash;1557, 2013. [26] Y. Tao, C. Sheng, C.-W. Chung, and J.-R. Lee. Range aggregation with set </span></p><p class="c10"><span class="c25">selection. </span><span class="c9">IEEE TKDE</span><span class="c25">, 26(5):1240&ndash;1252, 2014. [27] S.-H. Wu, K.-T. Chuang, C.-M. Chen, and M.-S. Chen. Diknn: an </span></p><p class="c10"><span class="c25">itinerary-based knn query processing algorithm for mobile sensor networks. In </span><span class="c9">ICDE</span><span class="c25">, pages 456&ndash;465, 2007. [28] T. Xia, D. Zhang, E. Kanoulas, and Y. Du. On computing top-t most influential </span></p><p class="c10"><span class="c25">spatial sites. In </span><span class="c9">VLDB</span><span class="c25">, pages 946&ndash;957, 2005. [29] M. L. Yiu, X. Dai, N. Mamoulis, and M. Vaitis. Top-k spatial preference </span></p><p class="c10"><span class="c25">queries. In </span><span class="c9">ICDE</span><span class="c25">, pages 1076&ndash;1085, 2007. [30] M. L. Yiu and N. Mamoulis. Multi-dimensional top-k dominating queries. </span><span class="c9">The </span></p><p class="c10"><span class="c9">VLDB Journal</span><span class="c25">, 18(3):695&ndash;718, 2009. [31] J. Yuan, Y. Zheng, X. Xie, and G. Sun. Driving with knowledge from the </span></p><p class="c10"><span class="c25">physical world. In </span><span class="c9">SIGKDD</span><span class="c25">, pages 316&ndash;324, 2011. [32] D. Zhang, Y. Du, T. Xia, and Y. Tao. Progressive computation of the min-dist </span></p><p class="c12"><span class="c25">optimal-location query. In </span><span class="c9">VLDB</span><span class="c25">, pages 643&ndash;654. t, 2006. [33] J. Zhang, W.-S. Ku, M.-T. Sun, X. Qin, and H. Lu. Multi-criteria optimal </span></p><p class="c10"><span class="c25">location query with overlapping voronoi diagrams. In </span><span class="c9">EDBT</span><span class="c25">, pages 391&ndash;402, 2014. [34] Y. Zheng, L. Zhang, X. Xie, and W.-Y. Ma. Mining interesting locations and travel sequences from gps trajectories. In </span><span class="c9">WWW</span><span class="c25">, pages 791&ndash;800, 2009. [35] Z. Zhou, W. Wu, X. Li, M. L. Lee, and W. Hsu. Maxfirst for maxbrknn. In </span></p><p class="c10"><span class="c9">ICDE</span><span class="c25">, pages 828&ndash;839, 2011. </span></p><p class="c10"><span class="c38">328 </span></p></body></html>