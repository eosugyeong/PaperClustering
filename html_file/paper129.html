<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c27{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Arial";font-style:normal}.c7{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c77{margin-left:-23.1pt;padding-top:3.1pt;text-indent:32.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19pt}.c78{margin-left:-23.1pt;padding-top:12pt;text-indent:32.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19pt}.c17{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:13.3pt;font-family:"Arial";font-style:normal}.c10{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Courier New";font-style:normal}.c35{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.3pt;font-family:"Courier New";font-style:normal}.c25{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:9.3pt;font-family:"Arial";font-style:normal}.c83{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12pt;font-family:"Arial";font-style:normal}.c52{margin-left:-23.1pt;padding-top:1pt;text-indent:40.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19pt}.c46{margin-left:-23.1pt;padding-top:1.7pt;text-indent:32.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19pt}.c68{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.3pt;font-family:"Arial";font-style:normal}.c11{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Courier New";font-style:normal}.c12{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Courier New";font-style:normal}.c74{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:13.3pt;font-family:"Courier New";font-style:normal}.c54{margin-left:-23.1pt;padding-top:1.4pt;text-indent:32.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19pt}.c8{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c76{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7pt;font-family:"Arial";font-style:normal}.c42{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.2pt;font-family:"Arial";font-style:normal}.c53{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.3pt;font-family:"Arial";font-style:normal}.c2{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:6.3pt;font-family:"Arial";font-style:normal}.c55{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.8pt;font-family:"Arial";font-style:normal}.c70{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Courier New";font-style:normal}.c20{margin-left:-23.1pt;padding-top:3.8pt;text-indent:32.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19pt}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10pt;font-family:"Arial";font-style:normal}.c22{margin-left:-32.2pt;padding-top:1.7pt;text-indent:41.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-9.9pt}.c16{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.9pt;font-family:"Arial";font-style:normal}.c28{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10pt;font-family:"Courier New";font-style:normal}.c59{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.7pt;font-family:"Arial";font-style:normal}.c47{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:17.9pt;font-family:"Arial";font-style:normal}.c26{margin-left:-32.2pt;padding-top:12.2pt;text-indent:41.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-9.9pt}.c37{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.3pt;font-family:"Courier New";font-style:normal}.c43{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c75{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5pt;font-family:"Courier New";font-style:normal}.c91{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:9.5pt;font-family:"Arial";font-style:normal}.c44{margin-left:-19pt;padding-top:1pt;text-indent:32.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19pt}.c9{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10pt;font-family:"Arial";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.6pt;font-family:"Arial";font-style:normal}.c38{margin-left:-23.1pt;padding-top:1.2pt;text-indent:40.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19pt}.c85{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:19.9pt;font-family:"Arial";font-style:normal}.c57{margin-left:-23.1pt;padding-top:3.8pt;text-indent:32.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19pt}.c24{margin-left:-32.2pt;padding-top:4.1pt;text-indent:41.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-10.2pt}.c14{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.2pt;font-family:"Arial";font-style:normal}.c23{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Arial";font-style:normal}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Arial";font-style:normal}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Arial";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Arial";font-style:normal}.c71{margin-left:-23.1pt;padding-top:3.8pt;text-indent:32.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.9pt}.c89{margin-left:-19pt;padding-top:1.2pt;text-indent:32.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-18.7pt}.c41{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:16.6pt;font-family:"Arial";font-style:normal}.c79{margin-left:-32.2pt;padding-top:23.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-9.9pt}.c30{margin-left:-20.2pt;padding-top:9.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:99.1pt}.c58{margin-left:24.5pt;padding-top:14.9pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:37.7pt}.c62{margin-left:-20.2pt;padding-top:9.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:108pt}.c51{margin-left:-19pt;padding-top:4.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19pt}.c87{margin-left:-31pt;padding-top:13pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:121.8pt}.c19{margin-left:-23pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-9.9pt}.c18{margin-left:218.2pt;padding-top:31.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-36.1pt}.c40{margin-left:218.2pt;padding-top:60pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-36.1pt}.c86{margin-left:-23pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:22.7pt}.c80{margin-left:-32.2pt;padding-top:0.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-9.9pt}.c67{margin-left:-9.7pt;padding-top:10.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19pt}.c32{margin-left:-13.9pt;padding-top:28.8pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-0.2pt}.c29{margin-left:-32.2pt;padding-top:16.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-9.9pt}.c82{margin-left:-32.2pt;padding-top:15.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:113pt}.c45{margin-left:-32.2pt;padding-top:3.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-9.9pt}.c64{margin-left:-32.2pt;padding-top:59pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-9.9pt}.c73{margin-left:-18.7pt;padding-top:8.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-9.9pt}.c60{margin-left:-9.7pt;padding-top:9.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19pt}.c33{margin-left:-18.7pt;padding-top:8.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-9.9pt}.c36{margin-left:-23.1pt;padding-top:14.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:28.1pt}.c49{margin-left:-32.2pt;padding-top:16.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-9.7pt}.c56{margin-left:-32.2pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-9.9pt}.c81{margin-left:-29.3pt;padding-top:11pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:94.5pt}.c61{margin-left:218.2pt;padding-top:41pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-278pt}.c69{margin-left:-9.7pt;padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18.7pt}.c65{margin-left:-19pt;padding-top:1pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-19pt}.c66{margin-left:-23.1pt;padding-top:8.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:38.4pt}.c13{margin-left:-31pt;padding-top:6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:142pt}.c39{margin-left:11pt;padding-top:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:24pt}.c72{margin-left:-32.2pt;padding-top:29.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:127.4pt}.c90{margin-left:-31pt;padding-top:24.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:16.2pt}.c34{margin-left:-20.2pt;padding-top:9.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:56.6pt}.c88{padding-top:10.1pt;text-indent:32.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c15{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c48{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c21{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c50{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c84{margin-left:-23.1pt;margin-right:-19pt}.c92{margin-left:-0.6pt;margin-right:-19pt}.c63{margin-left:-23.1pt;margin-right:164.9pt}.c31{text-indent:41.3pt}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:24pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:14pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c50"><p class="c39"><span class="c47">Group Recommendation with Temporal Affinities </span></p><p class="c32"><span class="c8">Sihem Amer-Yahia</span><span class="c6">&dagger;1</span><span class="c8">, Behrooz Omidvar-Tehrani</span><span class="c6">&dagger;&Dagger;1</span><span class="c8">, Senjuti Basu Roy</span><span class="c6">&Dagger;2</span><span class="c8">, Nafiseh Shabib</span><span class="c6">&Dagger;&dagger;3 </span><span class="c76">&dagger; </span><span class="c41">CNRS and LIG; </span><span class="c76">&dagger;&Dagger;</span><span class="c41">LIG; </span><span class="c76">&Dagger; </span><span class="c41">University of Washington Tacoma; </span><span class="c76">&Dagger;&dagger; </span><span class="c41">Norwegian University of Science and Technology </span></p><p class="c58"><span class="c3">1</span><span class="c85">{sihem.ameryahia,behrooz.omidvar-tehrani}@imag.fr, </span><span class="c3">2</span><span class="c85">senjutib@uw.edu, </span><span class="c3">3</span><span class="c85">shabib@idi.ntnu.no </span></p><p class="c79"><span class="c8">ABSTRACT </span><span class="c0">We examine the problem of recommending items to ad-hoc user groups. Group recommendation in collaborative rating datasets has received increased attention recently and has raised novel chal- lenges. Different consensus functions that aggregate the ratings of group members with varying semantics ranging from least misery to pairwise disagreement, have been studied. In this paper, we ex- plore a new dimension when computing group recommendations, that is, affinity between group members and its evolution over time. We extend existing group recommendation semantics to include temporal affinity in recommendations and design GRECA, an ef- ficient algorithm that produces temporal affinity-aware recommen- dations for ad-hoc groups. We run extensive experiments that show substantial improvements in group recommendation quality when accounting for affinity while maintaining very good performance. </span></p><p class="c82"><span class="c8">1. INTRODUCTION </span></p><p class="c45 c31"><span class="c0">Group recommendation refers to finding the best items that a set of users will appreciate together. It is an active research area as exemplified by numerous publications [3, 6, 13, 20, 23]. The main focus of existing work in group recommendation is the de- sign of appropriate consensus functions that aggregate individual group members&rsquo; preferences to reflect the group&rsquo;s preference for each item. A variety of functions have been used ranging from ma- jority voting to least misery. In this paper, we are interested in ex- ploring how affinity between group members and its evolution over time affect group recommendations. To the best of our knowledge, our work is the first to study affinity and its evolution over time in combination with existing group consensus functions. </span></p><p class="c56 c31"><span class="c0">The premise of this work relies on a simple conjecture that is, a user appreciates recommendations differently in the company of different people and at different times. When with girlfriends, a female user may want to watch a romantic movie that she may not want to watch with men. When with her parents, she may prefer to go to a nice Italian restaurant while she would prefer a burger joint with her kids. In addition, her appreciation of an item with the same group of people may change over time depending on how their connection and shared interests evolve. In other terms, the </span></p><p class="c64"><span class="c0">&copy; </span><span class="c27">2015, Copyright is with the authors. Published in Proc. 18th Inter- national Conference on Extending Database Technology (EDBT), March 23-27, 2015, Brussels, Belgium: ISBN 978-3-89318-067-7, on OpenPro- ceedings.org. Distribution of this paper is permitted under the terms of the Creative Commons license CC-by-nc-nd 4.0 </span></p><p class="c4 c84"><span class="c0">affinity of a user with other group members should be captured in how that user appreciates an item. </span></p><p class="c54"><span class="c0">Previous studies on single user recommendation have shown that contextual dimensions such as a user&rsquo;s mood and company or time and place, may affect her preferences [1, 2]. Indeed, according to behavioral research studies [5, 14, 18], consumers use differ- ent decision-making strategies and favor different brands and prod- ucts depending on their context. Such observations can be incorpo- rated in different ways into single user recommendations. In [1], a multidimensional recommendation model is developed to account for contextual information into a user&rsquo;s recommendation, one of which could be her affinity with other users. However, to the best of our knowledge, multidimensional recommendation has not been applied to group recommendation. In group recommendation, we conjecture that each user will have a relative preference for an item depending on her affinity with other group members. Formalizing the semantics of relative preference raises two new challenges: (i) how to account for user affinities in the definition of relative pref- erence and (ii) how to combine relative preference with popular group recommendation consensus functions [13]. </span></p><p class="c46"><span class="c0">A major difficulty when addressing (i) is to integrate the evolu- tion of affinities between users over time. For example, interns at a research lab may subscribe to a Facebook group during their in- ternship. When the internship period is over, the group becomes an alumni of the research lab and affinities between its members will likely change. Therefore, if events such as workshops or con- ferences are to be recommended to the alumni group in the future, affinities between its members should be accounted for, in order to decide which subgroup would be interested in which event. While numerous recent studies have shown the importance of accounting for time in recommender systems [8, 15, 17, 25], they have focused on user-item preferences and single-user recommendations. In this work, we propose two dynamic models to capture temporal affini- ties: a discrete model where time is discretized over a set of time periods and affinities computed for each sub-period, and a contin- uous model where time is represented as an exponential function that positively or negatively affects affinity over time. Both mod- els have a static component that denotes how close two users are in a time-independent fashion and a dynamic component that cap- tures the drift that the affinity of a user-pair exhibits compared to the overall user population. Finally, while the discrete model is an approximation of the continuous one, they are both used to capture increasing and decreasing affinities. </span></p><p class="c54"><span class="c0">Clearly, combining user-item preferences of group members in- dependently of each other to produce group recommendations is not enough to capture the impact of affinities on those recommen- dations. In other terms, applying the well-known group consensus functions such as aggregated voting, average preferences or least </span></p><p class="c61"><span class="c43">421 10.5441/002/edbt.2015.37 </span></p><p class="c29"><span class="c0">misery on individual group members&rsquo; preferences, does not cap- ture a scenario where the same user appreciates the same item dif- ferently in different groups. Therefore, we propose a two-step ap- proach to address (ii). First, we modify individual user-item prefer- ences on-the-fly to account for affinities and then we apply a group consensus function over the modified preferences. This approach has the benefit of dissociating recommendation computation from affinity computation and therefore being able to use relative prefer- ences with any group recommendation consensus semantics. </span></p><p class="c31 c56"><span class="c0">No recommendation work would be complete without consid- ering both recommendation effectiveness and efficiency. Those two dimensions raise new challenges when dealing with relative preference, namely, (i) how to assess the quality of group recom- mendations? and (ii) how to efficiently compute affinity-aware rec- ommendations on-the-fly for ad-hoc groups? To address (i), we build a Facebook application and generate movie recommendations using MovieLens dataset</span><span class="c6">1</span><span class="c0">. We leverage friendship and common page-likes to compute affinities and run an extensive set of exper- iments varying group size, cohesiveness (rating similarity between group members) and affinity between group members. To address (ii), we develop GRECA, an algorithm that non-trivially adapts the family of threshold algorithms [10], to account for affinities be- tween user pairs that evolve over time. GRECA leverages index structures that are extremely efficient with updates for maintaining time-variant affinities, and are used to efficiently produce the top- k recommended itemset for a group. In fact, as affinity between users evolves over time, GRECA does not need to recalculate any of the previously calculated affinities and just augments the index to account for the latest affinities. In addition to being instance opti- mal, the key novelty of GRECA is the use of a new buffer condition for termination, which constitutes a clear departure from traditional top-k style algorithms [10]. This condition simply implies that just by examining the items in the buffer, GRECA can terminate with the guarantee to have found the correct top-k itemset. </span></p><p class="c22"><span class="c0">Our experiments consistently indicate that incorporating tempo- ral affinities into group consensus functions is most effective for dissimilar user groups as well as low-affinity user groups whose preference significantly evolves over time. Prior work has shown that such groups generally take longer to reach consensus [20]. Our performance experiments demonstrate that GRECA achieves a save up of 75% or beyond in the number of accesses. These results strongly corroborate the effectiveness of our proposed solutions to include temporal affinities in group recommendation functions. </span></p><p class="c86"><span class="c0">The paper makes the following technical contributions: </span></p><p class="c73"><span class="c0">&bull; We motivate the need to account for user affinities between group members when computing recommendations and pro- pose to capture affinities in the relative preference of indi- vidual group members for each item. Relative preference modifies a user-item preference with the user&rsquo;s affinity with other group members. </span></p><p class="c73"><span class="c0">&bull; Since affinities may evolve over time, we propose two mod- els, discrete and continuous, to represent (positive or neg- ative) affinity drift of two users over time. This dynamic component is combined with a static component, that cap- tures how close two users are in a time-independent fashion, in order to form temporal affinities. </span></p><p class="c33"><span class="c0">&bull; We extend group recommendation semantics, i.e., average preferences, least misery and pairwise disagreement, to in- clude temporal affinities and design GRECA, an efficient al- gorithm that computes recommendations on-the-fly for ad- </span></p><p class="c13"><span class="c3">1</span><span class="c17">http://movielens.umn.edu/ </span></p><p class="c4 c92"><span class="c0">hoc groups. GRECA uses a new early termination condition to efficiently produce the top-k itemset for a group. </span></p><p class="c69"><span class="c0">&bull; We run extensive experiments using Facebook and Movie- Lens datasets and examine the impact of our temporal affin- ity model on group recommendation quality and efficiency. </span></p><p class="c84 c88"><span class="c0">The paper is organized as follows. Section 2 contains our for- malism. GRECA, our recommendation algorithm is provided in Section 3. Extensive experimental evaluation is given in detail in Section 4. Related work is summarized in Section 5 and conclusion in Section 6. </span></p><p class="c36"><span class="c8">2. DATA MODEL AND PROBLEM </span></p><p class="c57"><span class="c0">We present a data model that captures temporal affinities and define our problem of recommending items to ad-hoc groups. </span></p><p class="c54"><span class="c0">The underlying scenario that will be used to illustrate our model is a social network of individuals who have some intrinsic charac- teristics (e.g., birthplace, gender and age) and who express inter- ests for items via likes and votes as in Facebook and Twitter. At any given point in time, we are interested in recommending con- tent items (e.g., movies, books, conferences) to an ad-hoc group. Parts of this scenario will be used in this section and one instance will be described in specific details in Section 3.1. </span></p><p class="c46"><span class="c0">In our model, we assume a set of m items I = {i</span><span class="c9">1</span><span class="c5">,i</span><span class="c9">2</span><span class="c5">,...,i</span><span class="c9">m</span><span class="c5">} </span><span class="c0">and a set of n users U = {u</span><span class="c9">1</span><span class="c5">,...,u</span><span class="c9">n</span><span class="c5">} out of which any ad-hoc </span><span class="c0">group G &#10003; U can be built. To simplify exposition, we will not for- malize user or item attributes and will refer to them when needed in our example. We consider time as a set of consecutive timestamps that form periods. Each period p is a time interval of the form [s, f] where s is its starting timestamp and f its ending timestamp. </span></p><p class="c66"><span class="c8">2.1 Dynamic User Affinity Models </span></p><p class="c77"><span class="c0">Affinity describes the bonding between a pair of users(u, u</span><span class="c6">0</span><span class="c0">) and is denoted a</span><span class="c12">ff </span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">). It could be as simple as explicit friendship or users in the same age group or more sophisticated such as users who like similar movies, have visited similar places and have friends who live in different parts of the world. For simplicity, we assume that affinity between a user pair is symmetric, i.e., a</span><span class="c12">ff </span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">) = a</span><span class="c12">ff </span><span class="c0">(u</span><span class="c6">0</span><span class="c0">,u). More importantly, a</span><span class="c12">ff </span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">) is dynamic and changes over time. We therefore compute affinity a</span><span class="c12">ff </span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">,p) for a time period p = [s, f]. This dynamic affinity captures changes over time by combining its static and dynamic components defined below. </span></p><p class="c60"><span class="c0">&bull; Static Affinity - a</span><span class="c12">ff</span><span class="c3">s</span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">): This is a time-agnostic affinity component and is used to capture how close two users are in a time-independent fashion. Stable factors such as birth- place, age, and education naturally contribute to this com- ponent. However, depending on the application, other di- mensions could be accounted for. For example, Facebook friendship being stable, we use it to model static affinity in our experiments (Section 4.1.2). </span></p><p class="c67"><span class="c0">&bull; Dynamic Affinity- a</span><span class="c12">ff</span><span class="c9">y</span><span class="c5">(u, u</span><span class="c3">0</span><span class="c5">,p): This is a time-variant com- </span><span class="c0">ponent that captures affinity between two users u and u</span><span class="c6">0 </span><span class="c0">during period p by considering how close they are during that period. For example, shared political interests, common likes, and shared interests for world events, vary over time and could contribute to formulating this component. Intu- itively, the objective is to capture the aggregated drift that the affinity of a user pair exhibits for every time period from the beginning of time s</span><span class="c3">0 </span><span class="c0">to the end of the current period p = [s, f], compared to the overall user population. </span></p><p class="c18"><span class="c43">422 </span></p><p class="c4"><span class="c0">More specifically, time starts at the beginning of time s</span><span class="c9">0 </span><span class="c5">and </span><span class="c0">is segmented into subsequent time periods p</span><span class="c3">0</span><span class="c0">,...,p</span><span class="c3">now </span><span class="c0">of varying lengths. Given two time periods p</span><span class="c9">i </span><span class="c5">= [s</span><span class="c9">i</span><span class="c5">,f</span><span class="c9">i</span><span class="c5">] and </span><span class="c0">p</span><span class="c3">j </span><span class="c0">= [s</span><span class="c3">j</span><span class="c0">,f</span><span class="c3">j</span><span class="c0">], p</span><span class="c3">i </span><span class="c0">&#63743; p</span><span class="c3">j </span><span class="c0">is used to denote that p</span><span class="c3">i </span><span class="c0">precedes p</span><span class="c3">j</span><span class="c0">, i.e., s</span><span class="c9">i </span><span class="c5">&#63743; s</span><span class="c9">j </span><span class="c5">and f</span><span class="c9">i </span><span class="c5">&#63743; f</span><span class="c9">j</span><span class="c5">. Determining the right granularity </span><span class="c0">of a time period depends on the application at hand and the frequency of user actions and is orthogonal to our model. For example, in a social network such as Facebook, and when affinities are computed using shared posts, granularity may vary from hours to days depending on the time of year. On Twitter, granularity is finer and may vary from minutes to hours since post frequency is higher. Not all time periods are of the same length. Given a time period p = [s, f], for every time period p</span><span class="c6">0 </span><span class="c0">that is included in the interval starting at the beginning of time s</span><span class="c3">0 </span><span class="c0">and ending at f, the end of p, the periodic affinity drift is calculated as a difference between the periodic affin- ity a</span><span class="c12">ff </span><span class="c6">p</span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">,p</span><span class="c6">0</span><span class="c0">) between users u and u</span><span class="c6">0 </span><span class="c0">and the average periodic affinity Avga</span><span class="c12">ff </span><span class="c6">p</span><span class="c0">(p</span><span class="c6">0</span><span class="c0">) of the whole user population. These drifts are aggregated over all time periods included in the interval [s</span><span class="c9">0</span><span class="c5">,f] and normalized to generate a</span><span class="c11">ff</span><span class="c9">y </span><span class="c5">(u, u</span><span class="c3">0</span><span class="c5">,p). </span><span class="c0">Formally, </span></p><p class="c4"><span class="c0">a</span><span class="c12">ff</span><span class="c3">y</span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">,p) = </span><span class="c23">&#8963;</span><span class="c3">p</span><span class="c35">0</span><span class="c3">&#63743;p</span><span class="c0">(a</span><span class="c12">ff </span><span class="c6">P</span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">,p</span><span class="c6">0</span><span class="c0">) Avga</span><span class="c12">ff </span><span class="c6">P </span><span class="c0">(p</span><span class="c6">0</span><span class="c0">)) </span><span class="c5">(1) </span><span class="c0">The exact formulation of depends on how time is mod- eled (discrete or continuous) and is described. Interestingly, a</span><span class="c12">ff</span><span class="c3">y</span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">,p) could be either positive or negative and de- pends on how the affinity of (u, u</span><span class="c6">0</span><span class="c0">) evolves compared to the overall population. The exact formulation of a</span><span class="c12">ff </span><span class="c6">P </span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">,p</span><span class="c6">0</span><span class="c0">) depends on the ap- plication. In our Facebook experiment in Section 4.1.2, we use common page likes between u and u</span><span class="c6">0 </span><span class="c0">during period p</span><span class="c6">0</span><span class="c0">. Finally, Avga</span><span class="c12">ff </span><span class="c6">p</span><span class="c0">(p</span><span class="c6">0</span><span class="c0">) is defined as follows: </span></p><p class="c4"><span class="c0">Avga</span><span class="c12">ff </span><span class="c6">p</span><span class="c0">(p</span><span class="c6">0</span><span class="c0">) = </span><span class="c23">2 &#8677; &#8963;</span><span class="c3">(u,u</span><span class="c35">0</span><span class="c3">)2U,u=u</span><span class="c35">0</span><span class="c23">a</span><span class="c70">ff </span><span class="c6">P </span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">,p</span><span class="c6">0</span><span class="c0">) </span></p><p class="c4"><span class="c0">|U|</span><span class="c6">2 </span><span class="c0">|U| </span></p><p class="c4"><span class="c0">We now describe our dynamic affinity models that use a</span><span class="c12">ff</span><span class="c9">s</span><span class="c5">(u, u</span><span class="c3">0</span><span class="c5">) </span><span class="c0">and a</span><span class="c12">ff</span><span class="c9">y</span><span class="c5">(u, u</span><span class="c3">0</span><span class="c5">) as building blocks. The first model relies on dis- </span><span class="c0">cretized time periods to capture a</span><span class="c12">ff</span><span class="c9">y </span><span class="c5">whereas the second repre- </span><span class="c0">sents time in a continuous fashion. </span></p><p class="c4"><span class="c0">&bull; Discrete Dynamic Affinity Model: In this model, the a</span><span class="c12">ff</span><span class="c9">s </span><span class="c5">and </span><span class="c0">a</span><span class="c12">ff</span><span class="c3">y </span><span class="c0">affinity components are aggregated using a linear func- tion over a set of discretized time periods. Therefore, , the denominator in Equation 1, is simply the number of time pe- riods between s</span><span class="c9">0</span><span class="c5">, the beginning of time, and e, the end of </span><span class="c0">p. This simple aggregation also allows us to design efficient algorithms. a</span><span class="c12">ff </span><span class="c6">D</span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">,p) =a</span><span class="c12">ff</span><span class="c3">s</span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">) + a</span><span class="c12">ff</span><span class="c3">y </span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">,p) </span></p><p class="c4"><span class="c0">&bull; Continuous Dynamic Affinity Model: For this model, time is considered in a continuous fashion. In this case, the denomi- nator in Equation 1, =f-s</span><span class="c3">0 </span><span class="c0">is the length of time between the the beginning of time s</span><span class="c9">0 </span><span class="c5">and f, the end of p. As a natural rep- </span><span class="c0">resentation to capture continuous time, we consider an expo- nential function, which is also supported in prior work [17]. Formally, a</span><span class="c12">ff </span><span class="c6">C</span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">,p) = a</span><span class="c12">ff</span><span class="c9">s</span><span class="c5">(u, u</span><span class="c3">0</span><span class="c5">) &#8677; e </span><span class="c3">(f s</span><span class="c37">0</span><span class="c3">) </span></p><p class="c15"><span class="c0">Here is the rate of growth/decay of affinity and could sim- ply be replaced by a</span><span class="c12">ff</span><span class="c3">y</span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">,p) in Equation 1 to represent the cumulative effect of affinity drift over time. </span></p><p class="c4"><span class="c0">Consequently, the discrete time model could be viewed as an ap- proximation of the continuous one where time is discretized into sub-periods and each user pair&rsquo;s affinity is normalized over the number of periods (Equation 1). Alternatively, the continuous model treats time as a single interval [f-s</span><span class="c3">0</span><span class="c0">] and captures an exponential growth, resp., decay, affinity model when a</span><span class="c12">ff</span><span class="c9">y</span><span class="c5">(u, u</span><span class="c3">0</span><span class="c5">,p) is positive, </span><span class="c0">resp., negative. </span></p><p class="c4"><span class="c0">In both a</span><span class="c12">ff </span><span class="c6">D</span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">,p) and a</span><span class="c12">ff </span><span class="c6">C</span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">,p) affinity drift could be negative or positive thereby capturing situations in practice where affinity between two users may increase or decrease over time. We believe that the ability to capture this varying rate of change is im- portant in practice in particular for social networks where different users exhibit different interests over time. </span><span class="c8">2.2 User-Item Preference Models </span></p><p class="c15"><span class="c0">We now show how affinities are accounted for in computing the preference of a user for an item in a group. We first describe how affinity is incorporated into user-item preferences without account- ing for time then we show how to modify the formulation to com- pute time-aware user-item preferences. </span></p><p class="c4"><span class="c0">Time-Agnostic User-Item Preference: Given a group G, the preference of a user u 2 G for an item i 2 I is denoted pref (u, i,G) and depends on two components: </span></p><p class="c15"><span class="c0">&bull; Absolute preference - apref (u, i). This describes how much u likes item i akin to the predicted rating of u for i. Existing single-user recommendation algorithms, such as collabora- tive filtering, could be used to compute apref (u, i). </span></p><p class="c15"><span class="c0">&bull; Relative preference - rpref (u, i,G). This component cap- tures that a user likes an item i if close members in the group G also like i and similarly that a user dislikes an item i if close members in the group G dislike i. Affinity between group members is used to capture how close they are. More formally, rpref (u, i,G) combines the affinity of a user u with other members u</span><span class="c6">0 </span><span class="c0">2 G, denoted a</span><span class="c12">ff </span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">), with the preference of u</span><span class="c6">0 </span><span class="c0">for item i, denoted apref (u</span><span class="c6">0</span><span class="c0">,i). </span></p><p class="c4"><span class="c0">rpref (u, i, G) = &#8963;</span><span class="c9">8u</span><span class="c75">0</span><span class="c9">=u2G</span><span class="c5">a</span><span class="c11">ff </span><span class="c5">(u, u</span><span class="c3">0</span><span class="c5">) &#8677; apref (u</span><span class="c3">0</span><span class="c5">,i) </span></p><p class="c48"><span class="c0">The overall affinity-aware user-item preference is a simple com- bination of these two factors: pref (u, i) = apref (u, i)+rpref (u, i,G) </span></p><p class="c4"><span class="c0">Time-Aware User-Item Preference: We now modify the defi- nition of relative preference to capture temporal affinities: </span></p><p class="c4"><span class="c0">rpref (u, i,G,p) = &#8963;</span><span class="c9">8u</span><span class="c75">0</span><span class="c9">=u2G</span><span class="c5">a</span><span class="c11">ff </span><span class="c5">(u, u</span><span class="c3">0</span><span class="c5">,p) &#8677; apref (u</span><span class="c3">0</span><span class="c5">,i). </span></p><p class="c4"><span class="c0">Therefore, a user u&rsquo;s overall preference on item i during time period p can be simply formulated as: </span></p><p class="c4"><span class="c0">pref (u, i, G,p) = apref (u, i) + rpref (u, i, G,p) </span><span class="c8">2.3 Group Consensus Models </span></p><p class="c15"><span class="c0">Members of a group may not always have the same preferences for items and a consensus function needs to aggregate user-item preferences into a single group&rsquo;s preference for an item. Intuitively, there are two main aspects in a consensus function [20]. First, the preference of a group for an item needs to reflect the degree to which the item is preferred by all group members. The more group members prefer an item, the higher its group preference. Second, </span></p><p class="c4"><span class="c43">423 </span></p><p class="c15"><span class="c0">the group preference needs to capture the level at which members disagree or agree with each other. All other conditions being equal, an item that draws high agreement should have a higher score than an item with a lower overall group agreement. We call the first as- pect group preference and the second aspect group disagreement. We revisit the definitions we introduced in [3] to include a time component. </span></p><p class="c4"><span class="c0">Group Preference: The preference of an item i by a group G during a time period p, denoted gpref (G, i, p), is an aggregation over the preferences of each group member for that item. We con- sider two commonly used aggregation strategies: Average Preference: </span><span class="c6">1</span><span class="c3">|G| </span></p><p class="c4"><span class="c12">P</span><span class="c9">u2G </span><span class="c0">(pref (u, i,G,p)) Least-Misery Preference: min</span><span class="c9">u2G</span><span class="c5">(pref (u, i,G,p)) </span></p><p class="c15"><span class="c0">Group Disagreement: The disagreement of a group G over an item i during a time period p, denoted dis(G, i, p), reflects the de- gree of consensus in the user-item preferences for i among group members over time. We revisit the two most common disagreement computation methods: </span></p><p class="c4"><span class="c0">1) Average Pair-wise Disagreements: dis(G, i, p) = </span><span class="c6">2 </span></p><p class="c4"><span class="c3">|G|(|G| 1) </span></p><p class="c4"><span class="c12">P</span><span class="c5">(|pref (u, i,G,p) pref (v, i,G,p)|), </span><span class="c0">where u = v and u, v 2 G; </span></p><p class="c4"><span class="c0">2) Disagreement dis(G, i, p) = </span><span class="c3">|G| </span></p><p class="c4"><span class="c6">1</span><span class="c12">P</span><span class="c0">Variance: </span></p><p class="c15"><span class="c9">u2G </span><span class="c0">(pref (u, i,G,p) mean(i,G,p))</span><span class="c6">2</span><span class="c0">, where mean(G, i, p) is the mean of all the individual preferences for item i over time. </span></p><p class="c15"><span class="c0">The average pair-wise disagreement function computes the av- erage of pair-wise differences in preferences for the item among group members, while the variance disagreement function com- putes the mathematical variance of the preferences for the item among group members. Intuitively, the closer the preferences for i between users u and v, the lower their disagreement for i. </span></p><p class="c15"><span class="c0">Time-Aware Group Consensus: We combine group preference and group disagreement in a time-aware consensus function, de- noted F(G, i, p). The function combines group preference and dis- agreement for an item i and a group G into a single group con- sensus score using the following formula: F(G, i, p) = w</span><span class="c3">1 </span><span class="c0">&#8677; gpref (G, i, p)+w</span><span class="c9">2 </span><span class="c5">&#8677;(1 dis(G, i, p)) where w</span><span class="c9">1 </span><span class="c5">+w</span><span class="c9">2 </span><span class="c5">= 1.0 and </span><span class="c0">each specifies the relative importance of preference and disagree- ment in the overall group consensus. </span></p><p class="c15"><span class="c0">Note that the formulation of group consensus incorporates tem- poral affinities by aggregating the relative user-item preferences of its members with disagreement. The proposed formulation is or- thogonal to how affinities are modeled and incorporated into in- dividual relative preferences. This way accounting for temporal affinities in group recommendation is orthogonal to the consensus function used to aggregate group members. </span></p><p class="c4"><span class="c8">2.4 Problem Definition </span></p><p class="c15"><span class="c0">Given a group G, a time-aware consensus function F and an integer k, the objective is to recommend to G the k best itemset I</span><span class="c9">G </span><span class="c5">that accounts for its members&rsquo; affinities during a period p, such </span><span class="c0">that:</span><span class="c5">&bull; |I</span><span class="c9">G</span><span class="c5">| = k </span></p><p class="c4"><span class="c0">&bull; 8i 2 I</span><span class="c9">G</span><span class="c5">,u 2 G, i is not individually recommended to u </span></p><p class="c15"><span class="c0">&bull; </span><span class="c12">J</span><span class="c0">j 2 I, s.t. F(G, j, p) &gt; F(G, i, p), where j /2 I</span><span class="c9">G</span><span class="c5">,i 2 </span><span class="c0">I</span><span class="c3">G</span><span class="c0">, i.e., there does not exist any other item j in I whose consensus score is higher than any item in i in I</span><span class="c9">G</span><span class="c5">. </span></p><p class="c4"><span class="c8">3. INSTANCE OPTIMAL ALGORITHMS </span></p><p class="c15"><span class="c0">In this section, we discuss how to efficiently compute k affinity- aware recommendations for ad-hoc groups, meaning for groups that are not known beforehand. Recall that given a group G, the goal, stated in Section 2, is to find the k best items to recommend to G according to a consensus function F. </span></p><p class="c15"><span class="c0">We propose instance optimal algorithms to compute top-k items for a given group under different group consensus functions. The overall intuition of this algorithm is appropriately adapted from the family of Fagin-style top-k algorithms [10]. These algorithms, such as, Threshold algorithms TA or No Random Access Algorithm NRA, rely on a function that aggregates multiple score components into a single score for each item. Those algorithms are used in Web search to compute the score of each item (a document in that case) as a combination of its component scores (its scores for each keyword in the search query). These algorithms aim to find the k items that rank the highest (the ones with the highest aggregated scores) in as little time as possible. They take sorted item lists that correspond to each component and scan them using sequen- tial and random accesses (SAs and RAs), and the computation can be terminated without scanning the input lists fully, using stopping conditions based on score bounds (thresholds). Early stopping is possible when the ranking function is monotone [10]. </span></p><p class="c15"><span class="c0">L</span><span class="c42">EMMA </span><span class="c0">1. The temporal affinity-aware consensus function F is monotonic w.r.t. absolute preference lists and user-affinity lists for the dynamic user-affinity model, and pair-wise disagreement lists.</span><span class="c5">P</span><span class="c83">ROOF</span><span class="c5">. (sketch): In a prior work [3], we showed that all three </span><span class="c0">group consensus functions without considering time-agnostic affin- ity (average preference, least misery and pair-wise disagreement) are monotone. If all group members, except a user u, rate items i</span><span class="c3">1 </span><span class="c0">and i</span><span class="c3">2 </span><span class="c0">the same, i</span><span class="c3">1 </span><span class="c0">will have at least the same group prefer- ence as i</span><span class="c9">2 </span><span class="c5">if u rates i</span><span class="c9">1 </span><span class="c5">no less than i</span><span class="c9">2</span><span class="c5">. This holds for both the </span><span class="c0">average and least-misery. For pair-wise disagreement, we showed that our group disagreement functions (pair-wise and variance) can be transformed into aggregations of individual pair-wise disagree- ments and become monotone. </span></p><p class="c15"><span class="c0">Monotonicity remains true with the introduction of affinities and time. For an item i, if both users like i highly, higher affinity be- tween them only improves i&rsquo;s overall preference. On the contrary, for an item j, if they like j as highly as they do i, lower affinity between them only decreases j&rsquo;s overall preference. Introduction of time in the affinity model only makes the affinity calculation time-dependent by changing the temporal granularity at which it is computed; however, the relationship between dynamic affinity and the group consensus of an item does not change. </span></p><p class="c4"><span class="c0">As a result, we can design instance optimal algorithms with the early stopping. </span><span class="c8">3.1 Running Example and Data Structures </span></p><p class="c15"><span class="c0">We now describe the data structures necessary to run Fagin-style top-k processing algorithms via an example that will also be used to illustrate our algorithm, GRECA. </span></p><p class="c15"><span class="c0">Imagine a group G formed with three users u</span><span class="c9">1</span><span class="c5">,u</span><span class="c9">2</span><span class="c5">,u</span><span class="c9">3</span><span class="c5">. Given an </span><span class="c0">itemset I = {i</span><span class="c9">1</span><span class="c5">,i</span><span class="c9">2</span><span class="c5">,i</span><span class="c9">3</span><span class="c5">}, our objective is to identify the best item </span><span class="c0">(k = 1) to recommend to the group at time period p (for example, January 2014). Also, assume that the system has information about </span></p><p class="c4"><span class="c43">424 </span></p><p class="c4"><span class="c0">Algorithm 1 Group Recommendation with Temporal Affinities (GRECA) </span><span class="c27">Require: Group G, k, consensus function F; </span><span class="c5">1: </span><span class="c17">Retrieve user preference lists PL</span><span class="c9">u </span><span class="c17">for each user u in group G; </span><span class="c5">2: </span><span class="c17">Retrieve pair-wise affinities for </span><span class="c74">aff</span><span class="c9">s </span><span class="c27">, </span><span class="c10">aff</span><span class="c9">y </span><span class="c27">for each period; </span><span class="c5">3: </span><span class="c17">Sc</span><span class="c9">r </span><span class="c17">= {r</span><span class="c9">u</span><span class="c17">}, the last user preference from PL</span><span class="c9">u</span><span class="c17">, 8u 2 G </span><span class="c5">4: </span><span class="c17">Sc</span><span class="c9">a</span><span class="c28">ff</span><span class="c53">s </span><span class="c27">= {</span><span class="c10">aff</span><span class="c9">s u,v</span><span class="c27">}, the last pair-wise </span><span class="c10">aff</span><span class="c9">s </span><span class="c27">affinity values read 8u, v 2 G </span><span class="c5">5: </span><span class="c17">Sc</span><span class="c9">a</span><span class="c28">ff</span><span class="c53">y </span><span class="c27">= {</span><span class="c10">aff</span><span class="c9">y u,v</span><span class="c27">}, the last pair-wise periodic affinity values read for each time period p</span><span class="c6">0</span><span class="c27">, 8u, v 2 G </span><span class="c5">6: </span><span class="c17">Cursor cur = getNext() round-robin accesses to PL</span><span class="c9">u</span><span class="c17">, </span><span class="c74">aff</span><span class="c9">s </span><span class="c27">and </span><span class="c10">aff</span><span class="c9">y </span><span class="c17">lists </span><span class="c5">7: </span><span class="c17">while (cur &lt;&gt; NULL) do </span><span class="c5">8: </span><span class="c17">Get entry e at cur </span><span class="c5">9: </span><span class="c17">if !(in B(topKHeap,e)) then </span><span class="c5">10: </span><span class="c17">ComputeUB(e,F) </span><span class="c5">11: </span><span class="c17">ComputeLB(e,F) </span><span class="c5">12: </span><span class="c17">Add e in B </span><span class="c5">13: </span><span class="c17">else </span><span class="c5">14: </span><span class="c17">Update ComputeUB(e, F) and ComputeLB(e,F) </span><span class="c5">15: </span><span class="c17">end if </span><span class="c5">16: </span><span class="c17">Sc</span><span class="c9">th </span><span class="c27">= ComputeTh({E}, F) considering all current cursor posi- tions </span><span class="c5">17: </span><span class="c17">if Sc</span><span class="c9">th </span><span class="c27">&#63743; B.k</span><span class="c9">th</span><span class="c27">LB&amp;|B| = k then </span><span class="c5">18: </span><span class="c17">return topKList(B, k); </span><span class="c5">19: </span><span class="c17">Exit; </span><span class="c5">20: </span><span class="c17">else </span><span class="c5">21: </span><span class="c17">if CheckBuffer(B) is satisfied then </span><span class="c5">22: </span><span class="c17">return topKList(B,k) </span><span class="c5">23: </span><span class="c17">Exit; </span><span class="c5">24: </span><span class="c17">else </span><span class="c5">25: </span><span class="c17">cur = getNext() </span><span class="c5">26: </span><span class="c17">end if </span><span class="c5">27: </span><span class="c17">end if </span><span class="c5">28: </span><span class="c17">end while </span><span class="c0">29: </span><span class="c27">return topKList(B,k) </span></p><p class="c15"><span class="c0">group members u</span><span class="c9">1</span><span class="c5">,u</span><span class="c9">2</span><span class="c5">,u</span><span class="c9">3 </span><span class="c5">for one year, i.e., January 2013 to Jan- </span><span class="c0">uary 2014. The user-item preference lists of those group members are provided in Table 1. Each list contains items preferred by each user sorted in decreasing order of preference. </span></p><p class="c15"><span class="c0">The item preference of a member u of a group G is a combi- nation pref (u, i,G,p) = apref (u, i) + rpref (u, i,G,p), where rpref is the relative preference that accounts for the temporal affin- ity of u with other group members. </span></p><p class="c4"><span class="c0">u</span><span class="c9">1 </span><span class="c5">u</span><span class="c9">2 </span><span class="c5">u</span><span class="c9">3 </span><span class="c0">i</span><span class="c3">1 </span><span class="c0">5 i</span><span class="c3">1 </span><span class="c0">5 i</span><span class="c3">3 </span><span class="c0">2 i</span><span class="c9">2 </span><span class="c5">1 i</span><span class="c9">2 </span><span class="c5">1 i</span><span class="c9">1 </span><span class="c5">2 </span><span class="c0">i</span><span class="c9">3 </span><span class="c5">1 i</span><span class="c9">3 </span><span class="c5">0.5 i</span><span class="c9">2 </span><span class="c5">1 </span></p><p class="c4"><span class="c0">Table 1: Absolute Preference Lists PL</span><span class="c3">u </span><span class="c0">of u</span><span class="c3">1</span><span class="c0">,u</span><span class="c3">2</span><span class="c0">,u</span><span class="c3">3 </span></p><p class="c15"><span class="c0">Affinity between users consists of two components, static affinity a</span><span class="c12">ff</span><span class="c3">s </span><span class="c0">and dynamic affinity a</span><span class="c12">ff</span><span class="c3">y</span><span class="c0">. The detailed interpretations of these affinities and how they are calculated are given in Section 2. Out of the two aforementioned affinities, the latter is time-aware, where time is considered in a continuous fashion or over a discrete set of time periods (for example, two equal periods p</span><span class="c9">1 </span><span class="c5">and p</span><span class="c9">2 </span><span class="c5">each </span><span class="c0">of six months in our case). For simplicity, we consider the discrete model in this example. The a</span><span class="c12">ff</span><span class="c9">s </span><span class="c5">affinity involves all user-pairs </span><span class="c0">thereby creating 3&#8677;(3 1)/2 (i.e. n(n 1)/2 in general) entries. For every time period p</span><span class="c6">0</span><span class="c0">, similarly, there is a periodic affinity list of the same size. Notice that each affinity list a</span><span class="c12">ff</span><span class="c9">y </span><span class="c5">or a</span><span class="c11">ff</span><span class="c9">s </span><span class="c5">with </span><span class="c0">n(n 1)/2 entries could further be partitioned into a set of n 1 lists, where the i-th list stands for user u</span><span class="c9">i </span><span class="c5">with n i entries. For </span></p><p class="c15"><span class="c0">example, we can have a L</span><span class="c9">a</span><span class="c28">ff</span><span class="c53">s</span><span class="c0">(u</span><span class="c9">1</span><span class="c5">) that stores u</span><span class="c9">1</span><span class="c5">&rsquo;s static affinity </span><span class="c0">with u</span><span class="c3">2 </span><span class="c0">and with u</span><span class="c3">3</span><span class="c0">, one for L</span><span class="c9">a</span><span class="c28">ff</span><span class="c53">s</span><span class="c0">(u</span><span class="c3">2</span><span class="c0">) with u</span><span class="c3">2</span><span class="c0">&rsquo;s affinity with u</span><span class="c3">3 </span><span class="c0">only (storing u</span><span class="c9">1</span><span class="c5">&rsquo;s affinity here again is redundant), and no static </span><span class="c0">affinity list needs to be created for user u</span><span class="c3">3</span><span class="c0">. This partitioning allows us to design efficient algorithms, as we describe later in Section 3. Table 2 contains a</span><span class="c12">ff</span><span class="c9">s </span><span class="c5">affinity lists of all users sorted in decreasing </span><span class="c0">order and Tables 3 and 4 contain a</span><span class="c12">ff</span><span class="c3">y </span><span class="c0">affinity of users in periods p</span><span class="c9">1 </span><span class="c5">and p</span><span class="c9">2 </span><span class="c5">respectively. Note that the temporal affinity of users u</span><span class="c9">1 </span><span class="c0">and u</span><span class="c3">2 </span><span class="c0">has decreased between periods p</span><span class="c3">1 </span><span class="c0">and p</span><span class="c3">2</span><span class="c0">. </span></p><p class="c15"><span class="c0">In the above example, temporal affinity between user pairs(u, u</span><span class="c6">0</span><span class="c0">) is modeled in a discrete manner as a</span><span class="c12">ff </span><span class="c6">D</span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">,p). To facilitate ef- ficient computation, it is easy to see that the different absolute pref- erence lists and time-variant affinity lists are to be pre-computed. Even for a small group such as the one in the example with 3 users, there are 3 absolute preference lists. Furthermore, the all-pair user affinities for a given time period p</span><span class="c6">0 </span><span class="c0">are to be stored as well, either as a single list with n(n 1)/2 entries, or decomposed over a set of n 1 lists, where the i-th list represent user u</span><span class="c9">i</span><span class="c5">&rsquo;s affinities with </span><span class="c0">n i other users. Since the period affinities are independent of each other, we must precompute such lists for every time period. For the example case, this requires either creating 2 periodic affin- ity lists to capture a</span><span class="c12">ff</span><span class="c9">y </span><span class="c5">affinity and one static affinity list to capture </span><span class="c0">a</span><span class="c12">ff</span><span class="c9">s</span><span class="c5">. Each of these lists have n(n 1)/2 entries (as a single list </span><span class="c0">or splitted in n 1 lists, as described in the example). The size of each list is quadratic in the number of users, but the number of such lists (T ) is a function of how time is discretized into pe- riods. Even for a small group such as ours, many lists are to be used in the computation. Notice that all these user-affinity lists are required to compute the complete score of any item, because, the relative preference rpref (u, i,G,p) for every item requires access- ing all T &#8677;n(n 1)/2 entries. An algorithm such as TA must read all those entries to compute the complete score of an item and will hence incur a large number of RAs. </span></p><p class="c15"><span class="c0">We argue that all these accesses are not always necessary. For in- stance, based on preferences in Tables 1 to 4, we consider scanning item i</span><span class="c3">1 </span><span class="c0">in PL</span><span class="c3">u</span><span class="c37">1</span><span class="c0">. If we were following TA method, to compute the complete score of this item, 21 RAs are needed, i.e., one RA for each apref (u, i</span><span class="c3">1</span><span class="c0">) component and 6 RAs for each rpref (u, i</span><span class="c3">1</span><span class="c0">,p) component where u 2 {u</span><span class="c9">1</span><span class="c5">,u</span><span class="c9">2</span><span class="c5">,u</span><span class="c9">3</span><span class="c5">}. Note that to compute the </span><span class="c0">score of a single item i</span><span class="c9">1</span><span class="c5">, we have accessed all entries in a</span><span class="c11">ff</span><span class="c9">s</span><span class="c5">(u</span><span class="c9">1</span><span class="c5">), </span><span class="c0">a</span><span class="c12">ff</span><span class="c3">y </span><span class="c0">(u</span><span class="c3">1</span><span class="c0">,p</span><span class="c3">1</span><span class="c0">) and a</span><span class="c12">ff</span><span class="c3">y</span><span class="c0">(u</span><span class="c3">1</span><span class="c0">,p</span><span class="c3">2</span><span class="c0">) lists. For instance, entries in the list a</span><span class="c12">ff</span><span class="c9">s</span><span class="c5">(u</span><span class="c9">1</span><span class="c5">) is the static affinity scores between (u</span><span class="c9">1</span><span class="c5">,u</span><span class="c9">2</span><span class="c5">) and (u</span><span class="c9">1</span><span class="c5">,u</span><span class="c9">3</span><span class="c5">) </span><span class="c0">where we have accessed both. </span></p><p class="c15"><span class="c0">Instead, our instance optimal algorithm GRECA makes only se- quential accesses, i.e., SAs like NRA and potentially avoids con- suming all these T &#8677; n(n 1)/2 entries to determine the top-k itemset. Following previous example, if for instance a</span><span class="c12">ff</span><span class="c9">s</span><span class="c5">(u</span><span class="c9">1</span><span class="c5">,u</span><span class="c9">3</span><span class="c5">) </span><span class="c0">(in Table 2) is not yet scanned, we avoid making an RA to get this value, but based on NRA principle, we use the score under the cur- sor in the list of Table 2 (i.e., initially a</span><span class="c12">ff</span><span class="c3">s</span><span class="c0">(u</span><span class="c3">1</span><span class="c0">,u</span><span class="c3">2</span><span class="c0">)) to compute a partial score for i</span><span class="c9">1</span><span class="c5">. Details are mentioned in Section 3.2. </span></p><p class="c15"><span class="c0">GRECA returns the top-k itemset which contains the best set of k-items, although the rank among the returned itemset may not be fully distinguishable (i.e. giving rise to a partial order). This is rather reasonable, because k is usually small, and the group is po- tentially interested in all of the k-items. </span></p><p class="c4"><span class="c8">3.2 GRECA </span></p><p class="c15"><span class="c0">For ease of exposition, we describe GRECA using the simplest group consensus function Average Preference considering time- aware affinity. The other group consensus functions mimic its be- havior. The algorithm exploits the settings as is described in the example in Section 3.1. </span></p><p class="c4"><span class="c43">425 </span></p><p class="c4"><span class="c0">uu</span><span class="c9">1 </span><span class="c5">u</span><span class="c9">2 </span></p><p class="c4"><span class="c9">1 </span><span class="c5">u</span><span class="c9">2 </span><span class="c0">u</span><span class="c3">1</span><span class="c0">u</span><span class="c3">2 </span><span class="c0">1 u</span><span class="c3">2</span><span class="c0">u</span><span class="c3">3 </span><span class="c0">0.3 </span></p><p class="c4"><span class="c0">u</span><span class="c3">1</span><span class="c0">u</span><span class="c3">2 </span><span class="c0">0.8 u</span><span class="c3">2</span><span class="c0">u</span><span class="c3">3 </span><span class="c0">0.2 u</span><span class="c3">1</span><span class="c0">u</span><span class="c3">3 </span><span class="c0">0.2 </span></p><p class="c4"><span class="c0">u</span><span class="c3">1</span><span class="c0">u</span><span class="c3">3 </span><span class="c0">0.1 </span></p><p class="c4"><span class="c0">Table 2: Static Affinity Lists L</span><span class="c9">a</span><span class="c28">ff</span><span class="c53">s </span></p><p class="c4"><span class="c0">Table 3: L</span><span class="c9">a</span><span class="c28">ff</span><span class="c53">y </span><span class="c0">Lists for Period p</span><span class="c9">1 </span></p><p class="c4"><span class="c0">u</span><span class="c9">1 </span><span class="c5">u</span><span class="c9">2 </span><span class="c0">u</span><span class="c3">1</span><span class="c0">u</span><span class="c3">2 </span><span class="c0">0.7 u</span><span class="c3">2</span><span class="c0">u</span><span class="c3">3 </span><span class="c0">0.1 u</span><span class="c3">1</span><span class="c0">u</span><span class="c3">3 </span><span class="c0">0.1 </span></p><p class="c4"><span class="c0">Table 4: L</span><span class="c9">a</span><span class="c28">ff</span><span class="c53">y </span><span class="c0">Lists for Period p</span><span class="c9">2 </span></p><p class="c15"><span class="c0">Without loss of generality, for a given group with n users, GRECA uses n user-item preference lists, where each list PL</span><span class="c3">u </span><span class="c0">for user u has m items that are sorted in decreasing user-item preference. Each PL can be obtained with any single user recommendation strategy (in our experiments in Section 4, we use collaborative fil- tering). In addition, GRECA uses n 1 static affinity lists, and another n 1 dynamic periodic affinity lists for each time period. </span></p><p class="c15"><span class="c0">The algorithm runs in a round-robin fashion over the aforemen- tioned lists by making only SAs. It reads an entry e = (i, r), where i is the item-id and r is the user u&rsquo;s absolute preference score for i, or an entry e</span><span class="c6">0 </span><span class="c0">= (u</span><span class="c6">0</span><span class="c0">,r</span><span class="c6">0</span><span class="c0">), where r</span><span class="c6">0 </span><span class="c0">is the pair-wise affinity of (u, u</span><span class="c6">0</span><span class="c0">). Affinity between a pair of users is either static or periodic (i.e. dynamic), and the computation does not distinguish between these two kinds. The algorithm invokes the following 3 different subroutines to determine whether to continue further or to safely terminate and return the top-k itemset during its execution: </span></p><p class="c4"><span class="c0">(a) Compute Upper-Bound of an Item: ComputeUB(i): UB</span><span class="c9">i </span><span class="c0">computes the highest score that an item i can have in G based on so far accesses. </span></p><p class="c15"><span class="c0">(b) Compute Lower-Bound of an Item: ComputeLB(i): LB</span><span class="c9">i </span><span class="c5">computes the lowest score that an item i can have in G based </span><span class="c0">on so far accesses. </span></p><p class="c15"><span class="c0">(c) Compute Global Threshold: ComputeTh({E}): Input to this function is the current set {E} of entries read from all the lists. The output is simply a numeric score that captures the highest score that an unseen item can have for group G. </span></p><p class="c15"><span class="c0">Subroutines can be invoked after reading one entry from each type of list (preference list, static affinity list or dynamic affinity list) to make sure all types of lists are visited before or after reading the j-th entry from all lists. </span></p><p class="c15"><span class="c0">The first two subroutines return the latest bounds of an item i. Then, those updated bounds are pushed into an item buffer that is maintained throughout the execution of the algorithm. We describe our proposed buffer management strategy later on. Naturally, these two subroutines are to be invoked for all encountered items so far. </span></p><p class="c21"><span class="c0">Illustration of the Subroutines: The upper-bound score of an item i is simply the highest score it can have on current accesses. It is computed by combining the actual encountered values for some of the entries and then assigning the current cursor readings to the rest. Consider our three-user group described in Section 3.1 and assume that ComputeUB(i</span><span class="c3">3</span><span class="c0">) is invoked after the cursor reads the second tered, but entry for at the PLother </span><span class="c9">u</span><span class="c37">2</span><span class="c0">. At that point, apref (u</span><span class="c9">3</span><span class="c5">,i</span><span class="c9">3</span><span class="c5">)=2 </span><span class="c0">two users, these are to be </span><span class="c5">is encoun- </span><span class="c0">approximated based on the current cursor readings. For example, the highest score of apref (u</span><span class="c9">1</span><span class="c5">,i</span><span class="c9">3</span><span class="c5">)=1, apref (u</span><span class="c9">2</span><span class="c5">,i</span><span class="c9">3</span><span class="c5">)=1. Similarly, static </span><span class="c0">and dynamic periodic affinities of users u</span><span class="c3">1</span><span class="c0">,u</span><span class="c3">2 </span><span class="c0">and u</span><span class="c3">2</span><span class="c0">,u</span><span class="c3">3 </span><span class="c0">are en- countered, but those of u</span><span class="c9">1</span><span class="c5">,u</span><span class="c9">3 </span><span class="c5">are to be guessed based on the latest </span><span class="c0">cursor reading from the respective lists. This gives rise to ComputeUB(i</span><span class="c9">3</span><span class="c5">)= &#8963;</span><span class="c9">8i2{1,2,3}</span><span class="c0">UB[apref (u</span><span class="c9">i</span><span class="c5">,i</span><span class="c9">3</span><span class="c5">)] + UB[rpref (u</span><span class="c9">i</span><span class="c5">,i</span><span class="c9">3</span><span class="c5">,G,p)] </span><span class="c0">= 13.02 (by ignoring normalization and final averaging). </span></p><p class="c4"><span class="c0">The computation of the lower-bound of an item i is similar ex- cept that it replaces the unseen entries of the function with the low- est possible score. For example, instead of assigning apref (u</span><span class="c9">1</span><span class="c5">,i</span><span class="c9">3</span><span class="c5">) = </span><span class="c0">1, apref (u</span><span class="c9">2</span><span class="c5">,i</span><span class="c9">3</span><span class="c5">) = 1, it will consider those values to be 0 (as- </span><span class="c0">suming that the smallest absolute preference for an item could be 0). The same will happen in affinity calculation; as an example, it substitutes a</span><span class="c12">ff</span><span class="c3">s</span><span class="c0">(u1</span><span class="c3">,</span><span class="c0">u</span><span class="c3">3</span><span class="c0">)=0, instead of 0.8 in the upper-bound computation case. When invoked using item i</span><span class="c9">1</span><span class="c5">, ComputeLB(i</span><span class="c9">1</span><span class="c5">) </span><span class="c0">returns a value of 14.2 (ignoring normalization and final averag- ing).</span><span class="c5">Computation of ComputeTh({E}) is rather simple. It simply </span><span class="c0">incorporates each of the entries in {E} in the function and returns a numeric score. </span></p><p class="c4"><span class="c0">Buffer Management Strategy: Once the upper-bound and lower- bound scores of each item are computed, they are pushed into a buffer B and are sorted in decreasing order of lower-bound score. The buffer is implemented as a heap data structure which allows ef- ficient updates since it requires to maintain sorted lists of potential results and, in some cases, item lower-bounds and upper-bounds need to be updated (for example, when the item is encountered again in one of the lists). </span></p><p class="c15"><span class="c0">Stopping Condition: The algorithm has both global threshold computation and buffer management strategies. We now show that the buffer management itself is sufficient to govern early stopping. More importantly, unlike traditional threshold algorithms, GRECA cannot terminate only based on the threshold condition in the cases, where the buffer contains more than k items. </span></p><p class="c15"><span class="c0">&bull; Using the Global Threshold: If the current global threshold is not larger than the lower-bound score of the k-th item in the buffer, GRECA will not find any item later on whose score is larger than the current threshold. On the other hand, if the current threshold is no larger than the lower-bound of the k- th item in the buffer, any unseen item can never be in the top- k itemset. This implies that a subset of the items in the cur- rent buffer is the actual top-k itemset. If the buffer contains k items only, then GRECA can safely terminate and return those items in the buffer as the answer. However, in general, when the buffer has more than k-items, to precisely determine the actual top-k itemset, it needs to apply the buffer management strategy that we describe now. </span></p><p class="c15"><span class="c0">&bull; Using the Buffer: A key novelty of GRECA is in using only the buffer condition for termination. This condition sim- ply implies that just by looking into the items in the buffer, GRECA can terminate, as well as declare the partially ordered correct top-k itemset. The buffer stopping condition works as follows: the buffer contains k</span><span class="c6">0</span><span class="c0">-items (k</span><span class="c6">0 </span><span class="c0">&gt; k) such that the lower-bound of the k-th item score is no smaller than the upper-bound score of each of the remaining k</span><span class="c6">0 </span><span class="c0">k items. In that case, those remaining k</span><span class="c6">0 </span><span class="c0">k items could be safely pruned. Interestingly, satisfying this condition implies satis- fying the threshold condition as well, as Theorem 1 states. The remaining k items are returned as answers. </span></p><p class="c4"><span class="c43">426 </span></p><p class="c15"><span class="c0">&bull; Global Threshold and Buffer Management: Global thresh- old can simply determine that the current buffer contains a subset of items which are the actual top-k itemset. In a gen- eral case, where the buffer has more than k items, GRECA applies the buffer stopping conditions to determine that sub- set. It is still possible that the buffer condition for stopping is not met. In that case, GRECA resumes computation until the buffer condition is satisfied or all lists are exhaustively scanned. </span></p><p class="c4"><span class="c0">Theorem 1. Satisfying the buffer condition for termination im- plies that the global threshold condition for termination is met. </span></p><p class="c15"><span class="c0">P</span><span class="c42">ROOF</span><span class="c0">. (sketch): At a given snapshot during the execution of GRECA, the score returned by ComputeTh({E}) is strictly not greater than the upper-bound score of any item that is already seen and in the buffer, i.e., ComputeUB(i) ComputeTh({E}). Therefore, if the buffer condition is satisfied (meaning that the lower bound of the k-th item score in the buffer is not smaller than the upper-bound score of the remaining k</span><span class="c6">0 </span><span class="c0">k items), this automat- ically implies, that the lower bound of the k-th item score is not smaller than the current global threshold. Hence the proof. </span></p><p class="c4"><span class="c0">For our running example in Section 3.1, this returns i</span><span class="c9">1 </span><span class="c5">as the </span><span class="c0">top-1 item to the group. </span></p><p class="c15"><span class="c0">The pseudocode of GRECA is presented in Algorithm 1. In ad- dition to the group G and k, it takes the preference and affinity lists of G as inputs as well as the consensus function F. Lines 9 14 either add a new item into the buffer B and compute its lower-bound and upper-bound scores, or update the latest lower- bound and upper-bound score of an existing item and reorganize the buffer. Line 16 computes the global threshold condition us- ing the function ComputeTh(); lines 17 19 checks if the thresh- old stopping condition is satisfied. Otherwise, the control goes on to line 21 on wards and CheckBuffer(B) checks whether the stopping condition is met using the buffer. The computation con- tinues unless one of these conditions are satisfied, or all lists are exhaustively scanned. Of course, in the latter case, there is no save- up. However, as our experimental results exhibits, GRECA achieves speed-up, compared to its naive counterpart. </span></p><p class="c4"><span class="c0">L</span><span class="c42">EMMA </span><span class="c0">2. GRECA returns correct top-k itemset. </span></p><p class="c15"><span class="c0">P</span><span class="c42">ROOF</span><span class="c0">. Notice that GRECA returns from the buffer those k- items whose lower-bound scores are the highest and larger than the upper-bound score of any remaining item. As Theorem 1 proves that this also implies that the global threshold at that point cannot be larger than the lower-bound score of the k-th item in the buffer. Notice that the threshold captures the highest score that any unseen item can have. Due to the monotonicity property of the consen- sus function, global threshold decreases gradually, implying that the highest score of any item gets only smaller, as more entries are scanned from the lists. Therefore, when GRECA terminates and out- puts the itemset with the highest top-k lower-bound scores, this im- plies that any other items that are discarded or unseen cannot have higher score than the returned itemset. Hence the proof. However, since the complete score of many of the items may not be computed upon termination, the output may give rise to a partial order among the top-k items. </span></p><p class="c4"><span class="c0">L</span><span class="c42">EMMA </span><span class="c0">3. GRECA is instance optimal. </span></p><p class="c4"><span class="c0">P</span><span class="c42">ROOF</span><span class="c0">. (sketch): In [10], authors prove that NRA is instance optimal with optimality ratio m and no deterministic algorithm can </span></p><p class="c15"><span class="c0">perform any better. GRECA mimics the cursor movement of tra- ditional NRA, however, it has a different stopping condition. The- orems 1 and 2 prove that our stopping condition implies both the threshold stopping condition and result correctness, therefore, the instance optimality of GRECA holds. A detailed proof is deferred to an extended version of the paper. </span></p><p class="c4"><span class="c8">4. EXPERIMENTS </span></p><p class="c15"><span class="c0">We evaluate our group recommendation method from two major angles: effectiveness and efficiency. We conduct an extensive user study on Facebook to demonstrate that group recommendation with the consideration of temporal affinity is superior to solely relying on aggregating individual preferences (Section 4.1). We also run comprehensive experiments to show that GRECA achieves scalable performance when computing temporal affinity-aware recommen- dations for ad-hoc groups (Section 4.2). </span></p><p class="c15"><span class="c0">We implement our prototype system using JDK 1.8.0. All scala- bility experiments are conducted on an 2.4 GHz Intel Core i5 with 8 GB of memory on OS X 10.9.5 operating system. </span></p><p class="c15"><span class="c0">Dataset Description: We use the MovieLens 1M ratings dataset </span><span class="c6">2 </span><span class="c0">for our evaluation. MovieLens is a collaborative rating database where users provide a rating ranging from 1 to 5 for movies (5 being the best). Table 5 contains the statistics of the 1M ratings dataset. </span></p><p class="c4"><span class="c0"># users # movies # ratings 6,040 3,952 1,000,209 </span></p><p class="c4"><span class="c0">Table 5: The MovieLens 1M Dataset </span></p><p class="c15"><span class="c0">Individual User Preferences: We use collaborative filtering [2] to generate individual user preferences where user similarity is com- puted with cosine similarity over vec(u), i.e., the ratings of u for each movie. </span></p><p class="c4"><span class="c0">cos(du, </span><span class="c23">d</span><span class="c0">u</span><span class="c6">0</span><span class="c0">) = </span><span class="c23">du &#8677; d</span><span class="c0">u</span><span class="c6">0 </span></p><p class="c4"><span class="c0">kduk</span><span class="c6">2 </span><span class="c0">&#8677; k</span><span class="c23">d</span><span class="c0">u</span><span class="c6">0</span><span class="c0">k</span><span class="c6">2 </span></p><p class="c4"><span class="c8">4.1 Quality Experiment </span></p><p class="c15"><span class="c0">We exploit the availability of Facebook users for our user study which gives us the opportunity to obtain preferences of real users and leverage the social graph for affinities. Our aim is to com- pare our temporal affinity-aware group recommendation with naive methods without consideration of time or affinity. Our group rec- ommendations are produced and compared using the following con- sensus functions (as discussed in Section 2). </span></p><p class="c15"><span class="c0">&bull; Average Preference (AP), which computes the group prefer- ence for an item as the average of individual group members&rsquo; preferences for that item. </span></p><p class="c15"><span class="c0">&bull; Least-Misery Only (MO), which computes the group pref- erence for an item as the minimum among individual group members&rsquo; preferences for that item. </span></p><p class="c15"><span class="c0">&bull; Pair-wise Disagreement (PD), which computes the group preference for an item as the combination of its average and its pair-wise disagreement between individual group mem- bers&rsquo; preferences. </span></p><p class="c4"><span class="c3">2</span><span class="c17">http://movielens.umn.edu </span></p><p class="c4"><span class="c43">427 </span></p><p class="c29 c31"><span class="c0">For each of these functions, we incorporate time-aware affinity to compute the relative user preference to an item at a given time (see Section 2 for an exact definition of relative preference.) </span></p><p class="c31 c80"><span class="c0">We developed an application using the Facebook API</span><span class="c6">3 </span><span class="c0">and re- cruited 72 Facebook users overall to rate movies from the Movie- Lens 1M dataset. We obtained 1981 ratings. Our Facebook applica- tion asks only for public profiles and friend list access permissions. Also, we anonymize the dataset by mapping Facebook IDs to a ran- dom 5-digit number. The study is conducted in two phases: User Collection Phase and Quality Assessment. </span></p><p class="c26"><span class="c0">Summary of Results: In summary, we observe that including temporal affinity in group recommendation significantly improves user satisfaction. The amount of satisfaction is variable and is de- pendent on how groups are formed. In particular, dissimilar user groups as well as those with low-affinity users whose preference significantly evolves over time, are most satisfied. We found that prior work has indeed shown [20] that reaching consensus among such group members is indeed difficult. In addition, we found that PD, in general, is the method of choice and works best for dissim- ilar and high affinity groups. This observation is also in line with one of our prior results [22] where we showed that including dis- agreement in group consensus generates higher quality recommen- dations. We also observe that incorporating time models produces better results for high affinity groups suggesting that groups with high affinity are most sensitive to temporal affinities. Finally, the continuous time model is preferred by large groups of dissimilar members. That could be explained because it better captures vari- ability for groups whose members are more sensitive to differences between them. The discrete model on the other hand, is a good ap- proximation of the continuous one in the case of high affinity and high similarity groups. </span></p><p class="c81"><span class="c7">4.1.1 User Collection Phase </span></p><p class="c31 c45"><span class="c0">In this phase, the goal is to recruit users and collect their data. Later, collected users are used to form different groups and perform judgments on group recommendations. For this aim, we start with 13 seed users (denoted S). Users in S have to complete two tasks: i. rate at least 30 movies in MovieLens, and ii. invite between 10 and 20 of their friends to participate in the study. The set of friends of a seed user s 2 S is denoted friends(s). Note that we consider [</span><span class="c9">s2S</span><span class="c5">friends(s) \ S = ;. Friends are only asked to rate movies </span><span class="c0">and not invite friends, i.e., we stop at the depth 1 of the social graph for this study. </span></p><p class="c22"><span class="c0">We select a subset of MovieLens movies for participants to pro- vide their preferences. We consider two factors in selecting those movies: familiarity and diversity. On one hand, we want to present users with a set of movies that they do know about and therefore can provide ratings for. On the other hand, we want to maximize our chances of capturing different tastes among movie-goers. To- wards those two goals, we select two sets of movies. The first set is called the popular set, which contains the top-50 movies in Movie- Lens in term of popularity (i.e. the number of users who rated a movie in the set). The second set is called diversity set, which con- tains the 25 movies with the highest variance among their ratings and that are ranked in the top-200 in terms of popularity. Each par- ticipant rates movies in one of two pre-computed sets: the Similar Set which consists entirely of movies within the popular set and the Dissimilar Set which consists of the top-25 movies from the popular set and the 25 movies from the diversity set. </span></p><p class="c19"><span class="c0">Users are instructed to provide a rating between 1 and 5 (5 being </span></p><p class="c87"><span class="c3">3</span><span class="c17">https://developers.facebook.com </span></p><p class="c4 c84"><span class="c0">the best) for at least 30 movies listed in random order, according to their preferences. </span></p><p class="c34"><span class="c7">4.1.2 Static and Dynamic Affinities </span></p><p class="c20"><span class="c0">In addition to ratings, we store anonymized lists of friends and page-likes for each user. Since Facebook friendship is relatively stable over time, we use it to compute static affinity: a</span><span class="c12">ff</span><span class="c3">s</span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">) = 1friends(u) \ friends(u</span><span class="c6">0</span><span class="c0">)1. We normalize all static affinity values in a group by the maximum pair-wise value in the group to obtain a number between 0 and 1. </span></p><p class="c46"><span class="c0">Page likes are dynamic and are used to compute the time-varying component of affinity. To calculate dynamic affinity for each user, we store all pages (s)he has ever liked in Facebook and for each page, we record the timestamp of when the user liked it and the page category (music, movie, etc.). There exist 197 different page categories in Facebook. For privacy reasons, we do not record the name of the liked pages. Thus the periodic affinity between two users u and u</span><span class="c6">0 </span><span class="c0">in time-period p is calculated as: a</span><span class="c12">ff </span><span class="c6">p</span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">,p) = 1page_likes(u, p) \ page_likes(u</span><span class="c6">0</span><span class="c0">,p)1 where page_likes(u, p) is the set of page categories whose pages are liked by u in time-period p. Then we calculate a</span><span class="c12">ff</span><span class="c3">y</span><span class="c0">(u, u</span><span class="c6">0</span><span class="c0">,p) using Equation 1. We also nor- malize dynamic affinity values to be between 0 and 1. We consider 6 different two-month consecutive periods (Section 4.2.1). Note that the average standard deviation over number of common page- likes for all user pairs during 6 periods is 0.42. </span></p><p class="c62"><span class="c7">4.1.3 Group Formation </span></p><p class="c71"><span class="c0">We consider three main factors in forming user groups, i.e., group size, group cohesiveness and affinity strength. Size and cohesive- ness (i.e. how similar are group members in their movie tastes) are akin to prior work [22]. </span></p><p class="c54"><span class="c0">We hypothesize that varying group sizes will influence reach- ing consensus among the members and therefore to which degree members are satisfied with the group recommendation. We choose two group sizes, 3 and 6, representing small and large groups, re- spectively. </span></p><p class="c46"><span class="c0">Similarly, we assume that group cohesiveness is also a significant factor in their satisfaction with group recommendation. As a result, we form two kinds of groups: similar and dissimilar. A similar group is formed by selecting users who i. have watched Similar movies and ii. have the maximum summation of pair-wise simi- larities (between group members based on their provided ratings) among all groups of the same size. A dissimilar group is formed by selecting users who i. have completed the Dissimilar movie set and ii. have the minimum summation of pair-wise similarities among all groups of the same size. </span></p><p class="c46"><span class="c0">Finally, we consider groups with low and high affinity between members. We set affinity to be high if each pair-wise affinity in a group is equal to 0.4 or higher. </span></p><p class="c30"><span class="c7">4.1.4 Quality Assessment </span></p><p class="c20"><span class="c0">In the second phase of the study, users are instructed to de- cide which of the recommended movies they are satisfied with in a group. We form 8 groups out of Facebook users by considering dif- ferent combinations of group size, group cohesiveness and affinity strength. Each user evaluates movies in two phases: Independent and Comparative. </span></p><p class="c78"><span class="c0">Independent Evaluation: In the independent evaluation, a user, who is a member of a group, observes a single recommendation list at each time and is asked to say how satisfied she is with watch- ing those movies with other group members using a scale between 0 and 5 (5 being the best). Figure 1 illustrates the results of this </span></p><p class="c18"><span class="c43">428 </span></p><p class="c4"><span class="c2">(B) (A) Default </span></p><p class="c4"><span class="c2">Affinity-agnostic </span></p><p class="c4"><span class="c25">) %(e cnerefer</span><span class="c1">P</span><span class="c14">75 5025</span><span class="c25">) </span></p><p class="c4"><span class="c25">%(e cnerefer</span><span class="c1">P</span><span class="c14">75 5025</span><span class="c16">00</span><span class="c2">(C) Time-agnostic </span><span class="c16">100 </span></p><p class="c4"><span class="c16">100 </span></p><p class="c21"><span class="c25">) %(e cnerefer</span><span class="c1">P</span><span class="c14">75 5025</span><span class="c16">0</span><span class="c1">Groups Characteristic </span></p><p class="c4"><span class="c1">Groups Characteristic </span></p><p class="c4"><span class="c16">100 </span></p><p class="c4"><span class="c16">Sim Diss Small Large High Aff Low Aff </span></p><p class="c4"><span class="c16">Sim Diss Small Large High Aff Low Aff </span></p><p class="c4"><span class="c16">Sim Diss Small Large High Aff Low Aff </span></p><p class="c4"><span class="c1">Groups Characteristic </span></p><p class="c4"><span class="c2">(D) Continuous Time Model </span></p><p class="c4"><span class="c25">) %(e cnerefer</span><span class="c1">P</span><span class="c14">75 5025</span><span class="c16">0</span><span class="c2">(E) MO Concensus Function </span></p><p class="c4"><span class="c2">(F) PD Consensus Function </span></p><p class="c4"><span class="c16">100 </span></p><p class="c4"><span class="c16">100 </span></p><p class="c4"><span class="c16">100 </span></p><p class="c4"><span class="c25">) %(e cnerefer</span><span class="c1">P</span><span class="c14">75 5025</span><span class="c25">) </span></p><p class="c4"><span class="c25">%(e cnerefer</span><span class="c1">P</span><span class="c14">75 5025</span><span class="c16">Sim Diss Small Large High Aff Low Aff </span></p><p class="c4"><span class="c16">0Sim Diss Small Large High Aff Low Aff </span></p><p class="c4"><span class="c16">0Sim Diss Small Large High Aff Low Aff </span></p><p class="c4"><span class="c1">Groups Characteristic </span></p><p class="c4"><span class="c1">Groups Characteristic </span></p><p class="c4"><span class="c1">Groups Characteristic </span></p><p class="c4"><span class="c0">Figure 1: Independent Evaluation </span></p><p class="c15"><span class="c0">evaluation phase. The score is reported as a percentage, i.e., a re- sult with an average score of 5 gets 100%. Four parameters play a role in generating different recommendation lists in Figure 1, i.e., affinity awareness, time model (discrete vs. continuous), temporal awareness and consensus function. Figure 1. A illustrates results with default values, i.e., affinity-aware, discrete, time-aware and AP consensus function. In all other figures, only one parameter value changes, i.e., affinity-agnostic in B, time-agnostic in C, con- tinuous time model in D, MO function in E and finally PD func- tion in F. That parameter is mentioned in the title of each chart in Figure 1. </span></p><p class="c15"><span class="c0">We observe that in general, participants give a score of at least 80% to A, which is the default case with discrete temporal affin- ity. Participants in dissimilar groups have scored A with 90.66% preference while it is 10% lower for similar groups. This could be interpreted as: averaging individual ratings and using a discrete time model works well for groups formed by users who like dif- ferent movies. Interestingly, the same result holds for low affinity and high affinity groups. This potentially shows that our model is robust to time-varying tastes. On the other hand, the low preference of high affinity groups show that members of those groups benefit from another consensus function, i.e., PD (chart F). </span></p><p class="c15"><span class="c0">Lists without affinity (chart B) and time awareness (chart C) have at most 55% and 60% overall preference respectively. This margin of 20% difference in preference with the temporal affin- ity case (chart A) shows explicitly the importance of affinity and temporal affinity in group recommendation. In B, worst results are obtained for small (30.08%), high affinity (36.66%) and similar groups (40%) where we observe a decrease in satisfaction. This potentially shows those are the groups that would best benefit from using affinity in computing their recommendations. In C the worst results are for dissimilar and large groups (both 50.19%). One ex- planation is that dissimilar large groups, i.e., those who differ in their movie tastes among many members, prefer temporal recom- mendations, i.e., movies that are generated by taking into account their friendship and page-like differences over time. </span></p><p class="c15"><span class="c0">Groups with different tastes (dissimilar, large and low affinity) prefer the continuous time model (chart D). This is potentially be- cause of a higher precision in capturing time. Considering the time as a whole from the beginning of time is needed to deliver recom- </span></p><p class="c15"><span class="c0">mendations that satisfy all members of those heterogeneous groups. In case of MO (chart E), we observe a superior satisfaction for dis- similar and low affinity groups as increase in uncertainty in large groups leads members to like MO better. </span></p><p class="c15"><span class="c0">Comparative Evaluation: In the comparative evaluation, users are asked to compare two lists l</span><span class="c3">1 </span><span class="c0">and l</span><span class="c3">2 </span><span class="c0">at a time and pick the list they prefer. Following the closed world assumption, when a list is not chosen by a user, it means that it is not preferred. A user has to choose one and only one of the proposed lists. Figure 3 illustrates the preferences of l</span><span class="c9">1 </span><span class="c5">over l</span><span class="c9">2</span><span class="c5">. </span></p><p class="c15"><span class="c0">First, a user is asked to compare affinity-aware (l</span><span class="c3">1</span><span class="c0">) vs. affinity- agnostic (l</span><span class="c9">2</span><span class="c5">) recommendations. In A, we observe that in general, </span><span class="c0">in 75% of the cases, affinity-aware recommendations are preferred. They are mostly appreciated by small groups followed by high affinity groups. Larger groups have less preference for affinity- aware results. A large group potentially leads to higher variability of preference and weaker affinity among its members, thus natu- rally prohibiting an early agreement. </span></p><p class="c21"><span class="c0">In the second comparative study, we examine the effect of tem- poral affinity by comparing time-aware (l</span><span class="c3">1</span><span class="c0">) vs. time-agnostic (l</span><span class="c3">2</span><span class="c0">) recommendations. In B, we observe that in most groups, tempo- ral recommendations are preferred in over 80% of the cases. This leaves no doubt that participants like better results obtained based on time. It also shows that high affinity groups prefer not only affinity-based results, but also its temporal version. Small groups have also exhibited a high preference. This is because in groups with fewer members or groups whose participants deeply know each other, the effect of time manifests itself more strongly. Fi- nally, high preference for large groups show that the temporal di- mension of affinity is a useful component for such groups to obtain higher quality results, because group members potentially observe that their common affinity history plays a role in recommendations. We now examine which of the discrete or the continuous tempo- ral affinity models is better and in which case. In C, we observe that in general, the discrete time model is preferred for groups with strong connections between members (high affinity and high simi- larity). In the case of dissimilar and large groups, it is the contin- uous model that is preferred. The continuous nature of the latter is certainly better to capture variability for groups whose members </span></p><p class="c4"><span class="c43">429 </span></p><p class="c15"><span class="c0">are more sensitive to differences between them while the discrete one is a good approximation of the continuous model in the case of high affinity and high similarity groups. </span></p><p class="c21"><span class="c0">Finally, we compare different group consensus functions. This time, we compare 3 different lists together which are results of AP, MO and PD consensus functions. We are interested to discover which function delivers more satisfactory results when we account for temporal affinities. Figure 2 illustrates this comparison. In short, while the choice of which consensus function to apply heav- ily depends on group characteristics, there exists a general prefer- ence for PD especially in the case of loosely connected groups (low affinity and dissimilar groups). That could be explained by the fact that PD favors items that minimize disagreement between group members which is more appropriate for dissimilar group members. In summary, it is shown that AP is highly preferred in small and high affinity groups. Whenever AP has a high preference, PD is also highly preferred. MO provides higher quality results for larger groups (this is consistent with our findings in [22]) and for groups with loose connections. </span></p><p class="c4"><span class="c55">60 </span></p><p class="c4"><span class="c91">) %(e cnerefer</span><span class="c59">P</span><span class="c55">453015</span><span class="c68">0</span><span class="c59">Groups Characteristic </span></p><p class="c4"><span class="c68">PD </span></p><p class="c4"><span class="c68">Sim Diss Small Large High Aff Low Aff </span></p><p class="c4"><span class="c0">Figure 2: Qualitative Evaluation of Consensus Functions </span></p><p class="c4"><span class="c8">4.2 Scalability Experiment </span></p><p class="c15"><span class="c0">Experiment Settings: Unless otherwise stated, we form 20 dif- ferent random groups by selecting a subset of users who partici- pated in our quality experiment. The default settings of the rest of the parameters are, group size = 6, k = 10, number of items = 3900, consensus function = AP. Unless otherwise stated, affinity is computed using the discrete time model. For each scalability experiment, we compute the average percentage of SAs needed by GRECA in different settings. The percentage of SAs represents the computational cost that GRECA incurs, compared to a naive algo- rithm which entirely scans all lists. A smaller percentage exhibits higher scalability. </span></p><p class="c15"><span class="c0">We conduct experiments by varying time periods, result size (k), group size, number of input items, similarity and dissimilarity among items and users in the group, and considering the discrete and continuous affinity models. Our results illustrate the scalabil- ity of GRECA with different group consensus functions. We only present a subset of these results. The omitted results are similar to the ones presented. All results are presented with standard error bars, wherever applicable. </span></p><p class="c4"><span class="c0">Summary of Results: First and foremost, we observe that GRECA is highly scalable with varying k, group size, number of items and enables a significant saveup in the number of accesses (almost al- ways, more than 75% accesses are avoided) with early termination. Then, we observe that the pruning ability is highest for similar user groups. We observe that the score distribution of top-k itemsets for such groups is different from the rest of items, therefore, the stopping condition in the buffer is satisfied early. Third, we ob- serve that GRECA is effective across all group consensus functions. In fact, for some of the complex group consensus functions that </span></p><p class="c4"><span class="c68">AP </span></p><p class="c4"><span class="c68">MO </span></p><p class="c4"><span class="c0">Figure 6: Average Percentage of SAs for Different Periods in Discrete Time Model </span></p><p class="c4"><span class="c7">4.2.2 Varying </span><span class="c0">k</span><span class="c7">, Group Size and Number of Items </span></p><p class="c15"><span class="c0">In Figure 5, we illustrate the scalability of GRECA by varying result size, group size and number of items. In A, we vary k from 5 to 30 and run GRECA with the AP consensus function for 20 different groups with 6 members. We observe that GRECA scales linearly with varying k. The algorithm always produces a saveup of 81% or higher. </span></p><p class="c4"><span class="c43">430 </span></p><p class="c15"><span class="c0">consider user disagreement, GRECA incurs the smallest percent- age of accesses ensuring the highest saveup in computation cost. Fourth, GRECA scales linearly with an increasing number of peri- ods. Finally, we observe that GRECA is effective both for discrete and continuous models. </span></p><p class="c4"><span class="c7">4.2.1 Varying Time Period </span></p><p class="c15"><span class="c0">We explore discretizing time into periods of different lengths: week, month, two-month, season and half-year. Since dynamic affinity relies on user page-likes in Facebook and liking a page is not a frequent action, many time segments were empty after dis- cretization (Figure 4). The length of a time period should be cho- sen in such a way that each period contains enough data to compute affinities. Figure 4 shows that two-month periods achieve a good balance between the percentage of non-emptiness (65%) and the number of periods (6). We hence pick a two-month discretization for the rest of our experiments. </span></p><p class="c4"><span class="c25">) %(s doirePy tpme-noNf o</span><span class="c1"># </span><span class="c16">0.00 </span></p><p class="c4"><span class="c16">Non-empty Periods (%) # of Periods </span></p><p class="c4"><span class="c14">60 </span></p><p class="c4"><span class="c14">453015</span><span class="c25">s doirePf o</span><span class="c1"># </span><span class="c16">0</span><span class="c0">Figure 4: Different Time Periods </span></p><p class="c15"><span class="c0">Figure 6 illustrates the average number of accesses in each pe- riod. As expected, this figure shows a linear behavior in general, as going to subsequent periods increases the number of lists. An exception happens in period 5 where its average #SA is very close to its next period. By looking more carefully at the underlying data distribution, we noticed that the number of common page-likes be- tween user pairs in period 5 is very low. Therefore, scanning this period does not help to update bounds in order to have early termi- nation. </span></p><p class="c4"><span class="c16">100.00 </span></p><p class="c4"><span class="c16">75.00 </span></p><p class="c4"><span class="c16">50.00 </span></p><p class="c4"><span class="c16">25.00 </span></p><p class="c4"><span class="c16">Week Month Two-Month Season Half-Year </span></p><p class="c4"><span class="c1">Time Periods </span></p><p class="c4"><span class="c2">(C) (A) Affinity-aware vs. </span></p><p class="c4"><span class="c2">(B) Time-aware vs. Time-agnostic </span></p><p class="c4"><span class="c2">Continuous vs. Discrete Affinity-agnostic </span></p><p class="c4"><span class="c2">Time Model </span></p><p class="c4"><span class="c25">) %(e cnerefer</span><span class="c1">P</span><span class="c25">) </span></p><p class="c4"><span class="c25">%(e cnerefer</span><span class="c1">P</span><span class="c16">100 100 </span></p><p class="c4"><span class="c16">100 </span></p><p class="c4"><span class="c14">75 502575 </span></p><p class="c4"><span class="c14">5025</span><span class="c25">) </span></p><p class="c48"><span class="c25">%(e cnerefer</span><span class="c1">P</span><span class="c14">75 5025</span><span class="c16">000Sim Diss Small Large High Aff Low Aff </span></p><p class="c4"><span class="c1">Groups Characteristic </span></p><p class="c4"><span class="c1">Groups Characteristic </span></p><p class="c4"><span class="c1">Groups Characteristic </span></p><p class="c4"><span class="c0">Figure 3: Comparative Evaluation </span></p><p class="c4"><span class="c2">(A) Varying K </span></p><p class="c4"><span class="c25">% A S#e garev</span><span class="c1">A</span><span class="c16">9 </span></p><p class="c4"><span class="c16">Sim Diss Small Large High Aff Low Aff </span></p><p class="c4"><span class="c16">Sim Diss Small Large High Aff Low Aff </span></p><p class="c4"><span class="c2">(B) Varying Group Size </span></p><p class="c4"><span class="c25">% A S#e garev</span><span class="c1">A</span><span class="c16">0 </span></p><p class="c4"><span class="c2">(C) Varying Number of Items </span></p><p class="c4"><span class="c14">19 </span></p><p class="c4"><span class="c14">50 </span></p><p class="c4"><span class="c14">20 </span></p><p class="c48"><span class="c16">16.537.5</span><span class="c25">% A S#e garev</span><span class="c1">A</span><span class="c14">1514 25 10</span><span class="c16">11.512.5</span><span class="c14">5</span><span class="c16">5 10 15 20 25 30 </span></p><p class="c4"><span class="c16">3 6 9 12 </span></p><p class="c4"><span class="c16">0900 1400 1900 2400 2900 3400 3900 </span><span class="c1">k </span></p><p class="c4"><span class="c1">Group Size </span></p><p class="c4"><span class="c1"># of Items </span></p><p class="c4"><span class="c0">Figure 5: Average Percentage of SAs by Varying Result Size, Group Size and Number of Items </span></p><p class="c21"><span class="c0">In B, we examine the effect of different group sizes on perfor- mance. The results clearly demonstrate that GRECA scales well with varying group sizes. The average saveup is greater than 77%. In C, we vary the number of available items for group recom- mendation from 900 to 3900. The results demonstrate that the number of accesses does not necessarily increase with that. This observation is unsurprising as the number of accesses depends on the score distribution of the item preferences and user affinities. GRECA saves more than 83% accesses even in the worst case. </span></p><p class="c4"><span class="c25">% A S#e garev</span><span class="c1">A</span><span class="c16">0.00 </span></p><p class="c15"><span class="c0">cases, we obtain a saveup greater than 83%. The number of ac- cesses for both methods are very similar with a slight superiority for the discrete model. </span></p><p class="c4"><span class="c7">4.2.5 Consensus Functions </span></p><p class="c21"><span class="c0">In this last performance study, we compare different consensus functions. Figure 8 contains the results. We introduce two different versions of PD based on [22] by varying the weights used in the lin- ear combination of rating aggregation (w</span><span class="c9">1</span><span class="c5">) and disagreement (w</span><span class="c9">2</span><span class="c5">) </span><span class="c0">s.t. w</span><span class="c3">1 </span><span class="c0">+ w</span><span class="c3">2 </span><span class="c0">= 1. In PD V1, we consider w</span><span class="c3">1 </span><span class="c0">= 0.8 and in PD V2, </span><span class="c16">26.00 </span></p><p class="c4"><span class="c0">w</span><span class="c9">1 </span><span class="c5">= 0.2. </span></p><p class="c4"><span class="c16">19.50 </span></p><p class="c4"><span class="c14">18 </span></p><p class="c4"><span class="c16">13.00 </span></p><p class="c4"><span class="c16">6.50 </span></p><p class="c21"><span class="c25">% A S#e garev</span><span class="c1">A</span><span class="c14">149</span><span class="c16">Sim Diss High Aff Low Aff </span><span class="c14">5</span><span class="c1">Groups Characteristic </span></p><p class="c4"><span class="c16">0</span><span class="c0">Figure 7: Average Percentage of SAs for Similar, Dissimilar, </span></p><p class="c4"><span class="c1">Consensus Function </span><span class="c0">High Affinity and Low Affinity Groups </span></p><p class="c4"><span class="c7">4.2.3 Similarity/Dissimilarity </span></p><p class="c15"><span class="c0">We examine the effect of similarity on GRECA in two ways: first, we compare the number of accesses between groups with similar and dissimilar ratings; then, we compare groups with high and low affinities. Figure 7 contains the result. The results demonstrate that the effectiveness is higher for similar groups in both cases (item based similarity and high affinity). </span></p><p class="c4"><span class="c7">4.2.4 Time Models </span></p><p class="c15"><span class="c0">We examine the effect of continuous and discrete time models on GRECA. The average number of SAs for the continuous model is 16.32% and 16.6% for the discrete one. This means that in both </span></p><p class="c4"><span class="c16">AR MO PD V1 PD V2 </span></p><p class="c4"><span class="c0">Figure 8: Average Percentage of SAs for Different Consensus Functions </span></p><p class="c15"><span class="c0">All results clearly demonstrate that GRECA achieves significant saveups for those consensus functions. They also show that PD V2 outperforms PD V1. During our post-analysis, we observed that a higher weight on disagreement allows faster stopping, because the items have smaller scores. MO is the next best performer achieving as high as 83% in accesses&rsquo; saveups. </span></p><p class="c4"><span class="c8">5. RELATED WORK </span></p><p class="c4"><span class="c0">Group recommendation has been designed for various domains such as news pages [21], tourism [11] and music [7]. A group may </span></p><p class="c4"><span class="c43">431 </span></p><p class="c49"><span class="c0">be formed at any time by a random set of users with different in- terests, a number of persons who explicitly choose to be part of a group, or by computing similarities between users with respect to some similarity functions and then clustering similar users to- gether [19, 3]. </span></p><p class="c22"><span class="c0">There are two dominant strategies for group recommendations [4, 3]. The first approach creates a pseudo-user representing the group and then makes recommendations to that pseudo-user, while the second strategy computes a recommendation list for each group member and then combines them to produce a group&rsquo;s list. For the latter, a widely adopted approach is to apply an aggregation function to obtain a consensus group preference for a candidate item. However, to the best of our knowledge, none of the existing functions account for the influence between group members [24]. </span></p><p class="c56 c31"><span class="c0">Affinities may be strong emotional bonds, like links between family members or a clique of close friends. Those links may also be relatively weak thereby breaking with the passage of time or the occurrence of relationship-damaging events. In [16], an affinity model is proposed for group recommendation based on NEO-FFI </span><span class="c6">4 </span><span class="c0">personality test. Another model is proposed in [12] where 3 differ- ent components (social relationship, expertise and disagreement) are aggregated to form affinity. A possible extension of our work could make use of that affinity definition. </span></p><p class="c22"><span class="c0">On e-commerce platforms, recent studies have proved the im- portance of time in recommender systems. In [8], Yi Ding et al. assign different weights to different rating records based on their creation time, and reveal the existence of a dynamic change in user interests. Liang Xiong et al. [25] improved the accuracy of recom- mendations by incorporating the global evolution pattern of user preferences. Potentially the most similar contributions to ours on time models are [17, 15] where Yehuda Koren et al. take temporal dynamics of user and item biases into consideration for individual recommendations. To the best of our knowledge, no previous work has studied a time model for group recommendations. </span></p><p class="c22"><span class="c0">Threshold algorithms [9] have been used extensively for recom- mendation. Their attractiveness lies in monotonic score aggrega- tion functions, which operate on sorted input and enable the early pruning of low-ranked answers. In this work, we adapt NRA to ag- gregate individual preferences, disagreement and temporal affinity lists to compute temporal recommendations and propose a novel stopping condition and prove correctness and instance optimality. </span></p><p class="c72"><span class="c8">6. CONCLUSION </span></p><p class="c24"><span class="c0">We examined affinity-aware group recommendation over time and developed GRECA, an efficient algorithm with unique features that distinguish it from state-of-the-art recommendation algorithms. Our proposed semantics is compatible with popular group consen- sus functions. Our extensive experiments with real Facebook users and Movielens datasets assess the high quality of temporal affinity- aware recommendations for groups with different characteristics (small/large groups, similar/dissimilar groups, high and low affin- ity groups). In the future we would like to study the maintenance of our index structures over time in relationship with how often affin- ity between users changes. In particular, we are examining how to combine incremental clustering with our indices in order to deter- mine the minimum amount of information to store that guarantees instance optimality. Moreover, we plan to extend our performance studies to larger groups with thousands of users. </span></p><p class="c90"><span class="c3">4</span><span class="c5">Neuroticism Extroversion Openness Five Factor Inventory </span></p><p class="c4 c63"><span class="c8">References </span></p><p class="c51"><span class="c27">[1] G. Adomavicius, R. Sankaranarayanan, S. Sen, and A. Tuzhilin. In- corporating contextual information in recommender systems using a multidimensional approach. ACM Trans. Inf. Syst., Jan. 2005. [2] G. Adomavicius and A. Tuzhilin. Toward the next generation of rec- ommender systems: A survey of the state-of-the-art and possible ex- tensions. TKDE, 17(6):734&ndash;749, June 2005. [3] S. Amer-Yahia, S. B. Roy, A. Chawla, G. Das, and C. Yu. Group recommendation: Semantics and efficiency. PVLDB, 2(1):754&ndash;765, 2009. [4] S. Berkovsky and J. Freyne. Group-based recipe recommendations: analysis of data aggregation strategies. In RecSys, pages 111&ndash;118, 2010. [5] J. R. Bettman, E. J. Johnson, and J. W. Payne. Consumer decision </span></p><p class="c65"><span class="c27">making. Handbook of consumer behavior, 44(2):50&ndash;84, 1991. [6] L. Boratto, S. Carta, A. Chessa, M. Agelli, and M. L. Clemente. Group recommendation with automatic identification of users communities. In Web Intelligence/IAT Workshops, pages 547&ndash;550, 2009. [7] A. Crossen, J. Budzik, and K. J. Hammond. Flytrap: intelligent group </span></p><p class="c89"><span class="c27">music recommendation. In IUI, pages 184&ndash;185, 2002. [8] Y. Ding and X. Li. Time weight collaborative filtering. In CIKM, </span></p><p class="c44"><span class="c27">pages 485&ndash;492. ACM, 2005. [9] R. Fagin. Combining fuzzy information: an overview. SIGMOD </span></p><p class="c52"><span class="c27">Record, 31(2):109&ndash;118, 2002. [10] R. Fagin, A. Lotem, and M. Naor. Optimal aggregation algorithms for </span></p><p class="c38"><span class="c27">middleware. In P. Buneman, editor, PODS. ACM, 2001. [11] I. Garcia, L. Sebastia, and E. Onaindia. On the design of individ- ual and group recommender systems for tourism. Expert Syst. Appl., 38(6):7683&ndash;7692, 2011. [12] M. Gartrell, X. Xing, Q. Lv, A. Beach, R. Han, S. Mishra, and K. Seada. Enhancing group recommendation by incorporating social relationship interactions. In GROUP, pages 97&ndash;106. ACM, 2010. [13] A. Jameson and B. Smyth. Recommendation to groups. In The adap- </span></p><p class="c52"><span class="c27">tive web, pages 596&ndash;627. Springer, 2007. [14] N. M. Klein and M. Yadav. Context effects on effort and accuracy in choice: An inquiry into adaptive decision making. Journal of Con- sumer Research, 16:410&ndash;420, 1989. [15] N. Koenigstein, G. Dror, and Y. Koren. Yahoo! music recommen- dations: modeling music ratings with temporal dynamics and item taxonomy. In RecSys, pages 165&ndash;172, 2011. [16] M. Kompan and M. Bielikov&aacute;. Social structure and personality en- hanced group recommendation. In EMPIRE 2014, Aalborg, Denmark, pages 1613&ndash;0073, 2014. [17] Y. Koren. Collaborative filtering with temporal dynamics. Commun. </span></p><p class="c52"><span class="c27">ACM, 53(4):89&ndash;97, 2010. [18] D. A. Lussier and R. W. Olshavsky. Task complexity and contingent processing in brand choice. Journal of Consumer Research, 6:154&ndash; 165, 1979. [19] E. Ntoutsi, K. Stefanidis, K. N&oslash;rv&aring;g, and H.-P. Kriegel. Fast group recommendations by applying user clustering. In ER, pages 126&ndash;140, 2012. [20] M. O&rsquo;Connor, D. Cosley, J. A. Konstan, and J. Riedl. Polylens: a </span></p><p class="c38"><span class="c27">recommender system for groups of users. In ECSCW, 2001. [21] S. Pizzutilo, B. De Carolis, G. Cozzolongo, and F. Ambruoso. Group modeling in a public space: Methods, techniques, experiences. AIC&rsquo;05. WSEAS, 2005. [22] S. B. Roy, S. Amer-Yahia, A. Chawla, G. Das, and C. Yu. Space efficiency in group recommendation. VLDB J., 19(6):877&ndash;900, 2010. [23] S. B. Roy, S. Thirumuruganathan, S. Amer-Yahia, G. Das, and C. Yu. Exploiting group recommendation functions for flexible preferences. In ICDE Conference, 2014. [24] N. Shabib, J. A. Gulla, and J. Krogstie. On the intrinsic challenges of </span></p><p class="c52"><span class="c27">group recommendation. In RSWeb@RecSys, 2013. [25] L. Xiong, X. Chen, T.-K. Huang, J. G. Schneider, and J. G. Carbonell. Temporal collaborative filtering with bayesian probabilistic tensor fac- torization. In SDM, pages 211&ndash;222. SIAM, 2010. </span></p><p class="c40"><span class="c43">432 </span></p></body></html>