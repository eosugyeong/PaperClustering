<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Arial";font-style:normal}.c15{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.2pt;font-family:"Arial";font-style:normal}.c9{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:16.6pt;font-family:"Arial";font-style:normal}.c47{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.3pt;font-family:"Courier New";font-style:normal}.c70{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.8pt;font-family:"Courier New";font-style:normal}.c73{margin-left:-9.2pt;padding-top:1.9pt;text-indent:18.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.1pt}.c14{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:7.5pt;font-family:"Arial";font-style:normal}.c28{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Courier New";font-style:normal}.c48{margin-left:-18.2pt;padding-top:4.1pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-10.6pt}.c24{margin-left:-9.2pt;padding-top:11.8pt;text-indent:18.1pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.1pt}.c38{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:17.9pt;font-family:"Arial";font-style:normal}.c53{margin-left:-18.2pt;padding-top:3.8pt;text-indent:28.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-10.9pt}.c16{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c69{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:5.8pt;font-family:"Courier New";font-style:normal}.c40{color:#231f20;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:3.7pt;font-family:"Arial";font-style:normal}.c19{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10pt;font-family:"Arial";font-style:normal}.c67{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:13.3pt;font-family:"Arial";font-style:normal}.c41{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.5pt;font-family:"Arial";font-style:normal}.c32{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.3pt;font-family:"Courier New";font-style:normal}.c50{margin-left:-18.2pt;padding-top:1.9pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-7pt}.c56{margin-left:-18.2pt;padding-top:1.2pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-7pt}.c78{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:11.7pt;font-family:"Arial";font-style:normal}.c10{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:7.2pt;font-family:"Arial";font-style:normal}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Courier New";font-style:normal}.c11{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:13.3pt;font-family:"Arial";font-style:normal}.c58{margin-left:-9.2pt;padding-top:2.2pt;text-indent:18.1pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.1pt}.c42{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:7.5pt;font-family:"Courier New";font-style:normal}.c29{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Arial";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Arial";font-style:normal}.c87{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:18.3pt;font-family:"Arial";font-style:normal}.c18{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10pt;font-family:"Arial";font-style:normal}.c86{color:#363639;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11.9pt;font-family:"Arial";font-style:normal}.c62{color:#363639;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.2pt;font-family:"Arial";font-style:normal}.c35{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:5.7pt;font-family:"Arial";font-style:normal}.c31{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:13.3pt;font-family:"Courier New";font-style:normal}.c79{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:5.8pt;font-family:"Arial";font-style:normal}.c66{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10.8pt;font-family:"Arial";font-style:normal}.c23{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:6pt;font-family:"Arial";font-style:normal}.c65{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:3.3pt;font-family:"Arial";font-style:normal}.c77{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:7.6pt;font-family:"Arial";font-style:normal}.c7{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.3pt;font-family:"Courier New";font-style:normal}.c21{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Arial";font-style:normal}.c27{color:#231f20;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:3.2pt;font-family:"Arial";font-style:normal}.c12{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.5pt;font-family:"Arial";font-style:normal}.c34{color:#231f20;font-weight:400;text-decoration:none;vertical-align:sub;font-size:5.4pt;font-family:"Arial";font-style:normal}.c64{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7pt;font-family:"Courier New";font-style:normal}.c57{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:7pt;font-family:"Arial";font-style:normal}.c55{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:7.2pt;font-family:"Arial";font-style:normal}.c46{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.9pt;font-family:"Arial";font-style:normal}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Arial";font-style:normal}.c17{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:6pt;font-family:"Arial";font-style:normal}.c82{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12pt;font-family:"Arial";font-style:normal}.c33{color:#231f20;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:3.5pt;font-family:"Arial";font-style:normal}.c30{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.5pt;font-family:"Courier New";font-style:normal}.c72{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.2pt;font-family:"Arial";font-style:normal}.c20{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.2pt;font-family:"Arial";font-style:normal}.c25{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.3pt;font-family:"Arial";font-style:normal}.c60{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.2pt;font-family:"Arial";font-style:normal}.c54{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:19.9pt;font-family:"Arial";font-style:normal}.c22{color:#231f20;font-weight:400;text-decoration:none;vertical-align:sub;font-size:5.8pt;font-family:"Arial";font-style:normal}.c61{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:7.6pt;font-family:"Arial";font-style:normal}.c51{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Times New Roman";font-style:normal}.c8{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:7.5pt;font-family:"Arial";font-style:normal}.c13{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7pt;font-family:"Arial";font-style:normal}.c49{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:3.6pt;font-family:"Arial";font-style:normal}.c52{margin-left:-18.2pt;padding-top:36.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-7pt}.c83{margin-left:227.3pt;padding-top:34.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-26.7pt}.c85{margin-left:56.1pt;padding-top:63.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:49.4pt}.c68{margin-left:-18.2pt;padding-top:10.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-13pt}.c74{margin-left:-18.2pt;padding-top:13.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-7pt}.c84{margin-left:227.3pt;padding-top:36.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-26.7pt}.c36{margin-left:-9.2pt;padding-top:10.3pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-16.1pt}.c80{margin-left:-9.2pt;padding-top:0.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:146.9pt}.c75{margin-left:21.6pt;padding-top:31.7pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:24pt}.c43{margin-left:-18.2pt;padding-top:10.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-7.8pt}.c76{margin-left:4.2pt;padding-top:2.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.1pt}.c39{margin-left:-9.2pt;padding-top:7.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.1pt}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c26{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c44{padding-top:5pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c63{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c37{margin-left:-18.2pt;text-indent:28.6pt;margin-right:-7pt}.c59{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c81{margin-left:-9.2pt;text-indent:18.1pt;margin-right:-16.1pt}.c45{margin-left:36pt;margin-right:38.2pt}.c71{margin-left:-9.2pt;margin-right:52.6pt}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:24pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:14pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c59"><p class="c3 c45"><span class="c38">Local Search of Communities in Large Graphs </span></p><p class="c75"><span class="c18">Wanyun Cui</span><span class="c19">&sect; </span><span class="c18">Yanghua Xiao</span><span class="c19">&sect;</span><span class="c29">&lowast; </span><span class="c18">Haixun Wang</span><span class="c19">&Dagger; </span><span class="c29">&dagger; </span><span class="c18">Wei Wang</span><span class="c19">&sect; </span><span class="c2">&sect;</span><span class="c9">Shanghai Key Laboratory of Data Science, Fudan University, Shanghai, China </span><span class="c2">&Dagger;</span><span class="c9">Microsoft Research Asia, Beijing, China wanyuncui1@gmail.com, shawyh@fudan.edu.cn, haixun@gmail.com, weiwang1@fudan.edu.cn </span></p><p class="c52"><span class="c18">ABSTRACT </span><span class="c5">Community search is important in social network analysis. For a </span><span class="c0">given vertex in a graph, the goal is to find the best community the </span><span class="c5">vertex belongs to. Intuitively, the best community for a given vertex should be in the vicinity of the vertex. However, existing solutions </span><span class="c0">use global search to find the best community. These algorithms, al- </span><span class="c5">though straight-forward, are very costly, as all vertices in the graph may need to be visited. In this paper, we propose a local search </span><span class="c0">strategy, which searches in the neighborhood of a vertex to find the </span><span class="c5">best community for the vertex. We show that, because the mini- mum degree measure used to evaluate the goodness of a commu- </span><span class="c0">nity is not monotonic, designing efficient local search solutions is a </span><span class="c5">very challenging task. We present theories and algorithms of local search to address this challenge. The efficiency of our local search </span><span class="c0">strategy is verified by extensive experiments on both synthetic net- </span><span class="c5">works and a variety of real networks with millions of nodes. </span></p><p class="c68"><span class="c18">Categories and Subject Descriptors </span><span class="c5">H.2.8 [Database Management]: Database Applications&mdash;Data min- ing</span><span class="c54">Keywords </span><span class="c5">Community search; Social networks; Graph mining </span></p><p class="c43"><span class="c18">1. INTRODUCTION </span><span class="c5">Most real-life complex networks, including the Internet, social </span><span class="c0">networks, and biological neural networks, contain community struc- </span><span class="c5">tures. That is, the networks can be partitioned into groups within which connections are dense and between which connections are </span><span class="c0">sparse [1]. Finding communities in real networks is an impor- </span><span class="c5">tant analytical task, because community structures are imbued with meaning &ndash; that is, they are highly correlated with the functionality </span><span class="c0">of the network. For example, on the World Wide Web, communi- </span><span class="c5">ties consist of web sites that share common topics [2]. In protein- protein interaction networks [3] and metabolic networks [4], com- </span><span class="c0">munity structures correspond to functionality modules. </span><span class="c5">&lowast;</span><span class="c11">Correspondence author. This work was supported by the National NSFC (No. 61003001, 61170006, 61171132, 61033010); NSF of Jiangsu Province (No. BK2010280). &dagger;Current affiliation: Google Research, Mountain View, CA. </span></p><p class="c74"><span class="c13">Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full cita- tion on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or re- publish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. SIGMOD&rsquo;14, June 22&ndash;27, 2014, Snowbird, UT, USA. Copyright 2014 ACM 978-1-4503-2376-5/14/06 ...$15.00. http://dx.doi.org/10.1145/2588555.2612179 . </span></p><p class="c1 c81"><span class="c5">Due to the significance of community structures, the problem of community search, that is, finding the most likely community that a vertex belongs to, is important to many real life networks and </span><span class="c0">applications [5]. Typical applications include: </span></p><p class="c76"><span class="c5">&bull; Friend recommendation on Facebook. Given the friendship network, the system wants to suggest candidate friends to a specific user u. Intuitively, we will only recommend to u </span><span class="c0">those who are in the same community as u are but are not yet </span><span class="c5">u&rsquo;s friends. </span></p><p class="c76"><span class="c5">&bull; Advertising on social networks. People in the same commu- nity often share common interests. If we know a user is in- </span><span class="c0">terested in a particular type of advertisements, we may push </span><span class="c5">the same type of advertisements to other people in his or her community. </span></p><p class="c76"><span class="c5">&bull; Infectious disease control. If a person has come into contact </span><span class="c0">with a highly infectious disease, then who will most likely be </span><span class="c5">affected? Obviously, we may want to monitor people in his or her community. </span></p><p class="c76"><span class="c5">&bull; Semantic expansion. In information retrieval, when a user </span><span class="c0">submits a keyword query, say, &ldquo;image,&rdquo; he may also be inter- </span><span class="c5">ested in results related to other keywords such as &ldquo;pictures,&rdquo; &ldquo;photo,&rdquo; and so on. If a semantic link network [6] over key- </span><span class="c0">words is available, then we can expand the query by includ- </span><span class="c5">ing keywords in the same &ldquo;semantic community.&rdquo; </span></p><p class="c85"><span class="c5">Figure 1: An example graph </span></p><p class="c24"><span class="c5">To effectively perform community search, we must first deter- mine what a good community is. The goodness of a community is measured by the closeness of the vertices in the community. One </span><span class="c0">widely used closeness measure is a community&rsquo;s minimum degree, </span><span class="c5">that is, the minimum degree of all the vertices in the subgraph in- duced by the community. A good community is one that has a large </span><span class="c0">minimum degree. We illustrate this in Example 1. </span></p><p class="c36"><span class="c5">E</span><span class="c20">XAMPLE </span><span class="c5">1 (M</span><span class="c20">INIMUM DEGREE</span><span class="c5">). Suppose we want to find the best community that contains vertex a in Figure 1. Intuitively, V</span><span class="c2">1 </span><span class="c0">with </span><span class="c5">of 3. = </span><span class="c0">a. </span><span class="c5">If {a, we </span><span class="c0">In </span><span class="c5">include </span><span class="c0">fact, </span><span class="c5">b, c, d, </span><span class="c0">the </span><span class="c5">e} one </span><span class="c0">subgraph </span><span class="c5">forms more a vertex </span><span class="c0">induced </span><span class="c5">community f in </span><span class="c0">by </span><span class="c5">the </span><span class="c0">V</span><span class="c5">that community, </span><span class="c4">1 </span><span class="c0">has </span><span class="c5">is </span><span class="c0">a </span><span class="c5">highly </span><span class="c0">minimal </span><span class="c5">the connected minimal </span><span class="c0">degree </span></p><p class="c80"><span class="c5">degree will drop to 1. </span></p><p class="c36"><span class="c5">Another possible measure is average degree. Under this mea- </span><span class="c0">sure, the best community for a will also include vertex f and a </span><span class="c5">dense V</span><span class="c2">1 </span><span class="c0">erage </span><span class="c5">&cup; {f} </span><span class="c0">degree </span><span class="c5">subgraph &cup; V</span><span class="c2">2 </span><span class="c0">of V</span><span class="c5">is V</span><span class="c4">1 2 </span><span class="c5">approximately </span><span class="c0">(which = {g, h, i, j, k, l}, as the average degree of </span><span class="c5">3.8, which is larger than the av- </span><span class="c0">is 3.2). Intuitively, however, V</span><span class="c4">1 </span><span class="c0">and V</span><span class="c4">2 </span></p><p class="c84"><span class="c51">991 </span></p><p class="c1"><span class="c5">are more likely to be two separate communities, as they are con- nected only by a weak link through f. Hence, the minimum degree measure captures the intuitive notion of closeness better. In this pa- </span><span class="c0">per, we adopt the minimum degree measure for community search. </span><span class="c5">Thus, the community search problem will be finding the connected subgraph with the largest minimal degree for a given query vertex. </span><span class="c0">Besides the above rationale, the following reasons also motivate </span><span class="c5">us to take the minimum degree as the measure of community good- ness. First, minimum degree is one of the most fundamental charac- </span><span class="c0">teristics of a graph. For example, it is used to describe the evolution </span><span class="c5">of random graphs [7], and graph visualization [8]. The properties found in this paper about minimal degree can shed light on other </span><span class="c0">related problems. Second, in social network analysis, minimal de- </span><span class="c5">gree has been widely used as the measure of the cohesiveness of a group of persons [9, 5, 10]. It can be dated back to the Seidman&rsquo;s </span><span class="c0">research in 1983 [9]. The author compared minimal degree to many </span><span class="c5">other measures of cohesiveness, such as connectedness and diam- eter, finding that minimum degree is a good measure in social net- </span><span class="c0">work analysis. In a recent community search study [5], the authors </span><span class="c5">also used the minimum degree as the community measure for orga- nizing a cock tail party. They also found that, in community search </span><span class="c0">problem, minimum degree is better than some other measures, such </span><span class="c5">as average degree and density (measured by </span><span class="c19">2|E| </span></p><p class="c3"><span class="c2">|V |(|V |&minus;1)</span><span class="c29">, where |V | </span><span class="c5">and |E| are the vertex number and edge number, respectively). </span></p><p class="c26"><span class="c5">A straightforward strategy for community search is known as the global search [5]. The search is pessimistic in the sense that </span><span class="c0">it needs to explore the entire graph before deciding the best com- </span><span class="c5">munity for the query vertex. Note that in the worst case, the whole network may be the best community. For example, when the whole </span><span class="c0">network forms a complete graph. </span><span class="c5">In Example 2, we demonstrate a typical global search procedure on the graph shown in Figure 1. It starts with the whole graph </span><span class="c0">and then it iteratively removes vertices that cannot be part of the </span><span class="c5">answers. The procedure is repeated until no vertex can be removed. </span></p><p class="c3"><span class="c5">E</span><span class="c20">XAMPLE </span><span class="c5">2 (G</span><span class="c20">LOBAL SEARCH</span><span class="c5">). Suppose we want to find the </span><span class="c0">best community for vertex j in the network shown in Figure 1. </span><span class="c5">We repeatedly remove vertices with the minimum degree. Vertices m, n, f, a, b, c, d, e could be removed in turn, and we end up with </span><span class="c0">V = {g, h, i, j, k}, wherein j is one of the vertices with the min- </span><span class="c5">imum degree. We can show that any subset of V has a smaller minimal degree. Hence, V is the best answer. </span></p><p class="c1"><span class="c5">Global search is costly as it needs to explore the entire graph. This is unacceptable for large graphs. In this paper, we propose a local search strategy. The intuition is that the best community for </span><span class="c0">a given vertex is in the neighborhood of the vertex. Thus, it should </span><span class="c5">not be necessary to involve the entire graph in the search. The local search strategy works as follows: We start at the query vertex. </span><span class="c0">Initially the target community contains the query vertex only. The </span><span class="c5">community expands as we explore in the neighborhood of the query vertex. We stop the search when the current community is the best. </span><span class="c0">The problem is, how do we know whether the current commu- </span><span class="c5">nity we have found is the best? It would be nice if the minimum degree measure is &ldquo;monotonic,&rdquo; meaning as the community be- </span><span class="c0">comes larger, its minimum degree always becomes smaller. Then, </span><span class="c5">we can stop the search when the minimum degree drops below the given threshold. Unfortunately, the minimum degree measure is </span><span class="c0">not monotonic. This is demonstrated by Example 3. </span></p><p class="c3"><span class="c5">E</span><span class="c20">XAMPLE </span><span class="c5">3 (L</span><span class="c20">OCAL SEARCH AND NON</span><span class="c5">-</span><span class="c20">MONOTONICITY</span><span class="c5">). Suppose we want to find the best community for vertex a in Figure 1. </span><span class="c0">Assume the current community includes a&rsquo;s immediate neighbors: </span><span class="c5">b, d, e. The subgraph induced by S = {a, b, d, e} has a minimal degree of 2. To enlarge the community, we can add vertex c or f. </span><span class="c0">Adding f will decrease the minimal degree to 1, while adding c will </span><span class="c5">increase it to 3. </span></p><p class="c3"><span class="c5">Clearly, as shown by Example 3, the minimum degree measure is </span><span class="c0">not monotonic, which means that if S is a partial result containing </span></p><p class="c26"><span class="c5">the query vertex, for a vertex v that is adjacent to S, the subgraph induced by S &cup; {v} does not necessarily have a smaller or larger minimum degree. This poses a great challenge for us to decide </span><span class="c0">when to terminate the local search procedure. </span><span class="c5">In this paper, we present theories and algorithms for local search. We investigate sufficient conditions for deciding whether a neigh- </span><span class="c0">boring vertex should be added to expand the community. If no ver- </span><span class="c5">tex satisfies the condition, then we terminate the search. We show that such a sufficient condition does exist, but, in the worst case, </span><span class="c0">its evaluation may become as costly as performing a global search. </span><span class="c5">However, a typical local search always finds the best community with much less cost than a global search. </span><span class="c0">The rest of the paper is organized as follows. Section 2 intro- </span><span class="c5">duces some background information and formulates two commu- nity search problems: CST and CSM. Section 3 discusses how to </span><span class="c0">solve the problems using global community search. In Section 4, </span><span class="c5">we give several local search based solutions for the community search with a threshold constraint (CST) problem. In Section 5, </span><span class="c0">we present solutions to the community search with a maximality </span><span class="c5">constraint (CSM) problem. Section 6 reports experimental results. Section 7 reviews related work. We conclude in Section 8. </span></p><p class="c3"><span class="c18">2. PROBLEM DEFINITION </span></p><p class="c1"><span class="c5">In this section, we define a &ldquo;goodness&rdquo; measure for communities and we define the problems of community search. We then discuss the hardness of the problems. In this work, we are concerned with </span><span class="c0">simple graphs, that is, graphs with no self-loops or multi-edges. </span><span class="c5">Also, we focus on undirected and unweighted graphs only. </span></p><p class="c3"><span class="c21">G(V,E) A graph with vertex set V and edge set E. G[H] The subgraph of G induced by a set of vertex H. </span><span class="c11">It contains edges (H &times; H) &cap; E. </span><span class="c21">deg</span><span class="c4">G</span><span class="c21">(v) The degree of vertex v in G. &delta;(G) min{deg</span><span class="c4">G</span><span class="c21">(v)|v&isin;V } H</span><span class="c19">&lowast;</span><span class="c21">(G, v) Any best communities for vertex v in G. m</span><span class="c19">&lowast;</span><span class="c21">(G, v) The community goodness of H</span><span class="c19">&lowast;</span><span class="c21">(G, v). V</span><span class="c4">&ge;k </span><span class="c21">{v|deg</span><span class="c4">G</span><span class="c21">(v) &ge; k} C</span><span class="c4">naive</span><span class="c11">(k) Naive set of candidates for </span><span class="c31">CST</span><span class="c11">(k). </span><span class="c21">maxcore(G, v</span><span class="c4">0</span><span class="c11">) The maximum core of G w.r.t v</span><span class="c4">0 </span></p><p class="c3"><span class="c5">Table 1: Notations </span></p><p class="c3"><span class="c18">2.1 Problem Definition </span></p><p class="c1"><span class="c5">Let G(V,E) denote an undirected graph with vertex set V and edge set E. For any subset H &sube; V , the subgraph induced by S, denoted as G[H], is the graph whose vertex set is H and whose </span><span class="c0">edge set is (H &times; H) &cap; E. Furthermore, we use deg</span><span class="c4">G</span><span class="c0">(v) to denote </span><span class="c5">the degree of vertex v in graph G. Clearly, we have deg</span><span class="c4">G[H]</span><span class="c0">(v) &le; </span><span class="c5">deg</span><span class="c4">G</span><span class="c0">(v) since G[H] is a subgraph of G. Table 1 summarizes the </span><span class="c5">notations used in this paper. </span></p><p class="c1"><span class="c5">D</span><span class="c20">EFINITION </span><span class="c5">1 (C</span><span class="c20">OMMUNITY GOODNESS </span><span class="c5">[5]). Let G(V,E) be a graph. Let H &sube; V . We consider G[H], the subgraph induced </span><span class="c0">by H, as a community. The community goodness of G[H] is defined </span><span class="c5">by its minimum degree: </span></p><p class="c3"><span class="c5">&delta;(G[H]) = min{deg</span><span class="c4">G[H]</span><span class="c0">(v)|v&isin;H} </span></p><p class="c1"><span class="c5">Minimum degree is one of the most widely used community goodness measures [5]. One important characteristics of &delta;(&middot;), which we have illustrated in Example 3, is that it is non-monotonic. It </span><span class="c0">means &delta;(G[H &cup; {v}]) is not necessarily smaller than &delta;(G[H]). </span><span class="c5">Because of the non-monotonicity of &delta;(&middot;), the problem of finding the best community through local search is nontrivial. </span></p><p class="c1"><span class="c5">P</span><span class="c20">ROBLEM </span><span class="c5">D</span><span class="c20">EFINITION </span><span class="c5">1 (CSM). For a graph G(V,E) and </span><span class="c0">an arbitrary vertex v</span><span class="c4">0 </span><span class="c0">&isin; V , find H &sube; V such that (1) v</span><span class="c4">0 </span><span class="c0">&isin; H; </span><span class="c5">(2) G[H] is a connected subgraph; and (3) &delta;(G[H]) is maximized among all possible choices of H. We denote this problem as CSM, </span><span class="c0">or community search with the maximality constraint. </span></p><p class="c3"><span class="c51">992 </span></p><p class="c1"><span class="c5">For graph G and query vertex v, let m</span><span class="c19">&lowast;</span><span class="c5">(G, v) denote the possi- ble maximum community goodness, and let H</span><span class="c19">&lowast;</span><span class="c5">(G, v) denote any community that has the maximum goodness. We have: </span></p><p class="c3"><span class="c5">0 &le; m</span><span class="c19">&lowast;</span><span class="c5">(G, v) &le; deg</span><span class="c4">G</span><span class="c0">(v) (1) </span><span class="c5">Note that the optimal solution is not necessarily unique. In general, m</span><span class="c19">&lowast;</span><span class="c5">(G, v) is determined by v and the graph structure of G. In some applications, instead of finding communities that have </span><span class="c0">the maximum community goodness, we may be interested in find- </span><span class="c5">ing those that satisfy &delta;(G[H]) &ge; k, where k is a given constraint. Consider the infectious disease control problem. Infectious dis- </span><span class="c0">eases have different risk factors. For a highly contagious disease, </span><span class="c5">we may want to choose a lower k so that people who have little contact with the sick can also be found. For a less contagious dis- </span><span class="c0">ease, we may choose a higher k to focus on people who have very </span><span class="c5">close contact with the sick. By tuning k, we achieve flexibility in controlling the size of the resulting community. </span></p><p class="c3"><span class="c5">P</span><span class="c20">ROBLEM </span><span class="c5">D</span><span class="c20">EFINITION </span><span class="c5">2 (CST). For a given graph G(V,E), </span><span class="c0">a query vertex v</span><span class="c4">0 </span><span class="c0">&isin; V , and a constant k, find H &sube; V such that (1) </span><span class="c5">v</span><span class="c2">0 </span><span class="c5">&isin; H; (2) G[H] is a connected graph; and (3) &delta;(G[H]) &ge; k. We </span><span class="c0">denote this problem as </span><span class="c28">CST</span><span class="c0">(k), or community search with thresh- </span><span class="c5">old constraint. </span></p><p class="c1"><span class="c5">E</span><span class="c20">XAMPLE </span><span class="c5">4. We use the graph shown in Figure 1 as an exam- ple. Suppose the query vertex is a. In </span><span class="c6">CSM</span><span class="c5">, the subgraph induced </span><span class="c0">by H = {a, b, c, d, e} is the final solution because &delta;(G[H]) = 3 </span><span class="c5">and other Hs will have &delta;(G[H]) &lt; 3. In </span><span class="c6">CST</span><span class="c5">(k), if k = 3, then the solution is still H. If k = 2, then there are multiple choices for </span><span class="c0">H. For example, {a, b, d},{a, d, e} or {a, b, c, d, e}. </span></p><p class="c1"><span class="c5">We illustrate </span><span class="c6">CSM </span><span class="c5">and </span><span class="c6">CST </span><span class="c5">in Example 4. Both </span><span class="c6">CSM </span><span class="c5">and </span><span class="c6">CST </span><span class="c5">may return multiple answers. In fact, as shown in Section 2.2, </span><span class="c6">CST </span><span class="c0">may produce an exponential number of results (with regard to graph </span><span class="c5">size). Hence, we only focus on finding one solution for </span><span class="c6">CST</span><span class="c5">. Al- ternatively, we may want to find the smallest community. This new </span><span class="c0">problem, which is denoted as </span><span class="c28">mCST</span><span class="c0">, is formally below: </span></p><p class="c1"><span class="c5">P</span><span class="c20">ROBLEM </span><span class="c5">D</span><span class="c20">EFINITION </span><span class="c5">3 (</span><span class="c20">M</span><span class="c5">CST). For a graph G(V,E), a query vertex v</span><span class="c4">0 </span><span class="c0">&isin; V and a constant k, find H &sube; V such that (1) </span><span class="c5">v</span><span class="c2">0 </span><span class="c5">&isin; H; (2) G[H] is a connected graph; (3) &delta;(G[H]) &ge; k; and </span><span class="c0">(4) the size of H is minimized. We denote this problem as </span><span class="c28">mCST</span><span class="c0">(k). </span></p><p class="c3"><span class="c5">Unfortunately, the </span><span class="c6">mCST </span><span class="c5">problem is NP-complete as we will </span><span class="c0">prove in Section 2.3. In this paper we focus on </span><span class="c28">CST </span><span class="c0">and </span><span class="c28">CSM</span><span class="c0">. </span><span class="c18">2.2 Relationship between CSM and CST </span></p><p class="c1"><span class="c6">CSM </span><span class="c5">is an optimization problem, and it has a corresponding de- cision problem: deciding whether a subset H &sube; V exists that satis- </span><span class="c0">fies the three conditions specified in </span><span class="c28">CST</span><span class="c0">. Clearly, </span><span class="c28">CST </span><span class="c0">is the con- </span><span class="c5">structive version of the decision problem of </span><span class="c6">CSM</span><span class="c5">. In other words, we not only need to determine the existence of the valid solution </span><span class="c0">but also need to construct an instance of the solution if the valid </span><span class="c5">solution does exist. Besides these obvious relationships, we further establish some quantitative correlations between </span><span class="c6">CSM </span><span class="c5">and </span><span class="c6">CST </span><span class="c5">that </span><span class="c0">will serve as the foundation for solving these problems. </span></p><p class="c3"><span class="c5">P</span><span class="c20">ROPOSITION </span><span class="c5">1 (D</span><span class="c20">OWNWARD CLOSURENESS OF </span><span class="c6">CST</span><span class="c5">(k)). If H is a solution to </span><span class="c6">CST</span><span class="c5">(k), then H is also a solution to </span><span class="c6">CST</span><span class="c5">(k ) </span><span class="c0">where k &lt; k. </span></p><p class="c3"><span class="c5">P</span><span class="c20">ROPOSITION </span><span class="c5">2. For a graph G(V,E) and a query vertex v, if H is a solution of </span><span class="c6">CST</span><span class="c5">(k), then m</span><span class="c19">&lowast;</span><span class="c5">(G, v) is no less than k. </span></p><p class="c3"><span class="c5">P</span><span class="c20">ROPOSITION </span><span class="c5">3 (P</span><span class="c20">RUNING RULE</span><span class="c5">). For a vertex v with </span><span class="c0">deg</span><span class="c4">G</span><span class="c0">(v) &lt; k, v will not belong to any solutions to </span><span class="c28">CST</span><span class="c0">(k). </span></p><p class="c3"><span class="c5">Proposition 1 and 2 lead to an algorithm of polynomial com- plexity to solve </span><span class="c6">CSM </span><span class="c5">if we have a polynomial solution for </span><span class="c6">CST</span><span class="c5">. </span><span class="c0">Since m</span><span class="c2">&lowast;</span><span class="c0">(G, v) lies in the interval [0, deg</span><span class="c4">G</span><span class="c0">(v)], we can employ </span></p><p class="c3"><span class="c5">a binary search procedure starting from &lceil; </span><span class="c19">N&minus;1 </span></p><p class="c3"><span class="c2">2 </span><span class="c29">&rceil; to iteratively visit </span><span class="c5">the median of the interval to check whether the </span><span class="c6">CST </span><span class="c5">instance with the median as the threshold constraint has a valid solution. In this </span><span class="c0">manner, we can solve </span><span class="c28">CSM </span><span class="c0">in O(log deg</span><span class="c4">G</span><span class="c0">(v)f(N)), where f(N) </span><span class="c5">is the time complexity of </span><span class="c6">CST</span><span class="c5">. For both </span><span class="c6">CSM </span><span class="c5">and </span><span class="c6">CST</span><span class="c5">, we only look for one solution because </span><span class="c0">there may exist an exponential number of solutions. To see this, </span><span class="c5">consider a graph with N vertices of degree 1 and one vertex of de- gree N (Figure 2). Suppose the query vertex v</span><span class="c2">c </span><span class="c5">is the vertex of de- </span><span class="c0">gree N. Then, obviously we have m</span><span class="c2">&lowast;</span><span class="c0">(G, v</span><span class="c4">c</span><span class="c0">)=1. But H</span><span class="c2">&lowast;</span><span class="c0">(G, v</span><span class="c4">c</span><span class="c0">) </span><span class="c5">could be any subset containing v</span><span class="c4">c</span><span class="c0">. Thus the number of optimal so- </span><span class="c5">lutions is &Theta;(2</span><span class="c19">n</span><span class="c5">), where n is the number of all vertices of degree </span><span class="c0">1. To avoid returning an exponential number of solutions, in our </span><span class="c5">problem, we only consider one of them. </span></p><p class="c3"><span class="c64">c </span></p><p class="c3"><span class="c5">Figure 2: A graph with 1 vertex of degree N and N vertices of </span><span class="c0">degree 1. </span><span class="c18">2.3 NP-completeness of mCST </span></p><p class="c1"><span class="c5">Now we show that the </span><span class="c6">mCST </span><span class="c5">problem, which we introduced in Section 2.1, is NP-complete. To do this, we prove a problem related to </span><span class="c6">mCST </span><span class="c5">is NP-Complete, and we reduce that problem to </span><span class="c6">mCST</span><span class="c5">. </span></p><p class="c1"><span class="c5">L</span><span class="c20">EMMA </span><span class="c5">1. For a given graph G, a vertex v</span><span class="c4">0</span><span class="c0">, and an integer k, </span><span class="c5">if there exists a clique C such that v</span><span class="c2">0 </span><span class="c5">&isin; C and |C| = k + 1, then C is the smallest solution of </span><span class="c6">CST</span><span class="c5">(k). </span></p><p class="c3"><span class="c5">P</span><span class="c20">ROBLEM </span><span class="c5">D</span><span class="c20">EFINITION </span><span class="c5">4 (MCC). For a graph G(V,E) and v</span><span class="c2">0 </span><span class="c5">&isin; V , find the maximum clique that contains v</span><span class="c2">0</span><span class="c5">. </span></p><p class="c3"><span class="c5">L</span><span class="c20">EMMA </span><span class="c5">2. </span><span class="c6">MCC </span><span class="c5">is NP-Complete. </span></p><p class="c1"><span class="c5">P</span><span class="c20">ROOF</span><span class="c5">. It is clear that </span><span class="c6">MCC </span><span class="c5">belongs to NP. We prove it by reduc- </span><span class="c0">ing Maximal Clique (</span><span class="c28">MC</span><span class="c0">), a well-known NP-complete problem, to </span><span class="c6">MCC</span><span class="c5">. For any graph G(V,E), we construct a new graph G (V ,E ) by adding a vertex v</span><span class="c2">0 </span><span class="c5">and connecting v</span><span class="c2">0 </span><span class="c5">to all vertices in G, that is, </span><span class="c0">V = V &cup; {v</span><span class="c4">0</span><span class="c0">} and E = E &cup; {(v</span><span class="c4">i</span><span class="c0">,v</span><span class="c4">0</span><span class="c0">)|v</span><span class="c4">i </span><span class="c0">&isin; V }. Thus, an </span><span class="c28">MCC </span><span class="c5">in G is an </span><span class="c6">MC </span><span class="c5">in G. </span></p><p class="c3"><span class="c5">T</span><span class="c20">HEOREM </span><span class="c5">1. </span><span class="c6">mCST </span><span class="c5">is NP-complete. </span></p><p class="c1"><span class="c5">P</span><span class="c20">ROOF</span><span class="c5">. It is easy to see that </span><span class="c6">mCST </span><span class="c5">belongs to NP. Now we show that </span><span class="c6">mCST </span><span class="c5">is NP-complete by reducing </span><span class="c6">MCC </span><span class="c5">to it. Let G(V,E) be a graph, and let v</span><span class="c2">0 </span><span class="c5">be the query vertex. Consider the decision prob- </span><span class="c0">lem that corresponds to the optimization problem of </span><span class="c28">MCC</span><span class="c0">: Deter- </span><span class="c5">mine whether G has a clique of at least size k that contains v</span><span class="c2">0</span><span class="c5">. We can construct the following decision problem for </span><span class="c6">mCST</span><span class="c5">. Determine </span><span class="c0">whether a solution H &sube; V exists such that |H| = k and it satisfies </span><span class="c5">the </span><span class="c6">mCST </span><span class="c5">conditions: i) v</span><span class="c2">0 </span><span class="c5">&isin; H; ii) G[H] is connected; and iii) &delta;(G[H]) &ge; k &minus; 1. If H is the answer, then apparently G[H] is a </span><span class="c0">clique, as any node in H has degree &ge; k &minus; 1. </span></p><p class="c3"><span class="c18">3. GLOBAL SEARCH </span></p><p class="c3"><span class="c5">In this section, we describe global search based solutions for </span><span class="c6">CST </span><span class="c5">and </span><span class="c6">CSM</span><span class="c5">. The global search approach needs to visit all ver- tices and edges of the graph, which is costly for big graphs. </span><span class="c18">3.1 </span><span class="c5">k</span><span class="c18">-core and Maxcore </span><span class="c5">To understand global search, we first define two concepts: k-core </span><span class="c0">and maxcore. </span></p><p class="c1"><span class="c5">D</span><span class="c20">EFINITION </span><span class="c5">2 (k-</span><span class="c20">CORE</span><span class="c5">). A subgraph of G is called the k- </span><span class="c0">core of G if it is the biggest subgraph such that each of its vertices </span><span class="c5">has a degree of at least k. Note that the k-core may contain multiple connected components. </span></p><p class="c3"><span class="c51">993 </span></p><p class="c1 c37"><span class="c5">D</span><span class="c20">EFINITION </span><span class="c5">3 (M</span><span class="c20">AXIMUM </span><span class="c5">C</span><span class="c20">ORE</span><span class="c5">). For a vertex v, a maxi- mum core with regard to v, denoted as maxcore(v), is the k-core with the maximum k among all the k-cores that contain v. </span></p><p class="c37 c44"><span class="c5">E</span><span class="c20">XAMPLE </span><span class="c5">5. Consider graph G in Figure 1. The subgraph in- duced by {a, b, c, d, e, g, h, i, j, k, l} is the 3-core of G; the sub- </span><span class="c0">graph induced by {g, h, i, j, k, l} is the 4-core of G, which is also </span><span class="c5">the maximum core of G; and the subgraph induced by {a, b, c, d, e} is a maximum core with regard to vertex e, that is, maxcore(G, e). Example 5 illustrates the concepts of k-core and maxcore. We </span><span class="c0">use global search to find the k-core for a given k: We repeatedly </span><span class="c5">remove vertices from G whose degree is less than k until no more vertices can be removed. We need to visit every vertex to find its </span><span class="c0">degree and explore all of the edges in the graph. Hence, the com- </span><span class="c5">plexity for finding the k-core and maxcore is O(|V | + |E|). </span><span class="c18">3.2 Solving CST and CSM </span></p><p class="c50"><span class="c5">For a graph G and a query vertex v</span><span class="c4">0</span><span class="c0">, we now show that the k- </span><span class="c5">core and the maxcore(v</span><span class="c4">0</span><span class="c0">) contain the solutions to </span><span class="c28">CST </span><span class="c0">and </span><span class="c28">CSM</span><span class="c0">, </span><span class="c5">respectively. First, consider the problem of </span><span class="c6">CST</span><span class="c5">(k). If vertex v </span><span class="c0">belongs to any solution of </span><span class="c28">CST</span><span class="c0">(k), we call v an admissible vertex. </span><span class="c5">Let A be the set of all admissible vertices for </span><span class="c6">CST</span><span class="c5">(k). Similarly, we can define the admissible set A for the problem of </span><span class="c6">CSM</span><span class="c5">. Example 6 </span><span class="c0">illustrates the admissible sets in Figure 1: </span><span class="c5">E</span><span class="c20">XAMPLE </span><span class="c5">6. Consider graph G in Figure 1 and query vertex e. For </span><span class="c6">CSM</span><span class="c5">, we have m</span><span class="c19">&lowast;</span><span class="c5">(G, e)=3 and H</span><span class="c19">&lowast;</span><span class="c5">(G, e) = {a, b, c, d, e}. </span><span class="c0">Since no other H</span><span class="c2">&lowast;</span><span class="c0">(G, e) exists, the admissible set is simply A = </span><span class="c5">{a, b, c, d, e}. For </span><span class="c6">CST</span><span class="c5">(2), the solutions include {a, b, c, d, e} and </span><span class="c0">V &minus; {m, n}. Hence, we have A = V &minus; {m, n}. </span><span class="c5">Next, we show that A is a subset of the k-core of G. Similarly, A is contained in maxcore(v</span><span class="c2">0</span><span class="c5">). More specifically, we have: L</span><span class="c20">EMMA </span><span class="c5">3. For graph G and query vertex v</span><span class="c2">0</span><span class="c5">, the connected </span><span class="c0">component C</span><span class="c4">k </span><span class="c0">that contains v</span><span class="c4">0 </span><span class="c0">in the k-core of graph G is a solu- </span><span class="c5">tion of </span><span class="c6">CST</span><span class="c5">(k). Furthermore, for any other solution H of </span><span class="c6">CST</span><span class="c5">(k), we have H &sub; C</span><span class="c4">k</span><span class="c0">. </span></p><p class="c53"><span class="c5">L</span><span class="c20">EMMA </span><span class="c5">4. For graph G and query vertex v</span><span class="c4">0</span><span class="c0">, the connected </span><span class="c5">component that contains v</span><span class="c4">0 </span><span class="c0">inmaxcore(v</span><span class="c4">0</span><span class="c0">), denoted by C</span><span class="c4">max</span><span class="c0">(v</span><span class="c4">0</span><span class="c0">), </span><span class="c5">is a solution of </span><span class="c6">CSM</span><span class="c5">. Furthermore, for any other solution H of </span><span class="c6">CSM</span><span class="c5">, </span><span class="c0">we have H &sub; C</span><span class="c4">max</span><span class="c0">(v</span><span class="c4">0</span><span class="c0">). </span><span class="c5">P</span><span class="c20">ROOF</span><span class="c5">. By definition, C</span><span class="c2">max</span><span class="c5">(v</span><span class="c2">0</span><span class="c5">) is a solution of </span><span class="c6">CSM</span><span class="c5">. If there </span><span class="c0">exists another solution H = C</span><span class="c4">max</span><span class="c0">(v</span><span class="c4">0</span><span class="c0">), then H&cup;C</span><span class="c4">max</span><span class="c0">(v</span><span class="c4">0</span><span class="c0">) will be </span><span class="c5">a connected component in maxcore(v</span><span class="c4">0</span><span class="c0">), as both H and C</span><span class="c4">max</span><span class="c0">(v</span><span class="c4">0</span><span class="c0">) </span><span class="c5">contain v</span><span class="c2">0</span><span class="c5">. This contradicts the definition of C</span><span class="c2">max</span><span class="c5">(v</span><span class="c2">0</span><span class="c5">). </span></p><p class="c48"><span class="c5">Lemma 3 implies that a vertex v is an admissible vertex of </span><span class="c6">CST</span><span class="c5">(k) if and only if v &isin; C</span><span class="c4">k</span><span class="c0">; and Lemma 4 implies that v is an admissible </span><span class="c5">vertex of CSM if and only if v &isin; C</span><span class="c2">max</span><span class="c5">. Unfortunately, evaluat- </span><span class="c0">ing these sufficient and necessary conditions is equivalent to global </span><span class="c5">search. To solve </span><span class="c6">CST</span><span class="c5">, Lemma 3 implies that we can iteratively remove </span><span class="c0">vertices of less than k degree and their incident edges. Then, the </span><span class="c5">connected component that contains the query vertex is certainly a valid solution. </span><span class="c0">To solve </span><span class="c28">CSM</span><span class="c0">, Lemma 4 implies that we need to find the con- </span><span class="c5">nected component containing the query vertex in the maximum </span><span class="c0">core with regard to the query vertex. We do this by using a greedy </span><span class="c5">algorithm [5]. Let G</span><span class="c4">0 </span><span class="c0">= G. We delete from G</span><span class="c4">0 </span><span class="c0">the vertex with the </span><span class="c5">minimum degree as well as its incident edges, and we denote the </span><span class="c0">resulting graph as G</span><span class="c4">1</span><span class="c0">. We repeat the process and create a sequence </span><span class="c5">of graphs, G</span><span class="c4">0</span><span class="c0">,G</span><span class="c4">1</span><span class="c0">,&middot;&middot;&middot; ,G</span><span class="c4">t</span><span class="c0">, until at step t the query vertex v</span><span class="c4">0 </span><span class="c0">is the </span><span class="c5">next vertex to be deleted. Then, the connected component of G</span><span class="c2">i </span><span class="c0">(0 &le; i &le; t) with maximum &delta;(G</span><span class="c4">i</span><span class="c0">) that contains the query vertex is </span><span class="c5">an optimum solution [5]. </span></p><p class="c56"><span class="c5">The above two solutions have time complexity O(|V | + |E|)</span><span class="c19">1</span><span class="c5">, which means we need to visit all vertices and edges in the graph. </span><span class="c2">1</span><span class="c0">The linear complexity of a global search based </span><span class="c28">CSM </span><span class="c0">solution is achieved with some special technique. Please refer to [5] for its linear implementation. </span></p><p class="c3 c71"><span class="c18">4. LOCAL SEARCH FOR CST </span></p><p class="c73"><span class="c5">In this section, we devise local search algorithms for community search. The biggest challenge is to overcome the non-monotonicity of the minimum degree measure, which enables us to perform com- </span><span class="c0">munity search by exploring only the local neighborhood of the </span><span class="c5">query vertex. In the following, we first present a baseline local search solution, which is of exponential complexity. Then, we </span><span class="c0">present the general framework of our linear solution. Finally, we </span><span class="c5">give optimized realizations of this framework in Section 4.3.1 and Section 4.3.2. As we mentioned, </span><span class="c6">CSM </span><span class="c5">can be solved based on the </span><span class="c0">solutions to the corresponding </span><span class="c28">CST </span><span class="c0">problem. Hence, we focus on </span><span class="c6">CST </span><span class="c5">only. </span><span class="c18">4.1 The Baseline Solution </span></p><p class="c58"><span class="c5">We first give an in-depth analysis of the monotonicity of &delta;(&middot;), the community goodness function and introduce some notations. Con- </span><span class="c0">sider the exploration starting from the query vertex. At each step </span><span class="c5">we add a vertex until we get a solution H. Let v</span><span class="c2">0</span><span class="c5">,v</span><span class="c2">1</span><span class="c5">, ..., v</span><span class="c2">t </span><span class="c5">be a sequence of vertices which lead to H (we refer to such a sequence </span><span class="c0">as a sequence of H). Let H</span><span class="c4">i </span><span class="c0">= {v</span><span class="c4">0</span><span class="c0">,&middot;&middot;&middot; ,v</span><span class="c4">i</span><span class="c0">}. We have shown </span><span class="c5">that in general &delta;(&middot;) is a non-monotonic function of H. More for- </span><span class="c0">mally, &delta;(H</span><span class="c4">i</span><span class="c0">) is not necessarily smaller than &delta;(H</span><span class="c4">i+1</span><span class="c0">). Clearly, the </span><span class="c5">monotonicity of &delta;(H) depends on the order in which vertices are added to H. One interesting fact we discovered is that for any ver- </span><span class="c0">tex v</span><span class="c4">0 </span><span class="c0">&isin; H, we can always find a vertex sequence (each vertex is </span><span class="c5">in H) starting with v</span><span class="c4">0 </span><span class="c0">such that &delta;(H</span><span class="c4">i</span><span class="c0">) is a non-decreasing function </span><span class="c5">of i.</span><span class="c0">T</span><span class="c82">HEOREM </span><span class="c0">2. For any vertex v</span><span class="c4">0 </span><span class="c0">&isin; H in graph G, there always </span><span class="c5">exists a vertex sequence v</span><span class="c2">0</span><span class="c5">,v</span><span class="c2">1</span><span class="c5">, ..., v</span><span class="c2">t </span><span class="c5">of H starting with v</span><span class="c2">0 </span><span class="c5">such </span><span class="c0">that &forall;0 &le; i&lt;t, &delta;(H</span><span class="c4">i</span><span class="c0">) &le; &delta;(H</span><span class="c4">i+1</span><span class="c0">). </span><span class="c5">P</span><span class="c20">ROOF</span><span class="c5">. This is equivalent to proving that we can remove ver- </span><span class="c0">tices one by one from H until v</span><span class="c4">0 </span><span class="c0">such that the removal of each </span><span class="c5">vertex will not increase the minimal degree of the remaining ver- tices. Suppose the current set is H . If H = {v</span><span class="c2">0</span><span class="c5">}, we have al- </span><span class="c0">ready found the vertex sequence. If H = {v</span><span class="c4">0</span><span class="c0">,v</span><span class="c4">i</span><span class="c0">}, then removing </span><span class="c5">v</span><span class="c4">i </span><span class="c0">either decreases the minimal degree (if (v</span><span class="c4">0</span><span class="c0">,v</span><span class="c4">i</span><span class="c0">) &isin; E) or does </span><span class="c5">not change the minimal degree (if (v</span><span class="c2">0</span><span class="c5">,v</span><span class="c2">i</span><span class="c5">) &isin; E). Next, we con- </span><span class="c0">sider the case in which there are two or more vertices besides v</span><span class="c4">0 </span><span class="c0">in H . In such a case, there must be a vertex v &isin; H ,v = v</span><span class="c4">0 </span><span class="c0">and &delta;(G[H ]) &ge; &delta;(G[H &minus; {v}]). We just need to remove this vertex. If such vertices don&rsquo;t exist, it means that &forall;v &isin; H ,v = </span><span class="c5">v</span><span class="c4">0</span><span class="c0">,&delta;(G[H ]) &lt; &delta;(G[H &minus; {v}]). This only happens when v is </span><span class="c5">one of the vertices in H that has the minimal degree because re- </span><span class="c0">moving a non-minimal degree vertex will only keep the minimal </span><span class="c5">degree or decrease the minimal degree. Thus, there must be two or more such v. Removing each one of these vertices will not produce </span><span class="c0">a larger minimal degree. </span></p><p class="c39"><span class="c5">Theorem 2 implies that there is always an order of exploration </span><span class="c0">that monotonically leads to a solution. Theorem 2 also implies any </span><span class="c5">solution H of </span><span class="c6">CST</span><span class="c5">(k) can be produced by a vertex sequence of H starting from the query vertex v</span><span class="c2">0 </span><span class="c5">such that &delta;(H</span><span class="c2">i</span><span class="c5">) &le; &delta;(H</span><span class="c2">i+1</span><span class="c5">) for </span><span class="c0">each i. In general the existence of such a sequence is a necessary </span><span class="c5">but not a sufficient condition to find a valid solution. To see the insufficiency, consider the graph shown in Figure 1 and </span><span class="c6">CST</span><span class="c5">(3) </span><span class="c0">with query vertex e. Any vertex sequence starting with e, f will </span><span class="c5">not lead to a valid solution, but clearly &delta;(G[e, f]) is larger than &delta;(G[e]). </span><span class="c0">Theorem 2 leads to a straightforward algorithm which is outlined </span><span class="c5">in Algorithm 1. It starts from H = {v</span><span class="c4">0</span><span class="c0">} and then calls the search </span><span class="c5">function. The search function exhaustively enumerates each ver- </span><span class="c0">tex v form the neighbors of H such that &delta;(H &cup; {v}) &ge; &delta;(H ). If </span><span class="c5">a solution is found, the procedure stops. Otherwise, it calls search recursively. Theorem 2 ensures that such exhaustive enumeration </span><span class="c0">can always find a valid solution to </span><span class="c28">CST</span><span class="c0">(k). The solution can be </span><span class="c5">directly extended for </span><span class="c6">CSM</span><span class="c5">, but we omit the details here. Clearly, this baseline solution is of exponential complexity. This motivates </span><span class="c0">us to develop a more efficient local search solution. Next, we will </span><span class="c5">present our linear solution. </span></p><p class="c83"><span class="c51">994 </span></p><p class="c3"><span class="c5">Algorithm 1 Search() </span><span class="c21">Input: G(V,E), H , k </span><span class="c11">Output: H </span><span class="c0">1: </span><span class="c11">if &delta;(G[H ]) = k then </span><span class="c0">2: </span><span class="c11">H &larr; H </span><span class="c0">3: </span><span class="c11">return </span><span class="c0">4: </span><span class="c11">end if </span><span class="c0">5: </span><span class="c11">for all vertex v in the neighbors of H do </span><span class="c0">6: </span><span class="c11">if &delta;(G[H &cup; {v}]) &ge; &delta;(G[H ]) then </span><span class="c0">7: </span><span class="c11">Search(H &cup; {v}) </span><span class="c0">8: </span><span class="c11">if H = &empty; then </span><span class="c0">9: </span><span class="c11">return </span><span class="c0">10: </span><span class="c11">end if </span><span class="c0">11: </span><span class="c11">end if </span><span class="c0">12: </span><span class="c11">end for </span></p><p class="c3"><span class="c18">4.2 A Framework for Solving CST </span></p><p class="c1"><span class="c5">In this section, we introduce a local search framework for </span><span class="c6">CST</span><span class="c5">. As outlined in Algorithm 2, on the high level, it contains three sim- ple steps. First, we check if the graph meets the necessary con- </span><span class="c0">dition of containing an answer to </span><span class="c28">CST</span><span class="c0">(k). Second, we perform </span><span class="c6">candidateGeneration()</span><span class="c5">, that is, we explore from the vicin- ity of the query vertex, and generate candidate set C, which may </span><span class="c0">contain a solution to the problem. In most cases, the second step </span><span class="c5">will find a solution to </span><span class="c6">CST</span><span class="c5">, but if not, in the final step, we perform a global search (see Section 3) in the k-core of the subgraph induced </span><span class="c0">by C to find the solution. </span></p><p class="c3"><span class="c5">Algorithm 2 A General Framework of CST </span><span class="c21">Input: G(V,E), v</span><span class="c4">0</span><span class="c11">, k Output: solutions to CST(k) </span><span class="c0">1: </span><span class="c11">if k &gt;</span><span class="c31">upperBound</span><span class="c11">(G) then </span><span class="c0">2: </span><span class="c11">return </span><span class="c0">3: </span><span class="c11">end if </span><span class="c0">4: </span><span class="c11">C &larr;</span><span class="c31">candidateGeneration</span><span class="c11">(G, v</span><span class="c4">0</span><span class="c11">,k); </span><span class="c0">5: </span><span class="c11">if no solution is found then </span><span class="c0">6: </span><span class="c11">perform global search in the k-core of G[C]; </span><span class="c0">7: </span><span class="c11">end if </span><span class="c0">8: </span><span class="c11">return </span></p><p class="c63"><span class="c5">Algorithm 2 is guaranteed to return a valid solution as long as </span><span class="c6">candidateGeneration() </span><span class="c5">does not remove any admissible ver- </span><span class="c0">tex. This is summarized by Proposition 4. </span></p><p class="c26"><span class="c5">P</span><span class="c20">ROPOSITION </span><span class="c5">4. For graph G and query vertex v</span><span class="c4">0</span><span class="c0">, if H &sube; </span><span class="c5">V is a solution of CST(k), then for any H &sube; V , a k-core of </span><span class="c0">G[H &cup; H ] that contains v</span><span class="c4">0 </span><span class="c0">is a valid solution of CST(k). </span><span class="c5">In the following, we first introduce the upper bound in Section 4.2.1. We present a naive </span><span class="c6">candidateGeneration() </span><span class="c5">in Sec- </span><span class="c0">tion 4.2.2 and we analyze its complexity and effectiveness in depth. </span><span class="c16">4.2.1 Upper Bound </span></p><p class="c1"><span class="c5">Before we perform search, can we tell if a graph G has a solution for </span><span class="c6">CST</span><span class="c5">(k) with respect to a query vertex v? Obviously, if the </span><span class="c0">degree of v is less than k, we know immediately that there is no </span><span class="c5">solution to </span><span class="c6">CST</span><span class="c5">(k). In this section, we establish an upper bound of m</span><span class="c19">&lowast;</span><span class="c5">(G, v). If k is larger than the upper bound, then we immediately </span><span class="c0">know there is no solution. The upper bound is given by Theorem 3. </span></p><p class="c63"><span class="c5">T</span><span class="c20">HEOREM </span><span class="c5">3. Given a connected simple graph G(V,E), for </span><span class="c0">any v &isin; G, we have </span><span class="c5">m</span><span class="c19">&lowast;</span><span class="c5">(G, v) &le; &lfloor;</span><span class="c29">1 + &radic;</span><span class="c5">9 + 8(|E|&minus;|V |) </span></p><p class="c3"><span class="c5">2 </span><span class="c29">&rfloor; </span></p><p class="c1"><span class="c5">P</span><span class="c20">ROOF</span><span class="c5">. Since G is a connected graph, we have |E|&ge;|V | &minus; 1. For simplicity, we use H</span><span class="c19">&lowast; </span><span class="c5">and m</span><span class="c19">&lowast; </span><span class="c5">to denote the optimal commu- nity and its minimum degree. ThenG[H</span><span class="c19">&lowast;</span><span class="c5">] has at least &lceil;m</span><span class="c19">&lowast;</span><span class="c5">|H</span><span class="c19">&lowast;</span><span class="c5">|/2&rceil; </span><span class="c0">edges. For the rest of the vertices in V &minus;H</span><span class="c2">&lowast;</span><span class="c0">, there must be at least </span><span class="c5">|V |&minus;|H</span><span class="c19">&lowast;</span><span class="c5">| edges to ensure G is connected. Hence, </span></p><p class="c3"><span class="c5">&lceil;</span><span class="c29">m</span><span class="c19">&lowast;</span><span class="c5">|H</span><span class="c19">&lowast;</span><span class="c5">| </span></p><p class="c3"><span class="c5">2 </span><span class="c29">&rceil; + |V |&minus;|H</span><span class="c19">&lowast;</span><span class="c5">|&le;|E| (2) </span></p><p class="c1"><span class="c5">It is also easy to see that |H</span><span class="c19">&lowast;</span><span class="c5">| &ge; m</span><span class="c19">&lowast; </span><span class="c5">+ 1. Thus, from Equation 2, we have &lceil;( </span><span class="c19">m</span><span class="c7">&lowast;</span><span class="c2">2 </span><span class="c29">&minus; 1)|H</span><span class="c19">&lowast;</span><span class="c5">|&rceil; &le; |E|&minus;|V |. By simple transformation, we have ( </span><span class="c19">m</span><span class="c7">&lowast;</span><span class="c2">2 </span><span class="c29">&minus; 1)(m</span><span class="c19">&lowast; </span><span class="c5">+ 1) &le; |E|&minus;|V |. Solving the above equation, we get m</span><span class="c19">&lowast;</span><span class="c5">(G, v) &le; &lfloor; </span><span class="c19">1+</span><span class="c29">&radic;</span><span class="c2">9+8(|E|&minus;|V |) </span></p><p class="c3"><span class="c2">2 </span><span class="c29">&rfloor;. </span><span class="c16">4.2.2 A Naive Candidate Generation Method </span><span class="c5">In this section, we present a straightforward implementation of </span><span class="c28">candidateGeneration()</span><span class="c0">. We give a more sophisticated so- </span><span class="c5">lution in Section 4.3.1. </span></p><p class="c3"><span class="c5">Algorithm 3 Naive </span><span class="c6">candidateGeneration() </span><span class="c21">Input: G(V,E), v</span><span class="c4">0</span><span class="c11">, k Output: C </span><span class="c0">1: </span><span class="c11">queue.enque(v</span><span class="c4">0</span><span class="c11">); C &larr; &empty;; </span><span class="c0">2: </span><span class="c11">while queue is not empty do </span><span class="c0">3: </span><span class="c11">v &larr; queue.deque(); </span><span class="c0">4: </span><span class="c11">C &larr; C &cup; {v}; </span><span class="c0">5: </span><span class="c11">if &delta;(G[C]) &ge; k then </span><span class="c0">6: </span><span class="c11">A valid solution is found and Return C; </span><span class="c0">7: </span><span class="c11">end if </span><span class="c0">8: </span><span class="c11">for each(v, w) &isin; E do </span><span class="c0">9: </span><span class="c11">if w is not visited and deg</span><span class="c4">G</span><span class="c21">(w) &ge; k then </span><span class="c0">10: </span><span class="c11">queue.enque(w); </span><span class="c0">11: </span><span class="c11">end if </span><span class="c0">12: </span><span class="c11">end for </span><span class="c0">13: </span><span class="c11">end while </span><span class="c0">14: </span><span class="c11">return C </span></p><p class="c1"><span class="c5">We show an example of this pseudo-code in Example 7. In this </span><span class="c0">naive strategy, we generate candidate vertices by BFS starting from </span><span class="c5">the query vertex v</span><span class="c2">0</span><span class="c5">. As shown in Algorithm 3, we prune vertices of degree less than k as we traverse the graph (Proposition 3 of </span><span class="c0">Section 2.2). Algorithm 3 runs in &Theta;(n +m ) time, where n is the </span><span class="c5">number of vertices and m is the number of edges in G[C]. </span></p><p class="c3"><span class="c16">4.2.3 Complexity Analysis </span></p><p class="c63"><span class="c5">Next, we study the time complexity of Algorithm 2 when it im- plements </span><span class="c6">candidateGeneration() </span><span class="c5">as in Algorithm 3. The </span><span class="c0">last step of the global search has the same complexity as that of can- </span><span class="c5">didate generation. Thus, the complexity of Algorithm 2 is &Theta;(n + m ). Hence, to reduce the complexity, we need to reduce n = |C| </span><span class="c0">and m . Section 4.3 proposes optimization techniques to reduce n </span><span class="c5">and m . Before that, we first give the theoretic analysis of n and m to evaluate the pruning ability of the naive candidate generation. </span><span class="c16">Estimation of </span><span class="c5">n </span><span class="c16">. </span><span class="c0">First, the value of n has an obvious upper bound: |V |. In the </span><span class="c5">worst case, we have C = V (G). For example, when k = N &minus; 1 </span><span class="c0">and the graph is a complete graph with N vertices, for any query </span><span class="c5">vertex, only the entire graph will qualify. Thus, in the worst case, the local search algorithm will not have any advantage over the </span><span class="c0">global search algorithm. </span><span class="c5">Second, the value of n has a tighter upper bound: |V</span><span class="c4">&ge;k</span><span class="c0">|. Let </span><span class="c5">V</span><span class="c4">&ge;k </span><span class="c0">= {v|deg</span><span class="c4">G</span><span class="c0">(v) &ge; k} be the set of vertices in G with a de- gree no less than k. Clearly, G[C] belongs to one of the connected </span><span class="c5">components of G[V</span><span class="c4">&ge;k</span><span class="c0">]. As an example, let G be the graph shown </span><span class="c5">in Figure 1, and let g be the query vertex. Given k = 4, we have </span><span class="c0">C = {g, h, i, j, k, l}, whose induced subgraph is a connected com- </span><span class="c5">ponent of the subgraph induced by V</span><span class="c4">&ge;4 </span><span class="c0">= {d, e, g, h, i, j, k, l}. </span><span class="c5">We show in Figure 3 the simulation of above upper bounds of </span><span class="c0">|C| and the real size of |C| found by the naive candidate genera- </span><span class="c5">tion. We generated scale free graphs of different sizes under the same parameters as that used in Section 6.2. We randomly select </span><span class="c0">10 vertices as query vertices and record the average metrics of in- </span><span class="c5">terest. The size of the communities found by the improved local search proposed in Section 4.3.1 is also given (denoted by &rsquo;local </span><span class="c0">search&rsquo;). The simulation results show that |C| and the real commu- </span><span class="c5">nity size is quite close to |V</span><span class="c4">&ge;k</span><span class="c0">| but far away from |V |. This implies </span><span class="c5">that |V</span><span class="c4">&ge;k</span><span class="c0">| is a good upper bound of C. In the estimation of m , we will use |V</span><span class="c4">&ge;k</span><span class="c0">| as the approximation of |C|. </span></p><p class="c3"><span class="c51">995 </span></p><p class="c3"><span class="c25">0.1 </span><span class="c10">) 0001(secitreV</span><span class="c25">#</span><span class="c10">100 </span></p><p class="c3"><span class="c10">100 </span></p><p class="c3"><span class="c10">10 10 1 1 </span><span class="c25">0.1 0 20k 40k 60k 80k 100k </span></p><p class="c3"><span class="c25">0 20k 40k 60k 80k 100k Graph Size </span></p><p class="c3"><span class="c55">|V</span><span class="c69">&#19977;</span><span class="c79">50</span><span class="c25">|V| | </span><span class="c10">|C| </span><span class="c25">local search </span><span class="c5">(a) k = 50 </span></p><p class="c3"><span class="c10">) 0001(secitreV</span><span class="c25">#Graph Size </span></p><p class="c26"><span class="c55">|V</span><span class="c69">&#19977;</span><span class="c79">100</span><span class="c25">|V| | </span><span class="c10">|C| </span><span class="c25">local search </span><span class="c5">(b) k = 100 Figure 3: Simulation of upper bounds on |C| </span></p><p class="c26"><span class="c16">Estimation of </span><span class="c5">m </span><span class="c16">. </span><span class="c0">Clearly, the number of m . Degree distribution is edges one of in important G[V</span><span class="c4">&ge;k</span><span class="c0">] feature is an upper to characterize bound of </span><span class="c5">a real network. We estimate on the degree distribution of the G. number of edges in G[V</span><span class="c4">&ge;k</span><span class="c0">] based </span><span class="c5">dom </span><span class="c0">Let </span><span class="c5">has </span><span class="c0">p</span><span class="c4">k </span><span class="c5">degree </span><span class="c0">be the probability </span><span class="c5">k. Let P distribution </span><span class="c0">&sum;</span><span class="c4">0&le;i&le;&omega; </span><span class="c5">p</span><span class="c4">i </span><span class="c5">of </span><span class="c0">= </span><span class="c5">G, </span><span class="c0">1. that a vertex chosen uniformly at ran- </span><span class="c5">where &omega; is = the {p</span><span class="c2">0</span><span class="c5">,p</span><span class="c2">1</span><span class="c5">,p</span><span class="c2">2</span><span class="c5">, largest degree ..., p</span><span class="c2">&omega;</span><span class="c5">} of </span><span class="c0">In general, </span><span class="c5">be the degree graph G, and </span><span class="c0">it is reasonable to assume that &omega; &isin; </span><span class="c5">o(|V |) for large graphs in real life. Given these assumptions, our </span><span class="c0">major result is: Given a graph G with degree distribution P = </span><span class="c5">{pbe </span><span class="c4">0</span><span class="c0">,p</span><span class="c5">estimated </span><span class="c4">1</span><span class="c0">,p</span><span class="c4">2</span><span class="c0">, ..., </span><span class="c5">by</span><span class="c0">p</span><span class="c4">&omega;</span><span class="c0">} and the maximal degree &omega; &isin; o(|V |), m can </span></p><p class="c3"><span class="c0">|V</span><span class="c4">&ge;k</span><span class="c0">| </span></p><p class="c3"><span class="c0">&sum;</span><span class="c2">&omega;</span><span class="c4">t=1 </span></p><p class="c3"><span class="c5">t &times; q</span><span class="c2">t </span><span class="c5">= n </span></p><p class="c3"><span class="c0">&sum;</span><span class="c2">&omega;</span><span class="c5">p</span><span class="c2">i </span></p><p class="c3"><span class="c0">&sum;</span><span class="c2">&omega;</span><span class="c5">t &times; q</span><span class="c2">t </span><span class="c5">(3) </span><span class="c4">i=k </span></p><p class="c3"><span class="c4">t=1 </span></p><p class="c26"><span class="c5">where and Lemma q</span><span class="c4">t </span><span class="c0">is defined as Equation 4. </span><span class="c5">5. Theorem 4 gives the </span><span class="c0">(in an asymptotic case, that is, when This is built upon Theorem 4 </span><span class="c5">degree </span><span class="c0">the size </span><span class="c5">distribution </span><span class="c0">of the graph </span><span class="c5">of G[V</span><span class="c0">is large </span><span class="c4">&ge;k</span><span class="c0">] </span><span class="c5">enough). Lemma 5 gives the estimation of the largest degree in G[V</span><span class="c4">&ge;k</span><span class="c0">]. We omit their proofs due to space limitations. </span></p><p class="c3"><span class="c5">T</span><span class="c20">HEOREM </span><span class="c5">4. Given a graph G with degree distribution P = {p</span><span class="c2">0</span><span class="c5">,p</span><span class="c2">1</span><span class="c5">,p</span><span class="c2">2</span><span class="c5">, the </span><span class="c0">has </span><span class="c5">probability </span><span class="c0">degree t. </span><span class="c5">..., </span><span class="c0">Then </span><span class="c5">that p</span><span class="c2">&omega;</span><span class="c5">} </span><span class="c0">we </span><span class="c5">a and vertex </span><span class="c0">have: </span></p><p class="c3"><span class="c5">the chosen maximal uniformly degree &omega; at &isin; random o(|V |). in Let G[Vq</span><span class="c2">t </span><span class="c4">&ge;k</span><span class="c0">] </span><span class="c5">be </span></p><p class="c3"><span class="c5">q</span><span class="c4">t </span><span class="c0">= </span></p><p class="c3"><span class="c0">&sum;</span><span class="c2">&omega;</span><span class="c5">p</span><span class="c4">ii=t </span></p><p class="c3"><span class="c5">()</span><span class="c0">itp</span><span class="c2">t</span><span class="c0">(1 &minus; p)</span><span class="c2">(i&minus;t) </span><span class="c0">(4) </span></p><p class="c3"><span class="c5">where p = </span><span class="c19">&zeta;(k) </span></p><p class="c3"><span class="c2">&zeta;(0) </span><span class="c29">and &zeta;(x) = </span></p><p class="c3"><span class="c4">i=x </span><span class="c0">&sum;</span><span class="c2">&omega;</span><span class="c5">i &times; p</span><span class="c2">i</span><span class="c5">. </span></p><p class="c3"><span class="c5">L</span><span class="c20">EMMA </span><span class="c5">5. For a graph G with the largest degree &omega; and de- gree distribution almost surely </span><span class="c0">where n is the </span><span class="c5">that </span><span class="c0">number </span><span class="c5">P the = {p</span><span class="c2">0</span><span class="c5">,p</span><span class="c2">1</span><span class="c5">,p</span><span class="c2">2</span><span class="c5">, largest </span><span class="c0">of vertices </span><span class="c5">degree </span><span class="c0">in </span><span class="c5">..., </span><span class="c0">G. </span></p><p class="c26"><span class="c5">of p</span><span class="c2">&omega;</span><span class="c5">}. G[VIt </span><span class="c4">&ge;k</span><span class="c0">] </span><span class="c5">holds </span><span class="c0">is &omega; </span><span class="c5">asymptotically </span><span class="c0">as n &rarr; &infin;, </span><span class="c18">4.3 Optimization </span><span class="c5">In this section, we introduce two optimization techniques that improve the performance of the algorithm by reducing n and m . </span></p><p class="c3"><span class="c16">4.3.1 Intelligent Candidate Selection </span><span class="c5">Algorithm 3 is naive in the sense that it blindly chooses vertices </span><span class="c0">from the queue. The following example shows that it may take the </span><span class="c5">naive approach more steps to find a solution. </span></p><p class="c3"><span class="c62">Step 1: C={e} Q={a,c,d,f} Step 2: C={e,a} Q={b,c,d,f} Step 3: C={e,a,f} Q={b,c,d,g,n} ...</span><span class="c86">Step 12: C=V-{n,m} Q={} </span></p><p class="c3"><span class="c5">(a) Naive selection </span></p><p class="c3"><span class="c62">Step 1: C={e} Q={a,c,d,f} Step 2: C={e,a} Q={b,c,d,f} Step 3: C={e,a,d} Q={b,c,f} Step 4: C={e,a,d,b} Q={c,f} Step 5: C={e,a,d,b,c} Q={f} </span></p><p class="c3"><span class="c5">(b) Intelligent selection Figure 4: Naive vs. intelligent candidate generation </span></p><p class="c3"><span class="c5">E</span><span class="c20">XAMPLE </span><span class="c5">7 (C</span><span class="c20">ANDIDATE GENERATION</span><span class="c5">). Consider the graph shown in Figure 1. For query vertex e and CST(3), using the naive candidate generation method, f may be added into C (as shown in </span><span class="c0">the Step 3 of Figure 4(a)), which leads to no valid solution. But </span><span class="c5">the procedure still proceeds until all vertices are exhaustively enu- merated (overall 12 steps are needed). On the other hand, if we </span><span class="c0">always choose the vertex with the largest number of connections to </span><span class="c5">C, a valid solution can be found within 5 steps. The procedures for these two selections are illustrated in Figure 4, where Q is the </span><span class="c0">queue from which the vertex is selected. </span></p><p class="c3"><span class="c5">To reduce n = |C|, we propose two intelligent candidate selec- tion strategies. The basic idea to refine the candidate generation is </span><span class="c0">using priority queue so that we can select the most promising vertex </span><span class="c5">that leads to a solution fast. Theoretically, Lemma 3 can be used to compute the &ldquo;promisingness&rdquo; of a vertex. However, its compu- </span><span class="c0">tation is too costly. We are interested in lightweight heuristics of </span><span class="c5">constant cost. Next, we will propose two intelligent lightweight heuristics. </span><span class="c16">Largest increment of goodness (</span><span class="c5">lg)</span><span class="c16">. </span><span class="c5">Selecting the vertex </span><span class="c0">that leads to the largest increment of the goodness measure is a </span><span class="c5">straight-forward heuristic since the final goal of CST is to find a subset C satisfying &delta;(G[C]) &ge; k. In this strategy the priority of a </span><span class="c0">vertex v, f(v), is defined by </span></p><p class="c3"><span class="c5">f(v) = &delta;(G[C &cup; {v}]) &minus; &delta;(G[C]) (5) </span></p><p class="c3"><span class="c5">It is a greedy approach as it only considers the improvement of &delta;(C) for the next step. Note that at any time when a vertex is added to C, the increment of the goodness of the current C is at most 1. In </span><span class="c0">other words, for any v, we have f(v)=1 or f(v)=0. Hence, this </span><span class="c5">strategy is equivalent to the random selection from vertices which are adjacent to one of the vertices with the minimal degree in C. </span><span class="c16">Largest number of incidence (</span><span class="c5">li</span><span class="c16">). </span><span class="c5">This is a more intelligent </span><span class="c0">selection strategy. The priority of a vertex v is defined as </span></p><p class="c1"><span class="c5">f(v) = deg</span><span class="c4">G[C&cup;{v}]</span><span class="c0">(v) (6) </span><span class="c5">In this strategy, we select the vertex with the largest number of connections to the selected vertices. This yields the fastest increase of the mean degree of G[C]. In general, the lowest degree of a </span><span class="c0">graph will increase with the growth of its density, and consequently </span><span class="c5">a valid solution C with &delta;(G[C]) is expected to be found within a limited number of steps if there exists such a solution. </span><span class="c0">As we have shown in Example 7, these selection strategies gen- </span><span class="c5">erally are quite efficient. However, Example 8 shows that local information generally is not sufficient to construct a valid solution </span><span class="c0">within the WHILE loop. In this case, we need to perform a global </span><span class="c5">search in the k-core of G[C] (line 6) of Algorithm 2. This step ensures a valid solution, as stated in Proposition 4. </span></p><p class="c3"><span class="c5">E</span><span class="c20">XAMPLE </span><span class="c5">8 (H</span><span class="c20">ARDNESS OF SELECTION</span><span class="c5">). Continue Exam- ple 7, by li, it is quite possible that f is selected after e. As a result, even after all vertices are visited, no solution can be found. </span><span class="c16">Complexity Analysis </span><span class="c5">Let n and m denote the number of vertices and the number of </span><span class="c0">edges in G[C], respectively. In general lg and li can be imple- </span><span class="c5">mented in O(n +m log n ) time, because each time a new vertex is added into the queue, at most d queue update operations need to </span><span class="c0">be executed (where d is the degree of this vertex). As a result, at </span><span class="c5">most m update operations will be executed. Each queue operation (insert, delete, or priority update) generally needs O(log n ) time. </span><span class="c0">By careful design, li can be implemented in O(n +m ), achiev- </span><span class="c5">ing O(1) cost of expansion. We maintain a collection of lists each of which, contains vertices of V with the same f(v). Each time a </span><span class="c0">vertex is added to C, the f(&middot;) value of its neighbors (except those </span><span class="c5">already in C) will increase 1. For each of these influenced neigh- bors, we move v from the original f(v)&rsquo;s list to f(v)+1&rsquo;s list. </span><span class="c0">In this manner, we can always find one vertex with maximal f(&middot;) </span></p><p class="c3"><span class="c51">996 </span></p><p class="c3"><span class="c5">in O(1) time. We illustrate the above procedure in Figure 5 and Example 9. </span></p><p class="c3"><span class="c5">Figure 5: An example of the data structure used in li heuristic. </span></p><p class="c1"><span class="c5">E</span><span class="c20">XAMPLE </span><span class="c5">9. Consider the example graph in Figure 1. Sup- pose we have added e and a into C (candidate vertices). Then we have f(b) = f(c) = f(f)=1,f(d)=2. According to the f() </span><span class="c0">function value (i.e. the number of incidence to C), we can orga- </span><span class="c5">nize C&rsquo;s neighbors into two different lists, which are shown in the left part of Figure 5. We also record a pointer to the list with the </span><span class="c0">maximal incidence. The pointer helps find that node d has the most </span><span class="c5">incidences to C (Line 3, Algorithm 3). Then, we move d from its list </span><span class="c0">into C (Line 4, Algorithm 3). And update the two lists by moving </span><span class="c5">b and c from the list f(.)=1 to the list f(.)=2. In this way, we keep the freshness of the lists. </span></p><p class="c3"><span class="c16">4.3.2 Intelligent Expansion </span></p><p class="c26"><span class="c5">We have created a strategy to prune the neighbors we need to visit, i.e. reducing m . The basic idea is to sort the adjacent list </span><span class="c0">of vertices. We use the adjacent list to represent a graph and sort </span><span class="c5">the adjacent list of each vertex into the descending order of de- gree. Then, during candidate generation, when we expand a ver- </span><span class="c0">tex&rsquo;s neighbors (Line 9-11 in Algorithm 3), we stop the expansion </span><span class="c5">immediately when the neighbor has a degree of less than k. Con- sequently, we can avoid the cost of scanning all neighbors. </span><span class="c0">For a vertex with d neighbors, we need O(dlog d) time to or- </span><span class="c5">der its adjacent list. To avoid this cost, we perform the order- ing as a pre-computation step before online query processing. In </span><span class="c0">real life applications such as an online social network, numerous </span><span class="c5">community queries may be issued by users. In these cases, pre- computation to order the adjacent list is desired. When the graph </span><span class="c0">is dynamically evolving, maintaining the order of adjacent lists is </span><span class="c5">of marginal cost. We can use a binary search tree to represent the ordered adjacency list, costing us only O(log(d)) each time the list </span><span class="c0">changes. </span><span class="c5">Clearly, this optimization is only effective for local search and cannot be used to speedup global search. Our experiments show </span><span class="c0">that this optimization boosts local search significantly. </span></p><p class="c3"><span class="c18">5. LOCAL SEARCH FOR CSM </span></p><p class="c3"><span class="c5">The goal of </span><span class="c6">CSM </span><span class="c5">is to find the best community for a given ver- tex. The challenge is that the goodness measure &delta;(&middot;) is not mono- tonic. In Section 4.1, we have shown an exhaustive enumeration </span><span class="c0">approach. But it is of exponential complexity. In Section 2.2, we </span><span class="c5">introduced a method for solving </span><span class="c6">CSM </span><span class="c5">by repeatedly calling </span><span class="c6">CST</span><span class="c5">. In this section, we devise a more efficient, bottom-up solution. The </span><span class="c0">algorithm takes 3 steps. First, it expands the search space from the </span><span class="c5">query vertex v</span><span class="c4">0</span><span class="c0">. Second, it generates a candidate vertex set C in </span><span class="c5">the search space. Third, it invokes the maximum core method to </span><span class="c0">find the final solution in the candidate set. </span><span class="c18">5.1 Expanding the Search Space </span><span class="c5">In this step (line 1 to 15 of Algorithm 4), our goal is to expand </span><span class="c0">the search space and find a subset H whose &delta;(G[H]) is as large as </span><span class="c5">possible while pruning as many invalid vertices as possible under the linear cost. We start with v</span><span class="c2">0</span><span class="c5">, and at each step we select the </span><span class="c0">vertex that is the local optimal and add it into the current result </span><span class="c5">set. Here, we use the li (largest number of incidence) strategy to select the local optimal vertex (line 6 to 7). Then, at the end of </span><span class="c0">each iteration, we know that any vertex whose degree is smaller </span><span class="c5">than &delta;(G[H]) + 1 cannot appear in any better solution. Thus, in line 14, we expand the set of vertices we need to visit by using H </span><span class="c0">for filtering. </span></p><p class="c3"><span class="c5">Algorithm 4 A local-search framework to solve </span><span class="c6">CSM </span><span class="c21">Input: a graph G(V,E), v</span><span class="c4">0 </span><span class="c11">, &minus;&infin; &lt;&gamma;&lt; &infin; Output: H {Step 1: Iterative searching and filtering.} </span><span class="c0">1: </span><span class="c11">H &larr; &empty; /* the best solution found so far */ </span><span class="c0">2: </span><span class="c11">A &larr; {v</span><span class="c4">0</span><span class="c11">} /* vertices we have visited */ </span><span class="c0">3: </span><span class="c11">B &larr; {v|(v, v</span><span class="c4">0</span><span class="c11">) &isin; E} /* vertices we need to visit */; </span><span class="c0">4: </span><span class="c11">s &larr; 0 </span><span class="c5">5: </span><span class="c21">while B = &empty; and s &le; e</span><span class="c19">&minus;&gamma;</span><span class="c21">(&lfloor; </span><span class="c19">|E|&minus;|V | </span></p><p class="c3"><span class="c2">(&delta;(G[H])+1)/2&minus;1</span><span class="c67">&rfloor;&minus;|H|) do </span><span class="c5">6: </span><span class="c21">Let v be the vertex with most links to A from B; </span><span class="c0">7: </span><span class="c11">s &larr; s + 1; A &larr; A &cup; {v}; B &larr; B &minus; {v}; </span><span class="c0">8: </span><span class="c11">if &delta;(A) &gt; &delta;(H) then </span><span class="c0">9: </span><span class="c11">H &larr; A;s &larr; 0; </span><span class="c5">10: </span><span class="c21">if &delta;(H) = min{deg</span><span class="c4">G</span><span class="c21">(v</span><span class="c4">0</span><span class="c11">), &lfloor;</span><span class="c2">1+</span><span class="c67">&radic;</span><span class="c2">9+8(|E|&minus;|V |) </span></p><p class="c3"><span class="c2">2 </span><span class="c67">&rfloor;} then </span><span class="c5">11: </span><span class="c21">Return H; </span><span class="c0">12: </span><span class="c11">end if </span><span class="c0">13: </span><span class="c11">end if </span><span class="c0">14: </span><span class="c11">Add v&rsquo;s neighbors with degree larger than &delta;(G[H]) into B; </span><span class="c0">15: </span><span class="c11">end while {Step 2: Generating candidates} </span><span class="c0">16: </span><span class="c11">C &larr; Generate candidate vertex set based on H or A; {Step 3: Finding the solution} </span><span class="c0">17: </span><span class="c11">H &larr; maxcore(G[C],v</span><span class="c4">0</span><span class="c11">); </span><span class="c0">18: </span><span class="c11">return H; </span></p><p class="c3"><span class="c5">One critical question is when we can stop expanding the search. Clearly, H is the optimal solution if </span></p><p class="c3"><span class="c5">&delta;(H) = min{deg</span><span class="c2">G</span><span class="c5">(v</span><span class="c2">0</span><span class="c5">),&lfloor;</span><span class="c29">1 + &radic;</span><span class="c5">9 + 8(|E|&minus;|V |) </span></p><p class="c1"><span class="c5">2 </span><span class="c29">&rfloor;} (7) </span><span class="c5">However, Equation 7 is a sufficient but not necessary condition. For </span><span class="c0">instance, if an invalid vertex is introduced into H in the early stage </span><span class="c5">of expansion, H may never reach the upper bound, even if it already contains the optimal solution. To solve this problem, we introduce </span><span class="c0">another upper bound. We consider the extra number of vertices </span><span class="c5">that need to be added into the current H in order to improve the minimum degree of G[H], given that a better solution that contains </span><span class="c0">the current H exists. This upper bound is given by Corollary 1, </span><span class="c5">which is derived from Theorem 5. </span></p><p class="c3"><span class="c5">T</span><span class="c20">HEOREM </span><span class="c5">5. Let G(V,E) be a connected graph, and v &isin; V </span><span class="c0">be the query vertex. If H is a solution to </span><span class="c28">CST</span><span class="c0">(k), we have </span></p><p class="c3"><span class="c5">|H|&le;&lfloor;</span><span class="c29">|E|&minus;|V | </span></p><p class="c3"><span class="c5">k/2 &minus; 1 </span><span class="c29">&rfloor; </span></p><p class="c1"><span class="c5">P</span><span class="c20">ROOF</span><span class="c5">. Since G is connected, we have |E|&ge;|V | &minus; 1. Also, G[H] has at least k|H|/2 edges. There exist at least |V |&minus;|H| </span><span class="c0">edges incident with vertices in V &minus; H to maintain the connectivity </span><span class="c5">of graph G. Hence, we have k &middot; |H|/2 + |V |&minus;|H|&le;|E|, which leads to |H| &le; </span><span class="c19">|E|&minus;|V | </span></p><p class="c3"><span class="c2">k/2&minus;1 </span><span class="c29">. </span></p><p class="c1"><span class="c5">C</span><span class="c20">OROLLARY </span><span class="c5">1. Let G(V,E) be a connected graph, and let H be the current optimal solution found so far in Algorithm 4, if there </span><span class="c0">exists H &sup; H such that &delta;(G[H ]) = &delta;(G[H]) + 1, we need to </span><span class="c5">add at most </span></p><p class="c3"><span class="c5">&lfloor; </span><span class="c29">|E|&minus;|V | </span></p><p class="c3"><span class="c5">(&delta;(G[H]) + 1)/2 &minus; 1</span><span class="c29">&rfloor;&minus;|H| </span></p><p class="c3"><span class="c5">vertices to find H . </span></p><p class="c26"><span class="c5">From Corollary 1, we can see that the larger &delta;(G[H]), the tighter the upper bound. So this upper bound has better pruning power </span><span class="c0">when the solution has larger m</span><span class="c2">&lowast;</span><span class="c0">. </span><span class="c5">Given the above upper bound, we use two parameters s and &gamma; (the latter is exposed to users) to control the searching space. The </span><span class="c0">value of s denotes the number of vertices that have been added to </span><span class="c5">H (see line 7 and line 9). In line 5, we use </span></p><p class="c3"><span class="c5">s &le; e</span><span class="c19">&minus;&gamma;</span><span class="c5">(&lfloor; </span><span class="c29">|E|&minus;|V | </span></p><p class="c3"><span class="c5">(&delta;(G[H]) + 1)/2 &minus; 1</span><span class="c29">&rfloor;&minus;|H|) (8) </span></p><p class="c3"><span class="c51">997 </span></p><p class="c3"><span class="c5">with &minus;&infin; &lt;&gamma;&lt; &infin; to control the search space. We terminate the search when the upper bound is reached. Note that when &gamma; = 0, Eq 8 degrades into the exact bound given in Corollary 1. When </span><span class="c0">&gamma; &gt; 0, the number of extra vertices that will be added into H will </span><span class="c5">be less than the exact bound. When &gamma; &rarr; &minus;&infin;, no constraint on s is specified. We will come back to these parameters after the </span><span class="c0">introduction of following steps of the algorithm. </span><span class="c18">5.2 Generating Candidates </span><span class="c5">In the second step, we generate a candidate set from H obtained </span><span class="c0">in the first step. Specifically, we propose two solutions to generate </span><span class="c5">C (line 16), and we analyze the tradeoff between their quality and performance. Let C</span><span class="c2">naive</span><span class="c5">(k) be the result of Algorithm 3. That is, </span><span class="c0">C</span><span class="c4">naive</span><span class="c0">(k) is the set of vertices obtained by iteratively removing </span><span class="c5">vertex of degree less than k from the neighborhood of vertex v</span><span class="c4">0</span><span class="c0">. </span></p><p class="c3"><span class="c16">Solution 1: </span><span class="c5">C &larr; A</span><span class="c16">. </span><span class="c5">In this case, we have the following result: </span></p><p class="c3"><span class="c5">T</span><span class="c20">HEOREM </span><span class="c5">6. Given graph G and a query vertex v</span><span class="c4">0</span><span class="c0">, when &gamma; &rarr; </span><span class="c5">&minus;&infin;, Algorithm 4 finds an optimal solution for </span><span class="c6">CSM</span><span class="c5">. </span></p><p class="c1"><span class="c5">P</span><span class="c20">ROOF</span><span class="c5">. Consider when the WHILE loop exists in Algorithm 4. Let k = &delta;(G[H]). Clearly, we have m</span><span class="c19">&lowast;</span><span class="c5">(G, v</span><span class="c2">0</span><span class="c5">) &ge; k. We have </span><span class="c0">C</span><span class="c4">naive</span><span class="c0">(k) &sube; A. Then, we have C</span><span class="c4">naive</span><span class="c0">(m</span><span class="c2">&lowast;</span><span class="c0">(G, v</span><span class="c4">0</span><span class="c0">)) &sube; C</span><span class="c4">naive</span><span class="c0">(k). </span><span class="c5">Thus C</span><span class="c4">naive</span><span class="c0">(m</span><span class="c2">&lowast;</span><span class="c0">(G, v</span><span class="c4">0</span><span class="c0">)) &sube; A. Thus maxcore(G[A],v</span><span class="c4">0</span><span class="c0">) is an </span><span class="c5">optimal solution. </span></p><p class="c1"><span class="c5">When C &larr; A, Algorithm 4 also allows us to trade quality for performance by tuning parameter &gamma;. Specifically, when &gamma; is closer to &minus;&infin;, the solution is of higher quality; when &gamma; is closer to &infin;, </span><span class="c0">better performance can be achieved. We will discuss more about </span><span class="c5">this tradeoff in the experiments section. </span></p><p class="c3"><span class="c16">Solution 2: </span><span class="c5">C &larr; C</span><span class="c4">naive</span><span class="c0">(k)</span><span class="c87">. </span><span class="c0">Here, k = &delta;(G[H]). </span></p><p class="c3"><span class="c5">T</span><span class="c20">HEOREM </span><span class="c5">7. Given graph G and query vertex v</span><span class="c4">0</span><span class="c0">, Algorithm 4 </span><span class="c5">always finds an optimal solution: maxcore(G[C</span><span class="c2">naive</span><span class="c5">(k)],v</span><span class="c2">0</span><span class="c5">), </span><span class="c0">where k = &delta;(G[H]). </span></p><p class="c1"><span class="c5">P</span><span class="c20">ROOF</span><span class="c5">. For a graph G and a query vertex v</span><span class="c2">0</span><span class="c5">, C</span><span class="c2">naive</span><span class="c5">(k) be- </span><span class="c0">comes larger when k becomes smaller. Hence, for any k with </span><span class="c5">&le; m</span><span class="c19">&lowast;</span><span class="c5">(G, v</span><span class="c4">0</span><span class="c0">), C</span><span class="c4">naive</span><span class="c0">(k) contains all valid vertices. Since Al- </span><span class="c5">gorithm 4 will only return a subset H &sube; V with k = &delta;(G[H]) </span><span class="c0">no larger than m</span><span class="c2">&lowast;</span><span class="c0">(G, v</span><span class="c4">0</span><span class="c0">), maxcore(C</span><span class="c4">naive</span><span class="c0">(k),v</span><span class="c4">0</span><span class="c0">) is the optimal </span><span class="c5">solution of </span><span class="c6">CSM</span><span class="c5">(G, v</span><span class="c4">0</span><span class="c0">). </span></p><p class="c1"><span class="c5">Note that the choice of &gamma; has no influence on the quality of the </span><span class="c0">solution, but it may influence the running time. In general, when </span><span class="c5">&gamma; &rarr; &minus;&infin;, it is quite possible to find a complete solution or at least a good partial solution before the second step since we have given </span><span class="c0">enough number of tries to find a good H. However, this comes at </span><span class="c5">high cost of run time. If a solution is already found, or a partial solution is found in the first step, the maxcore procedure will be </span><span class="c0">unnecessary or use little time. Hence, it is possible for the existence </span><span class="c5">of an optimal &gamma; leading to the minimal running time. We will show this in the experiment section. </span><span class="c0">Finally, we highlight that Algorithm 4, under a different imple- </span><span class="c5">mentation strategy, runs in O(|V | + |E|) time in the worst case. However, in general, similar to </span><span class="c6">CST</span><span class="c5">, in </span><span class="c6">CSM </span><span class="c5">a smaller number of </span><span class="c0">vertices are expected to be visited for an optimal solution in our </span><span class="c5">local-search solutions than their global search competitors. </span></p><p class="c3"><span class="c18">6. EXPERIMENTS </span><span class="c5">In this section, we use experiments on real life graphs to show </span><span class="c0">the effectiveness and efficiency of our local search method. We also </span><span class="c5">conduct experiments on synthetic graphs to show its scalability. We implemented all of the algorithms in C++ and ran the experiments on a PC with AMD Athlon</span><span class="c19">TM</span><span class="c5">X2 Dual-core QL-62 at 2GHz, 2G </span><span class="c0">memory. </span></p><p class="c3"><span class="c18">6.1 Experiments on Real Life Graphs </span></p><p class="c3"><span class="c16">6.1.1 Datasets </span></p><p class="c1"><span class="c5">We used four real life large graphs in our experiments: DBLP, Berkeley, Youtube, and LiveJournal. DBLP is an author collabo- </span><span class="c0">ration network, where each vertex represents an author and each </span><span class="c5">edge represents a coauthor relationship. Berkeley is a web graph with nodes representing pages from berkeley.edu and stanford.edu </span><span class="c0">domains and edges representing hyperlinks between them. We ig- </span><span class="c5">nored the direction of the links. Youtube [11] is a user-to-user link network. LiveJournal is an online social network. For each dataset, </span><span class="c0">we only consider the largest connected component. The statistics </span><span class="c5">of degree these of graphs the maximal are reported core of in this Table graph 2, where is given the as minimal &delta;</span><span class="c19">&lowast;</span><span class="c5">(G). </span></p><p class="c3"><span class="c5">vertex </span></p><p class="c3"><span class="c21">Network #Vertex # Edge &delta;</span><span class="c19">&lowast;</span><span class="c21">(G) Opt.(ms) k=20 40 60 DBLP 481K 1.72M 114 703 0 0 0 </span><span class="c11">Berkeley 654K 6.58M 202 2328 9 0 0 Youtube 1.1M 3M 52 1359 0 0 0 LiveJournal 4.0M 34.7M 360 2381 0 0 0 </span><span class="c5">Table 2: Basic information of real dataset </span><span class="c16">6.1.2 Case Study </span><span class="c5">We presented two case studies to justify the minimal degree based </span><span class="c0">community search. The first is on DBLP. We used &quot;Jiawei Han&quot;, </span><span class="c5">who is a renowned scientist in Data Mining, as the query vertex. After setting k = 5, we got the community shown in Figure 6(a) </span><span class="c0">using ls &minus; li. We found that these six authors are all leading sci- </span><span class="c5">entists in data mining community and their cooperation is very fre- quent. For example, Jiawei Han and Jian Pei have coauthored over </span><span class="c0">37 papers, and Haixun Wang has coauthored with Philip S. Yu and </span><span class="c5">Jian Pei over 46 and 15 papers, respectively. The second case study is on WordNet. WordNet is a semantic </span><span class="c0">network, in which each vertex represents a specific sense, and each </span><span class="c5">edge represents a certain semantic relationship between senses. In this case study, </span><span class="c0">k = 3, we got </span><span class="c5">we </span><span class="c0">the </span><span class="c5">used </span><span class="c0">community </span><span class="c5">the word </span><span class="c0">shown </span><span class="c5">pot as </span><span class="c0">in </span><span class="c5">v</span><span class="c2">0</span><span class="c5">. </span><span class="c0">Figure </span><span class="c5">Using </span><span class="c0">6(b). </span><span class="c5">ls </span><span class="c0">We </span><span class="c5">&minus; li </span><span class="c0">found </span><span class="c5">with that the senses in the community are highly related in semantic: all of them are about the vessel. pot, bowl, dish are some vessel </span><span class="c0">entity. vessel and container are two hypernyms of those entities. </span><span class="c5">And containerful is an adjective word related to containers. </span></p><p class="c3"><span class="c33">Jiawei </span><span class="c22">Han </span></p><p class="c63"><span class="c33">Roberto </span><span class="c65">Wei </span><span class="c33">Philip </span><span class="c22">Battiti </span><span class="c65">Wang </span><span class="c22">S. Yu </span></p><p class="c3"><span class="c33">Jian </span><span class="c22">Pei </span></p><p class="c3"><span class="c33">Ke</span><span class="c22">Wang </span><span class="c5">(a) </span><span class="c0">nity </span></p><p class="c3"><span class="c5">Jiawei&rsquo;s commu- </span><span class="c40">vessel </span><span class="c27">container </span></p><p class="c3"><span class="c40">bowl </span></p><p class="c26"><span class="c27">contai </span><span class="c40">dish </span><span class="c34">nerful </span><span class="c5">(b) </span><span class="c0">&quot;Pot&quot; </span><span class="c5">Community for Figure 6: The effectiveness of community search. </span><span class="c16">6.1.3 Results for CST </span></p><p class="c1"><span class="c5">We evaluate the efficiency of our local search solutions for CST by comparing it with the global search solution introduced in Sec- </span><span class="c0">tion 2. We denote the global search as global, and we denote the </span><span class="c5">three versions of local search, i.e., the local search with naive can- didate generation, li, and lg as ls-naive, ls-li and ls-lg respectively. </span><span class="c0">Solutions to CST are sensitive to the input parameter k. To eval- </span><span class="c5">uate the with k performance of different solutions, = s,2s,3s, ...,8s, where s = &delta;</span><span class="c19">&lowast;</span><span class="c5">we (G)/10. tested each For each method k, </span><span class="c0">we randomly selected 100 vertices as the query vertex from the k- </span><span class="c5">core of the graph so that there was always a meaningful solution containing the query vertex. Then, we averaged the query time of </span><span class="c0">these 100 query vertices. </span><span class="c16">Baseline solution. </span><span class="c5">We first showed that the baseline solution in general is costly on big graphs. For each real network, we selected </span><span class="c0">k = 20,40,60. For each k, we randomly selected 100 vertices </span></p><p class="c3"><span class="c51">998 </span></p><p class="c3"><span class="c40">pot </span></p><p class="c3"><span class="c33">Haixun Wang </span></p><p class="c1"><span class="c5">with a degree of no less than k as the query vertex. We recorded in the last three columns of Table 2 the number of vertices for which the query result can be returned within 1 minute. The results show </span><span class="c0">that in most cases the baseline solution cannot produce result in the </span><span class="c5">given time. Hence, in the following experiments, it will be omitted. </span><span class="c16">Efficiency of off-line ordering. </span><span class="c5">We first justified the opti- </span><span class="c0">mization of local search by ordering the adjacency list. We just give </span><span class="c5">the results on DBLP data. Similar results on other real life graphs were obtained and omitted to save space. In Figure 7, we compare </span><span class="c0">local search with optimization (opt) to local search without opti- </span><span class="c5">mization (non-opt). We can see that, for both ls-li and ls-lg under most parameter values of k, the optimization technique brings an </span><span class="c0">obvious speedup. The optimization technique has a linear cost as </span><span class="c5">it only requires sorting the adjacent list of each vertex. For exam- ple, as reported in Table 2, for DBLP data, it only incurs 703ms. </span><span class="c0">Hence, in all the following experiments, all local search solutions </span><span class="c5">are optimized in this way. </span></p><p class="c3"><span class="c12">ls-li(opt) </span><span class="c8">120 </span><span class="c14">ls-li(non-opt) </span></p><p class="c3"><span class="c8">80 40 </span><span class="c12">0 11 22 33 44 55 66 77 88 99110 </span></p><p class="c3"><span class="c5">(a) ls-li </span></p><p class="c3"><span class="c8">600 </span></p><p class="c3"><span class="c12">ls-lg(opt) </span><span class="c14">ls-lg(non-opt) </span></p><p class="c3"><span class="c8">) sm(emi</span><span class="c12">T</span><span class="c8">) </span></p><p class="c3"><span class="c8">sm(emi</span><span class="c12">T</span><span class="c8">400 200 </span><span class="c12">0 11 22 33 44 55 66 77 88 99110 k </span></p><p class="c26"><span class="c12">k </span><span class="c5">(b) ls-lg Figure 7: The effectiveness of the optimization technique. </span></p><p class="c3"><span class="c16">Performance for CST. </span><span class="c5">We show the performance (mean run- </span><span class="c0">ning time as well as its std) of local search solutions for CST in </span><span class="c5">Figure 8. We can see that, in general, local search performs better than global search in most cases. When k increases, the advantage </span><span class="c0">of local search over global search becomes more obvious. In the </span><span class="c5">best case, for example when k is large on DBLP and Berkeley, ls-li or ls-lg is two orders of magnitudes faster than global search. Only </span><span class="c0">when k is small, global search is comparable to naive local search </span><span class="c5">and the two optimized local search solutions. The reason is that when k is small, most vertices in the graph tend to be involved in </span><span class="c0">the answer, which favors global search. We can also see that among </span><span class="c5">all strategies of local search, in most cases, ls-li performs the best. The running time for ls-li almost monotonically decreases with the </span><span class="c0">growth of k. This implies li is quite effective when k is large. </span><span class="c5">The stds show that the global approach is the most stable algo- rithm. This is because the search space of the global algorithm is </span><span class="c0">always the entire graph. In contrast, the local search solutions need </span><span class="c5">to search the entire graph only when the search within the local neighborhoods fails. That is to say, in most cases, local search so- </span><span class="c0">lution returns results quite fast. Only in some rare cases, its running </span><span class="c5">time is close to global solution (but will not be worse than global search). That is why our solution has larger stds. From the ex- </span><span class="c0">perimental results, we also can see that even considering the worst </span><span class="c5">case, that is mean running time+ std, ls &minus; li is better than global in most cases. </span><span class="c0">In some rare cases, for example in Figure 7(c), the global algo- </span><span class="c5">rithm is better than ls&minus;lg or ls&minus;naive. The reason is that ls&minus;lg and ls &minus; naive are not very intelligent. Their search spaces al- </span><span class="c0">though are less than the global one, in many cases are close to the </span><span class="c5">global one. Furthermore, in general local search solutions need to select the best vertex from candidates, which adds extra computa- </span><span class="c0">tion cost. Consequently, ls &minus; lg or ls &minus; naive may consume more </span><span class="c5">running time. Similar results can be found from Figure 8(b), 8(c) and they can be explained similarly </span><span class="c16">Influence of small k on local search. </span><span class="c5">To take a close look at the influence of small k (from 1 to 10), we conducted more ex- periments, the results of which are shown in Figure 9. It is quite </span><span class="c0">interesting to note that when k is extremely small, local search is </span></p><p class="c3"><span class="c49">10 </span><span class="c23">10000 1000 </span></p><p class="c3"><span class="c23">1000 100 10 </span><span class="c8">) sm(emi</span><span class="c12">T</span><span class="c23">100 </span><span class="c49">1 11 22 33 44 55 66 77 88 </span></p><p class="c3"><span class="c49">20 40 60 80 100 120 140 160 </span></p><p class="c3"><span class="c0">(b) Berkeley </span><span class="c12">k </span><span class="c23">10000 </span></p><p class="c3"><span class="c23">1000 </span><span class="c49">100 5 10 15 20 25 30 35 40 </span></p><p class="c3"><span class="c49">100000 </span></p><p class="c3"><span class="c8">) sm(emi</span><span class="c12">T</span><span class="c49">36 72 108 144 180 216 252 288 </span></p><p class="c3"><span class="c0">(d) LiveJournal </span><span class="c12">k </span><span class="c5">Figure 8: The efficiency of different solutions to CST </span></p><p class="c3"><span class="c23">1000 900 800 700 600 500 400 300 200 100 </span><span class="c49">0 1 2 3 4 5 6 7 8 </span></p><p class="c3"><span class="c23">10000 </span></p><p class="c3"><span class="c23">1000 </span><span class="c49">100 </span><span class="c23">1000 </span><span class="c60">global </span><span class="c57">ls-naive ls-li </span><span class="c23">900 800 </span><span class="c8">) sm(emi</span><span class="c12">T</span><span class="c60">global </span><span class="c57">ls-naive ls-li </span><span class="c8">) sm(emi</span><span class="c12">T</span><span class="c57">ls-lg</span><span class="c0">(a) DBLP </span></p><p class="c3"><span class="c12">k </span></p><p class="c3"><span class="c8">) sm(emi</span><span class="c12">T</span><span class="c0">(c) Youtube </span></p><p class="c3"><span class="c12">k </span><span class="c57">ls-lg</span><span class="c8">) </span></p><p class="c3"><span class="c8">sm(emi</span><span class="c12">T</span><span class="c23">700 600 500 400 300 200 100 </span><span class="c49">0 1 2 3 4 5 6 7 8 </span></p><p class="c3"><span class="c0">(a) DBLP </span></p><p class="c3"><span class="c12">k </span></p><p class="c3"><span class="c0">(b) Berkeley </span><span class="c12">k </span><span class="c23">3000 </span></p><p class="c3"><span class="c23">50000 </span></p><p class="c3"><span class="c23">2500 40000 </span><span class="c8">) sm(emi</span><span class="c12">T</span><span class="c23">2000 1500 1000 30000 20000 500 10000 </span><span class="c49">0 0 1 2 3 4 5 6 7 8 </span></p><p class="c3"><span class="c49">1 2 3 4 5 6 7 8 </span></p><p class="c3"><span class="c0">(c) Youtube </span></p><p class="c3"><span class="c12">k </span><span class="c8">) </span></p><p class="c3"><span class="c8">sm(emi</span><span class="c12">T</span><span class="c0">(d) LiveJournal </span><span class="c12">k </span><span class="c5">Figure 9: Performance of CST for small k </span></p><p class="c3"><span class="c5">significantly better than global search (it outperforms global search by two orders of magnitude). This is because when k is extremely small, local search tends to find smaller communities. For exam- </span><span class="c0">ple, when k = 1, any edge incident with the query vertex will be </span><span class="c5">immediately returned as an answer; when k = 2, any cycle con- </span><span class="c0">taining the query vertex is an answer. In summary, local search is </span><span class="c5">consistently better than global search across a wide range of k. </span><span class="c16">Performance over arbitrary vertices. </span><span class="c5">In the above exper- iments, the query vertices come from k-core, which means that a </span><span class="c0">valid community certainly exists. In this experiment, we tested the </span><span class="c5">performance over arbitrary vertices for which a valid community does not necessarily exist. We randomly select 100 query vertices </span><span class="c0">whose degree is no less than k from DBLP (otherwise we can surely </span><span class="c5">find no community for these vertices). We compare the best of lo- cal search solutions ls&minus;li to the global search. The result is shown </span><span class="c0">in Figure 10. Similar to previous experiment results, local search is </span><span class="c5">better than global search in almost all the cases. When k grows, the search space of local search becomes smaller. As a result, the mean </span><span class="c0">running time of local search decreases. Instead, the global search is </span><span class="c5">not aware of k and consistently consumes almost the same running time. </span></p><p class="c1"><span class="c16">Rationale of local search. </span><span class="c5">To understand the rationale of lo- cal search, we report the answer size and the number of visited </span><span class="c0">vertices in the search. We show the results for DBLP in Figure 13 </span><span class="c5">(results on other real networks are similar and are omitted to save space). We can see that the local search method tends to produce a </span><span class="c0">small community. In some cases, the community found by ls-li or </span></p><p class="c3"><span class="c51">999 </span></p><p class="c3"><span class="c46">1 </span><span class="c15">1000 </span></p><p class="c3"><span class="c46">global </span><span class="c72">lsli </span><span class="c78">) sm(emi</span><span class="c13">T</span><span class="c15">100 10 </span><span class="c46">11 22 33 44 55 66 77 88 99 110 </span><span class="c5">Figure 10: Performance </span><span class="c13">k </span></p><p class="c3"><span class="c5">over arbitrary vertices </span></p><p class="c1"><span class="c5">ls-lg is an order of magnitude smaller than that produced by global </span><span class="c0">search and ls-naive. The comparison of the number of visited ver- </span><span class="c5">tices shows that local search visits a much smaller number of ver- tices than global search. In many cases, local search outperforms </span><span class="c0">global search by two orders of magnitude. Both smaller answer </span><span class="c5">sizes and a fewer number of visited vertices explain the advantage of local search over global search. </span></p><p class="c3"><span class="c16">6.1.4 Results for CSM </span></p><p class="c3"><span class="c5">Recall that there are two local search solutions to CSM. We de- note the one that generates C by C &larr; A as CSM1, and the other as CSM2. We also compare them with global. In local search, </span><span class="c0">we present the results of li only, since previous results have already </span><span class="c5">shown its efficiency and effectiveness. </span><span class="c16">Performance for CSM. </span><span class="c5">For CSM1, we can trade the quality of the solution for performance by tuning parameter &gamma;. For the </span><span class="c0">sake of fair comparison, we set &gamma; &rarr; &minus;&infin; such that CSM1 is not </span><span class="c5">constrained by size s. The result is shown in Figure 11. From the comparisons, we can see that CSM2 performs the best. CSM1 </span><span class="c0">consumes the most time since we remove the size constraint of s, </span><span class="c5">which means that the search procedure will exhaustively search a huge space. In the next experiment, we will show that by tuning &gamma;, </span><span class="c0">CSM1 can run much faster than global search without sacrificing </span><span class="c5">the quality. </span><span class="c16">Effect of </span><span class="c5">&gamma; </span><span class="c16">on </span><span class="c5">CSM1</span><span class="c16">. </span><span class="c5">For CSM1, &gamma; controls the tradeoff be- </span><span class="c0">tween quality and performance. We ran CSM1 with &gamma; varying </span><span class="c5">from 1 to 15 to observe the change in quality and run time. The quality of CSM1 is measured by </span></p><p class="c3"><span class="c5">r</span><span class="c4">a </span><span class="c0">= &Sigma;</span><span class="c4">v</span><span class="c32">0</span><span class="c5">&delta;(H )/&Sigma;</span><span class="c4">v</span><span class="c32">0</span><span class="c5">&delta;(H) , where H is the answer found by CSM1, H is one of the op- </span><span class="c0">timal answers found by a global search, and the &Sigma; runs over all </span><span class="c5">randomly selected query vertices. We also summarize the time ef- ficiency measured by</span><span class="c0">r</span><span class="c4">t </span><span class="c0">= &Sigma;</span><span class="c4">v</span><span class="c32">0</span><span class="c5">t</span><span class="c2">1</span><span class="c5">(v</span><span class="c2">0</span><span class="c5">)/&Sigma;</span><span class="c2">v</span><span class="c32">0</span><span class="c5">t</span><span class="c2">2</span><span class="c5">(v</span><span class="c2">0</span><span class="c5">) , where is the run t</span><span class="c4">1</span><span class="c0">(v</span><span class="c5">time </span><span class="c4">0</span><span class="c0">) is </span><span class="c5">of </span><span class="c0">the </span><span class="c5">the </span><span class="c0">run </span><span class="c5">global </span><span class="c0">time of </span><span class="c5">search, </span><span class="c0">CSM1 </span><span class="c5">and </span><span class="c0">for </span><span class="c5">the </span><span class="c0">query </span><span class="c5">summarization </span><span class="c0">vertex v</span><span class="c4">0</span><span class="c0">, t</span><span class="c4">2</span><span class="c0">(v</span><span class="c5">runs </span><span class="c4">0</span><span class="c0">) over all sampled query vertices. </span></p><p class="c1"><span class="c5">The tradeoff between quality and performance is shown in Fig- ure 14. As expected, both performance and quality decrease with </span><span class="c0">the growth of &gamma;. However, performance drops drastically faster </span><span class="c5">than quality. As a result, even running for a short duration, the quality produced by CSM1 still remains almost at one hounded of </span><span class="c0">percent, especially for DBLP and Berkeley. For each of the three </span><span class="c5">networks, we can observe a critical point (identified by the dotted line), before which a minor drop of solution quality will bring us a </span><span class="c0">significant improvement of performance. The above results clearly </span><span class="c5">show that the trading of quality for performance in CSM1 is quite effective. In real applications, users can specify &gamma; based on their </span><span class="c0">requirement for the tradeoff between performance and accuracy. </span></p><p class="c1"><span class="c16">Effect of </span><span class="c5">&gamma; </span><span class="c16">on </span><span class="c5">CSM2</span><span class="c16">. </span><span class="c5">From Figure 15, we observe that for </span><span class="c0">each graph there is a certain &gamma; that leads to the minimal overall run </span><span class="c5">time of CSM2. The influence of &gamma; on the performance of CSM2 generally depends on the network structure. It seems that Berkeley </span><span class="c0">is more sensitive to &gamma; than the other two networks. However, our </span></p><p class="c3"><span class="c41">a</span><span class="c66">e zisy tinummoce garev</span><span class="c41">degree </span></p><p class="c3"><span class="c5">Figure 12: Community size vs </span><span class="c0">vertex degree on DBLP </span><span class="c5">results show that generally when 4 &le; &gamma; &le; 12, minimal run time of </span><span class="c0">CSM2 can be achieved. </span><span class="c16">Selection of </span><span class="c5">&gamma;</span><span class="c16">. </span><span class="c5">Next, we give guidelines for selecting an ap- propriate &gamma; for a query vertex when solving CSM. In general, the selection of &gamma; depends on the size of the resulting community, </span><span class="c0">which is determined by the local structure near the query vertex. </span><span class="c5">The larger the community size, the larger the search space. Hence, &gamma; should be tuned accordingly. However, it is hard to know the </span><span class="c0">exact community size before a local search is executed. We found </span><span class="c5">that, through the empirical analysis of DBLP data, the degree of the query vertex is a good hint of the vertex&rsquo;s community size. We </span><span class="c0">used global search to find a maximal community for a query ver- </span><span class="c5">tex in DBLP. For each degree, we randomly selected 10 vertices and recorded their average community size. The results are shown </span><span class="c0">in Figure 12. We observe that the community size generally de- </span><span class="c5">creases when the degree of the query vertex increases. Hence, we should choose a smaller &gamma; when the query vertex has a large degree </span><span class="c0">(recall that smaller &gamma; leads to larger search space). </span></p><p class="c3"><span class="c18">6.2 Experiments on Synthetic Networks </span></p><p class="c1"><span class="c5">To test the scalability and the sensitivity-to-community-structure of our solutions, we generated a collection of synthetic networks. Community search is meaningless on a network without commu- </span><span class="c0">nity structures, hence we used a generator [12] that can generate </span><span class="c5">synthetic graphs with a varying degree of &quot;clearness&quot; of commu- nity structure. It generates a graph using three parameters &alpha;, &beta;, </span><span class="c0">and &mu;. The degree and the community size follow the power-law </span><span class="c5">distribution with exponent &minus;&alpha; and &minus;&beta;, respectively. Parameter &mu; indicates the proportion of a vertex&rsquo;s neighbors that reside in other </span><span class="c0">communities. Clearly, by tuning &mu;, we can vary the clearness of </span><span class="c5">the community structure of the generated synthetic network. Since ls-li is the most efficient local search method, in the following ex- </span><span class="c0">periment, the results of the local search are produced by ls-li. </span><span class="c16">Scalability. </span><span class="c5">Using the above network model, we generated an ensemble of synthetic networks with size varying from 200K to 1M with &alpha; = 2,&beta; = 3,&mu; = 0.1. </span><span class="c0">The scalability results of the local search are shown in Figure 16. </span><span class="c5">We found that ls-li, CSM1, and CSM2 are consistently more ef- ficient than a global search even on graphs with millions of ver- </span><span class="c0">tices. Note that the result for CSM1 was obtained with 100% ac- </span><span class="c5">curacy (we omitted the accuracy result). The efficiency of CSM1 is quite impressive since it consistently outperforms a global search </span><span class="c0">by about three orders of magnitude without sacrificing the accuracy. </span><span class="c5">We also found that the run time of local search grows more slowly than global search when the graph size increases. In some cases, for </span><span class="c0">example in CST, the advantage of a local search over global search </span><span class="c5">is even more obvious when the graph is larger. These observations verify that a global search needs to visit all vertices. In contrast, a </span><span class="c0">local search only needs to visit the limited neighborhoods around </span><span class="c5">the query vertex. When the neighborhood grows more slowly than the whole graph size, a local search is certainly more efficient than </span><span class="c0">a global search. </span><span class="c16">Sensitivity to community structure. </span><span class="c5">Local search is sensi- tive to the clearness of community structures in the network. The </span><span class="c0">more obvious the community structure, the more efficient local </span></p><p class="c3"><span class="c51">1000 </span></p><p class="c3"><span class="c61">3000 </span><span class="c12">global </span><span class="c25">2.4</span><span class="c47">&sdot;</span><span class="c25">10</span><span class="c35">5 </span><span class="c61">2500 </span><span class="c77">CSM1 CSM2 </span></p><p class="c3"><span class="c61">2000 1500 1000 500 </span><span class="c12">0 DBLP Berkeley Youtube </span></p><p class="c3"><span class="c25">3 7 11 15 19 </span></p><p class="c3"><span class="c5">Figure 11: The performance </span><span class="c0">of local search to CSM </span></p><p class="c3"><span class="c25">2.0</span><span class="c47">&sdot;</span><span class="c25">10</span><span class="c35">5 </span></p><p class="c63"><span class="c61">) sm(smi</span><span class="c12">T</span><span class="c25">1.6</span><span class="c47">&sdot;</span><span class="c25">10</span><span class="c35">5 </span><span class="c25">1.2</span><span class="c47">&sdot;</span><span class="c25">10</span><span class="c35">5 </span></p><p class="c3"><span class="c25">8.0</span><span class="c47">&sdot;</span><span class="c25">10</span><span class="c35">4 </span></p><p class="c3"><span class="c5">search. To verify this conjecture, we generate synthetic networks with &mu; varying from 0.1 to 0.5. Other parameters were the same as the previous experiment. The larger the value of &mu;, the clearer the </span><span class="c0">community structure. </span><span class="c5">We present the result in Figure 17. It is clear that ls-li and CSM1 are consistently and significantly better than global search </span><span class="c0">for different &mu;. CSM2 exhibits a similar performance as global </span><span class="c5">search, but is still better than global search. The results in Fig- ure 17(c) show that CSM1 can help us find a good tradeoff be- </span><span class="c0">tween quality and performance, independent of the community struc- </span><span class="c5">ture of the network. We can also see that either the local search (both solutions of </span><span class="c0">CST and CSM) or global search consumes more time when the </span><span class="c5">network shows vaguer community structure. When &mu; is large, the boundary of the communities become vague, thus, for most of k, </span><span class="c0">the result of CST(k) that contains the query vertex will become </span><span class="c5">larger, and the maximal core of the graph tends to become larger. As a result, for both local search and global search, the run time </span><span class="c0">increases with the growth in the answer size. </span></p><p class="c3"><span class="c12">100 global </span><span class="c8">) 0001(secitreV</span><span class="c12">#10000 </span><span class="c14">ls-naive ls-li ls-lg </span></p><p class="c3"><span class="c12">1000 </span></p><p class="c3"><span class="c5">(a) The answer size </span></p><p class="c3"><span class="c8">) 0001(secitreV</span><span class="c12">#</span><span class="c14">0 20 40 60 80 100 120 </span></p><p class="c3"><span class="c12">k </span></p><p class="c3"><span class="c12">100 global </span><span class="c14">ls-naive ls-li ls-lg </span></p><p class="c3"><span class="c14">0 20 40 60 80 100 120 </span></p><p class="c26"><span class="c12">k </span><span class="c5">(b) </span><span class="c0">tices </span><span class="c5">The number of visited ver- Figure 13: Answer size and visited vertex size in local search </span></p><p class="c3"><span class="c18">7. RELATED WORK </span></p><p class="c3"><span class="c5">The work presented in this paper is closely related to community detection, local search on graphs, and k-core decomposition. </span><span class="c16">Community detection. </span><span class="c5">Community detection was first mod- </span><span class="c0">eled as a modularity optimization problem. Modularity [1] is a </span><span class="c5">well-known measure of the goodness of non-overlapping divisions in a network. Unfortunately, finding the division that maximizes </span><span class="c0">the modularity is NP-complete [13]. A typical solution to optimiz- </span><span class="c5">ing modularity is the Newman-Girvan approach [1], which derives good partitions on many real networks but it takes O(|E|</span><span class="c19">2</span><span class="c5">|V |), or O(|V |</span><span class="c19">3</span><span class="c5">) time on a sparse graph. It was also shown that modularity </span><span class="c0">optimization may fail in some special networks [14]. </span><span class="c5">Many successors devoted their efforts to improving the quality and performance of community detection. In recent years, label </span><span class="c0">propagation has attracted wide research interest since it in general </span><span class="c5">can produce high-quality communities with almost linear time [15, </span><span class="c0">16]. In real applications, only top clusters usually interest users. </span><span class="c5">A solution [17] was proposed to mine the top clusters of a net- work. Sparsification that can preserve the community structure is </span><span class="c0">also used to reduce the size of the graph so that community detec- </span><span class="c5">tion on the sparsified graph is more efficient [18]. Another direction of efforts focuses on extending current solu- </span><span class="c0">tion to support more semantics of communities. The real social net- </span><span class="c5">works usually have overlapping communities [19], i.e., vertices are shared among different communities. Some efficient approaches </span><span class="c0">for the identification of overlapping communities in large real net- </span><span class="c5">work have been proposed, including clique percolation method [20], q-state Potts model based method [21]. Considering the influence </span><span class="c0">of attributes of edges on the semantic of community, SA-Cluster, </span><span class="c5">which utilizes both structure and attribute information, is proposed for graph clustering [22]. </span><span class="c0">All these works do not consider community search, which was </span><span class="c5">first proposed in [5]. The community search problem addressed in this paper is a special case of that proposed in [5], where they </span><span class="c0">intend to find a community containing a set of query nodes while </span></p><p class="c63"><span class="c12">1e-005 </span><span class="c8">10 1 0.1 0.01 0.001 0.0001 </span><span class="c12">0 2 4 6 8 10 12 14 16 </span><span class="c30">&gamma; </span></p><p class="c3"><span class="c8">10 1 </span><span class="c42">&gamma;</span><span class="c8">=9 </span></p><p class="c3"><span class="c8">0.1 </span><span class="c12">0.01 </span><span class="c14">r</span><span class="c12">r</span><span class="c17">a </span></p><p class="c3"><span class="c17">t </span><span class="c12">0 2 4 6 8 10 12 14 16 </span></p><p class="c3"><span class="c30">&gamma;</span><span class="c5">(b) Berkeley </span></p><p class="c63"><span class="c8">10 1 0.1 0.01 </span><span class="c12">0.001 0 2 4 6 8 10 12 14 16 </span><span class="c30">&gamma; </span></p><p class="c3"><span class="c30">&gamma;</span><span class="c12">=13 </span></p><p class="c3"><span class="c14">r</span><span class="c12">r</span><span class="c17">a t </span><span class="c5">(a) DBLP </span></p><p class="c26"><span class="c8">1 </span><span class="c30">&gamma;</span><span class="c12">=12 </span><span class="c8">0.01 </span><span class="c14">r</span><span class="c12">r</span><span class="c17">a t </span><span class="c12">0.0001 0 2 4 6 8 10 12 14 16 </span></p><p class="c3"><span class="c70">&gamma; </span><span class="c5">(c) Youtube </span></p><p class="c3"><span class="c30">&gamma;</span><span class="c12">=11 </span></p><p class="c3"><span class="c14">r</span><span class="c12">r</span><span class="c17">at </span><span class="c0">(d) LiveJournal </span><span class="c5">Figure 14: &gamma;&rsquo;s affect on CSM1 </span></p><p class="c63"><span class="c8">700 600 500 400 </span><span class="c12">300 0 4 8 12 16 </span><span class="c30">&gamma; </span><span class="c5">(a) DBLP </span></p><p class="c63"><span class="c8">1300 1100 900 700 </span><span class="c12">500 0 4 8 12 16 </span><span class="c30">&gamma; </span><span class="c5">(b) Berkeley </span></p><p class="c63"><span class="c8">800 700 600 500 </span><span class="c12">400 0 4 8 12 16 </span><span class="c30">&gamma; </span><span class="c5">(c) Youtube </span></p><p class="c3"><span class="c12">1</span><span class="c8">10 </span></p><p class="c26"><span class="c12">20000 </span><span class="c8">30000 40000 50000 </span><span class="c12">0 2 4 6 8 10 12 14 16 </span><span class="c70">&gamma; </span><span class="c5">(d) LiveJournal Figure 15: &gamma;&rsquo;s affect on CSM2 </span></p><p class="c3"><span class="c5">in our problem we are interested in querying the community for a </span><span class="c0">single vertex. However, they solve the community search problem </span><span class="c5">by global search. </span></p><p class="c1"><span class="c16">Local search for communities. </span><span class="c5">In recent years, local search for communities in real graphs is attracting ever-increasing research interests [29, 30, 31, 32]. Aaron [29] first proposes the problem to </span><span class="c0">find a community with size constraint k for a certain vertex. But </span><span class="c5">he uses &quot;local modularity&quot; as the community goodness measure, which characterizes the relative density within the community to </span><span class="c0">outside of the community. According to the new measure, he pro- </span><span class="c5">poses a heuristic algorithm with quadratic time complexity regard- ing to k. Bagrow [30] further improves the performance by select- </span><span class="c0">ing the vertex with largest &quot;outwardness&quot;, where outwardness of </span><span class="c5">vertex v is the number of v&rsquo; neighbors outside the community mi- nus the number inside. Local search of community is widely used </span><span class="c0">in existing Sybil defense schemes [31]. Their basic idea is that lo- </span><span class="c5">cal community around a trusted node is also trustworthy [31]. And Wanyun [32] studies the overlapping structure of local search. </span><span class="c0">These local search methods [29, 30] find communities with size </span><span class="c5">constraint to limit the search space. As a result, they cannot en- sure to find the best community under corresponding community </span><span class="c0">goodness measure. Another weakness is that the size constraint as </span></p><p class="c3"><span class="c51">1001 </span></p><p class="c3"><span class="c12">0 </span><span class="c8">2500 </span><span class="c12">global </span><span class="c8">2000 </span><span class="c14">local search </span><span class="c8">) sm(emi</span><span class="c12">T</span><span class="c8">1500 1000 500 </span><span class="c12">0.1 0.2 0.3 0.4 0.5 </span></p><p class="c3"><span class="c30">&mu; </span><span class="c5">(a) CST </span></p><p class="c3"><span class="c8">3500 </span><span class="c12">global </span><span class="c14">local search </span><span class="c8">3000 ) sm(emi</span><span class="c12">T</span><span class="c8">2500 2000 1500 </span><span class="c12">1000 0.1 0.2 0.3 0.4 0.5 </span></p><p class="c3"><span class="c30">&mu; </span><span class="c5">(b) CSM2 </span></p><p class="c3"><span class="c8">1 </span><span class="c12">0.1</span><span class="c14">r</span><span class="c12">r</span><span class="c17">a </span></p><p class="c26"><span class="c17">t </span><span class="c12">0.1 0.2 0.3 0.4 0.5 </span><span class="c30">&mu; </span><span class="c5">(c) CSM1 Figure 17: Influence of community structure on efficiency of local search </span></p><p class="c3"><span class="c8">1000 </span></p><p class="c3"><span class="c8">800 600 400 200 </span><span class="c12">0 200k 400k 600k 800k 1M </span></p><p class="c3"><span class="c12">0.01 </span></p><p class="c3"><span class="c12">0.001 </span></p><p class="c3"><span class="c12">global </span><span class="c21">[6] </span><span class="c14">local search </span></p><p class="c3"><span class="c21">H. Zhuge et al., &ldquo;Query routing in a peer-to-peer semantic link </span><span class="c11">network,&rdquo; Computational Intelligience, vol. 21, no. 2, pp. 197&ndash;216. </span></p><p class="c3"><span class="c8">) sm(emi</span><span class="c12">T</span><span class="c8">) </span></p><p class="c3"><span class="c8">sm(emi</span><span class="c12">T</span><span class="c21">[7] B. Bollob&aacute;s, &ldquo;The evolution of sparse graphs,&rdquo; Graph Theory and </span><span class="c11">Combinatorics, Proc. Cambridge Combinatorial Conf. in honor of Paul Erdos, Academic Press, pp. 35-57. </span></p><p class="c3"><span class="c21">[8] M. Gaertler et al., &ldquo;Dynamic analysis of the autonomous system </span><span class="c11">graph,&rdquo; in IPS 2004, pp. 13&ndash;24 </span><span class="c21">[9] S. B. Seidman., &ldquo;Network structure and minimum degree,&rdquo; Social </span><span class="c12">Graph Size </span></p><p class="c3"><span class="c11">Networks , Vol. 5, pp. 269&ndash;287. </span><span class="c5">(a) CST </span></p><p class="c3"><span class="c21">[10] S. N. Dorogovtsev et al., &rdquo;k-core organization of complex networks,&rdquo; </span><span class="c11">Phys. Rev. Lett. Vol.96, pp. 040601. </span><span class="c21">[11] A. Mislove et al., &ldquo;Measurement and analysis of online social </span><span class="c11">networks,&rdquo; in IMC&rsquo;07. </span><span class="c21">[12] A. Lancichinetti et al., &ldquo;Benchmark graphs for testing community </span><span class="c11">detection algorithms,&rdquo; Phys. Rev. E, vol. 78, no. 4, p. 046110. </span><span class="c21">[13] U. Brandes et al., &ldquo;On modularity clustering,&rdquo; TKDE, vol. 20, no. 2, </span><span class="c11">pp. 172&ndash;188. </span><span class="c21">[14] S. Fortunato et al., &ldquo;Resolution limit in community detection,&rdquo; PNAS, </span><span class="c11">vol. 104, no. 1, p. 36. </span><span class="c21">[15] U. N. Raghavan et al., &ldquo;Near linear time algorithm to detect </span><span class="c11">community structures in large-scale networks,&rdquo; Phys.Rev.E, vol. 76, p. 036106. </span><span class="c21">[16] I. X. Y. Leung et al., &ldquo;Towards real-time community detection in </span><span class="c11">large networks,&rdquo; Phys.Rev.E, vol. 79, p. 066107. </span><span class="c21">[17] K. Macropol et al., &ldquo;Scalable discovery of best clusters on large </span><span class="c11">graphs,&rdquo; in VLDB&rsquo;10. </span><span class="c21">[18] V. Satuluri et al., &ldquo;Local graph sparsification for scalable clustering,&rdquo; </span><span class="c11">in SIGMOD &rsquo;11. </span><span class="c21">[19] G. Palla et al., &ldquo;Uncovering the overlapping community structure of </span><span class="c11">complex networks in nature and society,&rdquo; Nature, vol. 435, no. 7043, pp. 814&ndash;818. </span><span class="c21">[20] I. Derenyi et al., &ldquo;Clique percolation in random networks,&rdquo; Phys. Rev. </span><span class="c11">Letters, vol. 94, no. 16, p. 160202. </span><span class="c21">[21] J. Reichardt et al., &ldquo;Detecting fuzzy community structures in </span><span class="c11">complex x networks with a potts model,&rdquo; Phys. Rev. Letters, vol. 93, no. 21, p. 218701. </span><span class="c21">[22] Y. Zhou et al., &ldquo;Graph clustering based on structural/attribute </span><span class="c11">similarities,&rdquo; in VLDB&rsquo;09. </span><span class="c21">[23] B. Bollobas, Random Graphs. Cambridge University Press, 2001. [24] M. E. J. Newman et al., &ldquo;Random graphs with arbitrary degree </span><span class="c11">distributions and their applications,&rdquo; Phys. Rev. E, vol. 64, no. 2, p. 026118. </span><span class="c21">[25] B. Pittel et al., &ldquo;Sudden emergence of a giant k-core in a random </span><span class="c11">graph,&rdquo; J. Comb. Theory Ser. B, vol. 67, pp. 111&ndash;151. </span><span class="c21">[26] J. I. Alvarez-hamelin et al., &ldquo;Large scale networks fingerprinting and </span><span class="c11">visualization using the k-core decomposition,&rdquo; in NIPS&rsquo;06. </span><span class="c21">[27] S. Carmi et al., &ldquo;From the cover: A model of internet topology using </span><span class="c11">k-shell decomposition,&rdquo; PNAS, vol. 104, no. 27, pp. 11 150&ndash;11 154, 2007. </span><span class="c21">[28] J. Cheng et al., &ldquo;Efficient core decomposition in massive networks,&rdquo; </span><span class="c11">in ICDE&rsquo;11. </span><span class="c21">[29] A. Clauset., &ldquo;Finding local community structure in networks,&rdquo; Phys. </span><span class="c11">Rev. E, vol. 72, p. 026132. 2005. </span><span class="c21">[30] J. P. Bagrow, &ldquo;Evaluating local community methods in networks&rdquo; J. </span><span class="c11">Stat. Mech., vol. 2008, p. 05001. 2008. </span><span class="c21">[31] B. Viswanath et al., &ldquo;An analysis of social network-based sybil </span><span class="c11">defenses,&rdquo; SIGCOMM Comput. Commun. Rev., vol41, pp363&ndash;374. </span><span class="c21">[32] W. Cui et al., &ldquo;Online Search of Overlapping Communities,&rdquo; in </span><span class="c11">SIGMOD &rsquo;13. </span></p><p class="c3"><span class="c51">1002 </span><span class="c12">1000 </span></p><p class="c3"><span class="c12">100 </span></p><p class="c3"><span class="c14">CSM1 </span><span class="c12">global </span><span class="c8">10 </span><span class="c14">CSM2</span><span class="c12">1200k 400k 600k 800k 1M </span></p><p class="c26"><span class="c12">Graph Size </span><span class="c0">(b) CSM </span><span class="c5">Figure 16: Scalability of local search </span></p><p class="c3"><span class="c5">an input parameter is hard to select. In general, each vertex has its own the most appropriate community size. Either predefining a </span><span class="c0">global parameter or trying different parameters blindly can hardly </span><span class="c5">find meaningful results. k</span><span class="c16">-core decomposition. </span><span class="c5">The technique used in this paper is closely </span><span class="c0">related to the estimation of giant component size of random graphs </span><span class="c5">[23, 24] and k-core decomposition [25, 26]. The threshold of sud- den emergence of a giant k-core in a random graph is theoretically </span><span class="c0">studied in [25]. Newman et al. [24] proposed a novel method to </span><span class="c5">compute the mean component size of random graphs with arbitrary degree distribution using generating function. k-core decomposi- </span><span class="c0">tion is empirically investigated on many real large networks and </span><span class="c5">shown to be a new perspective to characterize the structure and function of real networks [27]. k-core decomposition is also used </span><span class="c0">to visualize large complex networks [26]. An external memory </span><span class="c5">based k-core decomposition solution is developed to handle mas- sive networks [28]. These techniques are rarely used for commu- </span><span class="c0">nity search. </span></p><p class="c3"><span class="c18">8. CONCLUSION </span></p><p class="c3"><span class="c5">We investigate the problem of finding the best community con- taining a given query vertex in its neighborhood. We propose a </span><span class="c0">local search method for this purpose. Local search is more effi- </span><span class="c5">cient than global search since global search needs to visit all ver- tices in the network for community detection. We address the local </span><span class="c0">search challenge that arises from the non-monotonicity of commu- </span><span class="c5">nity goodness measure. In this paper, we propose the CST and the CSM algorithms to solve a variety of community search prob- </span><span class="c0">lems. We conduct extensive experiments on synthetic and a variety </span><span class="c5">of real life, million-node networks. Our future work will consider constraints in community search, so that we can support applica- </span><span class="c0">tions in many emerging social settings, such as micro-blogging and </span><span class="c5">online social networks. </span><span class="c18">9. REFERENCES </span></p><p class="c3"><span class="c21">[1] M. E. J. Newman et al., &ldquo;Finding and evaluating community structure </span><span class="c11">in networks,&rdquo; Phys. Rev. E, vol. 69, no. 2, p. 026113. </span><span class="c21">[2] A. Broder et al., &ldquo;Graph structure in the web,&rdquo; Comput. Netw., </span><span class="c11">vol. 33, no. 1-6, pp. 309&ndash;320, June 2000. </span><span class="c21">[3] G. Palla et al., &ldquo;Uncovering the overlapping community structure of </span><span class="c11">complex networks in nature and society,&rdquo; Nature, vol. 435, no. 7043, pp. 814&ndash;818. </span><span class="c21">[4] R. Guimera et al., &ldquo;Functional cartography of complex metabolic </span><span class="c11">networks,&rdquo; Nature, vol. 433, no. 7028, pp. 895&ndash;900. </span><span class="c21">[5] M. Sozio et al., &ldquo;The community-search problem and how to plan a </span><span class="c11">successful cocktail party,&rdquo; in KDD&rsquo;10. </span></p></body></html>