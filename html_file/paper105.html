<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c84{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.5pt;font-family:"Courier New";font-style:normal}.c127{margin-left:-18.5pt;padding-top:3.4pt;text-indent:126pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-15.9pt}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.3pt;font-family:"Arial";font-style:normal}.c61{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11.1pt;font-family:"Arial";font-style:normal}.c86{color:#000000;font-weight:700;text-decoration:none;vertical-align:sub;font-size:21pt;font-family:"Arial";font-style:normal}.c93{color:#ffffff;font-weight:700;text-decoration:none;vertical-align:sub;font-size:13pt;font-family:"Courier New";font-style:normal}.c57{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:10.5pt;font-family:"Arial";font-style:normal}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Arial";font-style:normal}.c29{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:16.8pt;font-family:"Courier New";font-style:normal}.c12{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Arial";font-style:normal}.c97{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Courier New";font-style:normal}.c159{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:12.6pt;font-family:"Arial";font-style:normal}.c170{margin-left:-16.9pt;padding-top:2.6pt;text-indent:27pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18.5pt}.c8{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.9pt;font-family:"Arial";font-style:normal}.c94{color:#ffffff;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11.6pt;font-family:"Courier New";font-style:italic}.c113{margin-left:-18.5pt;padding-top:2.6pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.6pt}.c160{margin-left:-17.1pt;padding-top:11pt;text-indent:17.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.4pt}.c104{margin-left:-18.5pt;padding-top:1pt;text-indent:33.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.9pt}.c140{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8.5pt;font-family:"Arial";font-style:italic}.c168{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11.6pt;font-family:"Arial";font-style:normal}.c102{margin-left:-18.5pt;padding-top:2.6pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.4pt}.c58{color:#ffffff;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8.5pt;font-family:"Arial";font-style:italic}.c134{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:17.2pt;font-family:"Arial";font-style:normal}.c41{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Courier New";font-style:normal}.c119{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Arial";font-style:italic}.c54{margin-left:-19pt;padding-top:11.5pt;text-indent:19.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.6pt}.c83{margin-left:-18.5pt;padding-top:21.4pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.6pt}.c39{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:9.4pt;font-family:"Arial";font-style:normal}.c121{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Arial";font-style:normal}.c105{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Arial";font-style:normal}.c68{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:10.2pt;font-family:"Arial";font-style:normal}.c46{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.7pt;font-family:"Courier New";font-style:italic}.c89{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:15.2pt;font-family:"Arial";font-style:normal}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:9.1pt;font-family:"Arial";font-style:normal}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Arial";font-style:normal}.c45{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12.3pt;font-family:"Courier New";font-style:normal}.c71{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:12.1pt;font-family:"Courier New";font-style:normal}.c141{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:13.8pt;font-family:"Arial";font-style:italic}.c171{margin-left:-18.5pt;padding-top:2.6pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.2pt}.c99{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:18.4pt;font-family:"Arial";font-style:normal}.c76{color:#ffffff;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Arial";font-style:normal}.c22{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:9.7pt;font-family:"Arial";font-style:normal}.c158{color:#000000;font-weight:700;text-decoration:none;vertical-align:super;font-size:16.6pt;font-family:"Arial";font-style:normal}.c15{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.3pt;font-family:"Arial";font-style:normal}.c35{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:8.8pt;font-family:"Arial";font-style:normal}.c30{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:9.9pt;font-family:"Arial";font-style:normal}.c74{color:#ffffff;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10.4pt;font-family:"Arial";font-style:normal}.c135{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.2pt;font-family:"Arial";font-style:normal}.c82{color:#000000;font-weight:700;text-decoration:none;vertical-align:sub;font-size:16.1pt;font-family:"Arial";font-style:normal}.c65{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Arial";font-style:normal}.c136{margin-left:-17.1pt;padding-top:10.8pt;text-indent:17.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.4pt}.c175{margin-left:-16.9pt;padding-top:2.6pt;text-indent:27pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18pt}.c114{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:19pt;font-family:"Arial";font-style:normal}.c178{margin-left:-16.9pt;padding-top:1pt;text-indent:32.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19pt}.c37{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c147{color:#000000;font-weight:700;text-decoration:none;vertical-align:super;font-size:10.2pt;font-family:"Arial";font-style:normal}.c115{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8.3pt;font-family:"Arial";font-style:italic}.c133{color:#ffffff;font-weight:400;text-decoration:none;vertical-align:sub;font-size:19.4pt;font-family:"Arial";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:12.1pt;font-family:"Arial";font-style:normal}.c87{margin-left:-19pt;padding-top:2.6pt;text-indent:29.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.8pt}.c152{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:8.3pt;font-family:"Arial";font-style:normal}.c26{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8.8pt;font-family:"Courier New";font-style:italic}.c144{color:#595959;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.6pt;font-family:"Arial";font-style:normal}.c10{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.4pt;font-family:"Arial";font-style:normal}.c53{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7pt;font-family:"Arial";font-style:normal}.c36{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.3pt;font-family:"Courier New";font-style:normal}.c62{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11.7pt;font-family:"Arial";font-style:normal}.c96{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7pt;font-family:"Courier New";font-style:normal}.c25{color:#ffffff;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11.4pt;font-family:"Arial";font-style:normal}.c64{color:#000000;font-weight:700;text-decoration:none;vertical-align:sub;font-size:19.1pt;font-family:"Arial";font-style:normal}.c72{color:#595959;font-weight:400;text-decoration:none;vertical-align:super;font-size:10.5pt;font-family:"Arial";font-style:normal}.c9{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12.1pt;font-family:"Courier New";font-style:normal}.c55{color:#ffffff;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.5pt;font-family:"Arial";font-style:normal}.c108{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Arial";font-style:normal}.c80{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Courier New";font-style:normal}.c142{margin-left:-18.5pt;padding-top:8.6pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.8pt}.c17{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.5pt;font-family:"Arial";font-style:normal}.c63{color:#000000;font-weight:700;text-decoration:none;vertical-align:sub;font-size:14.7pt;font-family:"Arial";font-style:normal}.c42{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12.1pt;font-family:"Arial";font-style:normal}.c174{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Arial";font-style:normal}.c176{color:#595959;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:6.3pt;font-family:"Arial";font-style:normal}.c50{color:#ffffff;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.2pt;font-family:"Arial";font-style:italic}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5pt;font-family:"Arial";font-style:normal}.c59{color:#000000;font-weight:700;text-decoration:none;vertical-align:sub;font-size:11.5pt;font-family:"Arial";font-style:normal}.c79{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.5pt;font-family:"Arial";font-style:normal}.c165{margin-left:-16.9pt;padding-top:1pt;text-indent:32.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-18.2pt}.c19{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:16.8pt;font-family:"Arial";font-style:normal}.c75{color:#595959;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.3pt;font-family:"Arial";font-style:normal}.c111{color:#ffffff;font-weight:400;text-decoration:none;vertical-align:super;font-size:19pt;font-family:"Arial";font-style:normal}.c67{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:9.2pt;font-family:"Arial";font-style:normal}.c21{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:11.6pt;font-family:"Arial";font-style:normal}.c51{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16.4pt;font-family:"Arial";font-style:normal}.c155{color:#000000;font-weight:700;text-decoration:none;vertical-align:sub;font-size:13.7pt;font-family:"Arial";font-style:normal}.c13{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:19.9pt;font-family:"Arial";font-style:normal}.c16{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.7pt;font-family:"Arial";font-style:normal}.c20{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8.8pt;font-family:"Arial";font-style:normal}.c131{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:6.3pt;font-family:"Arial";font-style:normal}.c44{margin-left:-18.5pt;padding-top:1pt;text-indent:33.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.4pt}.c14{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:8.2pt;font-family:"Arial";font-style:normal}.c34{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11.4pt;font-family:"Arial";font-style:normal}.c150{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.2pt;font-family:"Arial";font-style:italic}.c139{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Courier New";font-style:normal}.c32{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10.9pt;font-family:"Arial";font-style:normal}.c98{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11.4pt;font-family:"Arial";font-style:normal}.c31{color:#ffffff;font-weight:700;text-decoration:none;vertical-align:sub;font-size:16.6pt;font-family:"Arial";font-style:normal}.c69{color:#ffffff;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.2pt;font-family:"Arial";font-style:italic}.c110{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:6.4pt;font-family:"Arial";font-style:normal}.c161{color:#ffffff;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11.6pt;font-family:"Arial";font-style:normal}.c49{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Arial";font-style:italic}.c88{color:#000000;font-weight:700;text-decoration:none;vertical-align:sub;font-size:16.6pt;font-family:"Arial";font-style:normal}.c182{color:#000000;font-weight:700;text-decoration:none;vertical-align:sub;font-size:12.3pt;font-family:"Arial";font-style:normal}.c78{color:#000000;font-weight:700;text-decoration:none;vertical-align:sub;font-size:17.4pt;font-family:"Arial";font-style:normal}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10.7pt;font-family:"Arial";font-style:normal}.c122{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:26.6pt;font-family:"Arial";font-style:normal}.c81{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:18.4pt;font-family:"Arial";font-style:normal}.c47{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:9.1pt;font-family:"Arial";font-style:normal}.c128{margin-left:-17.1pt;padding-top:7pt;text-indent:27.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.2pt}.c56{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c27{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10.1pt;font-family:"Arial";font-style:normal}.c7{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12.2pt;font-family:"Arial";font-style:normal}.c48{color:#000000;font-weight:700;text-decoration:none;vertical-align:sub;font-size:17.1pt;font-family:"Arial";font-style:normal}.c38{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Arial";font-style:italic}.c132{margin-left:10.3pt;padding-top:56.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:149.9pt}.c173{margin-left:-13.9pt;padding-top:25.2pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:143.2pt}.c70{margin-left:-18.5pt;padding-top:139.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.6pt}.c130{margin-left:7.7pt;padding-top:4.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:143pt}.c73{margin-left:-17.1pt;padding-top:22.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.2pt}.c117{margin-left:39.8pt;padding-top:73.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:129.8pt}.c167{margin-left:58.1pt;padding-top:6.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-8.2pt}.c185{margin-left:31pt;padding-top:4.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:143.2pt}.c166{margin-left:-17.1pt;padding-top:4.1pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-18.7pt}.c180{margin-left:-19pt;padding-top:23pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-16.2pt}.c92{margin-left:-5.5pt;padding-top:4.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:143.7pt}.c163{margin-left:-2.6pt;padding-top:5.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.2pt}.c126{margin-left:-13.4pt;padding-top:17.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:143pt}.c184{margin-left:-18.5pt;padding-top:19.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:146.3pt}.c60{margin-left:218.6pt;padding-top:52.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-35.4pt}.c116{margin-left:-18.5pt;padding-top:2.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.6pt}.c162{margin-left:218.6pt;padding-top:701.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:218.6pt}.c23{margin-left:-19pt;padding-top:11pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.6pt}.c101{margin-left:-2.6pt;padding-top:2.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.2pt}.c109{margin-left:-18.5pt;padding-top:14.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.6pt}.c95{margin-left:24.7pt;padding-top:43.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:14.6pt}.c66{margin-left:-11.6pt;padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:141.1pt}.c156{margin-left:218.6pt;padding-top:51.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-35.4pt}.c28{margin-left:-16.9pt;padding-top:10.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.8pt}.c157{margin-left:-17.1pt;padding-top:19.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.4pt}.c125{margin-left:274.6pt;padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:169pt}.c112{margin-left:17.5pt;padding-top:60.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:59.2pt}.c183{margin-left:24.4pt;padding-top:105.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:169pt}.c179{margin-left:-2.6pt;padding-top:2.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-12.3pt}.c169{margin-left:51.4pt;padding-top:7pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-8pt}.c164{margin-left:-18.5pt;padding-top:3.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.4pt}.c146{margin-left:6.2pt;padding-top:4.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:143pt}.c40{margin-left:-2.6pt;padding-top:2.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.2pt}.c143{margin-left:265pt;padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-85pt}.c90{margin-left:27.1pt;padding-top:4.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:143pt}.c118{margin-left:218.6pt;padding-top:563pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-35.4pt}.c172{margin-left:21.6pt;padding-top:4.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:143.7pt}.c103{margin-left:11.3pt;padding-top:4.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:143.7pt}.c148{margin-left:-11pt;padding-top:4.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:143.2pt}.c153{margin-left:-7.5pt;padding-top:6.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:133.4pt}.c124{margin-left:-18.5pt;padding-top:9.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.4pt}.c149{margin-left:-2.6pt;padding-top:13.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-0.3pt}.c107{margin-left:-18.5pt;padding-top:8.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.6pt}.c120{margin-left:-18.5pt;padding-top:31.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-18.1pt}.c11{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c145{padding-top:16.6pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c18{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c91{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c24{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c33{margin-left:93.3pt;text-indent:-87.5pt;margin-right:10.6pt}.c177{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c100{margin-left:-16.9pt;margin-right:-19.4pt}.c129{margin-left:-7.5pt;margin-right:145.7pt}.c151{margin-left:-16.9pt;margin-right:-19.2pt}.c137{margin-left:251.8pt;margin-right:-85pt}.c123{margin-left:270.7pt;margin-right:169pt}.c154{margin-left:-7.5pt;margin-right:133.4pt}.c52{margin-left:124pt;margin-right:-11.5pt}.c85{margin-left:-98.7pt;margin-right:258.5pt}.c43{margin-left:257.5pt;margin-right:169pt}.c181{margin-left:-168.6pt;margin-right:307.9pt}.c106{margin-left:52.2pt;margin-right:2.9pt}.c138{margin-left:20.6pt;margin-right:16pt}.c77{margin-left:7.1pt;margin-right:169pt}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:24pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:14pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c177"><p class="c11"><span class="c37">Series ISSN: 2367-2005 289 </span><span class="c41">10.5441/002/edbt.2018.26 </span></p><p class="c11"><span class="c134">Pattern Search in Temporal Social Networks </span></p><p class="c24"><span class="c56">Maximilian Franzke </span><span class="c105">Institute of Informatics, Ludwig-Maximilians-Universit&auml;t Munich, Germany franzke@dbs.ifi.lmu.de </span></p><p class="c24"><span class="c56">Tobias Emrich </span><span class="c105">Institute of Informatics, Ludwig-Maximilians-Universit&auml;t Munich, Germany emrich@dbs.ifi.lmu.de </span></p><p class="c24"><span class="c56">Andreas Z&uuml;fle </span><span class="c105">Department for Geography and GeoInformation Science George Mason University Fairfax, Virginia, United States azufle@gmu.edu </span></p><p class="c24"><span class="c56">Matthias Renz </span><span class="c105">Department for Computational and Data Sciences George Mason University Fairfax, Virginia, United States mrenz@gmu.edu </span></p><p class="c11"><span class="c32">ABSTRACT </span><span class="c3">Due to the wide availability of social media and the wide range of real-life and human-centered applications, social networks have become an attractive research area. However, the temporal aspect of relations between entities in a social network has been widely ignored. We argue that the temporal aspect of social networks is the key to understand interactions and other phenomena hap- pening in these networks and should thus be considered more closely. In this work we address the problem of pattern search in temporal social networks, thus finding all occurrences of a temporal pattern in a large temporal social network. As a first step, we define a temporal pruning criterion, which allows to quickly reduce the search space of candidates. Then, we present an index structure which allows to quickly find the occurrences of simple temporal network structures, from which more com- plex query structures can be derived from. Our experimental evaluation on a real-world temporal social network shows the effectiveness of our pruning approach and our proposed index structures, reducing the search-time for small temporal patterns by many orders of magnitude. </span></p><p class="c11"><span class="c32">1 INTRODUCTION </span><span class="c3">Social networks and other interaction networks</span><span class="c5">1 </span><span class="c3">are dynamic by nature. Bonds of friendship can last for an eternity, but often break and fade away over time. Active collaborations between researchers naturally change over time. Thus, any social network today will look significantly different tomorrow. Keeping in mind the dynamic nature of human beings, the history of a social net- work showing how interactions between individuals evolve over time should be considered when inferring knowledge from it, because the knowledge about the evolution of a social network yields further semantic information. For instance, in a collabo- ration network it might be interesting to see in which order a </span></p><p class="c11"><span class="c17">1</span><span class="c168">Though this paper mainly refers to social network, the proposed concepts are also </span><span class="c53">applicable for other interaction networks, e.g. economical networks, etc. </span></p><p class="c11"><span class="c96">&copy; </span><span class="c53">2018 Copyright held by the owner/author(s). Published in Proceedings of the 21st International Conference on Extending Database Technology (EDBT), March 26-29, 2018, ISBN 978-3-89318-078-3 on OpenProceedings.org. Distribution of this paper is permitted under the terms of the Creative Commons license CC-by-nc-nd 4.0. </span></p><p class="c11"><span class="c21">Brian </span></p><p class="c11"><span class="c8">Anna Chris </span><span class="c49">June </span></p><p class="c11"><span class="c3">Figure 1: Example evolution of a social network. </span></p><p class="c18"><span class="c3">group of researchers formed a network, which researchers only have short-term collaborations and which have rather long and sustainable research collaborations. However, existing solutions that consider only a snapshot in time, or building the union of all past collaborations, are not able to take such information into account. By considering this dynamic aspect of a social network, it becomes possible to identify more interesting and meaning- ful patterns. As a minimal example, consider Figure 1, showing an evolving social network. Initially, only one social link exists, between Anna and Brian. In the next month, an additional link is added between Brian and Chris. Finally, the triangle is closed with a link between Chris and Anna. In this example, Brian might act as a social hub, who brings Anna and Chris together. In prac- tice, more detailed temporal social patterns could matter, as for instance the duration of a social link between Anna and Chris, which was induced by Brian, may be of interest. The temporal development of edges like in our example has been adressed for more than a hundred years through the concept of &lsquo;triadic closure&rsquo;, where the future creation of the third connection in a </span></p><p class="c11"><span class="c45">&quot; </span></p><p class="c11"><span class="c45">&quot; </span></p><p class="c11"><span class="c8">Chris Anna </span><span class="c21">Brian </span></p><p class="c11"><span class="c49">March </span></p><p class="c11"><span class="c8">Chris Anna </span><span class="c21">Brian </span></p><p class="c11"><span class="c49">May </span></p><p class="c11"><span class="c45">! </span></p><p class="c11"><span class="c45">! </span></p><p class="c11"><span class="c45"># </span></p><p class="c11"><span class="c45"># </span></p><p class="c11"><span class="c45">&quot; </span></p><p class="c11"><span class="c45">&quot; </span></p><p class="c11"><span class="c8">Chris Anna </span><span class="c21">Brian </span></p><p class="c11"><span class="c49">April </span></p><p class="c11"><span class="c45">! </span></p><p class="c11"><span class="c45">! </span></p><p class="c11"><span class="c45"># </span></p><p class="c11"><span class="c45"># </span></p><p class="c107"><span class="c3">triange is tried to be estimated, e.g. through link prediction in social networks. A more complex temporal structure in a social graph is the &lsquo;microtaboo&rsquo;, where it is frowned upon when per- sons Alice and Dave want to engage in a relationship, but there exist prior relationships between Alice and Bob, Bob and Carol, and Carol and Dave (&ldquo;don&rsquo;t date your ex-girlfriend&rsquo;s boyfriend&rsquo;s ex-girlfriend&rdquo;) [2]. </span></p><p class="c87"><span class="c3">Another example are communication and transportation net- works, where links between nodes and hubs are only established temporarily. Routing policies of computer networks may decide differently at various time points on how to create links between network nodes in order to transmit data. Transportation net- works with feeder trucks, cargo aircraft and delivery vehicles link hubs differently according to current demand. To analyzes the behaviour of those networks, a temporal pattern analysis of the interaction graph can help in mining information from the graph&rsquo;s history to deduct findings and information for future optimization. </span></p><p class="c171"><span class="c3">In this paper we address the problem of efficient evolution pattern search in large temporal social networks. Our approach bridges the gap between social network analysis and temporal logic. The contributions of this paper can be summarized as follows: </span></p><p class="c163"><span class="c3">&bull; We formally introduce the temporal subgraph matching query as a new problem. </span></p><p class="c101"><span class="c3">&bull; We introduce a language to express such pattern-based queries. </span></p><p class="c179"><span class="c3">&bull; We introduce and discuss several query filter strategies. </span></p><p class="c40"><span class="c3">&bull; We propose an index structure that allows us to search for temporal subgraph patterns in large temporal social network graphs. </span></p><p class="c116"><span class="c3">&bull; We provide a broad evaluation of the performance of our approaches based on real world datasets and show that our approach significantly outperforms state-of-the-art approaches. Though our problem is a generalization of the subgraph isomorphism problem, which is known to be NP-complete [6, 11], we can show that our index-based solution is able to find simple temporal social patterns in large real-world social networks efficiently. We define the problem of temporal social subgraph search in Section 2. In Section 4, we propose filter strategies and intro- duce our new indexing method in Section 5. Our experimental evaluation is given in Section 7. </span></p><p class="c54"><span class="c32">2 PROBLEM DEFINITION </span><span class="c3">We first introduce our representation of a temporal social net- work which we define as a graph where each node refers to an individual and each edge between two nodes is associated with a discrete function that maps time to the domain {0,1} specifying the presence and absence of the edge over time. </span></p><p class="c142"><span class="c3">Definition 2.1 (Temporal Social Graph). Let T = {0,1,...,m} be a discrete time domain. A temporal social graph (TSG) G = (V</span><span class="c5">G</span><span class="c3">,E</span><span class="c5">G</span><span class="c3">, F</span><span class="c5">G</span><span class="c3">) is a graph, where V</span><span class="c5">G </span><span class="c3">= {v</span><span class="c5">G</span><span class="c15">1 </span><span class="c4">,v</span><span class="c5">G</span><span class="c15">2 </span><span class="c4">,...,v</span><span class="c5">G</span><span class="c15">n </span><span class="c4">} is the </span><span class="c3">set of nodes, E</span><span class="c5">G </span><span class="c3">&sube; V</span><span class="c5">G </span><span class="c3">&times;V</span><span class="c5">G </span><span class="c3">the set of links (with (v</span><span class="c5">G</span><span class="c15">i </span><span class="c4">,v</span><span class="c5">G</span><span class="c15">k </span><span class="c4">) &isin; E</span><span class="c5">G</span><span class="c3">), and F</span><span class="c5">G </span><span class="c3">= {f </span><span class="c5">G</span><span class="c36">v</span><span class="c2">G</span><span class="c17">i </span><span class="c71">,v</span><span class="c2">G</span><span class="c17">k </span><span class="c4">(t)|(v</span><span class="c5">G</span><span class="c15">i </span><span class="c4">,v</span><span class="c5">G</span><span class="c15">k </span><span class="c4">) &isin; E</span><span class="c5">G</span><span class="c3">} a set of discrete time-dependent functions, where f </span><span class="c5">G</span><span class="c36">v</span><span class="c2">G</span><span class="c17">i </span><span class="c71">,v</span><span class="c2">G</span><span class="c17">k </span><span class="c4">(t)&isin;{0, 1} describes the existence of a </span></p><p class="c91 c151"><span class="c3">connection between v</span><span class="c5">G</span><span class="c15">i </span><span class="c4">and v</span><span class="c5">G</span><span class="c15">k </span><span class="c4">(0 indicating no connection and </span><span class="c3">1 indicating there is a connection) at time t &isin; T. Furthermore, an edge (v</span><span class="c5">G</span><span class="c15">i </span><span class="c4">,v</span><span class="c5">G</span><span class="c15">k </span><span class="c4">) is only an element of E</span><span class="c5">G </span><span class="c3">if </span><span class="c80">&exist;</span><span class="c3">t &isin; T : f </span><span class="c5">G</span><span class="c36">v</span><span class="c2">G</span><span class="c17">i </span><span class="c71">,v</span><span class="c2">G</span><span class="c17">k </span><span class="c4">(t) 0. </span><span class="c3">Based on this definition we are now able to define temporal subgraph matching which finds a subgraph from a TSG that exactly matches a given temporal subgraph query. </span></p><p class="c128"><span class="c3">Definition 2.2. [Temporal Subgraph Matching] Let G = (V</span><span class="c5">G</span><span class="c3">, E</span><span class="c5">G</span><span class="c3">, F</span><span class="c5">G</span><span class="c3">) be a TSG defined on the time domain T = {0,1,...,m}. And let q = (V</span><span class="c5">q</span><span class="c3">,E</span><span class="c5">q</span><span class="c3">,F</span><span class="c5">q</span><span class="c3">) be a query TSG defined on the time domain T</span><span class="c5">q </span><span class="c3">= {0, 1,...,t</span><span class="c5">q</span><span class="c3">} where t</span><span class="c5">q </span><span class="c3">&le; m. A temporal subgraph matching query retrieves the set S of all temporal subgraphs S &ni; S = (V</span><span class="c5">S </span><span class="c3">&sube; V</span><span class="c5">G</span><span class="c3">, E</span><span class="c5">S </span><span class="c3">&sube; E</span><span class="c5">G</span><span class="c3">,F</span><span class="c5">S </span><span class="c3">&sube; F</span><span class="c5">G</span><span class="c3">), such that there exists a bijection h : V </span><span class="c5">q </span><span class="c3">&rarr; V </span><span class="c5">S </span><span class="c3">and </span><span class="c80">&#8710;</span><span class="c42">t </span><span class="c12">&isin; {0, ...,m &minus; t</span><span class="c15">q</span><span class="c12">} that </span><span class="c3">satisfies </span><span class="c80">&forall;</span><span class="c3">(v</span><span class="c5">q</span><span class="c15">i </span><span class="c4">,v</span><span class="c5">q</span><span class="c15">k</span><span class="c4">) &isin; E</span><span class="c5">q </span><span class="c3">: (h(v</span><span class="c5">q</span><span class="c15">i </span><span class="c4">),h(v</span><span class="c5">q</span><span class="c15">k</span><span class="c4">)) &isin; E</span><span class="c5">S </span><span class="c3">and </span><span class="c80">&forall;</span><span class="c3">t &isin; [0,t</span><span class="c5">q</span><span class="c3">] : f </span><span class="c5">q</span><span class="c36">v</span><span class="c2">q</span><span class="c17">i </span><span class="c71">,v</span><span class="c2">q</span><span class="c17">k </span><span class="c4">(t) = f </span><span class="c5">S</span><span class="c15">h(</span><span class="c36">v</span><span class="c2">q</span><span class="c17">i </span><span class="c5">)</span><span class="c71">,</span><span class="c5">h(</span><span class="c71">v</span><span class="c2">q</span><span class="c17">k </span><span class="c5">)</span><span class="c4">(t + </span><span class="c139">&#8710;</span><span class="c15">t</span><span class="c3">). </span></p><p class="c166"><span class="c3">An example for a temporal social graph G is given in Figure 2(a). For convenience we labeled the edges (v</span><span class="c42">i</span><span class="c12">,v</span><span class="c42">k</span><span class="c3">) with the set of time steps t &isin; T for which the function f</span><span class="c9">v</span><span class="c47">i</span><span class="c9">,v</span><span class="c47">k </span><span class="c3">(t) = 1. Figure 2(b) illustrates a temporal subgraph query q. A pattern match of q can be found at &clubs; in G for </span><span class="c80">&#8710;</span><span class="c42">t </span><span class="c12">= 2, h(v</span><span class="c15">q</span><span class="c42">1 </span><span class="c3">) = v</span><span class="c5">G</span><span class="c15">4 </span><span class="c4">, h(v</span><span class="c5">q</span><span class="c15">2 </span><span class="c4">) = v</span><span class="c5">G</span><span class="c15">2 </span><span class="c4">and </span><span class="c3">h(v</span><span class="c5">q</span><span class="c15">3 </span><span class="c4">) = v</span><span class="c5">G</span><span class="c15">1 </span><span class="c4">. A more sophisticated query q</span><span class="c5">&prime; </span><span class="c3">is depicted in Figure 6, which matches for h(v</span><span class="c5">q</span><span class="c2">&prime;</span><span class="c15">1 </span><span class="c4">) = v</span><span class="c5">G</span><span class="c15">11</span><span class="c4">, h(v</span><span class="c5">q</span><span class="c2">&prime;</span><span class="c15">2 </span><span class="c4">) = v</span><span class="c5">G</span><span class="c15">8 </span><span class="c4">, h(v</span><span class="c5">q</span><span class="c2">&prime;</span><span class="c15">3 </span><span class="c4">) = v</span><span class="c5">G</span><span class="c15">9 </span><span class="c4">, </span><span class="c3">h(v</span><span class="c5">q</span><span class="c2">&prime;</span><span class="c15">4 </span><span class="c4">) = v</span><span class="c5">G</span><span class="c15">10</span><span class="c4">, and h(v</span><span class="c5">q</span><span class="c2">&prime;</span><span class="c15">5 </span><span class="c4">) = v</span><span class="c5">G</span><span class="c15">6 </span><span class="c4">at </span><span class="c139">&#8710;</span><span class="c15">t </span><span class="c3">= 5 (around the &hearts; marker). A summary of the notations used throughout this paper can be found in Table 1. </span></p><p class="c160"><span class="c32">3 RELATED WORK </span><span class="c3">Various applications of temporal graphs and sources of temporal graph data can be found in surveys on temporals graphs [4, 10]. Existing research on temporal graphs primarily focuses to tempo- ral paths and their applications [1, 4, 12, 13, 15, 19, 22, 23]. None of these works study the search of a given query pattern. Most related is existing work on temporal community detection over temporal networks [9, 14, 25, 26] and multi-layer networks [3]. These work first identify communities in a static network, then identify the evolution of the communities from the changes of the network. Specifically, the problem of finding dense patterns in temporal graphs has been studied in [25, 26]. This work allows to find diversified dense regions, thus minimizing the temporal and social redundancy of the returned patterns. Such diversification may also be applied to the arbitrary patterns mined in this work, but is not in this paper&rsquo;s scope. A recent approach [16] considers relations between edges, namely the time-respecting subgraph isomorphism problem, where edges are put into temporal se- quence of each other. This is useful to model propagation in a network, but cannot handle more complex temporal constraints in the query. The authors propose a time-first, topology-first and a hybrid solution to approach their problem. A consideration of the fact that edges can appear and disappear over time is made in [18], which focuses on finding structural subgraph patterns in the graph that persist over the longest period of time. This is supported by three index structures that store label information, neighbourhood constellations and path maps. </span></p><p class="c175"><span class="c3">In summary, these works can be used to find dense regions such as cliques and quasi-cliques in a temporal network, but do not allow to find patterns arbitrarily shaped over time. Thus, to </span></p><p class="c60"><span class="c37">290 </span></p><p class="c11"><span class="c115">G </span><span class="c99">V </span><span class="c59">10 </span><span class="c89">&#9826; </span></p><p class="c11"><span class="c89">&clubs; </span></p><p class="c11"><span class="c22">6-9 </span><span class="c61">V </span><span class="c115">G </span><span class="c82">6 </span><span class="c22">2-8 </span></p><p class="c91"><span class="c81">V </span><span class="c141">G </span><span class="c22">9 1-9 2-9 5-9 </span></p><p class="c11"><span class="c22">6-9 </span><span class="c89">&#9825; </span></p><p class="c11"><span class="c99">V </span><span class="c59">11 </span><span class="c115">G </span><span class="c22">5-7 </span><span class="c81">V </span><span class="c141">G </span><span class="c22">3 1-9 </span></p><p class="c11"><span class="c61">V </span><span class="c115">G </span><span class="c82">5 </span><span class="c61">V </span></p><p class="c11"><span class="c115">G </span><span class="c82">8 </span><span class="c22">2-4 4-7 </span></p><p class="c91"><span class="c114">V </span><span class="c121">1 </span><span class="c150">q </span><span class="c158">0-2 </span><span class="c34">V </span><span class="c88">2 </span><span class="c140">q </span><span class="c121">1-2 2 </span><span class="c22">2-9 </span></p><p class="c11"><span class="c61">V </span></p><p class="c11"><span class="c115">G </span><span class="c82">2 </span><span class="c22">2-4 </span></p><p class="c11"><span class="c81">V </span></p><p class="c24"><span class="c141">G </span><span class="c22">4 2-4 </span><span class="c61">V </span><span class="c115">G </span><span class="c82">7 </span><span class="c22">4, 7-9 </span></p><p class="c24"><span class="c22">3-4 </span><span class="c61">V </span><span class="c115">G </span><span class="c82">1 </span><span class="c53">(a) </span><span class="c108">Temporal Social Graph G </span></p><p class="c11"><span class="c53">(b) </span><span class="c108">Temporal Subgraph Query q </span></p><p class="c18"><span class="c3">Figure 2: Example TSG and TSQ. Time points where the time dependent function of an edge returns a non-zero value are noted next to the edge: A dash (&lsquo;-&rsquo;) is used to denote intervals and commas (&lsquo;,&rsquo;) indicate enumeration of timepoints or intervals. The suit markers (&hearts;, &clubs;, &diams;) give visual guidance for the text description. </span></p><p class="c11"><span class="c3">t &isin; T = {0,1,...,m} time-domain (discrete) </span></p><p class="c11"><span class="c3">G = (V</span><span class="c5">G</span><span class="c3">,E</span><span class="c5">G</span><span class="c3">, F</span><span class="c5">G</span><span class="c3">) temporal social graph G </span></p><p class="c11"><span class="c3">vertices/nodes V, edges/links E, time-dependant function F(vex. </span><span class="c5">G </span><span class="c15">i </span><span class="c5">G</span><span class="c3">Figure = </span><span class="c4">,v</span><span class="c15">k </span><span class="c3">{f </span><span class="c5">G</span><span class="c4">) </span><span class="c36">v</span><span class="c5">G</span><span class="c17">i </span><span class="c4">&isin; </span><span class="c2">G</span><span class="c3">2(a) </span></p><p class="c11"><span class="c71">,v</span><span class="c4">E</span><span class="c17">k </span><span class="c5">G</span><span class="c2">G</span><span class="c4">(t)&isin;{0, </span><span class="c3">} </span></p><p class="c11"><span class="c34">V </span><span class="c88">3 </span><span class="c140">q </span><span class="c4">1}| </span></p><p class="c11"><span class="c3">q = (V </span><span class="c5">q</span><span class="c3">,E</span><span class="c5">q</span><span class="c3">, F</span><span class="c5">q</span><span class="c3">) temporal social query graph q </span></p><p class="c11"><span class="c3">ex. Figure 2(b) ex. Figure 6 </span></p><p class="c11"><span class="c3">S &isin; S subgraphs of G matching q S = (V </span><span class="c5">S</span><span class="c3">,E</span><span class="c5">S</span><span class="c3">, F</span><span class="c5">S</span><span class="c3">) </span></p><p class="c11"><span class="c3">G</span><span class="c5">&perp; </span><span class="c3">= (V </span><span class="c5">G</span><span class="c3">,E</span><span class="c5">G</span><span class="c3">) non-temporal projection of G </span></p><p class="c11"><span class="c3">h : V</span><span class="c5">q </span><span class="c3">&rarr; V </span><span class="c5">S </span><span class="c3">bijection mapping </span></p><p class="c11"><span class="c3">M</span><span class="c5">S </span><span class="c3">assignment map of an isomorph </span></p><p class="c11"><span class="c3">S to q within G size of M</span><span class="c5">S</span><span class="c3">: |V</span><span class="c5">q</span><span class="c3">|&times;|V </span><span class="c5">G</span><span class="c3">| </span></p><p class="c11"><span class="c3">M</span><span class="c5">0 </span><span class="c3">aggregation of all M</span><span class="c5">S </span></p><p class="c11"><span class="c3">ex. Figure 7 </span></p><p class="c11"><span class="c3">SSG = (V </span><span class="c5">SSG</span><span class="c3">, E</span><span class="c5">SSG</span><span class="c3">) simple subgraph structure </span></p><p class="c11"><span class="c3">ex. Figure 3 ex. Figure 9 </span></p><p class="c11"><span class="c3">&spades;,&hearts;, &clubs;, &diams; visual markers </span></p><p class="c11"><span class="c3">Table 1: Notations used throughout this paper. </span></p><p class="c18"><span class="c3">the best of our knowledge, our work is the first one for finding patterns in temporal graphs such that the query pattern exhibits temporal constraints. </span></p><p class="c18"><span class="c3">A further line of related work is pattern search on static (non- temporal) graphs. The solution to this problem was proposed by Ullmann [21] and serves as our baseline. This problem, for which a survey of solutions is found in [5], still attracts vivid research attention (e.g., [17, 20]). This pattern search has further been extended to labelled vertex-graphs, as surveyed in [8]. While this research field has received extensive attention, these solutions are not applicable to our problem setting since they do not consider any time-dependent network structures, which increases the complexity of the problem. </span></p><p class="c18"><span class="c3">Furthermore, solutions have been presented for the problem of finding subgraphs in a large collection of small graphs [24]. This approach first mines frequent structures and stores for each frequent structure the IDs of the graphs that contain it (similar to an inverted file). A query can then be answered by identify- ing the frequent structures contained in it and intersecting the corresponding lists of IDs. Although, this problem setting is also fundamentally different, it nonetheless inspired us for the index structure proposed in this work. </span></p><p class="c11"><span class="c37">291 </span></p><p class="c11"><span class="c32">4 BASIC TEMPORAL SUBGRAPH </span></p><p class="c11"><span class="c32">MATCHING </span><span class="c3">The problem of temporal subgraph matching is related to the classic subgraph isomorphism counting problem, which is to find the set S of all subgraphs of a non-temporal graph G that are isomorphic to a given non-temporal query graphq. This problem is a generalization of the NP-complete subgraph isomorphism problem [6, 11], where the challenge is to decide whether any such subgraph S &isin; S exists in G. Consequently, the subgraph isomorphism counting problem is NP-hard, since its result can be used in to decide the subgraph isomorphism problem in O(1), by testing the number of subgraphs for positivity. The current best- known algorithm for obtaining the exact count of an arbitrary query graph q is in O(n </span></p><p class="c18"><span class="c84">&omega;</span><span class="c17">k</span><span class="c47">3 </span><span class="c12">), where k is the size of query graph </span><span class="c3">q and &omega; is the exponent of fast matrix multiplication [7]. Our problem is at least as hard as subgraph counting, as we want to enumerate all instances ofq inG, while also considering temporal constraints on edges. </span></p><p class="c18"><span class="c3">The problem of finding all subgraph isomorphisms on static (non-temporal) graphs can be extended to temporal subgraphs as follows: Given a temporal query subgraph q = (V </span><span class="c5">q</span><span class="c3">,E</span><span class="c5">q</span><span class="c3">, F</span><span class="c5">q</span><span class="c3">), initialize the non-temporal graph q</span><span class="c5">&perp; </span><span class="c3">= (V</span><span class="c5">q</span><span class="c3">,E</span><span class="c5">q</span><span class="c3">), where F</span><span class="c5">q</span><span class="c2">&perp; </span><span class="c3">0. In informal words, two nodes in q</span><span class="c5">&perp; </span><span class="c3">are connected iff their corre- sponding vertices in q are connected at least at one point of time. This can be seen as a projection of the temporal query q to a single point of time. Now this projection is applied on the tempo- ral graph G = (V</span><span class="c5">G</span><span class="c3">, E</span><span class="c5">G</span><span class="c3">,F</span><span class="c5">G</span><span class="c3">) as well, yielding the non-temporal graph G</span><span class="c5">&perp; </span><span class="c3">= (V</span><span class="c5">G</span><span class="c3">,E</span><span class="c5">G</span><span class="c3">). Now solve the subgraph isomorphism problem on the &ldquo;flattened&rdquo; by finding the set of all subgraphs S</span><span class="c5">&perp; </span><span class="c3">of G</span><span class="c5">&perp; </span><span class="c3">that are isomorphic to q</span><span class="c5">&perp;</span><span class="c3">. This yields, for each any edge e in any resulting graph S</span><span class="c5">&perp; </span><span class="c3">&isin; S</span><span class="c5">&perp; </span><span class="c3">a mapping h(e) to an edge in G as described in Definition 2.2. </span></p><p class="c91"><span class="c3">Since the temporal subgraph query is more selective than the non-temporal query by considering temporal constraints, an additional refinement step is necessary. For any S</span><span class="c5">&perp; </span><span class="c3">&isin; S</span><span class="c5">&perp; </span><span class="c3">to be verified as a result of the overall temporal subgraph query, there function must F</span><span class="c5">q </span><span class="c3">exist matches a time the offset time </span><span class="c80">&#8710;</span><span class="c3">dependent </span><span class="c42">t </span><span class="c12">such that the time-dependent </span><span class="c3">function of S. More formally, S</span><span class="c5">&perp; </span><span class="c3">= (V </span><span class="c5">S</span><span class="c3">,E</span><span class="c5">S</span><span class="c3">) satisfies the temporal of q f </span><span class="c15">h(e)</span><span class="c5">G</span><span class="c3">iff </span><span class="c80">&exist;&#8710;</span><span class="c42">t </span><span class="c12">&isin; </span><span class="c4">(t + </span><span class="c139">&#8710;</span><span class="c15">t</span><span class="c3">). </span></p><p class="c11"><span class="c12">{0, ...,m &minus; q</span><span class="c15">t</span><span class="c12">} : </span><span class="c97">&forall;</span><span class="c12">e &isin; S</span><span class="c15">&perp; </span><span class="c12">: </span><span class="c97">&forall;</span><span class="c12">t </span><span class="c3">subgraph </span><span class="c12">&isin; [0,t</span><span class="c15">q</span><span class="c12">] : f </span><span class="c42">e </span><span class="c15">q</span><span class="c3">query (t) = </span></p><p class="c11"><span class="c32">4.1 Subgraph Isomorphism in Non-Temporal </span></p><p class="c24"><span class="c32">Graphs </span><span class="c3">Ullmann [21] introduces a viable method for solving the (non- temporal) subgraph isomorphism problem, which we will extend and briefly describe in this chapter: Let G be a non-temporal graph, which is the special case of a temporal graph having a singular time domain T = {0} and having all edges in E</span><span class="c5">G </span><span class="c3">exist at time 0. For every subgraph S = (V </span><span class="c5">S</span><span class="c3">,E</span><span class="c5">S</span><span class="c3">) &isin; G that is isomorph to a query that be interpreted M</span><span class="c15">i</span><span class="c36">,</span><span class="c15">j </span><span class="c5">S</span><span class="c4">= </span><span class="c3">graph </span><span class="c4">1 iff </span><span class="c3">as </span><span class="c4">h(v</span><span class="c3">q, an we </span><span class="c15">i </span><span class="c5">q</span><span class="c4">) </span><span class="c3">assignment can </span><span class="c4">= v</span><span class="c5">G</span><span class="c15">j </span><span class="c3">define </span><span class="c4">and </span><span class="c3">a |V </span><span class="c5">q</span><span class="c3">|&times;|V</span><span class="c4">0 otherwise. </span><span class="c3">map that </span><span class="c5">G</span><span class="c3">| matrix </span><span class="c4">M</span><span class="c5">S </span><span class="c3">locates M</span><span class="c5">S</span><span class="c3">, such can therefore the vertices of the subgraph in the larger graph. Note that in every row of M</span><span class="c5">S</span><span class="c3">, there is exactly one cell with the value of 1, while in every column there is at most one cell to contain a 1. </span></p><p class="c11"><span class="c3">Let furthermoreM</span><span class="c5">0 </span><span class="c3">be a matrix having the same dimensions as M</span><span class="c5">S </span><span class="c3">and M</span><span class="c15">i</span><span class="c36">,</span><span class="c15">j </span><span class="c5">0</span><span class="c4">= 1&minus; </span><span class="c15">S &isin;G</span><span class="c4">(1&minus;M</span><span class="c15">i</span><span class="c36">,</span><span class="c15">j</span><span class="c5">S</span><span class="c4">), so that M</span><span class="c5">0 </span><span class="c3">gives information </span></p><p class="c18"><span class="c3">about whether there exists any unspecified subgraph S so that h(v</span><span class="c15">i </span><span class="c5">S</span><span class="c4">) = v</span><span class="c5">G</span><span class="c15">j </span><span class="c4">. It is now possible to retrieve the individual subgraph </span><span class="c3">matrices M</span><span class="c5">S </span><span class="c3">from M</span><span class="c5">0</span><span class="c3">, along with possible other matrices, which do not belong to a valid subgraph query solution: Alter the cells of M</span><span class="c5">0 </span><span class="c3">by setting different cells from 1 to 0, until the constraints of a subgraph representation are fulfilled (exactly one 1 per row, max. one 1 per column). </span></p><p class="c91"><span class="c3">The main idea is to mine candidate subgraphs S from M</span><span class="c5">0</span><span class="c3">, which are matching in the &ldquo;flattened&rdquo; graph G</span><span class="c5">&perp; </span><span class="c3">that is oblivious to the time constraints. Therefore, a cell M</span><span class="c15">i</span><span class="c36">,</span><span class="c15">j </span><span class="c5">0</span><span class="c4">= 0 implies that </span><span class="c3">there exists no subgraph S where h(v</span><span class="c5">S</span><span class="c15">j </span><span class="c4">) would map vertex v</span><span class="c5">S</span><span class="c15">j </span><span class="c4">to </span><span class="c3">vertexvthat such </span><span class="c15">i </span><span class="c5">G</span><span class="c3">a </span><span class="c4">in </span><span class="c3">graph </span><span class="c4">the social </span><span class="c3">may </span><span class="c4">network. </span><span class="c3">possibly exist. </span><span class="c4">Analogously, </span><span class="c3">A trivial </span><span class="c4">a </span><span class="c3">case </span><span class="c4">value </span><span class="c3">is to </span><span class="c4">of </span><span class="c3">set </span><span class="c4">1 implies </span><span class="c3">every Msubgraph </span><span class="c15">i</span><span class="c36">,</span><span class="c15">j </span><span class="c5">0</span><span class="c4">to 1, which means that every vertex in G can be part in any </span><span class="c3">that fulfills q. But in order to improve the runtime of the algorithm, it is desireable to reduce the number of subgraph combination. This can be achieved by setting as many cells in M</span><span class="c5">0 </span><span class="c3">to 0 as possible. There are different methods to prune candidates with varying complexity and efficiency: </span></p><p class="c91"><span class="c3">&bull; Pruning works then Mthe </span><span class="c15">i</span><span class="c36">,</span><span class="c15">j </span><span class="c5">0</span><span class="c3">based on a node&rsquo;s degree. If deg(v</span><span class="c15">i </span><span class="c5">S</span><span class="c4">) &gt; deg(v</span><span class="c5">G</span><span class="c15">j </span><span class="c4">), can be set to 0. Note however, that in social net- </span><span class="c3">degree of the vertices is usually much higher than the degree of vertices in the query pattern q, which is why this approach yields limited pruning power. </span></p><p class="c18"><span class="c3">&bull; Pruning based on invalid neighbour mappings. Ver- tices can be pruned if there is no valid assignment for its neighbours, although the node itself can be mapped between S and q. More formally, a cell M</span><span class="c15">i</span><span class="c36">,</span><span class="c15">j </span><span class="c5">0</span><span class="c4">= 1 can be set </span><span class="c3">to 0 (and thus be pruned), if there is a neighbour vertex v</span><span class="c15">u </span><span class="c5">S</span><span class="c4">of v</span><span class="c15">i </span><span class="c5">S</span><span class="c4">(i.e. (v</span><span class="c15">i </span><span class="c5">S</span><span class="c4">,v</span><span class="c15">u</span><span class="c5">S</span><span class="c4">) &isin; E</span><span class="c5">S</span><span class="c3">) and no neighbour v</span><span class="c15">w </span><span class="c5">G</span><span class="c4">of v</span><span class="c5">G</span><span class="c15">j </span><span class="c3">(i.e. (v</span><span class="c5">G</span><span class="c15">j </span><span class="c4">,v</span><span class="c15">w</span><span class="c5">G</span><span class="c4">) &isin; E</span><span class="c5">G</span><span class="c3">) such that M</span><span class="c15">u</span><span class="c36">,</span><span class="c15">w </span><span class="c5">0</span><span class="c4">= 1: </span></p><p class="c11"><span class="c3">M</span><span class="c15">ij </span><span class="c5">0</span><span class="c4">&larr; M</span><span class="c15">i</span><span class="c36">,</span><span class="c15">j </span><span class="c5">0</span><span class="c4">&middot; </span></p><p class="c11"><span class="c3">( </span></p><p class="c11"><span class="c15">(</span><span class="c36">v</span><span class="c17">i </span><span class="c2">S</span><span class="c71">,v</span><span class="c17">u</span><span class="c2">S</span><span class="c5">)&isin;E</span><span class="c2">S </span></p><p class="c11"><span class="c3">(</span><span class="c12">1 &minus; M</span><span class="c42">uw</span><span class="c15">0</span><span class="c3">)</span><span class="c4">)) </span></p><p class="c18"><span class="c3">Pruning a cell may allow for further pruning of other cells, so a new pruning iteration should be invoked after a suc- cessfully setting a cell to 0. This method can be stacked with other methods to further remove further candidates after another method was successful in removing candi- dates. </span></p><p class="c11"><span class="c32">4.2 Additional Pruning Filters for Temporal </span></p><p class="c11"><span class="c32">Graphs </span><span class="c3">Besides the generic filter steps enlisted in Section 4.1, we further- more introduce two more viable filter steps that can be applied in the context of temporal subgraph isomorphisms: </span></p><p class="c91"><span class="c3">&bull; Pruning based on time offset. As described before, ev- ery derived subgraph S that is a candidate to be isomorph to the query (represented through M</span><span class="c5">S</span><span class="c3">) needs to be refined in the sense that there needs to exist a </span><span class="c80">&#8710;</span><span class="c42">t </span><span class="c12">so that the time- </span><span class="c3">dependant functions feasible to create frame from </span><span class="c80">&#8710;</span><span class="c15">t </span><span class="c3">match. a copy until </span><span class="c80">&#8710;</span><span class="c15">t </span><span class="c3">When testing + Mt</span><span class="c5">q </span><span class="c36">&#8710;</span><span class="c5">S</span><span class="c47">t </span><span class="c3">is of relevant M</span><span class="c5">S</span><span class="c3">. various </span><span class="c80">&#8710;</span><span class="c42">t</span><span class="c12">, it is </span><span class="c3">Since only the time for the matching of the functions, the graphG can be projected onto a more sparse graph N</span><span class="c9">&#8710;</span><span class="c47">t </span><span class="c3">than N by only inserting an edge into </span></p><p class="c11"><span class="c37">292 </span></p><p class="c11"><span class="c3">(</span><span class="c12">1 &minus; </span></p><p class="c11"><span class="c15">(</span><span class="c36">v</span><span class="c17">j </span><span class="c2">G</span><span class="c71">,v</span><span class="c17">w</span><span class="c2">G</span><span class="c5">)&isin;E</span><span class="c2">G </span></p><p class="c11"><span class="c3">E</span><span class="c5">N</span><span class="c84">&#8710;</span><span class="c47">t </span><span class="c12">, if the corresponding edge in G exists in this more </span><span class="c3">narrow time frame. </span></p><p class="c18"><span class="c3">&bull; Pruning based on network distance. When iterating through M</span><span class="c5">0</span><span class="c3">, after setting a candidate value for the first processed row of M</span><span class="c5">0</span><span class="c3">, we can try to cut down the the number of columns that can contain 1s at all. Let i be the index of a row where exactly one column j is set to one. Then we can compute the maximum hops from v</span><span class="c5">S</span><span class="c15">i </span><span class="c4">to any </span><span class="c3">other node in S. Then we determine all nodes in the graph N, whose hops distance to v</span><span class="c5">N</span><span class="c15">j </span><span class="c4">is larger than that distance. </span><span class="c3">Those columns can then be set to zero. This is a viable approach if |V </span><span class="c5">N </span><span class="c3">|&#8811;|V </span><span class="c5">S </span><span class="c3">| and N is sparse. For efficiency reasons, it is recommended to pick the first row i in a way so that v</span><span class="c5">S</span><span class="c15">i </span><span class="c4">lies in a central position in S, e.g. minimizing </span><span class="c3">the maximum hops distance. As temporal aspects are not a pruning criterion for this filter, it can generally be applied to non-temporal subgraph isomorphism queries as well. </span></p><p class="c18"><span class="c3">In our experiments, we will take a deeper look at the effective- ness and performance of the basic and our extended filters. We will also evaluate the processing order, in which these filters are applied. </span></p><p class="c11"><span class="c32">5 AN INDEX STRUCTURE FOR TEMPORAL </span></p><p class="c11"><span class="c32">GRAPHS </span><span class="c3">In this section we will give an in depth description of how to build an index for temporal social graphs and how to perform pattern queries on this index. </span></p><p class="c11"><span class="c3">The construction of an index structure that supports subgraph pattern search on temporal graphs can be summarized in four steps: (1) Select one or more simple subgraph structures (SSGs) and do the following steps for each of them. (2) Find each oc- currence of the SSG in the graph G without consideration of the temporal aspect. (3) Transform each occurrence into a string reflecting its unique behaviour over time considering the func- tions f of the edges. (4) Index the obtained strings using an index structure for substring search. In the following we will consider each of these steps in detail. Simple Subgraph Structure Selection: The selection of suit- able SSGs (SSG = (V </span><span class="c5">SSG</span><span class="c3">,E</span><span class="c5">SSG</span><span class="c3">)) is crucial for the performance of the index, since the index can later on only answer queries that contain at least one of the selected SSG. A good set of SSGs should thus contain even the simplest possible query structures. Let us note that a temporal pattern query on a TSG must involve at least a relationship (edge) of two entities (nodes). The most simple SSGs involving 2 and 3 nodes, illustrated in Figure 3, should thus always be indexed in order to allow index support for all possible queries. When challenging the trade off between simplicity and ubiquitousness of SSGs, multiple different SSGs may be indexed in parallel to suit a wider array of queries. In the following we will showcase the construction of the index based on the triangle structure. </span></p><p class="c18"><span class="c3">Finding SSG Occurrences: To find all occurances of the SSG in the graph, the temporal aspect of G will be neglected thus using &ldquo;flattened&rdquo; version of G</span><span class="c5">&perp; </span><span class="c3">of G as used in Section 4. Within G</span><span class="c5">&perp;</span><span class="c3">, we search for all occurrences of the SSG using a traditional subgraph isomorphism algorithm such as [21]. An SSG occurs at a set of nodesV</span><span class="c5">O </span><span class="c3">&sub; V</span><span class="c5">G </span><span class="c3">iff (v</span><span class="c5">O</span><span class="c15">i </span><span class="c4">,v</span><span class="c5">O</span><span class="c15">j </span><span class="c4">) &isin; E</span><span class="c5">N </span><span class="c3">&hArr; (v</span><span class="c5">SSG </span><span class="c15">i </span><span class="c4">,v</span><span class="c5">SSG </span><span class="c15">j </span><span class="c4">) &isin; E</span><span class="c5">SSG</span><span class="c3">. Please note that due to possible symmetries, several occurrence </span></p><p class="c91"><span class="c55">SSG</span><span class="c74">v </span><span class="c55">SSG</span><span class="c93">3</span><span class="c74">v </span><span class="c93">2</span><span class="c74">v </span></p><p class="c11"><span class="c55">SSG</span><span class="c93">1</span><span class="c74">v </span></p><p class="c11"><span class="c55">SSG</span><span class="c93">2</span><span class="c74">v </span></p><p class="c91"><span class="c55">SSG</span><span class="c93">1</span><span class="c161">V </span><span class="c74">v </span><span class="c94">k</span><span class="c133">2</span><span class="c55">SSG</span><span class="c93">2</span><span class="c74">v </span></p><p class="c11"><span class="c55">SSG</span><span class="c93">1</span><span class="c74">v </span><span class="c55">SSG</span><span class="c93">3</span><span class="c3">Figure 3: Simple Subgraph Structures (SSGs) with 2 and 3 nodes </span></p><p class="c11"><span class="c25">V </span></p><p class="c11"><span class="c31">2 </span><span class="c58">k </span><span class="c25">V </span></p><p class="c11"><span class="c31">2 </span><span class="c58">k </span><span class="c25">V </span><span class="c31">2 </span><span class="c58">k </span><span class="c111">V </span></p><p class="c11"><span class="c76">1 </span><span class="c50">k </span><span class="c98">A </span><span class="c25">V </span><span class="c31">3 </span><span class="c69">k </span><span class="c111">V </span></p><p class="c11"><span class="c76">1 </span><span class="c50">k </span><span class="c98">B </span><span class="c25">V </span><span class="c31">3 </span><span class="c69">k </span><span class="c111">V </span><span class="c76">1 </span><span class="c50">k </span><span class="c98">C </span><span class="c25">V </span><span class="c31">3 </span><span class="c69">k </span><span class="c25">V </span><span class="c31">2 </span><span class="c58">k </span><span class="c25">V </span></p><p class="c11"><span class="c31">2 </span><span class="c58">k </span><span class="c25">V </span><span class="c31">2 </span><span class="c58">k </span><span class="c111">V </span></p><p class="c11"><span class="c76">1 </span><span class="c50">k </span><span class="c98">D </span><span class="c25">V </span><span class="c31">3 </span><span class="c69">k </span><span class="c111">V </span></p><p class="c11"><span class="c76">1 </span><span class="c50">k </span><span class="c98">E </span><span class="c25">V </span><span class="c31">3 </span><span class="c69">k </span><span class="c111">V </span><span class="c76">1 </span><span class="c50">k </span><span class="c98">F </span><span class="c25">V </span><span class="c31">3 </span><span class="c69">k </span><span class="c25">V </span><span class="c31">2 </span><span class="c58">k </span><span class="c25">V </span><span class="c31">2 </span><span class="c58">k </span><span class="c111">V </span></p><p class="c11"><span class="c76">1 </span><span class="c50">k </span><span class="c98">G </span><span class="c25">V </span><span class="c31">3 </span><span class="c69">k </span><span class="c111">V </span><span class="c76">1 </span><span class="c50">k </span><span class="c98">H </span><span class="c25">V </span><span class="c31">3 </span><span class="c69">k </span><span class="c3">Figure 4: Encoding the edges of a graph. Each possible graph topology is encoded by an uppercase Latin charac- ter A-H. </span></p><p class="c11"><span class="c3">can happen for the same set of V </span><span class="c5">O</span><span class="c3">, depending on how V </span><span class="c5">O </span><span class="c3">is mapped to V </span><span class="c5">SSG</span><span class="c3">. </span></p><p class="c18"><span class="c3">Example 5.1. The triangle SSG occurs within the graph of Figure 2(a) at the positions marked with &hearts;, &clubs;, and &diams;. If there would </span><span class="c12">would </span><span class="c3">be </span><span class="c12">also </span><span class="c3">an </span><span class="c12">form </span><span class="c3">edge </span><span class="c12">an </span><span class="c3">(v</span><span class="c5">G</span><span class="c15">6 </span><span class="c12">occurrence, </span><span class="c4">,v</span><span class="c15">10</span><span class="c5">G</span><span class="c4">) at time </span><span class="c12">even </span><span class="c4">1, the </span><span class="c12">though </span><span class="c4">set of </span><span class="c12">at </span><span class="c4">nodesv</span><span class="c12">no point </span><span class="c5">G</span><span class="c15">6 </span><span class="c4">,v</span><span class="c12">of </span><span class="c15">9 </span><span class="c5">G</span><span class="c12">time </span><span class="c4">,v</span><span class="c15">10 </span><span class="c5">G</span><span class="c3">an actual triangle is formed between the nodes. </span></p><p class="c18"><span class="c3">The identification of those SSG occurances does not come free of cost: In particular, finding all subgraphs of G that are an occurance of the SSG has a runtime complexity of O(n </span></p><p class="c18"><span class="c84">&omega;</span><span class="c17">k</span><span class="c47">3 </span><span class="c12">), </span><span class="c3">where k is the size of query graphq and &omega; is the exponent of fast matrix multiplication [7]. However, this task can be performed offline and will not affect the query performance. Furthermore, the actual runtime is in general low enough due to two reasons: First, the SSGs are usually very small (in our example not more than 3 nodes) and second, the graph G is not fully connected in a real-world setting. </span></p><p class="c91"><span class="c3">String Transformation: At every discrete point of time, a set of nodes in the graph that belong to an SSG can form a certain constellation via their edges. Figure 4 shows all possible com- binations for a triangle SSG consisting of three, distinguishable nodes unique (vsymbol; </span><span class="c15">1 </span><span class="c5">SSG </span><span class="c4">, v</span><span class="c15">2 </span><span class="c5">SSG </span><span class="c3">here </span><span class="c4">, and </span><span class="c3">we </span><span class="c4">v</span><span class="c15">3 </span><span class="c5">SSG </span><span class="c3">are </span><span class="c4">) </span><span class="c3">using </span><span class="c4">and assigns each constellation a </span><span class="c3">uppercase Latin characters. To encode an SSG&rsquo;s temporal behaviour over time, at each time frame the currently present edges have to be figured out and be mapped via a pre-defined assignment table (such like Figure 4) to a unique symbol or character. In general, the alphabet to encode all constellations of an SSG having k edges consists of 2</span><span class="c5">k </span></p><p class="c11"><span class="c37">293 </span></p><p class="c18"><span class="c3">characters. Concatenating these characters along the chronologi- cal time-series will yield in a string representing the temporal behaviour. </span></p><p class="c18"><span class="c3">Example 5.2. The graphq denoted in Figure 2(b) shall be repre- sented by a string using the triangle SSG. When each node v</span><span class="c5">q</span><span class="c15">i </span><span class="c4">is </span><span class="c3">mapped tov</span><span class="c5">SSG </span><span class="c15">i </span><span class="c4">, the symbol representing the graph constellation </span><span class="c3">at each time frame t</span><span class="c42">j </span><span class="c12">(0 &le; j &le; t</span><span class="c15">q</span><span class="c12">) can be looked up in Figure 4 </span><span class="c3">(t</span><span class="c42">0</span><span class="c12">: B, t</span><span class="c42">1</span><span class="c12">: F, t</span><span class="c42">2</span><span class="c12">: H), thus yielding the string BFH. For other possible </span><span class="c3">mappings of v</span><span class="c5">q </span><span class="c3">to v</span><span class="c5">SSG </span><span class="c3">the string representations BGH, CEH, CGH, DEH, and DFH are valid as well. </span></p><p class="c18"><span class="c3">This schema can be applied to all substructure occurrences found in the graph, so that each occurrence&rsquo;s temporal behaviour can be described through a string. It is then feasible to index those strings in a way to efficiently support substring search. We propose to employ a suffix-tree to index these substrings concisely. </span></p><p class="c18"><span class="c3">Example 5.3. Consider the triangle SSG. It occurs three times in our example graph G (Figure 2(a)), namely at &hearts;, &clubs;, and &diams;. For every occurrence, there exist six possible permutations of how the substructure can occur at this position, due to the waysv</span><span class="c5">G</span><span class="c15">i </span><span class="c12">may be mapped to v</span><span class="c15">SSG </span><span class="c42">i </span><span class="c3">. We depict all of these occurrences and permutations in Figure 5. </span></p><p class="c11"><span class="c32">6 QUERY PROCESSING </span><span class="c3">Next, we describe how our string-index can find all occurrences of a given temporal query pattern q. As described in Section 5, in the following, we assume that an index has been build for a specific simple subgraph structures SSG. </span></p><p class="c11"><span class="c3">(1) Identify occurrences of the SSG in the &ldquo;flattened&rdquo; temporal </span></p><p class="c11"><span class="c3">graph query q</span><span class="c5">&perp;</span><span class="c3">. (2) For each such occurrence, perform the same string trans- </span></p><p class="c11"><span class="c3">formation than performed for the index (i.e., use the same character map). (3) Index-supported search for the transformed string to find </span></p><p class="c11"><span class="c3">candidates for verification. (4) Refine the candidates through verifying that the part of q which is not contained in the SSG is isomorph to the surrounding of a candidate. </span></p><p class="c91"><span class="c3">In more detail, to answer queries according to Definition 2.2 using the index support of the suffix-tree, we first have to isolate those SSG occurrences in the graph topology of the query graph of the SSG that was used for the string transformation process before. An SSG may occur not at all, once, or multiple times in the graph. If no SSG occurrence can be found, the index is of no help and the search has to default to a full scan, which is why there is a motivation to keep SSGs small and simple. In case of one or several occurrences of the SSG in q, we isolate the temporal behaviour of that part of the query graph and transform it using the same string encoding method used for the index construction. Since the queried time frame is usually smaller than the in- dexed time span, the length of the string derived from the SSG occurrence in q is shorter than the length of string belonging to the occurrence in the graph which is stored in the index. To answer the query, we now must find all those strings in the index that contain the substring belonging to the query. </span></p><p class="c18"><span class="c3">Example 6.1. Identification and String Transformation of SSG in query q. In our example query q</span><span class="c5">&prime; </span><span class="c3">(Figure 6), the tri- angle SSG occurs at the &spades; marker. Since there are six possible permutations of the occurrence, valid string transformations are EHH, EHH, FHH, FHH, GHH, and GHH. With each of these unique query strings, we can search our encoding index (suffix tree) for entries that contain the query string. The substring positions are indicated through bold and underlined text in Figure 5. Entries which do not contain one of the substrings can be pruned. </span></p><p class="c18"><span class="c3">Since practical SSGs consist of more than one node, there is usually always more than one way it can be mapped to either the nodes of the occurrence in the query graph or the occurrence in the main. I.e., there are also several string transformations of the occurrence. There are in general several ways to approach these permutations: </span></p><p class="c18"><span class="c3">&bull; Account for permutations at index creation and query processing. This means that every permutation is indexed, thus resulting in a larger index, and that index is queried multiple times (once for each permutation of the query) </span></p><p class="c11"><span class="c3">&bull; Consider the permutations in the index, but not for the query </span></p><p class="c11"><span class="c3">&bull; Consider the permutations only within the query </span></p><p class="c11"><span class="c3">&bull; Neglect the permutations in the query graph and at index creation. Neglecting all permutations may result in correct results not be- ing found, as there is no guarantee that an &lsquo;identical&rsquo; permutation has been used for the index and the query. On the other hand, if permutations are considered both times, the result will also show how the query &lsquo;fits&rsquo; into the graph, i.e. the direct mapping from the nodes can be deducted. However, multiple queries have to be performed on an increased index, thus increasing query cost. As a trade-off, it is possible to only consider all permuta- tions on one side (either the index or the query), and then find out the mapping in a refinement step. We recommend to con- sider all permutations within the index and not for the query, as submitting multiple queries increases the overall query cost linearly, while linearly enlarging the index results in a sublinear increase in query performance. Compared to the approach where permutations are considered on both sides, a refinement step is now necessary to deduct the exact mapping of the query to the substructure (one mapping per possible permutation). This is likely to be done faster after the query than it is to do multiple queries (one for each permutation). </span></p><p class="c18"><span class="c3">Example 6.2. Index-supported Search for Transformed String Representation of the SSG. If following our advice to only consider permutations within the index, querying our exam- ple query q</span><span class="c5">&prime; </span><span class="c3">(Figure 6) with a triangle SSG, the search string will either be EHH or FHH or GHH. The exemplary index in Figure 5 will then yield the set of nodes {v</span><span class="c5">G</span><span class="c15">3 </span><span class="c4">,v</span><span class="c5">G</span><span class="c15">5 </span><span class="c4">,v</span><span class="c5">G</span><span class="c15">6 </span><span class="c4">} for the &diams;, and </span><span class="c3">the set {v</span><span class="c5">G</span><span class="c15">8 </span><span class="c4">,v</span><span class="c5">G</span><span class="c15">9 </span><span class="c4">,v</span><span class="c5">G</span><span class="c15">11</span><span class="c4">} for the &hearts; occurance. However, the mapping </span><span class="c3">of v</span><span class="c5">q</span><span class="c2">&prime; </span></p><p class="c11"><span class="c15">i </span><span class="c4">to v</span><span class="c5">G</span><span class="c15">j </span><span class="c4">cannot be deducted from the index and has to be </span><span class="c3">refined computationally. </span></p><p class="c18"><span class="c3">Searching for a substring in the index then retrieves two im- portant facts for every match: (1) a subset ofV</span><span class="c5">G </span><span class="c3">that corresponds to an SSG occurrence, and (2) the temporal offset </span><span class="c80">&#8710;</span><span class="c42">t </span><span class="c12">at which </span><span class="c3">it occurred (calculated by the offset position of the substring from the beginning of the indexed string). Both are crucial for </span></p><p class="c11"><span class="c37">294 </span></p><p class="c11"><span class="c26">G</span><span class="c62">V</span><span class="c46">G</span><span class="c68">3 </span><span class="c48">1-9 </span><span class="c68">1-9 </span><span class="c122">&#9826;</span><span class="c62">V </span><span class="c48">6</span><span class="c68">2-9 </span></p><p class="c11"><span class="c68">2-4 </span></p><p class="c11"><span class="c68">4, 7-9 </span><span class="c26">G</span><span class="c62">V </span><span class="c26">G</span><span class="c48">5</span><span class="c62">V </span></p><p class="c11"><span class="c26">G</span><span class="c48">2</span><span class="c62">V </span></p><p class="c11"><span class="c26">G</span><span class="c48">4</span><span class="c68">3-4 </span></p><p class="c11"><span class="c62">V</span><span class="c46">G</span><span class="c68">9 </span><span class="c48">5-9 </span></p><p class="c91"><span class="c68">6-9 </span><span class="c122">&#9825;</span><span class="c62">V </span><span class="c182">11</span><span class="c68">5-7 </span><span class="c62">V </span></p><p class="c11"><span class="c26">G</span><span class="c48">1</span><span class="c62">V </span><span class="c26">G</span><span class="c48">8</span><span class="c20">Mapping </span><span class="c16">String !</span><span class="c0">1</span><span class="c10">#$$ </span><span class="c16">!</span><span class="c0">2</span><span class="c10">#$$ </span><span class="c16">!</span><span class="c0">3</span><span class="c10">#$$ </span><span class="c20">Transformation !</span><span class="c0">3</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">5</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">6</span><span class="c10">$ </span><span class="c16">A</span><span class="c63">FHH</span><span class="c16">HHHHHH </span><span class="c20">!</span><span class="c0">3</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">6</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">5</span><span class="c10">$ </span><span class="c16">A</span><span class="c63">FHH</span><span class="c16">HHHHHH </span><span class="c20">!</span><span class="c0">5</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">3</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">6</span><span class="c10">$ </span><span class="c16">A</span><span class="c63">GHH</span><span class="c16">HHHHHH </span><span class="c20">!</span><span class="c0">5</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">6</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">3</span><span class="c10">$ </span><span class="c16">A</span><span class="c63">EHH</span><span class="c16">HHHHHH </span><span class="c20">!</span><span class="c0">6</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">3</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">5</span><span class="c10">$ </span><span class="c16">A</span><span class="c63">GHH</span><span class="c16">HHHHHH </span><span class="c20">!</span><span class="c0">6</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">5</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">3</span><span class="c10">$ </span><span class="c16">A</span><span class="c63">EHH</span><span class="c16">HHHHHH </span></p><p class="c11"><span class="c174">&clubs; </span></p><p class="c11"><span class="c3">Figure 5: Transforming the temporal behaviour of the triangular SSG occurances in G to strings. </span></p><p class="c11"><span class="c13">V </span><span class="c57">3 </span><span class="c119">q </span><span class="c51">&spades; </span><span class="c13">V </span><span class="c57">2 </span><span class="c119">q </span><span class="c13">V </span><span class="c57">4 </span><span class="c119">q </span><span class="c57">1-2 </span></p><p class="c11"><span class="c56">V </span><span class="c78">1 </span><span class="c38">q </span><span class="c56">V </span><span class="c78">5 </span><span class="c38">q </span><span class="c20">Mapping </span><span class="c16">String </span></p><p class="c11"><span class="c20">Mapping </span><span class="c16">String </span></p><p class="c11"><span class="c16">!</span><span class="c0">1</span><span class="c10">#$$ </span><span class="c16">!</span><span class="c0">2</span><span class="c10">#$$ </span><span class="c16">!</span><span class="c0">3</span><span class="c10">#$$ </span></p><p class="c91"><span class="c20">Transformation </span><span class="c16">!</span><span class="c0">1</span><span class="c10">#$$ </span><span class="c16">!</span><span class="c0">2</span><span class="c10">#$$ </span><span class="c16">!</span><span class="c0">3</span><span class="c10">#$$ </span><span class="c20">Transformation !</span><span class="c0">1</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">2</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">4</span><span class="c10">$ </span><span class="c16">AACEHAABBB </span><span class="c20">!</span><span class="c0">8</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">9</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">11</span><span class="c10">$ </span><span class="c16">AAAAA</span><span class="c63">FHH</span><span class="c16">GG </span></p><p class="c11"><span class="c20">!</span><span class="c0">1</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">4</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">2</span><span class="c10">$ </span><span class="c16">AACGHAADDD </span></p><p class="c11"><span class="c20">!</span><span class="c0">8</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">11</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">9</span><span class="c10">$ </span><span class="c16">AAAAA</span><span class="c63">FHH</span><span class="c16">GG </span><span class="c20">!</span><span class="c0">2</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">1</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">4</span><span class="c10">$ </span><span class="c16">AADEHAABBB </span></p><p class="c11"><span class="c20">!</span><span class="c0">9</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">8</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">11</span><span class="c10">$ </span><span class="c16">AAAAA</span><span class="c63">GHH</span><span class="c16">GG </span><span class="c20">!</span><span class="c0">2</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">4</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">1</span><span class="c10">$ </span><span class="c16">AABGHAAFFF </span></p><p class="c11"><span class="c20">!</span><span class="c0">9</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">11</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">8</span><span class="c10">$ </span><span class="c16">AAAAA</span><span class="c63">EHH</span><span class="c16">GG </span><span class="c20">!</span><span class="c0">4</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">1</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">2</span><span class="c10">$ </span><span class="c16">AADFHAACCC </span></p><p class="c11"><span class="c20">!</span><span class="c0">11</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">8</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">9</span><span class="c10">$ </span><span class="c16">AAAAA</span><span class="c63">GHH</span><span class="c16">GG </span><span class="c20">!</span><span class="c0">4</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">2</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">1</span><span class="c10">$ </span><span class="c16">AABFHAACCC </span></p><p class="c11"><span class="c20">!</span><span class="c0">11</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">9</span><span class="c10">$ </span><span class="c16">!</span><span class="c0">8</span><span class="c10">$ </span><span class="c16">AAAAA</span><span class="c63">EHH</span><span class="c16">GG </span></p><p class="c11"><span class="c38">&#697; </span><span class="c57">0-2 </span></p><p class="c11"><span class="c38">&#697; </span></p><p class="c11"><span class="c57">1-2 0-2 </span></p><p class="c11"><span class="c57">0-2 </span></p><p class="c11"><span class="c3">Figure 6: A more complex TSQ q</span><span class="c5">&prime;</span><span class="c3">. </span></p><p class="c18"><span class="c3">efficiently refining the candidates. A refinement is necessary, as the query may be more restrictive than the SSG itself, i.e. through additional edges attached to the SSG, the retrieved candidates are a superset of the results. Therefore, this set has to be refined, i.e. it has to be checked whether the found SSG is part of a larger subgraph structure that can fulfill the query constraints with re- gards to graph structure as well as temporal behaviour. To refine the candidates, we return to the concept of Section 4.1. Before evaluating the substring candidates, we can still apply the degree filter for q</span><span class="c5">&prime; </span><span class="c3">and G to M</span><span class="c5">0</span><span class="c3">, as it is a quick way to eliminate some impossible assignments. </span></p><p class="c91"><span class="c3">Example 6.3. Figure 7 shows M</span><span class="c5">0 </span><span class="c3">for our sample query q</span><span class="c5">&prime; </span><span class="c3">after applying the degree and neighbour filters. It shows that for ex- 4, ample thus vleaving </span><span class="c15">1 </span><span class="c5">q</span><span class="c2">&prime;</span><span class="c3">On the other v</span><span class="c5">G</span><span class="c15">4 </span><span class="c4">, as v</span><span class="c15">4 </span><span class="c5">G</span><span class="c4">can only be mapped to nodes with a degree of at least </span><span class="c3">only cells M</span><span class="c15">1</span><span class="c36">,</span><span class="c15">4 </span><span class="c5">0</span><span class="c4">and M</span><span class="c15">1</span><span class="c36">,</span><span class="c15">9 </span><span class="c5">0</span><span class="c4">(unlike </span><span class="c3">hand, </span><span class="c4">v</span><span class="c15">2 </span><span class="c5">q</span><span class="c3">M</span><span class="c2">&prime;</span><span class="c4">) </span><span class="c15">2</span><span class="c36">,</span><span class="c15">3 </span><span class="c5">0</span><span class="c4">does is set to 0, asvnot have a in the first row with a 1. </span><span class="c5">q</span><span class="c2">&prime;</span><span class="c15">2 </span><span class="c4">cannot be mapped to neighbour of degree 4. </span></p><p class="c18"><span class="c3">After optimizing M</span><span class="c5">0</span><span class="c3">, for each found SSG x, we initialize a copy of M</span><span class="c5">0 </span><span class="c3">denoted as M</span><span class="c5">x </span><span class="c3">and thereby set M</span><span class="c15">i</span><span class="c36">,</span><span class="c15">j </span><span class="c5">x</span><span class="c4">:= M</span><span class="c15">i</span><span class="c36">,</span><span class="c15">j</span><span class="c5">0</span><span class="c4">. Each </span><span class="c3">found SSG instance x gives us a &lsquo;hint&rsquo;, where an occurrence of q</span><span class="c5">&prime; </span><span class="c3">in G may occur as well as the temporal offset </span><span class="c80">&#8710;</span><span class="c15">t </span><span class="c3">at which the temporal pattern of the subgraph structure matched. This hint will either lead to a correct result or may be false &ndash; but </span></p><p class="c91"><span class="c67">M</span><span class="c147">0 </span><span class="c27">!</span><span class="c15"># </span><span class="c7">&quot;</span><span class="c19">!</span><span class="c15"># </span><span class="c7">$</span><span class="c19">!</span><span class="c15"># </span><span class="c7">%</span><span class="c19">!</span><span class="c15"># </span><span class="c7">&amp;</span><span class="c19">!</span><span class="c15"># </span><span class="c7">&#39;</span><span class="c19">!</span><span class="c15"># </span><span class="c7">(</span><span class="c19">!</span><span class="c15"># </span><span class="c7">)</span><span class="c19">!</span><span class="c15"># </span><span class="c7">*</span><span class="c19">!</span><span class="c15"># </span><span class="c7">+</span><span class="c19">!</span><span class="c15"># </span><span class="c7">&quot;,</span><span class="c19">!</span><span class="c15"># </span><span class="c7">&quot;&quot;</span><span class="c27">!</span><span class="c15">-&prime; </span><span class="c7">&quot;</span><span class="c29">0 0 0 1 0 0 0 0 1 0 0 </span><span class="c38">&#697; </span></p><p class="c11"><span class="c38">&#697; </span></p><p class="c11"><span class="c27">!</span><span class="c15">-&prime; </span><span class="c7">$</span><span class="c29">1 1 0 0 1 1 1 1 0 0 1 </span></p><p class="c11"><span class="c38">&#697; </span></p><p class="c18"><span class="c27">!</span><span class="c15">-&prime; </span><span class="c7">%</span><span class="c29">1 1 0 0 1 1 1 1 0 0 1 </span><span class="c27">!</span><span class="c15">-&prime; </span><span class="c7">&amp;</span><span class="c29">1 1 0 0 1 1 1 1 0 1 1 </span><span class="c27">!</span><span class="c15">-&prime; </span><span class="c7">&#39;</span><span class="c29">1 1 0 0 1 1 1 1 0 1 1 </span></p><p class="c11"><span class="c3">Figure 7: Assignment matrix M</span><span class="c5">0 </span><span class="c3">for q</span><span class="c5">&prime; </span><span class="c3">and Q after apply- ing the degree and neighbour filters. </span></p><p class="c11"><span class="c67">M</span><span class="c30">&#9826;</span><span class="c147">4 </span><span class="c27">!</span><span class="c15"># </span><span class="c7">&quot;</span><span class="c19">!</span><span class="c15"># </span><span class="c7">$</span><span class="c19">!</span><span class="c15"># </span><span class="c7">%</span><span class="c19">!</span><span class="c15"># </span><span class="c7">&amp;</span><span class="c19">!</span><span class="c15"># </span><span class="c7">&#39;</span><span class="c19">!</span><span class="c15"># </span><span class="c7">(</span><span class="c19">!</span><span class="c15"># </span><span class="c7">)</span><span class="c19">!</span><span class="c15"># </span><span class="c7">*</span><span class="c19">!</span><span class="c15"># </span><span class="c7">+</span><span class="c19">!</span><span class="c15"># </span><span class="c7">&quot;,</span><span class="c19">!</span><span class="c15"># </span><span class="c7">&quot;&quot;</span><span class="c27">!</span><span class="c15">-&prime; </span><span class="c7">&quot;</span><span class="c19">0 0 0 1 </span><span class="c64">?! </span><span class="c19">0 0 0 0 0 0 </span><span class="c27">!</span><span class="c15">-&prime; </span><span class="c7">$</span><span class="c19">0 0 </span><span class="c64">?! </span><span class="c19">0 0 0 0 0 0 0 0 </span><span class="c27">!</span><span class="c15">-&prime; </span><span class="c7">%</span><span class="c19">0 0 0 0 0 </span><span class="c86">1 </span><span class="c19">0 0 0 0 0 </span><span class="c27">!</span><span class="c15">-&prime; </span><span class="c7">&amp;</span><span class="c19">1 1 0 0 0 0 1 1 0 1 1 </span><span class="c27">!</span><span class="c15">-&prime; </span><span class="c7">&#39;</span><span class="c19">1 1 0 0 0 0 1 1 0 1 1 </span></p><p class="c18"><span class="c3">Figure 8: Assignment matrix M</span><span class="c5">&diams;4 </span><span class="c3">after applying the as- signment from the index candidate. This means that the bold cells should be set to 1. However, cells depicted with &lsquo;?!&rsquo; already contain a 0 (ref. Figure 7) and cannot be set to 1 in a valid way. </span></p><p class="c18"><span class="c3">its correctness will not have any effect on other SSG instances, which is why we can process them individually and in parallel. Since the index found a matching SSG which implicitly matches </span></p><p class="c11"><span class="c37">295 </span></p><p class="c18"><span class="c3">the vertices of the structure to vertices of the graph (after consid- ering the permutations of the mapping), we can assign |V </span><span class="c5">SSG</span><span class="c3">| fix assignments, thus nullifying all other cells in those rows (since M</span><span class="c5">x </span><span class="c3">is usually much wider than tall, this drastically increases the number of cells containing a 0). Since </span><span class="c80">&#8710;</span><span class="c42">t </span><span class="c12">is known at this point </span><span class="c3">of time, we can now apply the more sophisticated time offset and network distance filters (Section 4.2) to M</span><span class="c5">x</span><span class="c3">. </span></p><p class="c18"><span class="c3">Example 6.4. Let us return to our running example, where we search for occurrences of the more complex query q</span><span class="c5">&prime; </span><span class="c3">(Figure 6) in the running social net work G (Figure 2(a)). Let&rsquo;s consider the fourth permutation of the &diams; substructure, which is returned as a candidate through the query permutation EHH (v</span><span class="c5">q</span><span class="c2">&prime;</span><span class="c15">1 </span><span class="c4">&rarr; v</span><span class="c5">SSG </span><span class="c15">1 </span><span class="c4">, </span><span class="c3">v</span><span class="c5">q</span><span class="c2">&prime;</span><span class="c15">2 </span><span class="c4">&rarr; v</span><span class="c5">SSG </span><span class="c15">3 </span><span class="c4">, v</span><span class="c5">q</span><span class="c2">&prime;</span><span class="c15">3 </span><span class="c4">&rarr; v</span><span class="c5">SSG </span><span class="c15">2 </span><span class="c4">) (see Figure 5). Mapping this SSG to G </span><span class="c3">yields the mappings v</span><span class="c5">q</span><span class="c2">&prime;</span><span class="c15">1 </span><span class="c4">&rarr; v</span><span class="c5">SSG </span><span class="c15">1 </span><span class="c4">&rarr; v</span><span class="c5">G</span><span class="c15">5 </span><span class="c4">;v</span><span class="c5">q</span><span class="c2">&prime;</span><span class="c15">2 </span><span class="c4">&rarr; v</span><span class="c5">SSG </span><span class="c15">3 </span><span class="c4">&rarr; v</span><span class="c5">G</span><span class="c15">3 </span><span class="c4">; and </span><span class="c3">v</span><span class="c5">q</span><span class="c2">&prime;</span><span class="c15">3 </span><span class="c4">&rarr; v</span><span class="c5">SSG </span><span class="c15">2 </span><span class="c4">&rarr; v</span><span class="c5">G</span><span class="c15">6 </span><span class="c4">also shown in Figure 5. We attempt to make </span><span class="c3">this assignment in the corresponding matrix M</span><span class="c5">&diams;4 </span><span class="c3">depicted in Fig- ure 8. Therefore, we have to set the values in M</span><span class="c5">&diams;4</span><span class="c15">1</span><span class="c36">,</span><span class="c15">5</span><span class="c4">, M</span><span class="c5">&diams;4</span><span class="c15">2</span><span class="c36">,</span><span class="c15">3 </span><span class="c4">and M</span><span class="c5">&diams;4</span><span class="c15">3</span><span class="c36">,</span><span class="c15">6 </span><span class="c12">to 1, but we see that the first two entries already contain a zero </span><span class="c3">in the global assignment matrix M</span><span class="c5">0</span><span class="c3">, such that this assignment does not yield a valid matching. Therefore we can stop here and prune this candidate. In fact, in our example we can prune all permutations of &diams; in the same way, as well as permutations 1, 3, 5, and 6 of &hearts;; with &clubs; not even providing candidates. In summary, this just leaves M</span><span class="c5">&hearts;2 </span><span class="c3">and M</span><span class="c5">&hearts;4 </span><span class="c3">for further refinement. </span></p><p class="c18"><span class="c3">We are now left with a set of matrices that we need to derive fi- nal assignment candidates from. A naive way would be to iterate over all possible assignments and verify them; one would do that by choosing a single M</span><span class="c5">X</span><span class="c15">i</span><span class="c36">,</span><span class="c15">j </span><span class="c4">= 1 and using it as an assignment, thus </span><span class="c3">nullifying other values row i and column j, and then proceeding to row i +1, re-applying the same concept. This needs to be done iteratively for allm</span><span class="c5">X</span><span class="c15">i</span><span class="c36">,</span><span class="c15">j </span><span class="c4">= 1 of a row. We aim to improve this expo- </span><span class="c3">nentially expensive approach by using heuristics. Therefore, we first take effort in finding a clever order of which we process the rows. We process rows in breadth-first-order starting at the corre- sponding SSG occurrence, skipping lines having a &ldquo;1&rdquo; assigned by the SSG occurrence. For any other line b, we look at any previous row a such that (v</span><span class="c5">q</span><span class="c2">&prime;</span><span class="c15">a </span><span class="c4">,v</span><span class="c5">q</span><span class="c2">&prime;</span><span class="c15">b </span><span class="c4">) &isin; E</span><span class="c5">q</span><span class="c2">&prime;</span><span class="c3">, i.e., a neighbour of v</span><span class="c5">q</span><span class="c2">&prime;</span><span class="c15">b </span><span class="c4">that we </span><span class="c3">have already assigned. Since we always start with a pre-assigned row and proceed in a breadth-first-manner, such a row must exist. That row a contains a single assignment h(v</span><span class="c5">q</span><span class="c15">a</span><span class="c4">) = v</span><span class="c5">G</span><span class="c15">c </span><span class="c4">. Assuming </span><span class="c3">this assignment is correct, we only need to look at columns d where v</span><span class="c5">G</span><span class="c15">d </span><span class="c4">is a neighbour of v</span><span class="c5">G</span><span class="c15">c </span><span class="c4">, thus having (v</span><span class="c5">G</span><span class="c15">c </span><span class="c4">,v</span><span class="c5">G</span><span class="c15">d </span><span class="c4">) &isin; E</span><span class="c5">G</span><span class="c3">. This can be deducted from the following: </span></p><p class="c91"><span class="c3">h(v</span><span class="c5">q</span><span class="c15">a</span><span class="c4">) = v</span><span class="c5">G</span><span class="c15">c </span><span class="c4">&and; h(v</span><span class="c5">q</span><span class="c15">b</span><span class="c4">) = v</span><span class="c5">G</span><span class="c15">d </span><span class="c4">&and; (v</span><span class="c5">q</span><span class="c15">a</span><span class="c4">,v</span><span class="c5">q</span><span class="c15">b</span><span class="c4">) &isin; E</span><span class="c5">q </span><span class="c3">&rArr; (v</span><span class="c5">G</span><span class="c15">c </span><span class="c4">,v</span><span class="c5">G</span><span class="c15">d </span><span class="c4">) &isin; E</span><span class="c5">G </span><span class="c3">because E</span><span class="c5">q </span><span class="c3">&sube; E</span><span class="c5">G</span><span class="c3">. </span></p><p class="c18"><span class="c3">For every neigbour v</span><span class="c5">G</span><span class="c15">d </span><span class="c4">where M</span><span class="c5">x</span><span class="c15">b</span><span class="c36">,</span><span class="c15">d </span><span class="c4">= 1 and the temporal </span><span class="c3">patterns match, we create a copy of the current M</span><span class="c5">x</span><span class="c3">, nullify all other cells in rowb and proceed to the next row in M</span><span class="c5">x</span><span class="c3">. When the last row is reached, every vertex in v</span><span class="c5">q </span><span class="c3">has been assigned exactly one partner in v</span><span class="c5">G</span><span class="c3">, thus being a result. </span></p><p class="c11"><span class="c3">Example 6.5. For our running example, we retrieve the follow- ing assignments from M</span><span class="c5">&hearts;2 </span><span class="c3">and M</span><span class="c5">&hearts;4</span><span class="c3">: </span></p><p class="c11"><span class="c3">M</span><span class="c5">&hearts;2 </span><span class="c3">: h(v</span><span class="c5">q</span><span class="c2">&prime;</span><span class="c15">1 </span><span class="c4">,v</span><span class="c5">q</span><span class="c2">&prime;</span><span class="c15">2 </span><span class="c4">,v</span><span class="c5">q</span><span class="c2">&prime;</span><span class="c15">3 </span><span class="c4">) = (v</span><span class="c5">G</span><span class="c15">9 </span><span class="c4">,v</span><span class="c5">G</span><span class="c15">8 </span><span class="c4">,v</span><span class="c5">G</span><span class="c15">11</span><span class="c4">) </span></p><p class="c11"><span class="c3">M</span><span class="c5">&hearts;4 </span><span class="c3">: h(v</span><span class="c15">1 </span><span class="c5">q</span><span class="c2">&prime;</span><span class="c4">,v</span><span class="c15">2 </span><span class="c5">q</span><span class="c2">&prime;</span><span class="c4">,v</span><span class="c5">q</span><span class="c15">3 </span><span class="c2">&prime;</span><span class="c4">) = (v</span><span class="c15">11</span><span class="c5">G</span><span class="c4">,v</span><span class="c5">G</span><span class="c15">8 </span><span class="c4">,v</span><span class="c15">9 </span><span class="c5">G</span><span class="c4">) </span></p><p class="c91"><span class="c3">The later one is therefore not be mapped we now retrieve two invalid, final to candidates vas </span><span class="c15">11</span><span class="c5">G</span><span class="c4">. </span><span class="c3">M</span><span class="c4">Following </span><span class="c15">1</span><span class="c36">,</span><span class="c15">11 </span><span class="c5">0</span><span class="c4">is already 0 and v</span><span class="c15">1 </span><span class="c5">q</span><span class="c2">&prime;</span><span class="c4">can the first assignment, </span><span class="c3">for the complete occurance of q</span><span class="c5">&prime;</span><span class="c3">: </span></p><p class="c11"><span class="c3">C</span><span class="c15">1 </span><span class="c3">: h(v</span><span class="c15">1 </span><span class="c5">q</span><span class="c2">&prime;</span><span class="c4">,v</span><span class="c15">2 </span><span class="c5">q</span><span class="c2">&prime;</span><span class="c4">,v</span><span class="c15">3 </span><span class="c5">q</span><span class="c2">&prime;</span><span class="c4">,v</span><span class="c15">4 </span><span class="c5">q</span><span class="c2">&prime;</span><span class="c4">,v</span><span class="c15">5 </span><span class="c5">q</span><span class="c2">&prime;</span><span class="c4">) = (v</span><span class="c15">9 </span><span class="c5">G</span><span class="c4">,v</span><span class="c5">G</span><span class="c15">8 </span><span class="c4">,v</span><span class="c15">11</span><span class="c5">G</span><span class="c4">,v</span><span class="c15">6 </span><span class="c5">G</span><span class="c4">,v</span><span class="c5">G</span><span class="c15">10 </span></p><p class="c11"><span class="c3">C</span><span class="c42">2 </span><span class="c12">: h(v</span><span class="c15">1 q</span><span class="c2">&prime;</span><span class="c4">,v</span><span class="c5">q</span><span class="c15">2 </span><span class="c2">&prime;</span><span class="c4">,v</span><span class="c15">3 </span><span class="c5">q</span><span class="c2">&prime;</span><span class="c4">,v</span><span class="c15">4 </span><span class="c5">q</span><span class="c2">&prime;</span><span class="c4">,v</span><span class="c5">q</span><span class="c15">5 </span><span class="c2">&prime;</span><span class="c4">) = (v</span><span class="c15">11</span><span class="c5">G</span><span class="c4">,v</span><span class="c5">G</span><span class="c15">8 </span><span class="c4">,v</span><span class="c15">9 </span><span class="c5">G</span><span class="c4">,v</span><span class="c15">10</span><span class="c5">G</span><span class="c4">,v</span><span class="c5">G</span><span class="c15">6 </span><span class="c4">) </span></p><p class="c11"><span class="c3">of function valid result which on to edges the the first query. </span></p><p class="c11"><span class="c3">(v</span><span class="c15">1 </span><span class="c5">q</span><span class="c3">one </span><span class="c2">&prime;</span><span class="c4">,v</span><span class="c15">4 </span><span class="c5">q</span><span class="c3">C</span><span class="c2">&prime;</span><span class="c4">) </span><span class="c42">1 </span><span class="c4">and </span><span class="c12">is invalid, as the time-dependant- </span><span class="c4">(v</span><span class="c15">9 </span><span class="c5">Q</span><span class="c4">,v</span><span class="c15">6 </span><span class="c5">Q</span><span class="c4">) do not match. C</span><span class="c5">2 </span><span class="c4">is a </span></p><p class="c11"><span class="c32">7 EXPERIMENTS </span><span class="c3">In this section we show experimental results of our proposed methods. As a baseline approach, we resort to Ullmann&rsquo;s algo- rithm as described in Section 4.1. This represents the expansion of traditional solutions to the temporal domain. We further eval- uate the included filters as well as our proposed additional filters individually and in combination to distinguish the naive baseline approach from a more advanced setup. We then compare this baseline approach, which has been extended to temporal graphs, to our advanced query processing approach proposed in Section 6 supported by the index structured introduced in Section 5. Ad- ditionally, we introduce the evaluated queries and the employed datasets. All experiments were performed on a 3Ghz workstation having 32 GB of RAM. The experiments were run on a single core. </span></p><p class="c11"><span class="c32">7.1 Datasets </span><span class="c3">As a datasource for our real data evaluation we use a snapshot of the ACM Digital Library</span><span class="c5">2 </span><span class="c3">taken on Dec 15, 2014 consisting of 582,150 publications with author information. Using only the co-author relationship for each calendar year, we build a tempo- ral social graph G = {V</span><span class="c5">G</span><span class="c3">,E</span><span class="c5">G</span><span class="c3">, F</span><span class="c5">G</span><span class="c3">}, reflecting the collaboration network over time, in the following way: </span></p><p class="c11"><span class="c3">&bull; Each researcher present in the dataset is represented by a node v</span><span class="c5">G</span><span class="c3">. </span></p><p class="c11"><span class="c3">&bull; Two researcher (vat </span><span class="c15">i </span><span class="c5">G</span><span class="c3">any </span><span class="c4">,v</span><span class="c5">G</span><span class="c15">j </span><span class="c3">time </span><span class="c4">) if they </span><span class="c3">t nodesv</span><span class="c15">i </span><span class="c5">G</span><span class="c4">andv</span><span class="c5">G</span><span class="c15">j </span><span class="c4">have at least co-authored </span><span class="c3">&isin; T. </span></p><p class="c11"><span class="c4">are connected by an edge one publication </span></p><p class="c11"><span class="c3">&bull; The time dependent function cates collaboration over time for an edge and is set the following (v</span><span class="c15">i </span><span class="c5">G</span><span class="c4">,v</span><span class="c5">G</span><span class="c15">j </span><span class="c4">) indi- </span><span class="c3">way: </span></p><p class="c11"><span class="c3">f </span><span class="c36">v</span><span class="c5">G</span><span class="c17">i </span><span class="c2">G</span><span class="c71">,v</span><span class="c17">j </span><span class="c2">G</span><span class="c4">(t) = </span></p><p class="c11"><span class="c3">&#63729;</span><span class="c12">&#63732;&#63732;&#63732;&#63732;&#63732;&#63732;&#63730;&#63732;&#63732;&#63732;&#63732;&#63732;&#63732;&#63731;</span><span class="c3">1 if v</span><span class="c15">i </span><span class="c5">G</span><span class="c4">and v</span><span class="c5">G</span><span class="c15">j </span><span class="c4">co-authored a publi- </span></p><p class="c11"><span class="c3">cation in year t 0 if v</span><span class="c15">i </span><span class="c5">G</span><span class="c4">and v</span><span class="c5">G</span><span class="c15">j </span><span class="c4">did not co-author a </span></p><p class="c11"><span class="c3">publication in year t </span></p><p class="c18"><span class="c3">The resulting temporal social graph is called PUBS in the re- mainder of this section. In order to evaluate naive approaches of the proposed algorithms we also use small subgraphs of PUBS </span></p><p class="c11"><span class="c17">2</span><span class="c168">http://dl.acm.org/ </span></p><p class="c11"><span class="c37">296 </span></p><p class="c70"><span class="c3">Figure 9: Evaluated subgraph structures in our experi- ments along with assigned names. </span></p><p class="c180"><span class="c3">PUBS MiniPUBS MicroPUBS Nodes 379,188 10,000 3,792 Edges 2,114,720 77,568 36,548 Timepoints 69 46 43 # Strings 2,114,720 77,568 36,548 # Arrows 44,379,646 1,541,152 917,810 # Triangles 13,191,264 422,736 176,286 # Squares 449,684,160 5,179,608 2,259,456 # Pans 1,438,921,874 25,601,204 21,972,438 # Crossboxes 411,978,792 3,967,824 1,196,184 Table 2: Characteristics of the researcher collaboration datasets </span></p><p class="c24 c106"><span class="c79">1 2 3 4 5 </span><span class="c35">Temporal length t of query pattern </span></p><p class="c100 c145"><span class="c3">Figure 11: Querying with a triangle and a crossbox struc- ture of constant edges and variable length t</span><span class="c5">q</span><span class="c3">. </span></p><p class="c73"><span class="c32">7.2 Queries </span><span class="c3">Figure 10 shows a set of standard query subgraphs that we used in our experimental evaluation. In the first set of experiments, the query time domain t</span><span class="c5">q </span><span class="c3">is set to relatively small values of 3 &le; t</span><span class="c5">q </span><span class="c3">&le; 5, to all the baseline approaches to terminate in reasonable time. The temporal pattern on these subgraphs is chosen uniformly random, such that at each point of time t &isin; T</span><span class="c5">q </span><span class="c3">of the query graph, any edge has a chance of 50% to be part of the query pattern. To avoid degenerated cases, we ensure that each edge of a standard query is required to exist at at least one time t. </span></p><p class="c117"><span class="c14">Triangle </span></p><p class="c132"><span class="c155">T-Long-Leg </span></p><p class="c11 c181"><span class="c14">T-Two-Legs T-One-Leg </span></p><p class="c11 c85"><span class="c14">T-Pair-Legs </span></p><p class="c11 c85"><span class="c14">T-Pair-Legs </span></p><p class="c112"><span class="c14">Double-Triangle Quad-Clique </span></p><p class="c149"><span class="c3">Figure 10: Small queries used in our experiments. </span></p><p class="c120"><span class="c3">called MiniPUBS and MicroPUBS, with 10000 nodes and 3792 nodes, respectively. These subgraphs were generated from PUBS by performing a breadth-first search rooted at the first two (anony- mous) authors of this work. </span></p><p class="c102"><span class="c3">Table 2 summarizes the characteristics of the three datasets. In addition to the number of nodes, the number of edges and the duration of the network in years Table 2 contains the number of the subgraph structures illustrated in Figure 9. </span></p><p class="c11 c100"><span class="c32">7.3 Baseline vs. Index </span><span class="c3">In a first experiment we compare the performance of our pro- posed index structure (cf Section 5) with the baseline approach as discussed in Section 4. Since the baseline approach is very time consuming we did this experiment on the MicroPUBS dataset. As a basic subgraph structure for our index we used the triangle and as queries we evaluated the triangle-query and the quad-clique- query with increasing temporal query length t</span><span class="c5">q</span><span class="c3">. The results are shown in Figure 11. The baseline approach has to build a projec- tion of the original TSG for each possible start time t over the duration of the query. With increasing duration of the query, this projection becomes more and more dense, which results in in- creasing runtime. The index based query processing on the other hand performs much faster in this setting. Note that, although the triangle query is beneficial to the index (since the index is built on the triangle structure), the quad-clique query can also be answered efficiently. With increasing query duration, the results quickly decrease, yielding a lower number of candidates, which leads to even lower runtime. </span></p><p class="c11 c100"><span class="c32">7.3 Baseline vs. Index </span><span class="c3">In a first experiment we compare the performance of our pro- posed index structure (cf Section 5) with the baseline approach as discussed in Section 4. Since the baseline approach is very time consuming we did this experiment on the MicroPUBS dataset. As a basic subgraph structure for our index we used the triangle and as queries we evaluated the triangle-query and the quad-clique- query with increasing temporal query length t</span><span class="c5">q</span><span class="c3">. The results are shown in Figure 11. The baseline approach has to build a projec- tion of the original TSG for each possible start time t over the duration of the query. With increasing duration of the query, this projection becomes more and more dense, which results in in- creasing runtime. The index based query processing on the other hand performs much faster in this setting. Note that, although the triangle query is beneficial to the index (since the index is built on the triangle structure), the quad-clique query can also be answered efficiently. With increasing query duration, the results quickly decrease, yielding a lower number of candidates, which leads to even lower runtime. </span></p><p class="c11 c100"><span class="c32">7.3 Baseline vs. Index </span><span class="c3">In a first experiment we compare the performance of our pro- posed index structure (cf Section 5) with the baseline approach as discussed in Section 4. Since the baseline approach is very time consuming we did this experiment on the MicroPUBS dataset. As a basic subgraph structure for our index we used the triangle and as queries we evaluated the triangle-query and the quad-clique- query with increasing temporal query length t</span><span class="c5">q</span><span class="c3">. The results are shown in Figure 11. The baseline approach has to build a projec- tion of the original TSG for each possible start time t over the duration of the query. With increasing duration of the query, this projection becomes more and more dense, which results in in- creasing runtime. The index based query processing on the other hand performs much faster in this setting. Note that, although the triangle query is beneficial to the index (since the index is built on the triangle structure), the quad-clique query can also be answered efficiently. With increasing query duration, the results quickly decrease, yielding a lower number of candidates, which leads to even lower runtime. </span></p><p class="c11 c100"><span class="c32">7.3 Baseline vs. Index </span><span class="c3">In a first experiment we compare the performance of our pro- posed index structure (cf Section 5) with the baseline approach as discussed in Section 4. Since the baseline approach is very time consuming we did this experiment on the MicroPUBS dataset. As a basic subgraph structure for our index we used the triangle and as queries we evaluated the triangle-query and the quad-clique- query with increasing temporal query length t</span><span class="c5">q</span><span class="c3">. The results are shown in Figure 11. The baseline approach has to build a projec- tion of the original TSG for each possible start time t over the duration of the query. With increasing duration of the query, this projection becomes more and more dense, which results in in- creasing runtime. The index based query processing on the other hand performs much faster in this setting. Note that, although the triangle query is beneficial to the index (since the index is built on the triangle structure), the quad-clique query can also be answered efficiently. With increasing query duration, the results quickly decrease, yielding a lower number of candidates, which leads to even lower runtime. </span></p><p class="c170"><span class="c3">Figure 12 shows the query time for various query patterns. As most of the 4-year-long queries have a highly specific temporal pattern, the index-based approach profits from early pruning of large parts of the data, while the baseline approach is first looking for the general graph structure and can only prune at a second step where the temporal behaviour is considered. We see that the Triangle query for t</span><span class="c5">q </span><span class="c3">= 3 has the highest run-time using our index, while having the lowest run-time of the baseline. The reason is that this query yields the largest number of (verified) results which, trivially, cannot be pruned. When changing the query time t</span><span class="c5">q </span><span class="c3">for the more complex T-Two-Legs query, we can </span></p><p class="c11 c138"><span class="c152">Arrow String Triangle </span></p><p class="c11 c52"><span class="c79">Triangle&#8208;Query, Baseline Triangle&#8208;Query, Index </span><span class="c135">Quad-Clique&#8208;Query, Baseline Quad&#8208;Clique-Query, Index </span></p><p class="c11 c77"><span class="c79">10,000 </span></p><p class="c11 c77"><span class="c79">10,000 </span></p><p class="c143"><span class="c79">1,000 </span></p><p class="c95"><span class="c152">Square Pan Crossbox </span></p><p class="c11 c137"><span class="c79">1,000,000 </span></p><p class="c183"><span class="c79">1 </span></p><p class="c11 c43"><span class="c79">100,000 </span></p><p class="c162"><span class="c37">297 </span></p><p class="c11 c123"><span class="c79">100 </span></p><p class="c125"><span class="c159">10 </span></p><p class="c11"><span class="c75">1000000 </span></p><p class="c24"><span class="c75">1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 </span><span class="c176">Temporal query length </span></p><p class="c11"><span class="c144">Results </span></p><p class="c11"><span class="c144">Runtime [ms] </span></p><p class="c11"><span class="c3">Figure 13: no. of results and runtime with increasing query length </span></p><p class="c18"><span class="c3">again observe that our index supported approach can benefit from early pruning. Note that the time needed to build the index for this microPUBS dataset was less than a second. </span></p><p class="c11"><span class="c32">7.4 Evaluating query parameters </span></p><p class="c11"><span class="c1">Quad&#8208;Clique t^q=4 </span></p><p class="c11"><span class="c1">Double&#8208;Triangle t^q=4 </span></p><p class="c11"><span class="c131">query time [ms] </span></p><p class="c11"><span class="c3">Figure 14: query time for harder queries </span></p><p class="c18"><span class="c3">In the next set of experiments we demonstrate the effect of the query duration t</span><span class="c5">q </span><span class="c3">on the large PUBS dataset. The Baseline approach was not evaluated on this dataset due to its excessive run-time. In the first experiment, shown in Figure 13, we use the </span></p><p class="c11"><span class="c79">Index </span><span class="c1">Quad&#8208;Clique </span><span class="c8">t</span><span class="c39">q</span><span class="c1">=4 </span><span class="c65">T&#8208;One-Leg </span><span class="c1">t</span><span class="c39">q</span><span class="c1">=4 </span></p><p class="c11"><span class="c79">Baseline </span><span class="c1">T&#8208;Long-Leg t</span><span class="c39">q</span><span class="c1">=4 T&#8208;Two-Legs t</span><span class="c39">q</span><span class="c1">=4 T&#8208;Pair-Legs t</span><span class="c39">q</span><span class="c1">=4 Double</span><span class="c6">&#8208;</span><span class="c1">Triangle t</span><span class="c39">q</span><span class="c1">=4 Triangle t</span><span class="c39">q</span><span class="c1">=4 Triangle t</span><span class="c39">q</span><span class="c1">=3 T&#8208;Two-Legs t</span><span class="c39">q</span><span class="c1">=5 T&#8208;Two-Legs t</span><span class="c39">q</span><span class="c1">=3 </span></p><p class="c11"><span class="c35">processing time [ms] </span></p><p class="c11"><span class="c3">Figure 12: Querying with a distinct queries. </span></p><p class="c11"><span class="c75">100000 </span></p><p class="c11"><span class="c75">10000 </span></p><p class="c11"><span class="c75">1000 </span></p><p class="c11"><span class="c75">100 </span></p><p class="c11"><span class="c72">10 </span></p><p class="c11"><span class="c72">1</span><span class="c75">0.10.01 </span></p><p class="c11"><span class="c1">T&#8208;One&#8208;Leg t^q=4 </span></p><p class="c11"><span class="c1">T&#8208;Long&#8208;Leg t^q=4 </span></p><p class="c11"><span class="c1">T&#8208;Two&#8208;Legs t^q=4 </span></p><p class="c11"><span class="c1">T&#8208;Pair&#8208;Legs t^q=4 </span></p><p class="c11"><span class="c1">Triangle t^q=4 </span></p><p class="c11"><span class="c1">0 20 40 60 80 100 </span></p><p class="c11"><span class="c1">Quad&#8208;Clique </span><span class="c8">t</span><span class="c39">q</span><span class="c1">=4 </span></p><p class="c11"><span class="c65">T&#8208;One-Leg </span><span class="c1">t</span><span class="c39">q</span><span class="c1">=4 </span></p><p class="c11"><span class="c1">T&#8208;Long-Leg t</span><span class="c39">q</span><span class="c1">=4 </span></p><p class="c11"><span class="c1">T&#8208;Two-Legs t</span><span class="c39">q</span><span class="c1">=4 </span></p><p class="c11"><span class="c1">T&#8208;Pair-Legs t</span><span class="c39">q</span><span class="c1">=4 </span></p><p class="c11"><span class="c1">Double</span><span class="c6">&#8208;</span><span class="c1">Triangle t</span><span class="c39">q</span><span class="c1">=4 </span></p><p class="c11"><span class="c1">Triangle t</span><span class="c39">q</span><span class="c1">=4 </span></p><p class="c11"><span class="c1">Triangle t</span><span class="c39">q</span><span class="c1">=3 </span></p><p class="c11"><span class="c1">T&#8208;Two-Legs t</span><span class="c39">q</span><span class="c1">=5 </span></p><p class="c11"><span class="c1">T&#8208;Two-Legs t</span><span class="c39">q</span><span class="c1">=3 </span></p><p class="c11"><span class="c3">Figure 16: Testing different indexed subgraph structures: processing time </span></p><p class="c18"><span class="c3">Triangle structure for query and indexing. Index construction on this large dataset took less than 30 minutes. Results using this index are averaged over 1K runs for random temporal patterns of the PUBS dataset. We observe that the run-time is directly proportional to the number of results. This behaviour is expected, since less refinement is needed. </span></p><p class="c18"><span class="c3">The previous experiment show-cased a best-case scenario, where the structure used for indexing is identical to the query structure. In this case, candidates returning by the index need only to be verified for temporally matching the query pattern. </span></p><p class="c18"><span class="c3">To show the behaviour in more realistic scenarios, we made the topological structure of the query more complex by adding additional edges, while still using triangle SSGs for indexing. Thus, those added edges are not covered by the index and need to be accounted for in the refinement step. Figure 14 shows that adding additional edges and nodes to the query increases the processing time: Adding two edges to the triangle produces a more complex query than just adding one (than adding none), and a Quad-triangle is more specific than a Double-Triangle than a simple triangle. </span></p><p class="c18"><span class="c3">Thus, in the next set of experiments shown in Figures 15 and 16, we test the efficiency of different SSGs on the MiniPUBS dataset. Here, we compare different structures used to build the index (specifically, the SSGs Triangle, Arrow and String), and different query structures for different time lengths t</span><span class="c5">q</span><span class="c3">. </span></p><p class="c11"><span class="c37">298 </span></p><p class="c11"><span class="c1">Quad&#8208;Clique </span><span class="c8">t</span><span class="c39">q</span><span class="c1">=4 </span></p><p class="c11"><span class="c65">T&#8208;One-Leg </span><span class="c1">t</span><span class="c39">q</span><span class="c1">=4 </span></p><p class="c11"><span class="c1">T&#8208;Long-Leg t</span><span class="c39">q</span><span class="c1">=4 </span></p><p class="c11"><span class="c1">T&#8208;Two-Legs t</span><span class="c39">q</span><span class="c1">=4 </span></p><p class="c11"><span class="c1">T&#8208;Pair-Legs t</span><span class="c39">q</span><span class="c1">=4 </span></p><p class="c11"><span class="c1">Double</span><span class="c6">&#8208;</span><span class="c1">Triangle t</span><span class="c39">q</span><span class="c1">=4 </span></p><p class="c11"><span class="c1">Triangle t</span><span class="c39">q</span><span class="c1">=4 </span></p><p class="c11"><span class="c1">Triangle t</span><span class="c39">q</span><span class="c1">=3 </span></p><p class="c11"><span class="c1">T&#8208;Two-Legs t</span><span class="c39">q</span><span class="c1">=5 </span></p><p class="c11"><span class="c1">T&#8208;Two-Legs t</span><span class="c39">q</span><span class="c1">=3 </span></p><p class="c11"><span class="c3">Figure 15: Testing different indexed subgraph structures: number of candidates </span></p><p class="c11"><span class="c1">Triangle Arrow String </span></p><p class="c11"><span class="c1">0.1 1 10 100 1000 </span></p><p class="c11"><span class="c131">Processing time [ms] </span></p><p class="c11"><span class="c1">Triangle Arrow String </span></p><p class="c11"><span class="c1">1 10 100 1000 10000 100000 </span></p><p class="c11"><span class="c131">Candidates from Index </span></p><p class="c126"><span class="c10">deg. + nei. + netw. + &lt;me. </span></p><p class="c130"><span class="c10">deg. + nei. + &lt;me. </span></p><p class="c146"><span class="c10">deg. + nei. + netw. </span></p><p class="c90"><span class="c10">deg. + nei. </span></p><p class="c92"><span class="c10">network distance filter </span></p><p class="c103"><span class="c10">&lt;me offset filter </span></p><p class="c148"><span class="c10">neighbour mapping filter </span></p><p class="c172"><span class="c10">degree filter </span></p><p class="c185"><span class="c10">no filters </span></p><p class="c169"><span class="c10">1,E+00 1,E+02 1,E+04 1,E+06 1,E+08 1,E+10 </span><span class="c110"># candidates left after applying filter </span></p><p class="c124"><span class="c3">Figure 17: Comparing the number of candidates left after applying filters to M</span><span class="c5">0</span><span class="c3">. </span></p><p class="c173"><span class="c10">deg. + nei. + 5me. + netw. deg. + nei. + netw. + 5me. deg. + nei. + 5me. deg. + nei. + netw. deg. + nei. network distance filter 5me offset filter neighbour mapping filter degree filter no filters </span></p><p class="c167"><span class="c10">1 10 100 1000 10000 </span></p><p class="c127"><span class="c110">processing +me for filter [ms] </span><span class="c3">Figure 18: Measuring the computational cost of applying filters to M</span><span class="c5">0</span><span class="c3">. </span></p><p class="c83"><span class="c3">Comparing these results to Table 2, we notice that simpler subgraph structures appear more often in graphs, whereas more complex structures appear less and are thus generally more selec- tive when used as the basis for an index. This also reflects in the number of candidates produced by our index-based approach for different basic query structures. We note that in these queries, using triangle structure for indexing yields much less candidates for refinement. This is because many Arrow and String structures may not be part of a triangle, thus creating additional candidates to be pruned. However, it should be noted that the triangle index is only applicable if the query structures contains at least one triangle, which is the case for query structures featured in this experiment. </span></p><p class="c23"><span class="c32">7.5 Evaluating Pruning Filters </span><span class="c3">In Section 4.2 we introduced additional pruning filters appli- cable to temporal graphs. We evaluated the various filters on the candidates retrieved after querying the index with a sim- ple subgraph structure (SSG) for our running query example q</span><span class="c5">&prime; </span><span class="c3">on the MiniPUBS graph. Therefore, we measure the perfor- mance of different pruning strategies (and their combinations) in their number of candidates generated from M</span><span class="c5">0 </span><span class="c3">that need to be refined. Figure 17 shows that the degree filter has no effect, because the only nodes not matched in the initial assignment M</span><span class="c5">0 </span><span class="c3">are the two legs not part of the SSG which just have a degree of 1. The network distance filter and the neighbour mapping filter reduce the number of candidates by a factor of about 10, 000 and 30,000, respectively. The time offset filter has the highest pruning power, reducing the number of candidates to less than </span></p><p class="c11 c129"><span class="c10">6me offset filter network distance filter </span></p><p class="c28"><span class="c3">Figure 19: Measuring the computational cost of applying filters to M</span><span class="c5">0 </span><span class="c3">with highlight of individual cost. </span></p><p class="c157"><span class="c3">two hundred. Furthermore, variations of sequential filter com- binations are depicted as well: A combination allows to narrow down the candidate size even more. Figure 18 shows the corre- sponding computational time of the filters: the network distance filter is by far the most expensive one, even though it cannot outperform the time filter. We contribute the bad performance of the network distance filter to the dataset, in which network dis- tances are generally very short, as the dataset was generated by a breadth-first search of a larger network. A more detailed look into the combination of filters is shown in 19, where it becomes clear that an expensive, but selective filter like the time offset filter, becomes cheap if applied after another more generic filter and in combination gives great results and a very small candidate set. We summarize that the time-offset filter is the most powerful pruning step in our setting. This is because most candidates to not match the specific temporal patterns exhibited by the tem- poral query graph, such that temporal pruning is very powerful. This also shows how traditional pruning methods only, which do not consider temporal patterns, are not sufficient to efficiently find patterns on temporal graphs. </span></p><p class="c136"><span class="c32">8 CONCLUSIONS </span><span class="c3">We proposed first solutions for the problem of searching patterns on temporal social networks. For this problem, existing solutions for graph isomorphism can not be applied directly, since tempo- ral conditions need to be handled. As a baseline approach, we define a temporal pruning heuristic to augment an existing sub- graph isomorphism search algorithm. Due to the high run-time of such approach on real social networks, we proposed a data structure to index all occurrences of basic graph structures, to find a candidate set of isomorphic subgraphs quickly at query time. This data structure transforms temporal graphs and tempo- ral graph queries in strings and employs a suffix tree to organize these strings efficiently. Our experimental evaluation shows that this index structure can reduce the run-time of searching small temporal query patterns by orders of magnitude. Still challenges remain open: since the problem of isomorphic subgraph search is exponentially hard in the size of the query graph, we cannot hope to scale to large query graphs. Thus, approximate solutions are required for larger and more complex query patterns. Further, we can relax the problem to estimation of the number of isomor- phic subgraphs, rather than returning all occurences and their location in the graph. This relaxation may allow more efficient </span></p><p class="c156"><span class="c37">299 </span></p><p class="c66"><span class="c10">deg. + nei. + 6me. + netw. deg. + nei. + netw. + 6me. deg. + nei. + 6me. deg. + nei. + netw. deg. + nei. 6me offset filter neighbour mapping filter degree filter </span></p><p class="c153"><span class="c10">degree filter 0 neighbour mapping filter </span></p><p class="c11 c154"><span class="c10">degree filter 0 neighbour mapping filter </span></p><p class="c11 c33"><span class="c10">10 20 30 </span><span class="c110">processing +me for filter [ms] </span></p><p class="c11 c33"><span class="c10">10 20 30 </span><span class="c110">processing +me for filter [ms] </span></p><p class="c109"><span class="c3">approximations. Another important future aspect of this work is the diversification of patterns as studied in [25, 26] for dense subgraphs only. Applying such diversification to arbitrary sub- graphs is a non-trivial task, as the notion of social and temporal overlap has to be redefined. </span></p><p class="c113"><span class="c3">As you have seen in our running examples, temporal subgraph queries need to be defined very detailed, i.e., each configuration at every point of time needs to be stated. In cases where such level of detail is unneeded (for example when a certain link may or not exist as well at a specific point of time) our algorithm cannot specifically account for this fact. While intuitively, al- lowing more configurations makes queries less hard to verify, it actually increases the query complexity as the program must now consider several possible configurations instead of one. A future version could benefit in these scenarios. </span></p><p class="c184"><span class="c32">REFERENCES </span></p><p class="c164"><span class="c53">[1] Miguel Araujo, Stephan G&uuml;nnemann, Spiros Papadimitriou, Christos Faloutsos, Prithwish Basu, Ananthram Swami, Evangelos E. Papalexakis, and Danai Koutra. 2016. Discovery of &quot;comet&quot; communities in temporal and labeled graphs (Com2). Knowl. Inf. Syst. 46, 3 (2016), 657&ndash;677. </span><span class="c96">DOI:</span><span class="c53">http://dx.doi.org/ 10.1007/s10115-015-0847-2 [2] Peter S Bearman, James Moody, and Katherine Stovel. 2004. Chains of affection: The structure of adolescent romantic and sexual networks. American journal of sociology 110, 1 (2004), 44&ndash;91. [3] Brigitte Boden, Stephan G&uuml;nnemann, Holger Hoffmann, and Thomas Seidl. 2012. Mining coherent subgraphs in multi-layer graphs with edge labels. In Proceedings of the 18th ACM SIGKDD international conference on Knowledge discovery and data mining. ACM, 1258&ndash;1266. [4] Arnaud Casteigts, Paola Flocchini, Walter Quattrociocchi, and Nicola Santoro. 2012. Time-varying graphs and dynamic networks. International Journal of Parallel, Emergent and Distributed Systems 27, 5 (2012), 387&ndash;408. [5] Donatello Conte, Pasquale Foggia, Carlo Sansone, and Mario Vento. 2004. Thirty years of graph matching in pattern recognition. International journal of pattern recognition and artificial intelligence 18, 03 (2004), 265&ndash;298. [6] Stephen A Cook. 1971. The complexity of theorem-proving procedures. In Proceedings of the third annual ACM symposium on Theory of computing. The MIT Press, 151&ndash;158. [7] Friedrich Eisenbrand and Fabrizio Grandoni. 2004. On the complexity of fixed parameter clique and dominating set. Theoretical Computer Science 326, 1-3 (2004), 57&ndash;67. [8] Wenfei Fan, Jianzhong Li, Shuai Ma, Nan Tang, and Yinghui Wu. 2011. Adding regular expressions to graph reachability and pattern queries. In Data Engi- neering (ICDE), 2011 IEEE 27th International Conference on. IEEE, 39&ndash;50. [9] Mao-Guo Gong, Ling-Jun Zhang, Jing-Jing Ma, and Li-Cheng Jiao. 2012. Com- munity detection in dynamic social networks based on multiobjective immune algorithm. Journal of Computer Science and Technology 27, 3 (2012), 455&ndash;467. [10] Petter Holme and Jari Saram&auml;ki. 2012. Temporal networks. Physics reports </span></p><p class="c104"><span class="c53">519, 3 (2012), 97&ndash;125. [11] Richard M Karp. 1972. Reducibility among combinatorial problems. In Com- </span></p><p class="c44"><span class="c53">plexity of computer computations. Springer, 85&ndash;103. [12] Gueorgi Kossinets, Jon Kleinberg, and Duncan Watts. 2008. The structure of information pathways in a social communication network. In Proceedings of the 14th ACM SIGKDD international conference on Knowledge discovery and data mining. ACM, 435&ndash;443. [13] Maxim Likhachev, Dave Ferguson, Geoff Gordon, Anthony Stentz, and Sebas- tian Thrun. 2008. Anytime search in dynamic graphs. Artificial Intelligence 172, 14 (2008), 1613&ndash;1643. [14] Yu-Ru Lin, Yun Chi, Shenghuo Zhu, Hari Sundaram, and Belle L Tseng. 2008. Facetnet: a framework for analyzing communities and their evolutions in dynamic networks. In Proceedings of the 17th international conference on World Wide Web. ACM, 685&ndash;694. [15] Raj Kumar Pan and Jari Saram&auml;ki. 2011. Path lengths, correlations, and centrality in temporal networks. Physical Review E 84, 1 (2011), 016105. [16] Ursula Redmond and P&aacute;draig Cunningham. 2016. Subgraph Isomorphism in Temporal Networks. CoRR abs/1605.02174 (2016). http://arxiv.org/abs/1605. 02174 [17] Carlos R Rivero and Hasan M Jamil. 2016. Efficient and scalable labeled subgraph matching using SGMatch. Knowledge and Information Systems (2016), 1&ndash;27. [18] Konstantinos Semertzidis and Evaggelia Pitoura. 2016. Durable graph pattern queries on historical graphs. In Data Engineering (ICDE), 2016 IEEE 32nd International Conference on. IEEE, 541&ndash;552. [19] John Tang, Mirco Musolesi, Cecilia Mascolo, and Vito Latora. 2010. Character- ising temporal distance and reachability in mobile and online social networks. ACM SIGCOMM Computer Communication Review 40, 1 (2010), 118&ndash;124. </span></p><p class="c24 c151"><span class="c53">[20] Ha-Nguyen Tran, Jung-jae Kim, and Bingsheng He. 2015. Fast subgraph match- ing on large graphs using graphics processors. In International Conference on Database Systems for Advanced Applications. Springer, 299&ndash;315. [21] J. R. Ullmann. 1976. An Algorithm for Subgraph Isomorphism. J. ACM 23, 1 </span></p><p class="c178"><span class="c53">(Jan. 1976), 31&ndash;42. </span><span class="c96">DOI:</span><span class="c53">http://dx.doi.org/10.1145/321921.321925 [22] Huanhuan Wu, James Cheng, Silu Huang, Yiping Ke, Yi Lu, and Yanyan Xu. 2014. Path problems in temporal graphs. Proceedings of the VLDB Endowment 7, 9 (2014), 721&ndash;732. [23] B Bui Xuan, Afonso Ferreira, and Aubin Jarry. 2003. Computing shortest, fastest, and foremost journeys in dynamic networks. International Journal of Foundations of Computer Science 14, 02 (2003), 267&ndash;285. [24] Xifeng Yan, Philip S. Yu, and Jiawei Han. 2004. Graph Indexing: A Frequent </span></p><p class="c165"><span class="c53">Structure-based Approach. In Proc. SIGMOD. 335&ndash;346. [25] Yi Yang, Da Yan, Huanhuan Wu, James Cheng, Shuigeng Zhou, and John CS Lui. 2016. Diversified temporal subgraph pattern mining. In Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (KDD 2016), San Francisco, CA, USA. 1965&ndash;1974. [26] Zhengwei Yang, Ada Wai-Chee Fu, and Ruifeng Liu. 2016. Diversified Top-k Subgraph Querying in a Large Graph. In Proceedings of the 2016 International Conference on Management of Data. ACM, 1167&ndash;1182. </span></p><p class="c118"><span class="c37">300 </span></p></body></html>