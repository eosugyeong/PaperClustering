<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c8{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10.5pt;font-family:"Times New Roman";font-style:normal}.c37{margin-left:-16.6pt;padding-top:11.5pt;text-indent:25.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-25.4pt}.c63{margin-left:-24.5pt;padding-top:9.1pt;text-indent:34.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.4pt}.c10{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c36{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10.5pt;font-family:"Arial";font-style:normal}.c42{margin-left:-24.5pt;padding-top:1.4pt;text-indent:33.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.4pt}.c77{margin-left:-25.7pt;padding-top:10.8pt;text-indent:35.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.4pt}.c65{margin-left:-25.7pt;padding-top:3.8pt;text-indent:34.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.4pt}.c48{margin-left:-15.4pt;padding-top:1.7pt;text-indent:24.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-26.4pt}.c84{margin-left:-25.7pt;padding-top:1.7pt;text-indent:34.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.4pt}.c24{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Courier New";font-style:normal}.c29{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Arial";font-style:normal}.c72{margin-left:-24.5pt;padding-top:1.7pt;text-indent:33.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.4pt}.c52{margin-left:-25.7pt;padding-top:1.4pt;text-indent:34.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.4pt}.c9{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Courier New";font-style:normal}.c38{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10pt;font-family:"Courier New";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Arial";font-style:normal}.c89{margin-left:-16.6pt;padding-top:10.3pt;text-indent:26.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-25.2pt}.c31{margin-left:-16.6pt;padding-top:1.4pt;text-indent:25.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-25.4pt}.c17{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Courier New";font-style:normal}.c46{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:16.6pt;font-family:"Arial";font-style:normal}.c117{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Courier New";font-style:normal}.c82{margin-left:-16.6pt;padding-top:11.3pt;text-indent:26.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-25.2pt}.c20{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.3pt;font-family:"Times New Roman";font-style:normal}.c57{margin-left:-16.6pt;padding-top:11.8pt;text-indent:25.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-25.4pt}.c53{margin-left:-25.7pt;padding-top:7.2pt;text-indent:35.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.4pt}.c47{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:19.9pt;font-family:"Arial";font-style:normal}.c64{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c62{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10.5pt;font-family:"Arial";font-style:normal}.c23{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10.5pt;font-family:"Times New Roman";font-style:normal}.c60{margin-left:-25.7pt;padding-top:10.6pt;text-indent:34.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.2pt}.c32{margin-left:-24.5pt;padding-top:1.9pt;text-indent:36.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.4pt}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Arial";font-style:normal}.c122{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.3pt;font-family:"Arial";font-style:normal}.c35{margin-left:-16.6pt;padding-top:4.1pt;text-indent:25.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-25.4pt}.c18{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.3pt;font-family:"Arial";font-style:normal}.c59{margin-left:-25.7pt;padding-top:1.7pt;text-indent:34.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.4pt}.c92{margin-left:-25.7pt;padding-top:8.4pt;text-indent:34.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.4pt}.c14{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Arial";font-style:normal}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10pt;font-family:"Arial";font-style:normal}.c11{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10pt;font-family:"Arial";font-style:normal}.c40{margin-left:-25.7pt;padding-top:0.5pt;text-indent:34.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.4pt}.c75{margin-left:-25.7pt;padding-top:1.4pt;text-indent:34.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.4pt}.c88{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:17.9pt;font-family:"Arial";font-style:normal}.c50{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5pt;font-family:"Courier New";font-style:normal}.c33{margin-left:-25.7pt;padding-top:25.7pt;text-indent:34.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.4pt}.c16{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c7{margin-left:-16.6pt;padding-top:1.7pt;text-indent:25.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-25.4pt}.c25{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5pt;font-family:"Arial";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Courier New";font-style:normal}.c41{margin-left:-16.6pt;padding-top:1.7pt;text-indent:25.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-25.4pt}.c45{margin-left:-25.7pt;padding-top:10.6pt;text-indent:34.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.4pt}.c56{margin-left:-25.7pt;padding-top:9.6pt;text-indent:35.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.4pt}.c51{margin-left:-25.7pt;padding-top:9.6pt;text-indent:34.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.4pt}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Arial";font-style:normal}.c96{margin-left:-3.2pt;padding-top:7.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-4.8pt}.c12{margin-left:-15.4pt;padding-top:8.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-26.4pt}.c54{margin-left:-6.6pt;padding-top:9.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:66pt}.c95{margin-left:5.9pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:43.7pt}.c80{margin-left:-24.5pt;padding-top:8.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.4pt}.c90{margin-left:-3.2pt;padding-top:6.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:117.1pt}.c19{margin-left:-16.6pt;padding-top:7.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:89pt}.c28{margin-left:-16.6pt;padding-top:10.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-25.4pt}.c44{margin-left:218.2pt;padding-top:55pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-36.1pt}.c43{margin-left:-25.7pt;padding-top:6.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.4pt}.c49{margin-left:-16.6pt;padding-top:19pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:95.3pt}.c130{margin-left:9.5pt;padding-top:3.4pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:0.7pt}.c128{margin-left:-3.2pt;padding-top:8.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-25.4pt}.c83{margin-left:-25.7pt;padding-top:7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.4pt}.c99{margin-left:-25.7pt;padding-top:11.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.4pt}.c100{margin-left:-5.8pt;padding-top:8.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-25.4pt}.c132{margin-left:-25.7pt;padding-top:20.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.4pt}.c93{margin-left:-16.6pt;padding-top:12pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-10.1pt}.c131{margin-left:-24.5pt;padding-top:8.9pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.4pt}.c34{margin-left:-3.2pt;padding-top:7.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:61.7pt}.c58{margin-left:-25.7pt;padding-top:8.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.4pt}.c30{margin-left:85.1pt;padding-top:4.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-15.4pt}.c110{margin-left:-15.4pt;padding-top:12.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:4.3pt}.c119{margin-left:-15.6pt;padding-top:13.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:137.4pt}.c111{margin-left:-16.6pt;padding-top:7.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:125pt}.c2{margin-left:5.9pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-25.2pt}.c102{margin-left:-3.2pt;padding-top:7.9pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-25.2pt}.c107{margin-left:19.8pt;padding-top:7.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:11pt}.c22{margin-left:-3.2pt;padding-top:8.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:78.5pt}.c120{margin-left:-25.7pt;padding-top:9.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.4pt}.c114{margin-left:-25.7pt;padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-16.4pt}.c108{margin-left:-25.7pt;padding-top:10.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.4pt}.c113{margin-left:-25.7pt;padding-top:6.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.4pt}.c125{margin-left:-3.2pt;padding-top:7.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-25.4pt}.c124{margin-left:-3.2pt;padding-top:7.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-5pt}.c112{margin-left:-5.8pt;padding-top:8.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-25.4pt}.c115{margin-left:28.7pt;padding-top:1.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:19.9pt}.c69{margin-left:-5.6pt;padding-top:10.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.3pt}.c123{margin-left:7.4pt;padding-top:10.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-28.3pt}.c55{margin-left:24.7pt;padding-top:7.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:34pt}.c127{margin-left:-3.2pt;padding-top:8.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:69.6pt}.c98{margin-left:-15.6pt;padding-top:20.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-6.3pt}.c67{margin-left:-16.6pt;padding-top:9.1pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-25.4pt}.c91{margin-left:-3.2pt;padding-top:9.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-25.4pt}.c87{margin-left:-3.2pt;padding-top:9.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-25.4pt}.c21{margin-left:-24.5pt;padding-top:12.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.4pt}.c74{margin-left:-25.7pt;padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.4pt}.c109{padding-top:3.8pt;text-indent:24.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c101{padding-top:3.8pt;text-indent:25.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c121{padding-top:0.7pt;text-indent:24.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c97{padding-top:10.1pt;text-indent:25.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c116{padding-top:11.5pt;text-indent:25.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c94{padding-top:1.4pt;text-indent:24.3pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c104{padding-top:19.4pt;text-indent:25.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c78{padding-top:10.1pt;text-indent:24.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c103{padding-top:9.6pt;text-indent:25.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c71{padding-top:12.7pt;text-indent:25.8pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c73{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c118{padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c61{padding-top:9.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c85{padding-top:6pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c26{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c15{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c66{padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c81{padding-top:13pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c105{padding-top:6.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c129{padding-top:7.9pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c86{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c39{margin-left:-16.6pt;text-indent:26.7pt;margin-right:-25.4pt}.c76{margin-left:-15.4pt;margin-right:-26.4pt}.c27{margin-left:-176.2pt;margin-right:245.5pt}.c13{margin-left:-191.6pt;margin-right:377.3pt}.c106{margin-left:-16.6pt;margin-right:-25.2pt}.c68{margin-left:-16.6pt;margin-right:-25.4pt}.c70{margin-left:205.9pt;margin-right:-15.7pt}.c79{text-indent:35.8pt}.c126{text-indent:34.8pt}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:24pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:14pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c86"><p class="c73"><span class="c88">Practical Query Answering in Data Exchange Under Inconsistency-Tolerant Semantics </span></p><p class="c4"><span class="c10">Balder ten Cate </span><span class="c46">UC Santa Cruz Google </span><span class="c47">btencate@ucsc.edu </span></p><p class="c4"><span class="c10">Richard L. Halpert </span><span class="c47">rhalpert@ucsc.edu </span></p><p class="c4"><span class="c46">UC Santa Cruz </span><span class="c10">Phokion G. Kolaitis </span><span class="c46">UC Santa Cruz IBM </span><span class="c47">kolaitis@ucsc.edu </span><span class="c46">Research - Almaden </span><span class="c10">ABSTRACT </span><span class="c0">Exchange-repair semantics (or, XR-Certain semantics) is a recently proposed inconsistency-tolerant semantics in the context of data exchange. This semantics makes it possi- ble to provide meaningful answers to target queries in cases in which a given source instance cannot be transformed into a target instance satisfying the constraints of the data ex- change specification. It is known that computing the an- swers to conjunctive queries under XR-Certain semantics is a coNP-complete problem in data complexity. Moreover, this problem can be reduced in a natural way to cautious reasoning over stable models of a disjunctive logic program. Here, we explore how to effectively perform XR-Certain query answering for practical data exchange settings by leveraging modern sophisticated solvers for disjunctive logic programming. We first present a new reduction, accompa- nied by an optimized implementation, of XR-Certain query answering to disjunctive logic programming. We then eval- uate this approach on a benchmark that we introduce here and which is modeled after a practical data exchange prob- lem in computational genomics. Specifically, we present a benchmark scenario that mimicks a portion of the UCSC Genome Browser data import process. Our initial results, based on real genomic data, suggest that the solvers we ap- ply fail to take advantage of some critical exploitable struc- tural properties of the specific instances at hand. We then develop an improved encoding to take advantage of these properties using techniques inspired by the notion of a re- pair envelope. The improved implementation utilizing these techniques computes query answers ten to one thousand times faster for large instances, and exhibits promising scal- ability with respect to the size of instances and the rate of target constraint violations. </span></p><p class="c4"><span class="c10">Categories and Subject Descriptors </span><span class="c0">H.2 [Database Management]: Systems&mdash;relational databases, rule based databases, query processing </span></p><p class="c4"><span class="c24">&copy;</span><span class="c29">2016, Copyright is with the authors. Published in Proc. 19th Inter- national Conference on Extending Database Technology (EDBT), March 15-18, 2016 - Bordeaux, France: ISBN 978-3-89318-070-7, on OpenPro- ceedings.org. Distribution of this paper is permitted under the terms of the Creative Commons license CC-by-nc-nd 4.0 EDBT 2016 Bordeaux, France </span></p><p class="c4"><span class="c10">General Terms </span><span class="c0">Theory, Algorithms, Design </span></p><p class="c4"><span class="c10">Keywords </span><span class="c0">Data exchange, certain answers, repairs, consistent query answering, disjunctive logic programming, stable models </span></p><p class="c4"><span class="c10">1. INTRODUCTION </span></p><p class="c15"><span class="c0">Data exchange is the task of transforming data structured under a source schema into data structured under a target schema in such a way that all constraints in a fixed set of source-to-target constraints and in a fixed set of target con- straints are satisfied. During the past decade, there has been an extensive and multifaceted investigation of data exchange (see the monograph [1]). There are two main algorithmic problems in data exchange: the problem of materializing an instance that, together with a given source instance satisfies all constraints (such an instance is a called a solution of the given source instance) and the problem of computing the certain answers to a query over the target schema, i.e., the intersection of the answers to the query over all solutions of a given source instance. In data exchange settings with a non-empty set of target constraints, it frequently happens that a given source instance has no solution. In particular, this may happen when the source instance at hand contains inconsistencies or conflicting information that is exposed by the target constraints. The standard data exchange frame- works are not able to provide meaningful answers to target queries in such circumstances; in fact, the certain answers to every target query trivialize. To address this problem and to give meaningful answers to target queries, we recently introduced the framework of exchange-repair semantics (or, XR-Certain semantics) [8]. This is an inconsistency-tolerant framework that is based on the notion of source repairs, where, informally, a source repair is a source instance that differs minimally from the original source data, but has a solution. In turn, source repairs give rise to the notion of the XR-Certain answers to target queries, which, by defini- tion, are the intersection of the answers to the query over all solutions of all source repairs of the given source instance. It should be noted that inconsistency-tolerant semantics have also been investigated in the context of data integration (see, e.g., [7, 17]) and in the context of ontology-based data ac- cess (OBDA) (see, e.g., the recent survey [5]). In [9], which is the full version of [8], we provided a detailed comparison between the XR-Certain semantics and the inconsistency- tolerant semantics in these two other frameworks. In partic- </span></p><p class="c4"><span class="c16">Series ISSN: 2367-2005 233 </span><span class="c117">10.5441/002/edbt.2016.23 </span></p><p class="c58"><span class="c0">ular, we showed that, as regards consistent query answering, the exchange-repairs framework and the OBDA framework can simulate each other. </span></p><p class="c59"><span class="c0">A data exchange task is specified using a schema map- ping M = (S,T,&Sigma;</span><span class="c3">st</span><span class="c6">,&Sigma;</span><span class="c3">t</span><span class="c6">), where S is the source schema, </span><span class="c0">T is the target schema, &Sigma;</span><span class="c1">st </span><span class="c0">is a set of constraints between S and T, and &Sigma;</span><span class="c3">t </span><span class="c6">is a set of constraints on T. The most </span><span class="c0">extensively studied schema mappings are the ones in which &Sigma;</span><span class="c3">st </span><span class="c6">is a set of source-to-target tuple-generating dependen- </span><span class="c0">cies (s-t tgds) and &Sigma;</span><span class="c3">t </span><span class="c6">is a weakly-acyclic set of target tuple- </span><span class="c0">generating dependencies (target tgds) and target equality- generating dependencies (target egds) [11]. Note that tuple- generating dependencies are also known as GLAV (global- and-local as view) constraints; as special cases, they contain the classes of GAV (global-as-view) constraints and LAV (local-as-view) constraints. In [8], it was shown that com- puting the XR-Certain answers to target conjunctive queries is a coNP-complete problem in data complexity; in fact, this intractability persists even in the case in which &Sigma;</span><span class="c3">st </span><span class="c6">is a set </span><span class="c0">of GAV constraints and &Sigma;</span><span class="c3">t </span><span class="c6">is a set of egds. Moreover, a con- </span><span class="c0">nection with disjunctive logic programming was unveiled in [8] by showing that the XR-Certain answers of conjunctive queries can be rewritten as the cautious answers of a union of conjunctive queries with respect to the stable models of a disjunctive logic program over a suitably defined expansion of the source schema. </span></p><p class="c59"><span class="c0">Here, our main aim is to explore how to effectively perform XR-Certain query answering for practical data exchange set- tings by leveraging modern sophisticated solvers for disjunc- tive logic programming. Disjunctive logic programming is a suitable formalism for coping with the intractability of XR-Certain query answering because it goes beyond the nat- ural expressiveness of SQL while still remaining in a declara- tive framework. Our first technical result is a new improved reduction, accompanied by an optimized implementation, of the problem of computing the XR-Certain answers of queries in the context of data exchange to the problem of comput- ing the certain answers of queries with respect to the stable models of disjunctive logic programs. We then evaluate this approach on a benchmark that we introduce here and which is modeled after a practical data exchange problem in com- putational genomics. Specifically, we present a benchmark scenario that mimics a portion of the data import process of the UCSC Genome Browser (</span><span class="c24">https://genome.ucsc.edu/</span><span class="c0">), a widely used genomics resource that &ldquo;contains the reference sequence and working draft assemblies for a large collection of genomes.&rdquo; We believe that data sets from computational sciences, such as computational genomics, are particularly in need of concepts and techniques that, like XR-Certain answers, eliminate the unquantifiable uncertainty that arise from constraint violations. </span></p><p class="c59"><span class="c0">We carry out two experimental evaluations using real ge- nomic data. The first is based on what we call a monolithic approach, which generates a disjunctive logic program from a given query and source instance, and then runs the clingo solver from the Potassco collection [12]. The results of this evaluation suggest that the solver fails to take advantage of some critical exploitable structural properties of the spe- cific instances at hand. Intuitively, the cost of transforming the data from the source schema into the target schema is embedded in the execution cost of running each individual query, which causes large instances to become unworkable even for simple queries. In view of this, we develop a dif- </span></p><p class="c15 c68"><span class="c0">ferent segmentary approach that utilizes an improved en- coding to take advantage of the aforementioned structural properties using techniques inspired by the notion of a repair envelope. The improved implementation utilizing these tech- niques computes query answers ten to one thousand times faster than the monolithic approach for large instances, and exhibits promising scalability with respect to the size of in- stances and the rate of target constraint violations. </span></p><p class="c49"><span class="c10">2. PRELIMINARIES </span></p><p class="c35"><span class="c0">This section contains definitions of basic notions and a minimum amount of background material on data exchange and on disjunctive logic programming. More detailed infor- mation about schema mappings and certain answers can be found in [1, 11]. </span></p><p class="c68 c118"><span class="c64">Instances, Queries, and Homomorphisms. </span><span class="c0">Fix an infi- nite set Const of elements, and an infinite set Nulls of ele- ments such that Const and Nulls are disjoint. A schema R is a finite set of relation symbols, each having a designated arity. An R-instance is a finite database I over the schema R whose active domain is a subset of Const &cup;Nulls. A fact of an R-instance I is an expression of the form R(a</span><span class="c1">1</span><span class="c0">,...,a</span><span class="c3">k</span><span class="c6">), </span><span class="c0">where R is a relation symbol of arity k in R and (a</span><span class="c3">1</span><span class="c6">,...,a</span><span class="c3">k</span><span class="c6">) </span><span class="c0">is a member of the relation R</span><span class="c11">I </span><span class="c0">on I that interprets the sym- bol R. Every R-instance can be identified with the set of its facts. We say that an R-instance I is a sub-instance of an R-instance I if I &sube; I, where I and I are viewed as sets of facts. If I is an R-instance and R &sube; R, then by the R - restriction of I we will mean the subinstance of I containing only those facts that involve relations from R . </span></p><p class="c31"><span class="c0">We assume familiarity with conjunctive queries (CQs) and unions of conjunctive queries (UCQs). The answers to a query q in an instance I are denoted by q(I), and we denote by q&darr;(I) the answers of q on I that contain only values from Const. </span></p><p class="c41"><span class="c0">The active domain of an instance I is the set of values from Const&cup;Nulls that occur in facts of I. By a homomorphism from an R-instance I to another R-instance I , we mean a map h from the active domain of I to the active domain of I , such that h(c) = c for all c &isin; Const, and such that for every fact R(v</span><span class="c3">1</span><span class="c6">, ..., v</span><span class="c3">n</span><span class="c6">) &isin; I we have that R(h(v</span><span class="c3">1</span><span class="c6">),...,h(v</span><span class="c3">n</span><span class="c6">)) &isin; I . </span></p><p class="c28"><span class="c64">Schema Mappings. </span><span class="c0">A tuple-generating dependency (tgd) over a schema R is an expression of the form &forall;x(&phi;(x) &rarr; &exist;y&psi;(x,y)), where &phi;(x) and &psi;(x,y) are conjunctions of atoms over R. Tgds are also known as GLAV (global-and- local-as-view) constraints. Two important special cases are the GAV constraints and the LAV constraints. A GAV con- straint is a tgd of the form &forall;x(&phi;(x) &rarr; P(x)) (that is, the right-hand side of the implication consists of a single atom without existential quantifiers) and a LAV constraint is a tgd of the form &forall;x(R(x) &rarr; &exist;y&psi;(x,y)) (that is, the left- hand side of the implication consists of a single atom). </span></p><p class="c41"><span class="c0">Let S and T be disjoint schemas, called the source schema and the target schema. A source-to-target tgd (s-t tgd, or, source-to-target GLAV constraint) is a tgd as defined above, where &phi;(x) is a conjunction of atoms over S and &psi;(x,y) is a conjunction of atoms over T. </span></p><p class="c41"><span class="c0">An equality-generating dependency (egd) over a schema R is an expression of the form &forall;x(&phi;(x) &rarr; x</span><span class="c3">i </span><span class="c6">= x</span><span class="c3">j</span><span class="c6">) with &phi;(x) </span><span class="c0">a conjunction of atoms over R. </span></p><p class="c44"><span class="c16">234 </span></p><p class="c92"><span class="c0">For the sake of readability, we will frequently drop univer- sal quantifiers when writing tgds and egds. </span></p><p class="c59"><span class="c0">A schema mapping is a quadruple M = (S,T,&Sigma;</span><span class="c3">st</span><span class="c6">,&Sigma;</span><span class="c3">t</span><span class="c6">), </span><span class="c0">where S is a source schema, T is a target schema, &Sigma;</span><span class="c1">st </span><span class="c0">is a finite set of s-t tgds, and &Sigma;</span><span class="c3">t </span><span class="c6">is a finite set of tgds and/or </span><span class="c0">egds over the target schema. We will also call such schema mappings glav</span><span class="c24">+</span><span class="c0">(glav, egd) schema mappings. In the spe- cial case where &Sigma;</span><span class="c3">st </span><span class="c6">consists of (source-to-target) GAV con- </span><span class="c0">straints and &Sigma;</span><span class="c3">t </span><span class="c6">consists of GAV constraints and/or egds, we </span><span class="c0">will say that M is a gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema mapping. </span></p><p class="c114"><span class="c64">Universal Solutions and Certain Answers. </span><span class="c0">Let M = (S,T,&Sigma;</span><span class="c3">st</span><span class="c6">,&Sigma;</span><span class="c3">t</span><span class="c6">) be a schema mapping, and let I be a source </span><span class="c0">instance. As usual in data exchange, we will assume that the source instances we consider do not contain null values. A target instance J is a solution for a source instance I w.r.t. M if the pair (I,J) satisfies the constraints of M, that is, I and J together satisfy &Sigma;</span><span class="c3">st</span><span class="c6">, while J satisfies &Sigma;</span><span class="c3">t</span><span class="c6">. </span><span class="c0">In general, a source instance may have many solutions. A universal solution for I (with respect to M) is a solution J for I such that for all solutions J of I, there is a homo- morphism h from J to J . Universal solutions are considered the preferred solutions in data exchange. One reason for this is that universal solutions can be used to compute certain answers to target queries. </span></p><p class="c84"><span class="c0">If q is a query over the target schema T, then the certain answers of q with respect to I and M are defined as </span></p><p class="c98"><span class="c0">certain(q,I,M) = </span><span class="c6">&#8898;{q(J) : J is a solution for I w.r.t. M} </span></p><p class="c126 c132"><span class="c0">It was shown in [11] that, if J is a universal solution for a source instance I w.r.t. a schema mapping M, then for every conjunctive query q, it holds that certain(q,I,M) = q&darr;(J). </span></p><p class="c74"><span class="c64">Weak Acyclicity and the Chase. </span><span class="c0">If M = (S,T,&Sigma;</span><span class="c3">st</span><span class="c6">,&Sigma;</span><span class="c3">t</span><span class="c6">) </span><span class="c0">is an arbitrary glav</span><span class="c24">+</span><span class="c0">(glav, egd) schema mapping, then a given source instance may have no solution or it may have a solution, but no universal solution. For this reason, in [11] the concept of weak acyclicity was introduced, and it was shown that, when &Sigma;</span><span class="c3">t </span><span class="c6">is the union of a weakly acyclic set of </span><span class="c0">target tgds and a set of egds, then, for all source instances I, a solution exists if and only if a universal solution exists. Moreover, the chase procedure can be used to determine in polynomial time (data complexity) whether a solution for I exists and, if so, to construct a universal solution for I in time polynomial in the size of I. The obtained solution, which we will denote by chase(I, M) (when it exists), is known as the canonical universal solution of I. We refer to [11] for more details, including the definition of weak acyclic- ity and of the chase procedure. </span></p><p class="c59"><span class="c0">By a glav</span><span class="c24">+</span><span class="c0">(wa-glav, egd) schema mapping we will mean a schema mapping M = (S,T,&Sigma;</span><span class="c3">st</span><span class="c6">,&Sigma;</span><span class="c3">t</span><span class="c6">), where &Sigma;</span><span class="c3">st </span><span class="c0">is a finite set of s-t tgds, and &Sigma;</span><span class="c1">t </span><span class="c0">is the union of a weakly acyclic set of target tgds and a set of egds. We spell out here two basic facts that are used in several arguments in this paper: let M be any glav</span><span class="c24">+</span><span class="c0">wa-glav schema mapping (without egds). Then (i) every source instance I has a solu- tion (and hence has a canonical universal solution), and (ii) whenever I &sube; I, then chase(I ,M) &sube; chase(I,M). The latter is also known as the monotonicity of the chase. </span></p><p class="c15 c68"><span class="c64">Disjunctive Logic Programming. </span><span class="c0">A disjunctive logic pro- gram (DLP program) &Pi; over a schema R is a finite collection of rules of the form </span></p><p class="c107"><span class="c0">&alpha;</span><span class="c3">1 </span><span class="c6">&or; ... &or; &alpha;</span><span class="c3">n </span><span class="c6">&larr; &beta;</span><span class="c3">1</span><span class="c6">,...,&beta;</span><span class="c3">m</span><span class="c6">,&not;&gamma;</span><span class="c3">1</span><span class="c6">,...,&not;&gamma;</span><span class="c3">k</span><span class="c6">. </span></p><p class="c68 c105"><span class="c0">where n, m, k &ge; 0 and &alpha;</span><span class="c3">1</span><span class="c6">,...,&alpha;</span><span class="c3">n</span><span class="c6">,&beta;</span><span class="c3">1</span><span class="c6">,...,&beta;</span><span class="c3">m</span><span class="c6">,&gamma;</span><span class="c3">1</span><span class="c6">,...,&gamma;</span><span class="c3">k </span><span class="c6">are </span><span class="c0">atoms formed from the relations in R &cup; {=, =}, using the constants in Const and first-order variables. A DLP pro- gram is said to be ground if it consists of rules that do not contain any first-order variables. A model of &Pi; is an R- instance I over the domain Const that satisfies all rules of &Pi; (viewed as universally quantified first-order sentences). A minimal model of &Pi; is a model M of &Pi; such that there does not exist a model M of &Pi; where the facts of M form a strict subset of the facts of M. For a ground DLP &Pi; over a schema R and an R-instance M over the domain Const, the reduct &Pi;</span><span class="c11">M </span><span class="c0">of &Pi; with respect to M is the DLP containing, for each rule &alpha;</span><span class="c3">1 </span><span class="c6">&or; ... &or; &alpha;</span><span class="c3">n </span><span class="c6">&larr; &beta;</span><span class="c3">1</span><span class="c6">,...,&beta;</span><span class="c3">m</span><span class="c6">, &not;&gamma;</span><span class="c3">1</span><span class="c6">,...,&not;&gamma;</span><span class="c3">k</span><span class="c6">, with </span><span class="c0">M |= &gamma;</span><span class="c3">i </span><span class="c6">for all i &le; k, the rule &alpha;</span><span class="c3">1 </span><span class="c6">&or;...&or;&alpha;</span><span class="c3">n </span><span class="c6">&larr; &beta;</span><span class="c3">1</span><span class="c6">,...,&beta;</span><span class="c3">m</span><span class="c6">. A </span><span class="c0">stable model of a ground DLP &Pi; is an R-instance M over the domain Const such that M is a minimal model of the reduct &Pi;</span><span class="c11">M</span><span class="c0">. See [13] for more details. The cautious answers to a query q, w.r.t. a DLP program &Pi; (under the stable model semantics) are defined as </span></p><p class="c115"><span class="c0">&#8898;</span><span class="c6">{q(s) | s is a stable model of &Pi;} . </span></p><p class="c67"><span class="c0">The stable model semantics is the most widely used seman- tics of DLP programs, and many solvers have been developed that support reasoning over stable models. In particular, stable models of disjunctive logic programs have been well- studied as a way to compute database repairs ([18] provides a thorough treatment). </span></p><p class="c93"><span class="c10">3. EXCHANGE REPAIR FRAMEWORK </span></p><p class="c68 c101"><span class="c0">We briefly recall here the exchange-repair framework that was introduced in [8]. The development of this framework was motivated by the observation that the definition of certain(q,I,M) trivializes when a source instance I has no solution w.r.t. a given schema mapping M. XR-Certain an- swers were proposed as a semantics that provides meaningful answers to queries in such cases. </span></p><p class="c89"><span class="c0">Definition 1. [8] Let M = (S,T, &Sigma;</span><span class="c3">st</span><span class="c6">,&Sigma;</span><span class="c3">t</span><span class="c6">) be a schema </span><span class="c0">mapping, let I be an S-instance. </span></p><p class="c112"><span class="c0">1. A source instance I is said to be a source repair of I with respect to M if I &sube; I, I has a solution with respect to M, and no instance I with I </span><span class="c24">&#8842; </span><span class="c0">I &sube; I has a solution with respect to M. </span></p><p class="c100"><span class="c0">2. We say that a pair (I ,J ) is an exchange-repair so- </span></p><p class="c2"><span class="c0">lution (or XR-Solution) for I with respect to M if I is a source repair of I with respect to M and J is a solution for I with respect to M. </span></p><p class="c100"><span class="c0">3. For a query q over the target schema T, the XR-certain </span></p><p class="c95"><span class="c0">answers to q in I w.r.t. M is the set </span></p><p class="c123"><span class="c0">XR-Certain(q,I,M) = </span><span class="c6">&#8898;{q(J ) | (I ,J ) is an XR-Solution for I w.r.t. M}. </span></p><p class="c68 c71"><span class="c0">Note that, whenever a source instance I does have so- lutions w.r.t. M, then, for all queries q, we have that </span></p><p class="c44"><span class="c16">235 </span></p><p class="c80"><span class="c0">XR-Certain(q,I, M) = certain(q,I,M). While the XR- Certain semantics takes inspiration from the well-established notions of database repairs and consistent query answers [2, 4], the precise definition of the semantics reflects impor- tant assumptions that are specific to the context of data exchange. Specifically, the definitions of XR-Solution and XR-Certain reflect the fact that in a data exchange setting, it is preferred to make tgds satisfied by deriving additional facts, rather than by deleting facts; and the data used to answer target queries should derive from coherent sets of source facts. </span></p><p class="c42"><span class="c0">It was shown in [8] that, in the case of glav</span><span class="c24">+</span><span class="c0">(wa-glav, egd) schema mappings, the data complexity of XR-Certain query answering for conjunctive queries is coNP-complete (note that the restriction to weakly acyclic schema map- pings is necessary here, since it follows from results in [11] that the same problem is undecidable for arbitrary glav</span><span class="c24">+ </span><span class="c0">(glav, egd) schema mappings). Furthermore, several ap- proaches to query answering were studied in [8]. In partic- ular, it was shown that, for glav</span><span class="c24">+</span><span class="c0">(wa-glav, egd) schema mappings, XR-certain answers can be computed by means of a disjunctive logic program. We discuss this approach in the next section. </span></p><p class="c21"><span class="c10">4. BASIC APPROACH TO QUERY AN- </span></p><p class="c32"><span class="c10">SWERING </span><span class="c0">Based on the initial results in [8], we pursue here the devel- opment of a practical system for XR-Certain query answer- ing via disjunctive logic programming, leveraging modern sophisticated solvers. Note that the emergence of such pow- erful solvers for NP-hard problems has already enabled prac- tical solutions for many other computationally hard prob- lems in industry. Concretely, in this section, we present a first implementation of XR-Certain query answering based on a translation along the lines of [8], that takes as input a schema mapping M and a source instance I, and produces a single, typically large, DLP program whose stable mod- els describe the XR-solutions of I w.r.t. M. We refer to this as the monolithic approach, in order to contrast it with another approach, which will be presented in Section 6, in- volving multiple DLP programs of smaller size. </span></p><p class="c72"><span class="c0">The first step in this approach consists of a reduction from the general case of glav</span><span class="c24">+</span><span class="c0">(wa-glav, egd) schema mappings to the case of gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema mappings. </span></p><p class="c63"><span class="c0">Theorem 1 ([8]). If M = (S,T, &Sigma;</span><span class="c3">st</span><span class="c6">,&Sigma;</span><span class="c3">t</span><span class="c6">) is a glav</span><span class="c5">+ </span><span class="c0">(wa-glav, egd) schema mapping and q a conjunctive query over T, then there exist a gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema map- ping </span><span class="c14">&circ;</span><span class="c0">M and union of conjunctive queries &circ;q such that XR-Certain(q,I, M) = XR-Certain(&circ;q,I, </span><span class="c14">&circ;</span><span class="c0">M). </span></p><p class="c131"><span class="c0">The resulting schema mapping may in general be exponen- tially larger than the original. However, as we will see in Section 5.2, our implementation incurs only a modest in- crease when applied to our benchmark. </span></p><p class="c72"><span class="c0">Next, in [8], we present a very natural and concise encod- ing of XR-Certain for gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema mappings as the cautious answers over the parallel circumscription of a disjunctive logic program &Pi;. In [15] it was shown that the problem of finding such models can be subsequently reduced to that of computing stable models of a translation of &Pi; into a new disjunctive logic program. However, the translation involved requires the explicit representation of the herbrand </span></p><p class="c15 c76"><span class="c0">base of the source instance, which can be prohibitively large even for small source instances. We now present an im- proved, direct reduction of XR-Certain to the cautious an- swers over stable models of a disjunctive logic program. </span></p><p class="c76 c94"><span class="c0">In order to facilitate the discussion below, it is convenient to introduce the notion of a canonical XR-Solution. An XR-Solution (I ,J ) for I w.r.t. M is said to be a canon- ical XR-Solution if J is a canonical universal solution for I w.r.t. M, that is, J = chase(I,M). </span></p><p class="c48"><span class="c0">For any gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema mapping M = (S,T,&Sigma;</span><span class="c1">st</span><span class="c0">,&Sigma;</span><span class="c1">t</span><span class="c0">), let &Pi;</span><span class="c1">M </span><span class="c0">be the DLP program given in Fig- ure 1. Observe that the schema of the program &Pi;</span><span class="c3">M </span><span class="c6">con- </span><span class="c0">tains multiple distinct copies of each relation from S &cup; T. The program in Theorem 2 intends to describe the canoni- cal XR-Solutions of a source instance. Suppose (I ,J ) is a canonical XR-Solution for some source instance I w.r.t. a gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema mapping M = (S,T,&Sigma;</span><span class="c3">st</span><span class="c6">,&Sigma;</span><span class="c3">t</span><span class="c6">), and </span><span class="c0">let J be the canonical universal solution for I w.r.t. the tgds of M. The program introduces three predicates for each source relation, one with the original name meant to con- tain the facts of I, one subscripted with </span><span class="c24">d </span><span class="c0">(&ldquo;deleted&rdquo;) meant to contain the facts of I\I , and one subscripted with </span><span class="c24">r </span><span class="c0">(&ldquo;re- mains&rdquo;) meant to contain the facts of I . The program also introduces these same three predicates for each target rela- tion, plus a fourth subscripted with </span><span class="c24">i </span><span class="c0">(&ldquo;incidentally deleted&rdquo;) meant to contain the target facts in J \J that are also con- tained in some subset J &supe; J of J that is consistent with &Sigma;</span><span class="c1">t </span><span class="c0">(that is, they are not in a canonical XR-Solution but they may appear in some other XR-Solution). </span></p><p class="c76 c121"><span class="c0">For every stable model M of &Pi;</span><span class="c1">M</span><span class="c0">, we denote by I</span><span class="c11">M </span><span class="c0">and J</span><span class="c11">M </span><span class="c0">the S-instance and T-instance consisting of those facts R(a) in the relevant schema for which R</span><span class="c3">r</span><span class="c6">(a) &isin; M. </span></p><p class="c76 c97"><span class="c0">Theorem 2. Let M = (S,T,&Sigma;</span><span class="c1">st</span><span class="c0">,&Sigma;</span><span class="c1">t</span><span class="c0">) be a gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema mapping and I a source instance. The XR- solutions of I w.r.t. M are precisely those pairs of instances that are of the form (I</span><span class="c11">M</span><span class="c0">,J</span><span class="c11">M</span><span class="c0">) for some stable model M of &Pi;</span><span class="c3">M </span><span class="c6">&cup; I. </span></p><p class="c76 c104"><span class="c0">Corollary 1. Let M be a gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema mapping. For every union of conjunctive queries q and for every source instance I, </span></p><p class="c69"><span class="c0">XR-Certain(q,I,M) = </span><span class="c6">&#8898;{q</span><span class="c3">r</span><span class="c6">(s) | s a stable model of &Pi;</span><span class="c3">M </span><span class="c6">&cup; I} </span></p><p class="c12"><span class="c0">where q</span><span class="c3">r </span><span class="c6">is the query formed from q by replacing every oc- </span><span class="c0">currence of a relation R with R</span><span class="c3">r</span><span class="c6">. </span></p><p class="c76 c78"><span class="c0">With this new encoding, we can now compute XR-Certain using the disjunctive logic program &Pi;</span><span class="c3">M</span><span class="c6">&cup;I, whose size is lin- </span><span class="c0">ear in the combined size of the source instance and schema mapping. The DLP generated using the prior approach of [8], in contrast, is lower-bounded in size by |adom(I)|</span><span class="c11">s</span><span class="c0">, where s is the maximum arity of the relations in the source schema. </span></p><p class="c110"><span class="c10">5. SCENARIO: GENOME BROWSER </span></p><p class="c76 c109"><span class="c0">Scientific data is a potentially important application of XR-Certain query answering because research decisions and discoveries are often made based on data drawn from a vari- ety of sources, and because unquantifiable uncertainty must </span></p><p class="c44"><span class="c16">236 </span></p><p class="c4"><span class="c0">Table For each tgd (R1(x,y) &and; ... &and; Rn(x,y) &rarr; T(x)) &isin; (&Sigma;</span><span class="c1">st</span><span class="c0">&cup;&Sigma;</span><span class="c1">t</span><span class="c0">), </span></p><p class="c4"><span class="c0">1: Source Instances construct a chase rule, deletion rule, and target remainder rule respectively: </span></p><p class="c26"><span class="c24">T</span><span class="c0">(x) &larr; </span><span class="c24">R1</span><span class="c0">(x,y), ..., </span><span class="c24">R</span><span class="c0">n(x,y). </span><span class="c24">R1</span><span class="c38">d</span><span class="c6">(x,y) &or; ... &or; </span><span class="c5">R</span><span class="c6">n</span><span class="c38">d</span><span class="c6">(x,y) &larr; </span><span class="c5">T</span><span class="c38">d</span><span class="c6">(x),</span><span class="c5">R1</span><span class="c6">(x,y), ...,</span><span class="c5">R</span><span class="c6">n(x,y), </span><span class="c0">&not;</span><span class="c24">R1</span><span class="c9">i</span><span class="c0">(x,y), ...,&not;</span><span class="c24">R</span><span class="c0">n</span><span class="c9">i</span><span class="c0">(x,y). </span><span class="c24">T</span><span class="c38">r</span><span class="c6">(x) &larr; </span><span class="c5">R1</span><span class="c38">r</span><span class="c6">(x,y),...,</span><span class="c5">R</span><span class="c6">n</span><span class="c38">r</span><span class="c6">(x,y). </span></p><p class="c26"><span class="c0">total # of total # of Database Relations Attributes Tuples UCSC* 2 13 165,920 RefSeq 5 38 706,923 EntrezGene 1 3 431,114 UniProt 1 3 4,405,573 For each egd (R1(x) &and; ... &and; Rn(x) &rarr; x</span><span class="c3">i </span><span class="c6">= x</span><span class="c3">j</span><span class="c6">) &isin; &Sigma;</span><span class="c3">t</span><span class="c6">, con- </span></p><p class="c4"><span class="c0">*Transcript alignments and crossreference only. struct a deletion rule: </span></p><p class="c4"><span class="c24">R1</span><span class="c9">d</span><span class="c0">(x) &or; ... &or; </span><span class="c24">R</span><span class="c0">n</span><span class="c9">d</span><span class="c0">(x) &larr; </span><span class="c24">R1</span><span class="c0">(x),...,</span><span class="c24">R</span><span class="c0">n(x),x</span><span class="c1">i </span><span class="c0">= x</span><span class="c1">j</span><span class="c0">, </span></p><p class="c4"><span class="c0">&not;</span><span class="c24">R1</span><span class="c38">i</span><span class="c6">(x), ...,&not;</span><span class="c5">R</span><span class="c6">n</span><span class="c38">i</span><span class="c6">(x). </span></p><p class="c4"><span class="c0">it was observed), and each may have subsections specify- </span></p><p class="c4"><span class="c0">For each relation R &isin; S, construct a source remainder rule: </span></p><p class="c26"><span class="c0">ing what protein it encodes and what gene it is transcribed from. These subsections often link to other databases us- </span><span class="c24">R</span><span class="c38">r</span><span class="c6">(x) &larr; </span><span class="c5">R</span><span class="c6">(x),&not;</span><span class="c5">R</span><span class="c38">d</span><span class="c6">(x) </span></p><p class="c4"><span class="c0">For each relation R &isin; T, construct an incidental deletion rule, and the one-of-three rules: </span></p><p class="c15"><span class="c0">ing external protein and gene identifiers. Our ETL step places transcripts, sources, references, genes, and proteins into five separate respective relations, all keyed by transcript accession identifier. The EntrezGene database is available </span></p><p class="c4"><span class="c24">R</span><span class="c38">i</span><span class="c6">(x) &larr; </span><span class="c5">R</span><span class="c6">(x),&not;</span><span class="c5">R</span><span class="c38">r</span><span class="c6">(x),&not;</span><span class="c5">R</span><span class="c38">d</span><span class="c6">(x) </span><span class="c0">&perp; &larr; </span><span class="c24">R</span><span class="c9">r</span><span class="c0">(x),</span><span class="c24">R</span><span class="c9">d</span><span class="c0">(x) &perp; &larr; </span><span class="c24">R</span><span class="c38">r</span><span class="c6">(x),</span><span class="c5">R</span><span class="c38">i</span><span class="c6">(x) </span><span class="c0">&perp; &larr; </span><span class="c24">R</span><span class="c9">d</span><span class="c0">(x),</span><span class="c24">R</span><span class="c9">i</span><span class="c0">(x) </span></p><p class="c15"><span class="c0">in ASN.1 format, which we first convert to xml using the </span><span class="c24">gene2xml </span><span class="c0">tool from the NCBI ToolBox [19]. From the re- sulting xml, we extract the desired fields into a single table using the </span><span class="c24">xtract </span><span class="c0">tool from NCBI Entrez Direct [20]. </span></p><p class="c4"><span class="c0">Our complete schema mapping is available for down- load at </span><span class="c24">https://users.soe.ucsc.edu/~rhalpert/ </span><span class="c0">Figure 1: Procedure to construct the disjunctive logic pro- gram &Pi;</span><span class="c1">M </span></p><p class="c4"><span class="c24">xr-benchmarks/</span><span class="c0">. Table 1 summarizes the data sources. </span></p><p class="c26"><span class="c0">We represent the given part of UCSC&rsquo;s gene model with two tables, ComputedAlignments, which holds data about the transcripts themselves, and ComputedCrossref, which holds a cross-reference between UCSC &ldquo;known gene IDs&rdquo; (re- be eliminated from the data before a decision or discovery is </span></p><p class="c4"><span class="c0">ferred to here as &ldquo;transcripts&rdquo;) and the closest correspond- made. The guarantee given by XR-Certain query answers &ndash; </span></p><p class="c4"><span class="c0">ing external database transcript identifier (usually a RefSeq that all possible repairs of the source instance agree on them </span></p><p class="c4"><span class="c0">accession) and protein identifier (usually a UniProt or Ref- &ndash; is a natural fit for these circumstances. </span></p><p class="c4"><span class="c0">Seq accession). Our hand-written schema mapping specifies Inspired by the UCSC Genome Browser, we present a </span></p><p class="c4"><span class="c0">how these tables and the RefSeq, EntrezGene, and UniProt benchmark that uses real data: a loose simulation of the </span></p><p class="c4"><span class="c0">databases are used to populate the target schema. It also genome browser data import process. The UCSC Genome </span></p><p class="c4"><span class="c0">applies a key constraint to each target relation, per industry Browser database is constructed using a variety of algo- </span></p><p class="c4"><span class="c0">best-practice. Many of the key constraints are specified by rithms and public data sources. Our benchmark focuses </span></p><p class="c4"><span class="c0">the Genome Browser&rsquo;s schema, while some are not specified on the human gene model, a set of genomic sequences which </span></p><p class="c4"><span class="c0">but are reasonable constraints that are in fact satisfied by putatively capture the portion of the human genome that </span></p><p class="c4"><span class="c0">the Genome Browser data. encodes proteins. The UCSC Genome Browser algorithms </span></p><p class="c4"><span class="c0">The true Genome Browser&rsquo;s process computes a single compute these sequences from a reference genome by com- </span></p><p class="c4"><span class="c0">coherent truth which may differ from that represented in puting alignments for known/observed proteins and tran- </span></p><p class="c4"><span class="c0">the external databases. Our schema mapping, on the other scripts from the UniProt and GenBank databases [14]. For </span></p><p class="c4"><span class="c0">hand, consolidates these sources into the target schema, and our purposes, we treat the set of transcripts as given (that </span></p><p class="c4"><span class="c0">this gives rise to some inconsistency. The key constraints on is, as a source instance rather than the result of a compu- </span></p><p class="c4"><span class="c0">the knownGene and kgXref tables prove critical in this re- tation), and we provide a schema mapping mimicking how </span></p><p class="c4"><span class="c0">gard: they enforce that each transcript have exactly one this data, plus a significant volume of data from the Ref- </span></p><p class="c4"><span class="c0">value for the exon count, and one gene symbol, respectively. Seq, Entrez Gene, and UniProt databases, are combined </span></p><p class="c4"><span class="c0">Since values from both the UCSC gene model and from the and transformed into the UCSC Genome Browser database. </span></p><p class="c4"><span class="c0">other sources are used to populate the relevant attributes, Our schema mapping makes several loose approximations of </span></p><p class="c4"><span class="c0">this effectively gives rise to constraint violations when the scientific reality which serve to maximize the portion of the </span></p><p class="c4"><span class="c0">UCSC gene model disagrees with RefSeq on the number of genome browser schema that we populate, but which also in- </span></p><p class="c4"><span class="c0">exons, and when RefSeq and EntrezGene collectively list troduce some inconsistency to the data. It is for this reason </span></p><p class="c4"><span class="c0">more than one gene symbol. These two circumstances are that we say our schema mapping merely mimicks the true </span></p><p class="c4"><span class="c0">expected to arise a small fraction of the time. The relevant UCSC Genome Browser data import process, even though </span></p><p class="c4"><span class="c0">parts of the schema mapping are depicted in Figure 2. our target schema is faithful to the real database. </span></p><p class="c4"><span class="c0">The knownIsoforms relation groups transcripts into clus- The RefSeq and EntrezGene databases are not avail- </span></p><p class="c4"><span class="c0">ters, where each cluster represents a gene. The Genome able for download in a flat relational format. The RefSeq </span></p><p class="c4"><span class="c0">Browser computes this relation based on genomic coordi- database is offered in a text file format, within which the </span></p><p class="c4"><span class="c0">nates [14]. Our schema mapping populates the knownIso- data are arranged in a nested fashion with transcripts as the </span></p><p class="c4"><span class="c0">forms relation using a naive simplification of this approach: top-level elements. Every transcript has associated source </span></p><p class="c4"><span class="c0">transcripts that share either an Entrez Gene ID or a gene and reference information (documenting how and by whom </span></p><p class="c4"><span class="c0">symbol are made to reside in the same cluster. These two </span></p><p class="c4"><span class="c16">237 </span></p><p class="c4"><span class="c25">Acc </span></p><p class="c4"><span class="c25">ExonCount ...</span><span class="c122">ComputedAlignments </span><span class="c25">exonCount ... </span></p><p class="c4"><span class="c25">knownGene </span></p><p class="c4"><span class="c25">name (A) </span></p><p class="c4"><span class="c25">exonCount ... </span></p><p class="c4"><span class="c25">(B) </span></p><p class="c4"><span class="c25">Gene </span></p><p class="c4"><span class="c25">Symbol ...</span><span class="c122">GenBankToEntrez </span><span class="c25">Symbol ... </span></p><p class="c4"><span class="c25">kgXref </span></p><p class="c4"><span class="c25">kgID </span></p><p class="c4"><span class="c25">geneSymbol ... </span></p><p class="c4"><span class="c25">(C) </span></p><p class="c4"><span class="c25">refLink </span></p><p class="c4"><span class="c25">name ... </span></p><p class="c4"><span class="c25">knownToLocusLink </span><span class="c50">&#8883;&#8882; </span><span class="c25">knownIsoforms </span></p><p class="c4"><span class="c25">kgID </span></p><p class="c4"><span class="c25">entrez clusterId </span></p><p class="c4"><span class="c25">kgXref </span><span class="c50">&#8883;&#8882; </span><span class="c25">knownIsoforms </span></p><p class="c4"><span class="c25">kgID </span></p><p class="c4"><span class="c25">geneSymbol ... clusterId </span></p><p class="c15"><span class="c0">Figure 2: Critical parts of the schema mapping. Single ar- rows represent value propagation via tgds, and double ar- rows represent functional dependencies (egds). Keys (also egds) are underlined. (A) Competing values for the exon count. (B) Competing values for the gene symbol. (C) Clus- tering of transcripts according to Entrez Gene ID and gene symbol. The indicated egds give rise to equalities between nulls. </span></p><p class="c4"><span class="c0">approaches are incomparable. Ours relies on existing gene symbol annotations from Entrez and UniProt, as well as crossreference annotations on UCSC transcripts, all of which have different levels of rigor and completeness. The known- Isoforms table is thus included in our schema mapping pri- marily to exercise the interaction of existentially quanti- fied values with egds, which is a differentiating feature of weakly acyclic schema mappings versus other types of syn- tactic restrictions of glav</span><span class="c24">+</span><span class="c0">(glav, egd) schema mappings (e.g., gav</span><span class="c24">+</span><span class="c0">(gav, egd) or separable [6] schema mappings). This part of the schema mapping is depicted in Figure 2. </span><span class="c10">5.1 Benchmark Data and Queries </span></p><p class="c15"><span class="c0">We wish to test the scalability of our implementation rel- ative to two factors: the instance size and the proportion of the source tuples &ldquo;involved&rdquo; in egd violations (called &ldquo;sus- pect&rdquo; tuples), which we make precise with the notion of a source repair envelope defined in Section 6.2). To this end, we define a set of instances having specified sizes and ra- tios of suspect to total source tuples. In order to construct our test instances, we chase the unmodified source instances with the schema mapping and compute which source tuples are suspect. We call this the raw result. Then, each test in- stance is produced by selecting a randomized subset of the source instances with the desired size and ratio of suspect to total tuples in one particular table (ComputedCrossref), which we use as a rough proxy for the ratio for the entire source. Thus, for the largest size (&ldquo;full&rdquo;), the maximum ratio is the ratio found in the raw result (2.9%), and there is only one such instance. For the smaller instances, we are able to select enough suspect tuples to produce larger ratios. We use a randomized selection procedure to materialize a set of instances for each profile; six (at 3% suspect) for small and medium instances, three per ratio for large instances, and, necessarily, just one full instance (at 2.9% suspect). The characteristics of these instances are given in Table 2. </span></p><p class="c15"><span class="c0">Table 2: Test instances have sizes small (S), medium (M), large (L), and full (F), and 0, 3, 9, or 20 percent of their transcripts suspect. </span></p><p class="c4"><span class="c29">instance: L0 L3 L9 L20 source tuples 321k 322k 316k 301k total tuples 716k 724k 731k 748k suspect transcripts 0% 3% 9% 20% suspect tuples* 0% 2</span><span class="c17">.</span><span class="c29">0% 5</span><span class="c17">.</span><span class="c29">8% 13</span><span class="c17">.</span><span class="c29">4% instance: S3 M3 L3 F3 source tuples 3.5k 36k 322k 1,846k total tuples 7.9k 77k 724k 5,354k suspect transcripts 3% 3% 3% 2</span><span class="c17">.</span><span class="c29">9% suspect tuples* 1</span><span class="c17">.</span><span class="c29">8% 1</span><span class="c17">.</span><span class="c29">8% 2</span><span class="c17">.</span><span class="c29">0% 3</span><span class="c17">.</span><span class="c29">4% *includes source and target </span></p><p class="c4"><span class="c0">Table 3 lists our query suite. Queries labeled &ldquo;epN&rdquo; are adapted from the EQUIP query suite [16]: five of the 21 queries given there are applicable to our target schema. Ad- ditional queries labeled &ldquo;xrN&rdquo; are new queries created to exercise the critical parts of the schema mapping, including what is XR-Certain knowledge in the knownGene relation, and what pairs of transcripts reside in the same cluster in the knownIsoforms relation. In our experiments, we run the queries sequentially. </span><span class="c10">5.2 Monolithic Implementation and Results </span></p><p class="c15"><span class="c0">Using the reduction given in Theorem 2, we have imple- mented a monolithic approach to XR-Certain query answer- ing. Our monolithic implementation takes as input a glav</span><span class="c24">+ </span><span class="c0">(wa-glav, egd) schema mapping (encoded as text), an ar- bitrary source instance (via a JDBC connection string), and a union of conjunctive queries over the target schema (also text). The schema mapping is transformed into a gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema mapping using an optimized version of the re- duction in Theorem 1, and the query is transformed into a new union of conjunctive queries using the same reduction. These transformations take an average of 18.7 seconds com- bined, and the resulting schema mapping is approximately seven times larger than the original (from 33 tgds and 26 egds to 339 tgds and 67 egds). We generate a separate dis- junctive logic program for each query and instance, and run them using clingo 4.4.0, a solver from the Potsdam Answer Set Solving Collection[12] (Potassco). </span></p><p class="c15"><span class="c0">All experiments are run on an 8-core Intel Core i7-2720QM CPU @2.20GHz with 16GB RAM, running Ubuntu 14.04 LTS (Linux 3.13.0 SMP x86 64). The plots of Figure 3 de- pict the runtime for these programs versus the percentage of suspect tuples and versus the instance size, respectively, with a line for each query. The latter is a log-log plot, since each instance size is an order of magnitude larger than the last.</span><span class="c6">These results illustrate a significant problem with this </span><span class="c0">monolithic logic program approach: the cost of transform- ing the data from the source schema into the target schema is embedded in the execution cost of each individual query, which causes large instances to become unworkable even for simple queries. Additionally, the rapid increase in query runtimes as instance size increases, even for queries whose answers should be easy to compute, suggest that this imple- mentation fails to take advantage of some exploitable struc- ture in the instance and schema mapping. This is perhaps a symptom of the fact that the disjunctive logic program&rsquo;s rules are no simpler for areas of the source and target in- </span></p><p class="c4"><span class="c16">238 </span></p><p class="c4"><span class="c0">Table 3: Query Suite, with approximate answer counts for the large-size instances. </span></p><p class="c4"><span class="c29">Query Answers ep1() :- refLink(symbol, , acc, protacc, , , , ), kgXref(ucscid, , spid, , symbol, , , , , ) 1* ep2(protacc) :- refLink(symbol, , acc, protacc, , , , ), kgXref(ucscid, , spid, , symbol, , , , , ) 6,000 ep3(protacc,spid) :- refLink(symbol, , acc, protacc, , , , ), kgXref(ucscid, , spid, , symbol, , , , , ) 12,000 ep15(symbol) :- kgXref(ucscid, , , , symbol, refseq, , , , ), refLink( , product, refseq, , , , entrez, ) 1,500 ep16(symbol,entrez) :- kgXref(ucscid, , , , symbol, refseq, , , , ), refLink( , product, refseq, , , , entrez, ) 1,500 xr1() :- knownGene(kgid, ch, sd, txs, txe, cs, ce, exc, exs, exe, pac, alignid) 1* xr2(kgid) :- knownGene(kgid, ch, sd, txs, txe, cs, ce, exc, exs, exe, pac, alignid) 10,000 xr3(kgid, ch, sd, txs, txe, cs, ce, exc, exs, exe, pac, ai) :- knownGene(kgid, ch, sd, txs, txe, cs, ce, exc, exs, exe, pac, ai) 10,000** xr4() :- knownIsoforms(cluster, transcript1), knownIsoforms(cluster, transcript2) 1* xr5(transcript1) :- knownIsoforms(cluster, transcript1), knownIsoforms(cluster, transcript2) 10,000 xr6(transcript1, transcript2) :- knownIsoforms(cluster, transcript1), knownIsoforms(cluster, transcript2) 35,000 *boolean **projection-free </span></p><p class="c4"><span class="c18">Query Duration vs. Suspect Percentage, L0, L3, L9, L20 instances </span></p><p class="c4"><span class="c20">Query Duration vs. Instance Size, S3, M3, L3, F3 instances </span><span class="c62">6000 </span><span class="c18">ep15 </span><span class="c23">100000 </span><span class="c20">ep15 </span><span class="c36">ep16 </span><span class="c8">ep16 </span><span class="c62">5000 </span><span class="c36">ep1 ep2 </span><span class="c23">10000 </span><span class="c8">ep1 ep2 </span><span class="c36">ep3 </span><span class="c8">ep3 </span><span class="c62">4000 </span><span class="c36">xr1 xr2 </span><span class="c23">1000 </span><span class="c8">xr1 xr2 </span><span class="c62">s dnoce</span><span class="c18">s</span><span class="c62">3000 2000 1000 </span><span class="c18">0 0 2 4 6 8 10 12 14 </span></p><p class="c4"><span class="c36">xr3 xr4 xr5 </span><span class="c23">100 </span><span class="c36">xr6 </span></p><p class="c4"><span class="c23">10 1 </span><span class="c20">0.1 1000 10000 100000 1e+06 1e+07 </span></p><p class="c4"><span class="c8">xr3 xr4 xr5 xr6 </span></p><p class="c4"><span class="c18">percent suspect </span></p><p class="c4"><span class="c0">Figure 3: Performance of XR-Certain query answering using clingo. </span></p><p class="c15"><span class="c0">stances that are unaffected by egd violations than for those that are affected. In the following section, we will develop techniques to identify and exploit such structure by ground- ing the egds. </span></p><p class="c4"><span class="c10">6. ENHANCED APPROACH TO QUERY </span></p><p class="c4"><span class="c10">ANSWERING </span><span class="c0">Although the monolithic approach serves as a precise, straightforward specification of XR-Certain answers, it does not lend itself to fine-grained optimization. In this sec- tion, we present practical adaptations and optimizations to XR-Certain query answering that are motivated by our ex- perimentation with the monolithic implementation, and that draw on techniques described in the literature for query an- swering over inconsistent databases, specifically, the notion of repair envelopes introduced by Eiter et al. [10]. We split query answering into two phases. The first, the &ldquo;exchange phase&rdquo;, is a tractable-time query-independent preprocessing step, which enables the second, the &ldquo;query phase&rdquo;, in which XR-Certain answers to a particular query are computed by solving a collection of small disjunctive logic programs. Al- though the problem at hand is coNP-complete, this new segmentary approach allows us to answer queries by solving many small hard problems rather than one large one. At the end of this section, we evaluate an implementation based on this enhanced approach. </span><span class="c10">6.1 Candidate Answers </span></p><p class="c4"><span class="c0">The following definition of candidate answers effectively </span></p><p class="c4"><span class="c23">s dnoce</span><span class="c20">stotal source and target tuples </span></p><p class="c15"><span class="c0">provides an upper bound on the set of XR-Certain answers of a query, in the sense that the latter is always a subset of the former. </span></p><p class="c4"><span class="c0">Definition 2. Let M = (S,T,&Sigma;</span><span class="c1">st</span><span class="c0">,&Sigma;</span><span class="c1">t</span><span class="c0">) be a gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema mapping. </span></p><p class="c4"><span class="c0">1. We denote by M</span><span class="c11">tgd </span><span class="c0">the schema mapping (S,T,&Sigma;from &Sigma;</span><span class="c1">t</span><span class="c0">. </span><span class="c3">st</span><span class="c6">,&Sigma;</span><span class="c0">That </span><span class="c1">tgd </span><span class="c3">t </span><span class="c0">) is, where all egds &Sigma;are </span><span class="c11">tgd </span><span class="c1">t </span><span class="c14">consists of the tgds </span></p><p class="c4"><span class="c0">dropped. </span></p><p class="c15"><span class="c0">2. The canonical quasi-solution of a source instance I w.r.t. M is the canonical universal solution of I w.r.t. M</span><span class="c11">tgd</span><span class="c0">. </span></p><p class="c15"><span class="c0">3. For every UCQ q over T, the candidate answers to q w.r.t. I and M are q(J), where J is the canonical quasi-solution of I w.r.t. M. </span></p><p class="c15"><span class="c0">Proposition 1. Let M = (S, T,&Sigma;</span><span class="c1">st</span><span class="c0">,&Sigma;</span><span class="c1">t</span><span class="c0">) be a gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema mapping. Let I be an S-instance. Let J be the canonical quasi-solution of I w.r.t. M. </span></p><p class="c4"><span class="c0">1. For all canonical XR-Solutions (I ,J ) for I w.r.t. M, </span></p><p class="c4"><span class="c0">it holds that J &sube; J. </span></p><p class="c15"><span class="c0">2. For every UCQ q, we have that XR-Certain(q,I,M) &sube; q(J). That is, every XR-Certain answer is indeed a candidate answer. </span></p><p class="c15"><span class="c0">Proof. Let (I ,J ) be a canonical XR-Solution for I w.r.t. M. Since M is gav</span><span class="c24">+</span><span class="c0">(gav, egd) and J is the canoni- cal universal solution for I w.r.t. M, J is simply the closure </span></p><p class="c4"><span class="c16">239 </span></p><p class="c58"><span class="c0">of I w.r.t. the tgds of M. Therefore J is also the canoni- cal universal solution for I w.r.t. M</span><span class="c11">tgd</span><span class="c0">. Finally, since the chase procedure is monotone [11] and I &sube; I, we have that J &sube; J. </span></p><p class="c52"><span class="c0">The second item follows directly from the first, since UCQs are monotone queries. </span><span class="c10">6.2 Source Repair Envelopes </span></p><p class="c65"><span class="c0">It is often possible to exclude a large portion of the database from high-complexity computations. We will de- fine a notion similar to a repair envelope from [10] but suited to the setting of data exchange. </span></p><p class="c79 c108"><span class="c0">Definition 3. Let M be a glav</span><span class="c24">+</span><span class="c0">(wa-glav, egd) schema mapping and I a source instance. A subset E of I is a source repair envelope if (I \ I ) &sube; E for all source repairs I . </span></p><p class="c60"><span class="c0">We will now see that we can restrict our attention within a source repair envelope when computing source repairs. </span></p><p class="c108 c79"><span class="c0">Proposition 2. Let M be a glav</span><span class="c24">+</span><span class="c0">(wa-glav, egd) schema mapping, I a source instance, and E &sube; I a source repair envelope for I w.r.t. M. Then {I | I is a source repair of I w.r.t. M} = {E &cup;(I \ E) | E is a source repair of E w.r.t. M}. </span></p><p class="c79 c83"><span class="c0">Proof. Claim: I &cap; E is a source repair of E. Suppose for the sake of contradiction that I &cap; E is not a source repair of E. Then either I &cap;E has no solution (which cannot be the case due to monotonicity of the chase) or I &cap;E is strictly contained in a source repair E of E. But then E must be contained in a source repair I of I. However, the definition of a source repair envelope tells us that I contains all of E &cup; (I \ E). Hence it contains I , so I wasn&rsquo;t a source repair of I after all. </span></p><p class="c52"><span class="c0">Claim: if E is a source repair of E then E &cup; (I \ E) is a source repair of I. Indeed, E must be contained in a source repair of I, and by the definition of a source repair envelope, that source repair of I must contain all of (I \ E). Therefore it contains E &cup; (I \ E). However, it cannot be a strict superset of E &cup; (I \ E) because then E could be extended to a larger source repair of E. </span></p><p class="c45"><span class="c0">There are many ways to calculate a source repair enve- lope (e.g., I is a trivial source repair envelope). Consider the ideal source repair envelope, given by I &minus; </span><span class="c14">&#8898;</span><span class="c0">{I | I is a source repair for I w.r.t. M}. Equivalently, the ideal source repair envelope is the minimal source repair envelope for I w.r.t. M. The next result tells us that computing this envelope is hard. </span></p><p class="c77"><span class="c0">Theorem 3. Fix a schema mapping M. Let the intersec- tion of source repairs membership problem be the following decision problem: given a source instance I, and a fact f of I, is f contained in the intersection of all source repairs (that is, is f &isin; </span><span class="c14">&#8898;</span><span class="c0">{I | I is a source repair for I w.r.t. M})? There is a gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema mapping for which this problem is coNP-hard. </span></p><p class="c53"><span class="c0">Proof. The result is proven by reduction from the com- plement of 3-colorability. Let G = (V,E) be a graph, with edge set E = {e</span><span class="c1">1</span><span class="c0">,...,e</span><span class="c1">n</span><span class="c0">}. I</span><span class="c1">G </span><span class="c0">is the source instance, with active domain V &cup;{1,...,n}, containing, for each edge e</span><span class="c3">i </span><span class="c6">= (a, b) the fact E(a, b, i, i+1); for each vertex a &isin; V , the </span></p><p class="c4 c106"><span class="c0">facts C</span><span class="c1">r</span><span class="c0">(a),C</span><span class="c1">g</span><span class="c0">(a),C</span><span class="c3">b</span><span class="c6">(a); and one additional fact, namely </span><span class="c0">F(n,1). </span></p><p class="c7"><span class="c0">M is the schema mapping consisting of the source-to- target tgds </span></p><p class="c124"><span class="c0">&bull; E(x, y, u, v) &and; C</span><span class="c1">z</span><span class="c0">(x) &rarr; E (x, y) (for z &isin; {r, g, b}) </span></p><p class="c96"><span class="c0">&bull; E(x, y, u, v) &and; C</span><span class="c3">z</span><span class="c6">(x) &rarr; F (u, v) (for z &isin; {r, g, b}) </span></p><p class="c34"><span class="c0">&bull; P</span><span class="c3">z</span><span class="c6">(x) &rarr; P </span><span class="c3">z</span><span class="c0">(x) (for z &isin; {r, g, b}) </span></p><p class="c90"><span class="c0">&bull; F(u, v) &rarr; F (u, v) </span></p><p class="c111"><span class="c0">and target constraints </span></p><p class="c125"><span class="c0">&bull; E (x, y) &and; P </span><span class="c3">z</span><span class="c0">(x) &and; P </span><span class="c3">z</span><span class="c0">(y) &and; F (u, v) &rarr; u = v (for all z &isin; {r, g, b}) </span></p><p class="c127"><span class="c0">&bull; F (u, v) &and; F (v, w) &rarr; F (u, w) </span></p><p class="c22"><span class="c0">&bull; F (u, u) &and; F (v, w) &rarr; v = w </span></p><p class="c68 c129"><span class="c0">Note that I has no solutions with respect to M, regardless of whether G is 3-colorable. This is because a solution J of I has to contain a directed cycle of F -edges (of length n), and F must be transitive, which means that J would have to include facts of the form F (i, i), leading to an egd violation. Indeed, every source-repair of I must either (i) omit at least one of the E-facts, or (ii) omit all P</span><span class="c1">z</span><span class="c0">-facts (z &isin; {r, g, b}) for some vertex or (iii) omit the F(n,1) fact. It is then not hard to see that G is 3-colorable if and only if some source repair omits F(n,1). Note that, if G is 3-colorable, then there is a source repair that retains all E-facts and that retains at least one P</span><span class="c1">z</span><span class="c0">-fact for each vertex (z &isin; {r, g, b}). This source repair must then omit the F(n,1) fact. If, on the other hand, G is not 3-colorable, then every source repair has to satisfy (i) or (iii) and, consequently, will include F(n,1). </span></p><p class="c68 c103"><span class="c0">The hardness established in Theorem 3 shows that com- puting the ideal source repair envelope is not helpful, given that the purpose of a source repair envelope is to help reduce the need for high-complexity computations. Our next result pertains to a source repair envelope that can be computed in PTIME. </span></p><p class="c41"><span class="c0">First, we introduce the notion of support sets for a target fact. For an egd or GAV tgd &sigma; and an instance I, we denote by ground(&sigma;, J) the set of all groundings of &sigma; using values from the active domain of I (that is, quantifier-free formulas that can be obtained from &sigma; by replacing universally quan- tified variables by values from the active domain of I). Note that, if J is a canonical quasi-solution for a source instance I w.r.t. a gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema mapping, then the active domain of J is already included in the active domain of I. </span></p><p class="c39 c61"><span class="c0">Definition 4. Let M = (S,T,&Sigma;</span><span class="c1">st</span><span class="c0">,&Sigma;</span><span class="c1">t</span><span class="c0">) be a gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema mapping. Let I be an S-instance with canon- ical quasi-solution J, and let f &isin; J be a fact. </span></p><p class="c102"><span class="c0">&bull; A support set for f is a set of the form {f</span><span class="c3">1</span><span class="c6">,...,f</span><span class="c3">n</span><span class="c6">} </span><span class="c0">where (f</span><span class="c1">1 </span><span class="c0">&and;&middot;&middot;&middot;&and; f</span><span class="c1">n </span><span class="c0">&rarr; f) &isin; ground(&Sigma;</span><span class="c1">st </span><span class="c0">&cup; &Sigma;</span><span class="c1">t</span><span class="c0">,I), and (I,J) |= f</span><span class="c3">1 </span><span class="c6">&and;&middot;&middot;&middot;&and; f</span><span class="c3">n</span><span class="c6">. The set of all support sets of f </span><span class="c0">is denoted by support sets(f,I,M). </span></p><p class="c128"><span class="c0">&bull; The support closure for a set F of facts, denoted as support*(F,I,M), is the smallest set containing F such that whenever g &isin; support*(F,I,M), then all facts that belong to a support set of g belong to support*(F,I,M) as well. </span></p><p class="c44"><span class="c16">240 </span></p><p class="c58 c79"><span class="c0">Definition 5. Let M = (S,T,&Sigma;</span><span class="c1">st</span><span class="c0">,&Sigma;</span><span class="c1">t</span><span class="c0">) be a gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema mapping. Let J be the canonical quasi-solution of I. Let </span></p><p class="c15 c68"><span class="c0">as the smallest set containing E such that whenever g &isin; influence(E,I, M), every fact f that has a support set con- taining g also belongs to influence(E,I,M). </span></p><p class="c119"><span class="c0">violations(I,M) = </span></p><p class="c4 c13"><span class="c0">{</span><span class="c6">f </span></p><p class="c4 c27"><span class="c0">&#8739;</span><span class="c6">&#8739;&#8739;&#8739; </span><span class="c0">f </span><span class="c6">&sigma; &isin; </span><span class="c0">occurs </span><span class="c6">ground(&Sigma;</span><span class="c0">in the body of some </span><span class="c3">t</span><span class="c6">,I) with J |= &sigma; </span></p><p class="c4 c27"><span class="c0">&#8739;</span><span class="c6">&#8739;&#8739;&#8739; </span><span class="c0">f </span><span class="c6">&sigma; &isin; </span><span class="c0">occurs </span><span class="c6">ground(&Sigma;</span><span class="c0">in the body of some </span><span class="c3">t</span><span class="c6">,I) with J |= &sigma; </span></p><p class="c4 c70"><span class="c0">} </span></p><p class="c4 c70"><span class="c0">} </span></p><p class="c33"><span class="c0">We say that a source fact f &isin; I is suspect (w.r.t. M) if it belongs to support*(violations(I,M),I,M), and that it is safe otherwise. The set of suspect facts of I is denoted by I</span><span class="c1">suspect </span><span class="c0">and the set of safe facts of I is denoted by I</span><span class="c3">safe</span><span class="c6">. </span></p><p class="c15 c39"><span class="c0">Proposition 4. Let M be a gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema mapping and I a source instance. Let J be the canonical quasi-solution of I w.r.t. M. Let E be a source repair enve- lope for I w.r.t. M, and let F = influence(E,I,M). Then (E,F) is an exchange repair envelope for I w.r.t. M. </span></p><p class="c15 c39"><span class="c0">Proposition 4. Let M be a gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema mapping and I a source instance. Let J be the canonical quasi-solution of I w.r.t. M. Let E be a source repair enve- lope for I w.r.t. M, and let F = influence(E,I,M). Then (E,F) is an exchange repair envelope for I w.r.t. M. </span></p><p class="c15 c39"><span class="c0">Proposition 4. Let M be a gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema mapping and I a source instance. Let J be the canonical quasi-solution of I w.r.t. M. Let E be a source repair enve- lope for I w.r.t. M, and let F = influence(E,I,M). Then (E,F) is an exchange repair envelope for I w.r.t. M. </span></p><p class="c7"><span class="c0">In particular, (I</span><span class="c1">suspect</span><span class="c0">,J</span><span class="c1">suspect</span><span class="c0">) is an exchange repair en- velope for I, where J</span><span class="c3">suspect </span><span class="c6">= influence(I</span><span class="c3">suspect</span><span class="c6">,I, M). </span></p><p class="c75"><span class="c0">The violation set is, intuitively, the set of facts that are directly involved in an egd violation, while the violation clo- sure is, intuitively, the set of facts that are, possibly in- directly, involved in an egd violation. The notation I</span><span class="c3">safe </span><span class="c0">and I</span><span class="c3">suspect </span><span class="c6">assumes that it is clear from the context which </span><span class="c0">schema mapping is being referred to. </span></p><p class="c56"><span class="c0">Proposition 3. Let M be a gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema mapping and I a source instance. Then I</span><span class="c3">suspect </span><span class="c6">is a source </span><span class="c0">repair envelope for I (w.r.t. M). Moreover, I</span><span class="c1">suspect </span><span class="c0">can be computed in polynomial time (data complexity). </span></p><p class="c51"><span class="c0">To see that this proposition holds, suppose that some f &isin; I is omitted by a source repair I of I. Then I &cup;{f} has no solution. It follows that f must be in the violation closure of I w.r.t. M (with the steps of the chase of I &cup;{f} serving as proof of such). Therefore, f belongs to I</span><span class="c3">suspect</span><span class="c6">. </span></p><p class="c40"><span class="c0">The following example reminds us that I</span><span class="c3">suspect </span><span class="c6">is not nec- </span><span class="c0">essarily a minimal source repair envelope. </span></p><p class="c79 c120"><span class="c0">Example 1. Let I = {P(a, b),P(a, c),Q(b, c)}, and let M = ({P, Q},{P ,Q },{P(x, y) &rarr; P (x, y),Q(x, y) &rarr; Q (x, y)},{P (x, y)&and;P (x, y ) &rarr; y = y ,P (x, y)&and;P (x, y )&and; Q (y, y ) &rarr; y = y }). Then </span></p><p class="c55"><span class="c0">I</span><span class="c1">suspect </span><span class="c0">= {P(a, b),P(a, c),Q(b, c)} </span></p><p class="c43"><span class="c0">However, the key constraint on P forces every XR-Solution to have at most one of P(a, b),P(a, c), so the second egd in &Sigma;</span><span class="c3">t </span><span class="c6">is satisfied without eliminating Q(b, c). Indeed, the ideal </span><span class="c0">source repair envelope for I is {P(a, b),P(a, c)}. </span></p><p class="c51"><span class="c0">Nonetheless, I</span><span class="c1">suspect </span><span class="c0">is a potentially useful source repair envelope: we vary the proportion of facts in I</span><span class="c3">suspect </span><span class="c6">versus </span><span class="c0">I</span><span class="c3">safe </span><span class="c6">in our test instances in order to evaluate the importance </span><span class="c0">of this measure. </span></p><p class="c52"><span class="c0">We will now extend the notion of a source repair envelope to include target instances. </span></p><p class="c56"><span class="c0">Definition 6. Let M be a gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema map- ping, and I a source instance. Let J be the canonical quasi- solution of I. Two sets E &sube; I and F &sube; J of facts, to- gether comprise an exchange repair envelope (E,F) if, for all canonical XR-Solutions (I ,J ) of I w.r.t. M, we have that (I \ I ) &sube; E and (J \ J ) &sube; F. </span></p><p class="c51"><span class="c0">It follows from Theorem 3 that computing the minimal exchange repair envelope is hard. We will now see how to extend an existing source repair envelope to the target, in polynomial time. </span></p><p class="c56"><span class="c0">Definition 7. Let M = (S,T,&Sigma;</span><span class="c3">st</span><span class="c6">,&Sigma;</span><span class="c3">t</span><span class="c6">) be a gav</span><span class="c5">+</span><span class="c6">(gav, </span><span class="c0">egd) schema mapping, and I be an S-instance. Let J be the canonical quasi-solution of I w.r.t. M. Define the in- fluence of a set of facts E &sube; I, denoted influence(E,I,M), </span></p><p class="c15 c39"><span class="c0">Proof. Let (I ,J ) be a canonical XR-Solution for I w.r.t. M. Let t be a fact in J \ J . Since t is not in (I ,J ), there must be some fact f in support*({t},I,M) in I \ I . Therefore, f is contained in the source repair envelope E, so by definition we have that t &isin; influence(E,I,M). </span></p><p class="c82"><span class="c0">Fact 1. The following two statements hold, where F is an arbitrary set of target facts: </span></p><p class="c87"><span class="c0">&bull; The influence of the source restriction of the support closure of F contains the support closure of F; and </span></p><p class="c91"><span class="c0">&bull; A support closure of F and its influence are equal over their source restrictions. </span></p><p class="c37"><span class="c0">In light of the above, we can refer to violation influ- ences instead of violation closures whenever we wish to work with exchange repair envelopes rather than source repair en- velopes. It is important to notice that a fact may have one support set which places it in a violation influence, but also another support set whose facts are not contained in any vi- olation influence. Such facts lie in the difference between the violation influence and the ideal exchange repair envelope, but are nonetheless easy to identify. </span><span class="c10">6.3 Violation Clusters </span></p><p class="c35"><span class="c0">Violation clusters are a concept that will help us fur- ther reduce the combinatorial complexity of computing XR-Certain answers. We start with a motivating example. </span></p><p class="c39 c66"><span class="c0">Example 2. Let I = {P</span><span class="c1">1</span><span class="c0">(a, b),P</span><span class="c1">1</span><span class="c0">(a, c),P</span><span class="c1">2</span><span class="c0">(a, b),P</span><span class="c1">2</span><span class="c0">(a, c), ...,P</span><span class="c3">n</span><span class="c6">(a, b),P</span><span class="c3">n</span><span class="c6">(a, c)}, and let </span></p><p class="c54"><span class="c0">M = ({P</span><span class="c3">1</span><span class="c6">,...,P</span><span class="c3">n</span><span class="c6">},{Q</span><span class="c3">1</span><span class="c6">,...,Q</span><span class="c3">n</span><span class="c6">}, </span></p><p class="c130"><span class="c0">{P</span><span class="c3">1</span><span class="c6">(x, y) &rarr; Q</span><span class="c3">1</span><span class="c6">(x, y),...P</span><span class="c3">n</span><span class="c6">(x, y) &rarr; Q</span><span class="c3">n</span><span class="c6">(x, y)}, </span><span class="c0">{Q</span><span class="c1">1</span><span class="c0">(x, y) &and; Q</span><span class="c1">1</span><span class="c0">(x, y ) &rarr; y = y ,..., </span></p><p class="c30"><span class="c0">Q</span><span class="c3">n</span><span class="c6">(x, y) &and; Q</span><span class="c3">n</span><span class="c6">(x, y ) &rarr; y = y }) </span></p><p class="c68 c85"><span class="c0">There are 2</span><span class="c11">n </span><span class="c0">source repairs, which can be built by choosing one source atom from each of the n relations, in every pos- sible combination. In this sense, the set of source repairs for this example is highly structured. </span></p><p class="c41"><span class="c0">Now consider the query q(x):- Q</span><span class="c3">1</span><span class="c6">(x, y). Every source re- </span><span class="c0">pair of I w.r.t. M contains either P</span><span class="c1">1</span><span class="c0">(a, b) or P</span><span class="c1">1</span><span class="c0">(a, c), so we can conclude that q(a) &isin; XR-Certain(q,I,M) by consider- ing just the two possibilities for the the P</span><span class="c1">1 </span><span class="c0">relation. In so doing, we ignore the other n &minus; 1 relations and avoid having to consider 2</span><span class="c11">n </span><span class="c0">source repairs. </span></p><p class="c68 c116"><span class="c0">In this section, we will generalize the above observation and demonstrate that it can be used to reduce the size of instances and schema mappings for which we must explore </span></p><p class="c44"><span class="c16">241 </span></p><p class="c58"><span class="c0">all source repairs. To do so, we introduce a notion of inde- pendence that captures when particular egd violations are sufficiently isolated from each other to be processed sepa- rately. </span></p><p class="c75"><span class="c0">To simplify the presentation, it will be convenient to con- sider schema mappings M = (S,T,&Sigma;</span><span class="c1">st</span><span class="c0">,&Sigma;</span><span class="c1">t</span><span class="c0">) in which &Sigma;</span><span class="c1">t </span><span class="c0">may contain grounded egds (where universally quantified vari- ables have been replaced by constants). This will allow us to more easily describe how an instance is carved up into segments that can be processed independently. Intuitively, each grounding of an egd describes one potential violation of that egd. The notions of solutions, universal solutions, source repairs, and exchange repair solutions all apply with- out modification to schema mappings containing grounded egds.</span><span class="c6">As a slight abuse of notation, when D is a set of target </span><span class="c0">constraints, we will write M&cup;D to denote the schema map- ping obtained by adding the constraints in D to the target constraint set of a schema mapping M. </span></p><p class="c99 c79"><span class="c0">Definition 8. Let M = (S,T,&Sigma;</span><span class="c3">st</span><span class="c6">,&Sigma;</span><span class="c3">t</span><span class="c6">) be a gav</span><span class="c5">+</span><span class="c6">(gav, </span><span class="c0">egd) schema mapping. Let I be an S-instance. Let J be the canonical quasi-solution for I w.r.t. M. Let &sigma;</span><span class="c3">1</span><span class="c6">,&sigma;</span><span class="c3">2 </span><span class="c6">&isin; </span><span class="c0">ground(&Sigma;</span><span class="c3">t</span><span class="c6">,I) be distinct grounded egds with J |= &sigma;</span><span class="c3">1 </span><span class="c6">and </span><span class="c0">J |= &sigma;</span><span class="c1">2</span><span class="c0">. Let E</span><span class="c1">1 </span><span class="c0">be the ideal source repair envelope for I w.r.t (M</span><span class="c11">tgd </span><span class="c0">&cup; {&sigma;</span><span class="c3">1</span><span class="c6">}), and let E</span><span class="c3">2 </span><span class="c6">be the ideal source repair </span><span class="c0">envelope for I w.r.t (M</span><span class="c11">tgd </span><span class="c0">&cup; {&sigma;</span><span class="c1">2</span><span class="c0">}). We say &sigma;</span><span class="c1">1 </span><span class="c0">and &sigma;</span><span class="c1">2 </span><span class="c0">are pairwise-independent if source repairs(I,M</span><span class="c11">tgd </span><span class="c0">&cup;{&sigma;</span><span class="c3">1</span><span class="c6">,&sigma;</span><span class="c3">2</span><span class="c6">}) = </span><span class="c0">{(I \ (E</span><span class="c3">1 </span><span class="c6">&cup; E</span><span class="c3">2</span><span class="c6">)) &cup; E </span><span class="c3">1 </span><span class="c0">&cup; E </span><span class="c3">2 </span><span class="c0">| E </span><span class="c3">1 </span><span class="c0">&isin; source repairs(I &cap; E</span><span class="c1">1</span><span class="c0">,M</span><span class="c11">tgd </span><span class="c0">&cup; {&sigma;</span><span class="c1">1</span><span class="c0">}) and E </span><span class="c3">2 </span><span class="c0">&isin; source repairs(I &cap; E</span><span class="c1">2</span><span class="c0">,M</span><span class="c11">tgd </span><span class="c0">&cup; {&sigma;</span><span class="c3">2</span><span class="c6">})}. We say &sigma;</span><span class="c3">1 </span><span class="c6">and &sigma;</span><span class="c3">2 </span><span class="c6">are pairwise-dependent if they are </span><span class="c0">not pairwise-independent. </span></p><p class="c75"><span class="c0">Consider the graph of all egd violations in the quasi- solution and connect each pair of pairwise dependent egd violations by an edge. Each connected component of this graph is called a violation cluster. If &sigma;</span><span class="c3">1 </span><span class="c6">and &sigma;</span><span class="c3">n </span><span class="c6">reside in </span><span class="c0">distinct violation clusters then we say &sigma;</span><span class="c1">1 </span><span class="c0">and &sigma;</span><span class="c1">n </span><span class="c0">are inde- pendent. </span></p><p class="c99 c126"><span class="c0">If a pair of violations is independent, by definition, their XR-Solutions can be processed separately, then suitably re- combined. Note that the above definition of violation clus- ters does not provide us with a way to compute them ef- ficiently, because the definition involves ideal source repair envelopes. The following proposition provides an approxi- mation. </span></p><p class="c79 c99"><span class="c0">Proposition 5. Let M = (S,T,&Sigma;</span><span class="c1">st</span><span class="c0">,&Sigma;</span><span class="c1">t</span><span class="c0">) be a gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema mapping. Let I be an S-instance. Let J be the canonical quasi-solution I w.r.t. M. Let &sigma;</span><span class="c1">1</span><span class="c0">,&sigma;</span><span class="c1">2 </span><span class="c0">be distinct grounded egds in ground(&Sigma;</span><span class="c3">t</span><span class="c6">,I) such that J |= &sigma;</span><span class="c3">1 </span><span class="c6">and J |= </span><span class="c0">&sigma;</span><span class="c1">2</span><span class="c0">. Let E</span><span class="c1">1</span><span class="c0">,E</span><span class="c1">2 </span><span class="c0">be ideal source repair envelopes for I w.r.t. M&cup;&sigma;</span><span class="c3">1 </span><span class="c6">and M&cup;&sigma;</span><span class="c3">2</span><span class="c6">, respectively. If E</span><span class="c3">1 </span><span class="c6">and E</span><span class="c3">2 </span><span class="c6">are disjoint, </span><span class="c0">then &sigma;</span><span class="c3">1 </span><span class="c6">and &sigma;</span><span class="c3">2 </span><span class="c6">are pairwise-independent. </span></p><p class="c79 c113"><span class="c0">Proof. Suppose E</span><span class="c3">1 </span><span class="c6">&cap;E</span><span class="c3">2 </span><span class="c6">= &empty;, and let (I ,J ) be a canon- </span><span class="c0">ical XR-Solution for I w.r.t. M&cup;{&sigma;</span><span class="c1">1</span><span class="c0">,&sigma;</span><span class="c1">2</span><span class="c0">}. Let E </span><span class="c3">1 </span><span class="c0">= E</span><span class="c1">1 </span><span class="c0">&cap;I and let E </span><span class="c3">2 </span><span class="c0">= E</span><span class="c3">2 </span><span class="c6">&cap; I . By definition of a source repair enve- </span><span class="c0">lope, (I\E</span><span class="c3">1</span><span class="c6">)&cup;E </span><span class="c3">1 </span><span class="c0">is an XR-Solution for I w.r.t. M&cup;{&sigma;</span><span class="c3">1</span><span class="c6">}, and </span><span class="c0">likewise (I\E</span><span class="c1">2</span><span class="c0">)&cup;E </span><span class="c3">2 </span><span class="c0">is an XR-Solution for I w.r.t. M&cup;{&sigma;</span><span class="c1">2</span><span class="c0">}, and since E</span><span class="c3">1 </span><span class="c6">and E</span><span class="c3">2 </span><span class="c6">are disjoint, it is easy to see that E </span><span class="c3">1 </span><span class="c6">is an XR-Solution for E</span><span class="c3">1 </span><span class="c6">w.r.t. M&cup;{&sigma;</span><span class="c3">1</span><span class="c6">,&sigma;</span><span class="c3">2</span><span class="c6">} and E </span><span class="c3">2 </span><span class="c0">is an XR-Solution for E</span><span class="c3">2 </span><span class="c6">w.r.t. M&cup;{&sigma;</span><span class="c3">1</span><span class="c6">,&sigma;</span><span class="c3">2</span><span class="c6">}. Finally, since gav </span><span class="c0">chase is monotone, we have that (I \ E</span><span class="c3">1 </span><span class="c6">\ E</span><span class="c3">2</span><span class="c6">) &cup; (E </span><span class="c3">1</span><span class="c0">) &cup; (E </span><span class="c3">2</span><span class="c0">) </span></p><p class="c15 c68"><span class="c0">has a solution w.r.t. M&cup;{&sigma;</span><span class="c1">1</span><span class="c0">,&sigma;</span><span class="c1">2</span><span class="c0">}, and there is no instance I &sub; I which strictly contains (I \ E</span><span class="c3">1 </span><span class="c6">\ E</span><span class="c3">2</span><span class="c6">) &cup; (E </span><span class="c3">1</span><span class="c0">) &cup; (E </span><span class="c3">2</span><span class="c0">) and also has a solution w.r.t. M&cup;{&sigma;</span><span class="c3">1</span><span class="c6">,&sigma;</span><span class="c3">2</span><span class="c6">}. </span></p><p class="c57"><span class="c0">We can, in polynomial time, compute the support closure for each egd violation, then compute an overapproximation of the violation clusters based on the restriction to the source schema of those closures. The next proposition follows sim- ply from the definition of a support closure, but provides some intuition and gives a shortcut for computing a source repair envelope for a violation cluster. </span></p><p class="c81 c39"><span class="c0">Proposition 6. Let M = (S, T,&Sigma;</span><span class="c3">st</span><span class="c6">,&Sigma;</span><span class="c3">t</span><span class="c6">) be a gav</span><span class="c5">+</span><span class="c6">(gav, </span><span class="c0">egd) schema mapping. Let I be an S-instance. Let J be the canonical quasi-solution for I w.r.t. M. Let &sigma;</span><span class="c3">1</span><span class="c6">,...,&sigma;</span><span class="c3">n </span><span class="c6">be </span><span class="c0">a violation cluster (so each &sigma;</span><span class="c3">i </span><span class="c6">is a ground egd where J |= </span><span class="c0">&sigma;</span><span class="c1">i</span><span class="c0">), with support closures E</span><span class="c1">1</span><span class="c0">,...,E</span><span class="c1">n</span><span class="c0">. Then E</span><span class="c1">1 </span><span class="c0">&cup; ... &cup; E</span><span class="c1">n </span><span class="c0">is the support closure of the facts in &sigma;</span><span class="c3">1</span><span class="c6">,...,&sigma;</span><span class="c3">n</span><span class="c6">, and its S- </span><span class="c0">restriction is a source repair envelope for I w.r.t. M</span><span class="c11">tgd </span><span class="c0">&cup; {&sigma;</span><span class="c3">1</span><span class="c6">,...,&sigma;</span><span class="c3">n</span><span class="c6">} </span></p><p class="c57"><span class="c0">We have now seen how to compute a conservative ap- proximation of the violation clusters for an instance w.r.t. a given schema mapping. Proposition 6 makes clear the fact that distinct violation clusters have disjoint source repair en- velopes, and are therefore pairwise-independent themselves. Definition 8 tells us that we can thus compute the source repairs for an entire instance by computing separately the source repairs for the envelope of each violation cluster. We will now see how this supports query answering. </span></p><p class="c19"><span class="c10">6.4 Answering Queries </span></p><p class="c35"><span class="c0">We now show how to use the techniques introduced in the previous sections to compute XR-Certain answers for unions of conjunctive queries. In fact, without loss of generality, we can restrict attention to projection-free atomic queries: Let q(x):- &phi;</span><span class="c3">1</span><span class="c6">(x,y) &or; ... &or; &phi;</span><span class="c3">n</span><span class="c6">(x,y) be a union of conjunctive </span><span class="c0">queries with n clauses. Define t</span><span class="c1">1</span><span class="c0">,...,t</span><span class="c1">n </span><span class="c0">to be a set of new gav tgds, where the head of each tgd is the head of q, and the body of each tgd t</span><span class="c3">k </span><span class="c6">is &phi;</span><span class="c3">k</span><span class="c6">(x,y). If we extend a canonical </span><span class="c0">quasi-solution J with the new relation symbol q, and chase with t</span><span class="c3">1</span><span class="c6">,...,t</span><span class="c3">n</span><span class="c6">, the result will be J &cup;{q(J)}. We will use the </span><span class="c0">notation XR-Certain(I,M&cup;{t</span><span class="c1">1</span><span class="c0">,...,t</span><span class="c1">n</span><span class="c0">}) to denote the set of facts in the intersection of all exchange repair solutions for I w.r.t. M&cup;{t</span><span class="c1">1</span><span class="c0">,...,t</span><span class="c1">n</span><span class="c0">}, and the term candidate facts to refer to the tuples of any relation in T &cup; q. </span></p><p class="c41"><span class="c0">Consider the definition of support sets in Section 6.2, and suppose f is a candidate fact. By definition, f is XR-Certain if it is contained in every exchange repair solution. Since ex- change repair solutions satisfy the constraints of the schema mapping, it is easy to see that f is XR-Certain if it has at least one support set in every XR-Solution, or equivalently, in every canonical XR-Solution. </span></p><p class="c41"><span class="c0">Proposition 6 naturally extends to exchange repair en- velopes. Thus we define a violation cluster influence to refer to the union of the influences of the violations in a cluster. </span></p><p class="c39 c81"><span class="c0">Example 3. This example illustrates that a can- didate fact f may belong to the influences of multiple distinct violation clusters. Let I = {P(a</span><span class="c1">1</span><span class="c0">,a</span><span class="c1">2</span><span class="c0">),P(a</span><span class="c1">1</span><span class="c0">,a</span><span class="c1">3</span><span class="c0">),Q(a</span><span class="c1">1</span><span class="c0">,a</span><span class="c1">2</span><span class="c0">),Q(a</span><span class="c1">1</span><span class="c0">,a</span><span class="c1">3</span><span class="c0">)}, and let M = ({P, Q},{R, S, T},{P(x, y) &rarr; R(x, y),Q(x, y) &rarr; S(x, y)},{R(x, y)&and;S(x, z) &rarr; T(x, y, z),R(x, y)&and;R(x, y ) &rarr; </span></p><p class="c44"><span class="c16">242 </span></p><p class="c4"><span class="c0">y = y ,S(x, y),S(x, y ) &rarr; y = y }). Then the violation cluster influence for {R(a</span><span class="c3">1</span><span class="c6">,a</span><span class="c3">2</span><span class="c6">),R(a</span><span class="c3">1</span><span class="c6">,a</span><span class="c3">3</span><span class="c6">)} is </span><span class="c0">{</span><span class="c6">P(a</span><span class="c3">1</span><span class="c6">,a</span><span class="c3">2</span><span class="c6">),P(a</span><span class="c3">1</span><span class="c6">,a</span><span class="c3">3</span><span class="c6">),R(a</span><span class="c3">1</span><span class="c6">,a</span><span class="c3">2</span><span class="c6">),R(a</span><span class="c3">1</span><span class="c6">,a</span><span class="c3">3</span><span class="c6">), </span></p><p class="c4"><span class="c0">T(a</span><span class="c1">1</span><span class="c0">,a</span><span class="c1">2</span><span class="c0">,a</span><span class="c1">3</span><span class="c0">),T(a</span><span class="c1">1</span><span class="c0">,a</span><span class="c1">3</span><span class="c0">,a</span><span class="c1">2</span><span class="c0">),T(a</span><span class="c1">1</span><span class="c0">,a</span><span class="c1">2</span><span class="c0">,a</span><span class="c1">2</span><span class="c0">),T(a</span><span class="c1">1</span><span class="c0">,a</span><span class="c1">3</span><span class="c0">,a</span><span class="c1">3</span><span class="c0">)</span><span class="c14">} </span></p><p class="c4"><span class="c0">and the violation cluster influence for S(a</span><span class="c3">1</span><span class="c6">,a</span><span class="c3">2</span><span class="c6">),S(a</span><span class="c3">1</span><span class="c6">,a</span><span class="c3">3</span><span class="c6">) is </span></p><p class="c4"><span class="c0">{</span><span class="c6">Q(a</span><span class="c3">1</span><span class="c6">,a</span><span class="c3">2</span><span class="c6">),Q(a</span><span class="c3">1</span><span class="c6">,a</span><span class="c3">3</span><span class="c6">),S(a</span><span class="c3">1</span><span class="c6">,a</span><span class="c3">2</span><span class="c6">),S(a</span><span class="c3">1</span><span class="c6">,a</span><span class="c3">3</span><span class="c6">), </span></p><p class="c4"><span class="c0">T(a</span><span class="c3">1</span><span class="c6">,a</span><span class="c3">2</span><span class="c6">,a</span><span class="c3">3</span><span class="c6">),T(a</span><span class="c3">1</span><span class="c6">,a</span><span class="c3">3</span><span class="c6">,a</span><span class="c3">2</span><span class="c6">),T(a</span><span class="c3">1</span><span class="c6">,a</span><span class="c3">2</span><span class="c6">,a</span><span class="c3">2</span><span class="c6">),T(a</span><span class="c3">1</span><span class="c6">,a</span><span class="c3">3</span><span class="c6">,a</span><span class="c3">3</span><span class="c6">)</span><span class="c0">} which are disjoint in their restriction to the source schema, yet both contain the target facts T(a</span><span class="c3">1</span><span class="c6">,a</span><span class="c3">2</span><span class="c6">,a</span><span class="c3">3</span><span class="c6">), T(a</span><span class="c3">1</span><span class="c6">,a</span><span class="c3">3</span><span class="c6">,a</span><span class="c3">2</span><span class="c6">), </span><span class="c0">T(a</span><span class="c1">1</span><span class="c0">,a</span><span class="c1">2</span><span class="c0">,a</span><span class="c1">2</span><span class="c0">), and T(a</span><span class="c1">1</span><span class="c0">,a</span><span class="c1">3</span><span class="c0">,a</span><span class="c1">3</span><span class="c0">). </span></p><p class="c26"><span class="c0">This example illustrates how distinct target violations with non-overlapping source repair envelopes may jointly af- fect target tuples; we cannot determine the status of tuples in T without considering violations of both key constraints. Suppose f is a candidate fact in T. Each support set for f may be contained in only certain combinations of XR-Solutions from the violation cluster influences contain- ing f. So, to determine if f has at least one support set in every XR-Solution w.r.t. the broader schema mapping, it is necessary to consider all combinations of XR-Solutions from the violation cluster influences containing f. We call the set of violation clusters whose influences contain f the signature of f, denoted signature(f). Recall that I</span><span class="c3">safe </span><span class="c6">denotes the set </span><span class="c0">of source facts that are safe, that is, not suspect (Defini- tion 5). In the following, let J</span><span class="c3">safe </span><span class="c6">denote chase(I</span><span class="c3">safe</span><span class="c6">,M). </span></p><p class="c15"><span class="c0">Theorem 4. Let M = (S,T,&Sigma;</span><span class="c3">st</span><span class="c6">,&Sigma;</span><span class="c3">t</span><span class="c6">) be a gav</span><span class="c5">+</span><span class="c6">(gav, </span><span class="c0">egd) schema mapping. Let I be an S-instance. Let J be the canonical quasi-solution for I w.r.t. M. Let f be a candidate fact in J. Let I</span><span class="c3">f-focus </span><span class="c6">and J</span><span class="c3">f-focus </span><span class="c6">be, respec- </span><span class="c0">tively, the source and target parts of </span><span class="c14">&#8899;</span><span class="c0">{V | V the influ- ence for a violation cluster in signature(f)}. Then f &isin; XR-Certain(I,M) &harr; f &isin; </span><span class="c14">&#8898;</span><span class="c0">{chase(J </span><span class="c3">f-focus </span><span class="c0">&cup; J</span><span class="c1">safe</span><span class="c0">,&Sigma;</span><span class="c1">t</span><span class="c0">) | J </span><span class="c3">f-focus </span><span class="c0">&isin; XR-Solution(I</span><span class="c3">f-focus</span><span class="c6">,M)}. </span></p><p class="c15"><span class="c0">Proof Sketch. By definition, the violations in the clusters in signature(f) are contained in J</span><span class="c3">f-focus</span><span class="c6">. Thus </span><span class="c0">(I</span><span class="c3">f-focus</span><span class="c6">,J</span><span class="c3">f-focus</span><span class="c6">) is an exchange repair envelope for I w.r.t. </span><span class="c0">M</span><span class="c11">tgd </span><span class="c0">augmented with those violations. Furthermore, all of the violations in J</span><span class="c3">f-focus </span><span class="c6">are pairwise independent of all </span><span class="c0">of the violations in J \ J</span><span class="c3">f-focus</span><span class="c6">, from which we conclude </span><span class="c0">that every fact in every support set for f is contained in (I</span><span class="c3">f-focus</span><span class="c6">,J</span><span class="c3">f-focus</span><span class="c6">) or in (I</span><span class="c3">safe</span><span class="c6">,J</span><span class="c3">safe</span><span class="c6">). </span></p><p class="c15"><span class="c0">This result gives us the following algorithm for computing XR-Certain for an instance I and schema mapping M, using a (hopefully large) J</span><span class="c3">safe </span><span class="c6">combined with, for each signature, </span><span class="c0">a (hopefully small) J</span><span class="c1">focus</span><span class="c0">. For the exchange phase: Chase I with M</span><span class="c11">tgd</span><span class="c0">, compute the violation set of I w.r.t. M, and compute the support closure of each violation. Then mark source facts safe if they do not reside in any violation closure, chase I</span><span class="c3">safe </span><span class="c6">with M</span><span class="c1">tgd</span><span class="c6">, and mark every resulting fact safe. </span><span class="c0">Lastly, compute violation clusters, and the influence of each cluster. For the query phase: Compute the candidate facts, marking safe those with support sets in J</span><span class="c3">safe</span><span class="c6">. Next, com- </span><span class="c0">pute the signature of each unmarked candidate fact. Finally, generate and solve a grounded disjunctive logic program to compute XR-Certain w.r.t. M for (I</span><span class="c3">focus</span><span class="c6">,J</span><span class="c3">focus</span><span class="c6">) for each </span><span class="c0">signature. This program is the restriction to (I</span><span class="c3">focus</span><span class="c6">,J</span><span class="c3">focus</span><span class="c6">) </span><span class="c0">of the grounding of the program from Theorem 2. Facts in (I</span><span class="c3">focus</span><span class="c6">,J</span><span class="c3">focus</span><span class="c6">)&cap;(I</span><span class="c3">safe</span><span class="c6">,J</span><span class="c3">safe</span><span class="c6">) may be represented by the value </span><span class="c0">true in the program. </span></p><p class="c4"><span class="c10">6.5 Segmentary Implementation and Results </span></p><p class="c15"><span class="c0">Using the techniques developed in this section, we have implemented a segmentary approach to XR-Certain query answering using Java 1.7.0 80, MySQL 5.5.42, and clingo 4.4.0. Our segmentary implementation takes as input a glav</span><span class="c24">+</span><span class="c0">(wa-glav, egd) schema mapping (encoded as text), an arbitrary source instance (via a JDBC connection string), and a union of conjunctive queries over the target schema (also text). As with the monolithic implementation, the schema mapping is transformed into a gav</span><span class="c24">+</span><span class="c0">(gav, egd) schema mapping. Additionally, the query is transformed into an atomic query using the reduction described at the beginning of Section 6.4. </span></p><p class="c15"><span class="c0">Using the above algorithm, query answering is done in two phases: the exchange phase, and the query phase. The exchange phase materializes the target instance in MySQL using a chase procedure written in Java. The detailed im- plementation of the chase procedure is immaterial: here, we use a semi-na &#776;&#305;ve chase. The exchange phase next computes violation cluster influences, fact signatures, and the &ldquo;safe&rdquo; part of the source and target instances (also in MySQL, run from Java). The query phase appends candidate answers to the target instance, marks &ldquo;safe&rdquo; candidates, and generated disjunctive logic programs as explained in Section 6.4, which are then solved using clingo. The results obtained from clingo are used to mark each candidate either &ldquo;accepted&rdquo; or &ldquo;rejected&rdquo;. The &ldquo;safe&rdquo; candidates and &ldquo;accepted&rdquo; candidates together comprise the XR-Certain query answers. </span></p><p class="c4"><span class="c0">Table 4: Duration of the exchange phase, in seconds. </span></p><p class="c4"><span class="c0">instance L0 L3 L9 L20 duration 150.7 196.7 235.7 297.3 instance S3 M3 L3 F3 duration 36.5 50.8 196.7 2229.7 </span></p><p class="c15"><span class="c0">Table 4 gives the runtime of the exchange phase for each instance. Notice that for large instances, the exchange phase compares very favorably against the per-query runtime of the monolithic approach described in Section 5.2. The plots in Figure 4 give the performance of each query as we scale the rate of violations and the instance size, respectively, with the latter on a log-log scale. These results improve consider- ably on the monolithic approach: the query phase runtimes are between ten times and one thousand times faster for large and full instances. </span></p><p class="c4"><span class="c10">7. CONCLUDING REMARKS </span></p><p class="c15"><span class="c0">We have implemented XR-Certain query answering and evaluated it on real data using a benchmark that mimicks the UCSC Genome Browser data import process. Our ex- periments suggest that using the reduction from XR-Certain to disjunctive logic programming to create a monolithic logic program is not a viable approach using today&rsquo;s best-of-breed solvers. However, by efficiently computing a suitable overap- proximation, our segmentary approach computes query an- swers ten to one thousand times faster for larger instances, and exhibits promising scalability with respect to both in- stance size and the rate of target constraint violations. </span></p><p class="c15"><span class="c0">We note that significant progress has recently been made toward broadly applicable, reproducible schema mapping benchmarks, in particular iBench [3]. We intend as fu- </span></p><p class="c4"><span class="c16">243 </span></p><p class="c4"><span class="c18">Query Duration vs. Suspect Percentage, L0, L3, L9, L20 instances </span></p><p class="c4"><span class="c20">Query Duration vs. Instance Size, S3, M3, L3, F3 instances </span><span class="c62">30 </span><span class="c18">ep15 </span><span class="c23">100 </span><span class="c20">ep15 </span><span class="c36">ep16 </span><span class="c8">ep16 </span><span class="c62">25 </span><span class="c36">ep1 ep2 </span><span class="c8">ep1 ep2 </span><span class="c62">20 </span><span class="c36">ep3 xr1 </span><span class="c23">10 </span><span class="c8">ep3 xr1 </span><span class="c36">xr2 </span><span class="c8">xr2 </span><span class="c62">s dnoce</span><span class="c18">s</span><span class="c36">xr3 xr4 xr5 </span><span class="c23">1 </span><span class="c36">xr6 </span></p><p class="c4"><span class="c23">0.1 </span><span class="c20">0.01 1000 10000 100000 1e+06 1e+07 </span><span class="c8">xr3 xr4 </span><span class="c62">15 </span><span class="c8">xr5 xr6 </span></p><p class="c73"><span class="c62">10 5 </span><span class="c18">0 0 2 4 6 8 10 12 14 percent suspect </span></p><p class="c4"><span class="c0">Figure 4: Performance of XR-Certain query answering using MySQL along with clingo. </span></p><p class="c15"><span class="c0">ture work to further evaluate our segmentary implementa- tion on such benchmarks. Nonetheless, our success with our Genome Browser benchmark serves as evidence that XR-Certain query answering may be efficiently computable in practice for realistic applications. </span></p><p class="c4"><span class="c10">8. ACKNOWLEDGMENTS </span></p><p class="c15"><span class="c0">The research of all authors was partially supported by NSF Grant IIS-1217869. Kolaitis&rsquo; research was also sup- ported by the project &ldquo;Handling Uncertainty in Data Inten- sive Applications&rdquo; under the program THALES. </span></p><p class="c4"><span class="c10">9. REFERENCES </span></p><p class="c4"><span class="c0">[1] M. Arenas, P. Barcel&oacute;, L. Libkin, and F. Murlak. </span></p><p class="c4"><span class="c0">Relational and XML Data Exchange. Synthesis Lectures on Data Management. Morgan &amp; Claypool Publishers, 2010. [2] M. Arenas, L. E. Bertossi, and J. Chomicki. </span></p><p class="c4"><span class="c0">Consistent query answers in inconsistent databases. In V. Vianu and C. H. Papadimitriou, editors, PODS, pages 68&ndash;79. ACM Press, 1999. [3] P. C. Arocena, B. Glavic, R. Ciucanu, and R. J. </span></p><p class="c4"><span class="c0">Miller. The iBench integration metadata generator. PVLDB, 9(3):108&ndash;119, 2015. [4] L. E. Bertossi. Database Repairing and Consistent Query Answering. Synthesis Lectures on Data Management. Morgan &amp; Claypool Publishers, 2011. [5] M. Bienvenu and M. Ortiz. Ontology-mediated query </span></p><p class="c4"><span class="c0">answering with data-tractable description logics. In Reasoning Web. Web Logic Rules - 11th Int. Summer School, pages 218&ndash;307, 2015. [6] A. Cal`&#305;, M. Console, and R. Frosini. Deep separability of ontological constraints. CoRR, abs/1312.5914, 2013. [7] A. Cal`&#305;, D. Lembo, and R. Rosati. On the decidability </span></p><p class="c26"><span class="c0">and complexity of query answering over inconsistent and incomplete databases. In F. Neven, C. Beeri, and T. Milo, editors, PODS, pages 260&ndash;271. ACM, 2003. [8] B. ten Cate, R. L. Halpert, and P. G. Kolaitis. </span></p><p class="c26"><span class="c0">Exchange-repairs: Managing inconsistency in data exchange. In RR, volume 8741 of Lecture Notes in Computer Science, pages 140&ndash;156. Springer, 2014. [9] B. ten Cate, R. L. Halpert, and P. G. Kolaitis. </span></p><p class="c4"><span class="c0">Exchange-repairs: Managing inconsistency in data </span></p><p class="c4"><span class="c23">s dnoce</span><span class="c20">stotal source and target tuples </span></p><p class="c4"><span class="c0">exchange, September 2015. arXiv </span><span class="c24">http://arxiv.org/abs/1509.06390</span><span class="c0">, 29 pages; to appear in the Journal of Data Semantics. [10] T. Eiter, M. Fink, G. Greco, and D. Lembo. Repair </span></p><p class="c26"><span class="c0">localization for query answering from inconsistent databases. ACM Trans. Database Syst., 33(2), 2008. [11] R. Fagin, P. G. Kolaitis, R. J. Miller, and L. Popa. </span></p><p class="c4"><span class="c0">Data exchange: semantics and query answering. Theor. Comput. Sci., 336(1):89&ndash;124, 2005. [12] M. Gebser, R. Kaminski, B. Kaufmann, M. Ostrowski, T. Schaub, and M. Schneider. Potassco: The Potsdam answer set solving collection. AI Communications, 24(2):107&ndash;124, 2011. [13] M. Gelfond and V. Lifschitz. The stable model </span></p><p class="c4"><span class="c0">semantics for logic programming. In R. A. Kowalski and K. A. Bowen, editors, ICLP/SLP, pages 1070&ndash;1080. MIT Press, 1988. [14] F. Hsu, W. J. Kent, H. Clawson, R. M. Kuhn, </span></p><p class="c73"><span class="c0">M. Diekhans, and D. Haussler. The UCSC known genes. Bioinformatics, 22(9):1036&ndash;1046, 2006. [15] T. Janhunen and E. Oikarinen. Capturing parallel </span></p><p class="c4"><span class="c0">circumscription with disjunctive logic programs. In J. J. Alferes and J. A. Leite, editors, JELIA, volume 3229 of Lecture Notes in Computer Science, pages 134&ndash;146. Springer, 2004. [16] P. G. Kolaitis, E. Pema, and W.-C. Tan. Efficient </span></p><p class="c4"><span class="c0">querying of inconsistent databases with binary integer programming. PVLDB, 6(6):397&ndash;408, 2013. [17] D. Lembo, M. Lenzerini, and R. Rosati. Source </span></p><p class="c4"><span class="c0">inconsistency and incompleteness in data integration. In KRDB, 2002. [18] M. C. Marileo and L. E. Bertossi. The consistency </span></p><p class="c4"><span class="c0">extractor system: Answer set programs for consistent query answering in databases. Data Knowl. Eng., 69(6):545&ndash;572, 2010. [19] National Center for Biotechnology Information. NCBI </span></p><p class="c4"><span class="c0">ToolBox, 2001. </span><span class="c24">http://www.ncbi.nlm.nih.gov/IEB/ToolBox/</span><span class="c0">. [20] National Center for Biotechnology Information. Entrez </span></p><p class="c4"><span class="c0">Programming Utilities, 2013. </span><span class="c24">http://www.ncbi.nlm.nih.gov/books/NBK25501/</span><span class="c0">. </span></p><p class="c4"><span class="c16">244 </span></p></body></html>