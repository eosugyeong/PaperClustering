<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c57{margin-left:-9.2pt;padding-top:12.2pt;text-indent:19pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.1pt}.c65{margin-left:-18.2pt;padding-top:11.3pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.4pt}.c34{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Times New Roman";font-style:normal}.c50{margin-left:-9.2pt;padding-top:1.7pt;text-indent:27.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-11.8pt}.c9{color:#231f20;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10pt;font-family:"Arial";font-style:italic}.c51{color:#231f20;font-weight:400;text-decoration:none;vertical-align:super;font-size:10pt;font-family:"Arial";font-style:italic}.c79{margin-left:-13.7pt;padding-top:1.4pt;text-indent:28.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-2pt}.c55{margin-left:-13.7pt;padding-top:1.7pt;text-indent:27.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-6.8pt}.c29{color:#231f20;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c67{color:#231f20;font-weight:400;text-decoration:none;vertical-align:sub;font-size:19.9pt;font-family:"Arial";font-style:normal}.c21{margin-left:-9.2pt;padding-top:1.4pt;text-indent:18.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.1pt}.c19{color:#231f20;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.3pt;font-family:"Arial";font-style:italic}.c82{margin-left:-18.2pt;padding-top:11.3pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-7pt}.c17{color:#231f20;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Arial";font-style:normal}.c12{color:#231f20;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Courier New";font-style:normal}.c75{margin-left:-9.2pt;padding-top:1.7pt;text-indent:27.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-13.2pt}.c78{color:#231f20;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Times New Roman";font-style:italic}.c10{margin-left:-18.2pt;padding-top:1.7pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-5.8pt}.c81{margin-left:-9.2pt;padding-top:7.7pt;text-indent:18.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-15.8pt}.c1{color:#231f20;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c41{color:#231f20;font-weight:700;text-decoration:none;vertical-align:sub;font-size:19.9pt;font-family:"Times New Roman";font-style:normal}.c8{color:#231f20;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Times New Roman";font-style:normal}.c49{margin-left:-18.2pt;padding-top:3.8pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-7pt}.c46{margin-left:-18.2pt;padding-top:1.4pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-7pt}.c31{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c48{margin-left:-18.2pt;padding-top:10.3pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-7pt}.c0{color:#231f20;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Arial";font-style:italic}.c24{margin-left:-14.4pt;padding-top:0.5pt;text-indent:25.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:38.8pt}.c58{margin-left:-18.2pt;padding-top:4.1pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-7pt}.c84{color:#231f20;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Arial";font-style:italic}.c7{color:#231f20;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Arial";font-style:italic}.c14{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c20{color:#231f20;font-weight:400;text-decoration:none;vertical-align:super;font-size:10pt;font-family:"Arial";font-style:normal}.c4{color:#231f20;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Arial";font-style:italic}.c76{color:#231f20;font-weight:400;text-decoration:none;vertical-align:sub;font-size:16.6pt;font-family:"Arial";font-style:normal}.c35{color:#231f20;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Arial";font-style:normal}.c11{color:#231f20;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Arial";font-style:normal}.c3{color:#231f20;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Times New Roman";font-style:normal}.c33{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Times New Roman";font-style:normal}.c83{color:#231f20;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Times New Roman";font-style:normal}.c61{color:#231f20;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Times New Roman";font-style:normal}.c59{color:#231f20;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:17.9pt;font-family:"Arial";font-style:normal}.c2{color:#231f20;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10pt;font-family:"Arial";font-style:normal}.c53{color:#231f20;font-weight:700;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Times New Roman";font-style:normal}.c39{color:#231f20;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Times New Roman";font-style:italic}.c23{margin-left:-18.2pt;padding-top:44.2pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-7pt}.c5{color:#231f20;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Times New Roman";font-style:normal}.c70{margin-left:-18.2pt;padding-top:12.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:131pt}.c73{margin-left:-18.2pt;padding-top:9.1pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-7pt}.c56{margin-left:-18.2pt;padding-top:4.1pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-7pt}.c60{margin-left:-13.7pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:8.8pt}.c97{margin-left:-6.3pt;padding-top:10.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:17pt}.c44{margin-left:-9.2pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:7pt}.c43{margin-left:-14.2pt;padding-top:0.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:40.5pt}.c37{margin-left:227.3pt;padding-top:213.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-26.7pt}.c72{margin-left:-18.2pt;padding-top:8.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:42.4pt}.c74{margin-left:227.3pt;padding-top:34.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-26.7pt}.c52{margin-left:-9.2pt;padding-top:6.7pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-16.1pt}.c66{margin-left:-15.4pt;padding-top:9.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:74.3pt}.c28{margin-left:-13.4pt;padding-top:4.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-3.9pt}.c22{margin-left:-6.1pt;padding-top:8.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-12.7pt}.c45{margin-left:-9.2pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-15.8pt}.c94{margin-left:-9.2pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-11.5pt}.c36{margin-left:-13.4pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-5.6pt}.c77{margin-left:-18.2pt;padding-top:4.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:87pt}.c47{margin-left:227.3pt;padding-top:31.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-26.7pt}.c80{margin-left:-18.2pt;padding-top:12pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:0.4pt}.c68{margin-left:-9.2pt;padding-top:151.9pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-15.8pt}.c32{margin-left:-13.4pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:3pt}.c54{margin-left:9.5pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:11.5pt}.c62{margin-left:-13.7pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:4.5pt}.c85{margin-left:-18.2pt;padding-top:25pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-6.8pt}.c15{margin-left:4.3pt;padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-6.8pt}.c13{margin-left:0.5pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:19.6pt}.c86{margin-left:-14.2pt;padding-top:0.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-6.8pt}.c38{margin-left:-13.7pt;padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:9.8pt}.c99{padding-top:11pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c96{padding-top:6.2pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c18{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c63{padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c16{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c6{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c64{padding-top:1.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c98{padding-top:3.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c95{padding-top:9.1pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c88{padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c26{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c30{margin-left:-9.2pt;text-indent:18.1pt;margin-right:-16.1pt}.c69{margin-left:-9.2pt;text-indent:18.3pt;margin-right:-16.1pt}.c42{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c90{margin-left:-18.2pt;margin-right:156.2pt}.c92{margin-left:-18.2pt;margin-right:-7pt}.c25{margin-left:-18.2pt;margin-right:153.8pt}.c27{margin-left:-152.5pt;margin-right:313.9pt}.c93{margin-left:-9.2pt;margin-right:-15.8pt}.c89{margin-left:-189.9pt;margin-right:370.1pt}.c91{margin-left:-9.2pt;margin-right:-8.2pt}.c40{margin-left:-192.6pt;margin-right:309.8pt}.c87{margin-left:-9.2pt;margin-right:-16.1pt}.c71{margin-left:-4.6pt;margin-right:23.5pt}.c100{text-indent:27.4pt}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:24pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:14pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c42"><p class="c6"><span class="c59">TEDI: Efficient Shortest Path Query Answering on Graphs </span></p><p class="c6"><span class="c29">Fang Wei </span><span class="c76">Computer Science Department University of Freiburg </span><span class="c67">fwei@informatik.uni-freiburg.de </span><span class="c76">Freiburg, Germany </span><span class="c1">ABSTRACT </span><span class="c5">Efficient shortest path query answering in large graphs is enjoying a growing number of applications, such as ranked keyword search in databases, social networks, ontology rea- soning and bioinformatics. A shortest path query on a graph finds the shortest path for the given source and target ver- tices in the graph. </span></p><p class="c18"><span class="c5">Current techniques for efficient evaluation of such queries are based on the pre-computation of compressed Breadth First Search trees of the graph. However, they suffer from drawbacks of scalability. To address these problems, we pro- pose TEDI, an indexing and query processing scheme for the shortest path query answering. TEDI is based on the tree decomposition methodology. The graph is first decomposed into a tree in which the node (a.k.a. bag) contains more than one vertex from the graph. The shortest paths are stored in such bags and these local paths together with the tree are the components of the index of the graph. Based on this index, a bottom-up operation can be executed to find the shortest path for any given source and target vertices. </span></p><p class="c18"><span class="c5">Our experimental results show that TEDI offers orders- of-magnitude performance improvement over existing ap- proaches on the index construction time, the index size and the query answering. </span></p><p class="c6"><span class="c1">Categories and Subject Descriptors </span><span class="c5">H.3.3 [</span><span class="c8">Information Search and Retrieval</span><span class="c5">]: Search pro- cess; H.3.1 [</span><span class="c8">Content Analysis and Indexing</span><span class="c5">]: Indexing methods </span></p><p class="c6"><span class="c1">General Terms </span><span class="c5">Algorithms, Design </span></p><p class="c6"><span class="c1">Keywords </span><span class="c5">graphs, indexing, shortest path, tree decomposition </span></p><p class="c6"><span class="c61">Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. </span><span class="c78">SIGMOD&rsquo;10, </span><span class="c61">June 6&ndash;11, 2010, Indianapolis, Indiana, USA. Copyright 2010 ACM 978-1-4503-0032-2/10/06 ...$10.00. </span></p><p class="c6"><span class="c1">1. INTRODUCTION </span></p><p class="c18"><span class="c5">Querying and manipulating large scale graph-like data have attracted much attention in the database community, due to the wide application areas of graph data, such as ranked keyword search, XML databases, bioinformatics, so- cial network, and ontologies. The shortest path query an- swering in a graph is among the fundamental operations on the graph data. </span></p><p class="c18"><span class="c5">In a ranked keyword search scenario over structured data, people usually give scores by measuring the link distance between two connected elements. If more than one path ex- ists, it is desirable to retrieve the shortest distance between them, because shorter distance normally means higher rank of the connected elements [19, 20, 12]. In a social network application such like Facebook </span><span class="c20">1</span><span class="c5">, registered users can be considered as vertices and edges represent the friend rela- tionship between them. Normally two users are connected through different paths with various lengths. The problem of retrieving the shortest path among the users efficiently is of great importance. </span></p><p class="c18"><span class="c5">Let </span><span class="c0">G </span><span class="c5">= (</span><span class="c0">V,E</span><span class="c5">) be an undirected graph where </span><span class="c0">n </span><span class="c5">= </span><span class="c0">|V |</span><span class="c5">. Given </span><span class="c0">u, v &isin; V </span><span class="c5">, the shortest path problem finds a shortest path from </span><span class="c0">u </span><span class="c5">to </span><span class="c0">v </span><span class="c5">with respect to the length of paths from </span><span class="c0">u </span><span class="c5">to </span><span class="c0">v</span><span class="c5">. One obvious solution for the shortest path problem is to execute the Breadth First Search (BFS) on the graph. The time complexity of the BFS method is </span><span class="c0">O</span><span class="c5">(</span><span class="c0">n</span><span class="c5">). If the graph is of large size, the efficiency of query answering is expected to be improved. </span></p><p class="c18"><span class="c5">The query answering can be performed in constant time, if the BFS tree for each vertex of the graph is pre-computed. However, the space overhead is </span><span class="c0">n</span><span class="c20">2</span><span class="c5">. This is obviously not affordable if </span><span class="c0">n </span><span class="c5">is of large value. Therefore, appropriate in- dexing and query scheme for answering shortest path queries must find the best trade-off between these two extreme meth- ods.</span><span class="c3">Xiao et al.[23] proposed the concept of </span><span class="c7">compact BFS-trees </span><span class="c5">where the BFS-trees are compressed by exploiting the sym- metry property of the graphs. It is shown that the space cost for the compact BFS trees is reduced in comparison to the normal BFS trees. Moreover, shortest path query answer- ing is more efficient than the classic BFS-based algorithm. However, this approach suffers from scalability. Although the index size of the compact BFS-trees can be reduced by 40% or more (depending on the symmetric property of the graph), the space requirement is still prohibitively high. For instance, for a graph with 20 K vertices, the compact BFS- tree has the size of 744 MB, and the index construction takes </span></p><p class="c6"><span class="c11">1</span><span class="c17">http://www.facebook.com </span></p><p class="c6"><span class="c34">99 </span></p><p class="c6"><span class="c5">performance more than 30 minutes. Therefore, this approach can not be </span></p><p class="c6"><span class="c5">improvement over existing algorithms. More- applied for graphs with larger size which contain hundreds </span></p><p class="c6"><span class="c5">over, we conduct the experiments over large graphs such as of thousands of vertices. </span></p><p class="c6"><span class="c5">DBLP and road networks. The encouraging results show </span><span class="c1">1.1 Our Contributions </span></p><p class="c6"><span class="c5">that TEDI scales well on large datasets. </span></p><p class="c6"><span class="c5">The rest of the paper is organized as follows: in Section 2 To overcome these difficulties, we propose </span><span class="c8">TEDI (TreE </span></p><p class="c6"><span class="c5">we introduce the formal definitions of the tree decomposition </span><span class="c8">Decomposition based Indexing)</span><span class="c5">, an indexing and query </span></p><p class="c6"><span class="c5">and prove the theoretical results regarding to the shortest processing scheme for the shortest path query answering. </span></p><p class="c6"><span class="c5">path query answering. Section 3 contains the detailed algo- Briefly stated, we first </span><span class="c0">decompose </span><span class="c5">the graph </span><span class="c0">G </span><span class="c5">into a tree </span></p><p class="c6"><span class="c5">rithms and the complexity analysis. In Section 4 we present in which each node contains a set of vertices in </span><span class="c0">G</span><span class="c5">. These </span></p><p class="c6"><span class="c5">the experimental results. We survey related works in Section tree nodes are called </span><span class="c0">bags</span><span class="c5">. Different from other partitioning </span></p><p class="c6"><span class="c5">5 and conclude in Section 6. based methods, there are overlapping among the bags, i.e., for any vertex </span><span class="c0">v </span><span class="c5">in </span><span class="c0">G</span><span class="c5">, there can be more than one bag in the tree which contains </span><span class="c0">v</span><span class="c5">. However, it is required that all these related bags constitute a connected subtree (see Definition </span></p><p class="c6"><span class="c1">2. GRAPH INDEXING WITH TREE </span></p><p class="c6"><span class="c1">DECOMPOSITION </span></p><p class="c6"><span class="c5">1 for the formal definition). </span></p><p class="c18"><span class="c5">Based on the decomposed tree, we can execute the short- est path search in a bottom-up manner and the query time is decided by the height and the bag cardinality of the tree, instead of the size of the graph. If both of these two param- eters are small enough, the query time can be substantially improved. Of course, in order to compute the shortest paths along the tree, we have to pre-compute the </span><span class="c0">local </span><span class="c5">shortest paths among the vertices in every bag of the tree. This con- stitutes the major part of the index structure of the TEDI </span></p><p class="c6"><span class="c1">2.1 Tree Decomposition </span></p><p class="c16"><span class="c5">An undirected graph is defined as </span><span class="c0">G </span><span class="c5">= (</span><span class="c0">V,E</span><span class="c5">), where </span><span class="c0">V </span><span class="c5">= </span><span class="c0">{</span><span class="c5">0</span><span class="c0">, </span><span class="c5">1</span><span class="c0">,...,n &minus;</span><span class="c5">1</span><span class="c0">} </span><span class="c5">is the vertex set and </span><span class="c0">E &sube; V &times;V </span><span class="c5">is the edge set. Let </span><span class="c0">n </span><span class="c5">= </span><span class="c0">|V | </span><span class="c5">be the number of vertices and </span><span class="c0">m </span><span class="c5">= </span><span class="c0">|E| </span><span class="c5">be the number of edges. In this paper, we consider only undi- rected graphs, where </span><span class="c0">&forall;u, v &isin; V </span><span class="c5">: (</span><span class="c0">u, v</span><span class="c5">) </span><span class="c0">&isin; E &hArr; </span><span class="c5">(</span><span class="c0">v, u</span><span class="c5">) </span><span class="c0">&isin; E </span><span class="c5">holds. Moreover, we assume that the edges are not labeled. In the rest of the paper, we will use the term </span><span class="c0">graph </span><span class="c5">to denote </span><span class="c0">undirected graph</span><span class="c5">. scheme. Our main contributions are the following: </span></p><p class="c6"><span class="c5">Definition 1 (Tree Decomposition). </span><span class="c0">A tree decom- </span></p><p class="c6"><span class="c0">&bull; </span><span class="c8">Solid theoretical background. </span><span class="c5">TEDI is based on the well-known concept of the tree decomposition, which is proved being of great importance in computational complexity theory. The abundant theoretical results provide a solid background for designing and correct- ness proofs of the TEDI algorithms. </span></p><p class="c18"><span class="c0">position of G </span><span class="c5">= (</span><span class="c0">V,E</span><span class="c5">)</span><span class="c0">, denoted as T</span><span class="c9">G</span><span class="c7">, is a pair </span><span class="c3">(</span><span class="c7">{X</span><span class="c9">i </span><span class="c7">| i &isin; </span><span class="c0">I},T</span><span class="c5">)</span><span class="c0">, where {X</span><span class="c4">i </span><span class="c0">| i &isin; I} is a collection of subsets of V and T </span><span class="c5">= </span><span class="c0">1. </span><span class="c5">(</span><span class="c0">I,F</span><span class="c5">) </span><span class="c12">J</span><span class="c4">i&isin;I </span><span class="c84">X</span><span class="c51">i </span><span class="c0">is a tree </span><span class="c83">= </span><span class="c84">V . </span></p><p class="c6"><span class="c0">such that: </span></p><p class="c6"><span class="c0">2. for every </span><span class="c5">(</span><span class="c0">u, v</span><span class="c5">) </span><span class="c0">&isin; E, there is i &isin; I, s.t. u, v &isin; X</span><span class="c4">i</span><span class="c0">. </span></p><p class="c6"><span class="c0">&bull; </span><span class="c8">Linear time tree decomposition algorithm. </span><span class="c5">In spite of the theoretical importance of the tree de- </span></p><p class="c6"><span class="c0">3. for all v &isin; V , the set {i | v &isin; X</span><span class="c9">i</span><span class="c7">} induces a subtree of </span></p><p class="c6"><span class="c0">T. </span></p><p class="c6"><span class="c5">composition concept, many results are practically use- </span></p><p class="c6"><span class="c5">A tree decomposition consists of a set of tree nodes, where less due to the fact that finding a tree decomposition with optimal treewidth is an NP-hard problem, w.r.t. </span></p><p class="c16"><span class="c5">each node contains a set of vertices in </span><span class="c0">V </span><span class="c5">. We call the sets </span><span class="c0">X</span><span class="c9">i </span><span class="c0">bags</span><span class="c5">. It is required that every vertex in </span><span class="c0">V </span><span class="c5">should occur in the size of the graph. To overcome this difficulty, we </span></p><p class="c6"><span class="c5">at least one bag (condition 1), and for every edge in </span><span class="c0">E</span><span class="c5">, both propose in TEDI the simple heuristics to achieve a lin- </span></p><p class="c6"><span class="c5">vertices of the edge should occur together in at least one ear time tree decomposition algorithm. To the best of </span></p><p class="c6"><span class="c5">bag (condition 2). The third condition is usually referred to our knowledge, TEDI is the first scheme that applies </span></p><p class="c6"><span class="c5">as the </span><span class="c0">connectedness condition</span><span class="c5">, which requires that given a the tree decomposition heuristics dealing with graphs </span></p><p class="c6"><span class="c5">vertex </span><span class="c0">v </span><span class="c5">in the graph, all the bags which contain </span><span class="c0">v </span><span class="c5">should of large size, and based on that, enables efficient query </span></p><p class="c6"><span class="c5">be connected. answering algorithms to be developed. </span></p><p class="c6"><span class="c5">Note that from now on, the node in the graph </span><span class="c0">G </span><span class="c5">is re- </span></p><p class="c18"><span class="c0">&bull; </span><span class="c8">Flexibility of balancing the time and space ef- ficiency. </span><span class="c5">From the proposed tree decomposition algo- rithm, we discover an important correlation between the query time and the index size. If less space for the index is available, we can reduce the index size by increasing some parameter </span><span class="c0">k </span><span class="c5">during the tree decompo- sition process, while the price to pay is longer query time. On the other hand, if the space is less critical, and the query time is more important, we can decrease </span><span class="c0">k </span><span class="c5">to achieve higher efficiency of the query answering. This flexibility offered by TEDI enables the users to </span></p><p class="c18"><span class="c5">ferred to as </span><span class="c0">vertex</span><span class="c5">, and the node in the tree decomposition is referred to as </span><span class="c0">tree node </span><span class="c5">or simply </span><span class="c0">node</span><span class="c5">. For each tree node </span><span class="c0">i</span><span class="c5">, there is a bag </span><span class="c0">X</span><span class="c4">i </span><span class="c5">consisting of vertices. To simplify the presentation, we will sometimes use the term </span><span class="c0">node </span><span class="c5">and its corresponding </span><span class="c0">bag </span><span class="c5">interchangeably. Given a tree decompo- sition </span><span class="c0">T</span><span class="c4">G</span><span class="c5">, we denote its root as </span><span class="c0">R</span><span class="c5">. </span></p><p class="c16"><span class="c5">Given any graph </span><span class="c0">G</span><span class="c5">, there may exist many tree decomposi- tions which fulfill all the conditions in Definition 1. However, we are interested in those tree decompositions with smaller bag sizes. We call the cardinality of a bag the </span><span class="c0">width </span><span class="c5">of the bag.choose the best time/space trade-off according to the </span></p><p class="c6"><span class="c3">Definition 2 (Width, Treewidth). </span><span class="c7">Let G </span><span class="c3">= (</span><span class="c7">V,E</span><span class="c3">) </span><span class="c5">system requirements. </span></p><p class="c6"><span class="c0">be a graph. </span></p><p class="c6"><span class="c5">Finally we conduct experiments on real and synthetic datasets, and compare the results with the compact BFS-tree ap- </span></p><p class="c6"><span class="c0">&bull; The </span><span class="c5">width </span><span class="c0">of a tree decomposition defined as max{|X</span><span class="c9">i</span><span class="c7">| | i &isin; I} </span><span class="c11">2</span><span class="c7">. </span></p><p class="c6"><span class="c5">(</span><span class="c0">{X</span><span class="c4">i </span><span class="c0">| i &isin; I},T</span><span class="c5">) </span><span class="c0">is </span></p><p class="c6"><span class="c5">proach. The experimental results confirm our theoretical analysis by demonstrating that TEDI offers orders-of-magnitude </span></p><p class="c6"><span class="c3">due </span><span class="c11">2</span><span class="c3">The to original technical definition reasons. of the width is </span><span class="c7">max{|X</span><span class="c9">i</span><span class="c7">| | i &isin; I}&minus;</span><span class="c3">1, </span><span class="c34">100 </span></p><p class="c6"><span class="c5">(</span><span class="c0">{</span><span class="c5">4</span><span class="c0">, &bull; The </span><span class="c5">treewidth </span><span class="c0">of G is the minimal width of all tree </span></p><p class="c6"><span class="c5">0</span><span class="c0">},{</span><span class="c5">3</span><span class="c0">, </span><span class="c5">0</span><span class="c0">}</span><span class="c5">), (</span><span class="c0">{</span><span class="c5">4</span><span class="c0">,</span><span class="c5">3</span><span class="c0">}, {</span><span class="c5">1</span><span class="c0">,</span><span class="c5">3</span><span class="c0">}</span><span class="c5">), (</span><span class="c0">{</span><span class="c5">4</span><span class="c0">, </span><span class="c5">0</span><span class="c0">}, {</span><span class="c5">5</span><span class="c0">,</span><span class="c5">0</span><span class="c0">}</span><span class="c5">), </span><span class="c0">...</span><span class="c5">. Note that </span><span class="c0">decompositions of G. It is denoted as tw</span><span class="c5">(</span><span class="c0">G</span><span class="c5">) </span><span class="c0">or simply </span></p><p class="c6"><span class="c5">it is possible that the same pair of vertices occurs in more </span><span class="c0">tw. </span></p><p class="c6"><span class="c5">than one bag. For instance, the edge (4</span><span class="c0">,</span><span class="c5">3) occurs in both </span></p><p class="c6"><span class="c5">Example 1. </span><span class="c0">Consider the graph illustrated in Figure 1(a). One of the tree decompositions is shown in Figure 1(b). The width of this tree decomposition is 3. It is not hard to check that this tree decomposition is optimal, thus the treewidth of the graph is 3. </span></p><p class="c6"><span class="c5">bags </span><span class="c0">X</span><span class="c2">0 </span><span class="c3">and </span><span class="c7">X</span><span class="c2">1</span><span class="c3">. Thus there are two inner edges: (</span><span class="c7">{</span><span class="c3">4</span><span class="c7">,</span><span class="c3">1</span><span class="c7">},{</span><span class="c3">3</span><span class="c7">, </span><span class="c3">1</span><span class="c7">}</span><span class="c3">) </span><span class="c5">and (</span><span class="c0">{</span><span class="c5">4</span><span class="c0">,</span><span class="c5">0</span><span class="c0">}, {</span><span class="c5">3</span><span class="c0">,</span><span class="c5">0</span><span class="c0">}</span><span class="c5">). </span></p><p class="c18"><span class="c5">In order to traverse from one bag to another in the tree decomposition, we need to define the second kind of edge, the </span><span class="c0">inter edge</span><span class="c5">. Note that two neighboring bags in the tree are in fact connected by the common vertices they share, according to the connectedness condition in Definition 1. </span></p><p class="c6"><span class="c5">Definition 4 (Inter edge). </span><span class="c0">Let G </span><span class="c5">= (</span><span class="c0">V,E</span><span class="c5">) </span><span class="c0">be a graph and T</span><span class="c4">G </span><span class="c5">= (</span><span class="c0">{X</span><span class="c4">i </span><span class="c0">| i &isin; I},T</span><span class="c5">) </span><span class="c0">a tree decomposition of G. Let v &isin; X</span><span class="c9">i </span><span class="c7">and v &isin; X</span><span class="c9">j</span><span class="c7">, where either </span><span class="c3">(</span><span class="c7">i, j</span><span class="c3">) </span><span class="c7">&isin; F or </span><span class="c3">(</span><span class="c7">j, i</span><span class="c3">) </span><span class="c7">&isin; F </span><span class="c0">holds. We call the edge from vertex {v, i} to {v, j} the </span><span class="c5">inter edge </span><span class="c0">and denote it as </span><span class="c5">(</span><span class="c0">{v, i}, {v, j}</span><span class="c5">)</span><span class="c0">. </span></p><p class="c6"><span class="c5">(a) (b) </span></p><p class="c16"><span class="c5">For instance, in Example 1, (</span><span class="c0">{</span><span class="c5">5</span><span class="c0">, </span><span class="c5">0</span><span class="c0">},{</span><span class="c5">5</span><span class="c0">,</span><span class="c5">2</span><span class="c0">}</span><span class="c5">) is an inter edge, as well as (</span><span class="c0">{</span><span class="c5">5</span><span class="c0">,</span><span class="c5">2</span><span class="c0">}, {</span><span class="c5">5</span><span class="c0">,</span><span class="c5">0</span><span class="c0">}</span><span class="c5">), because vertex 5 occurs in bags </span><span class="c0">X</span><span class="c2">0 </span><span class="c5">and </span><span class="c0">X</span><span class="c11">2</span><span class="c5">, where 0 is the parent node of 2. Now we are ready </span><span class="c8">Figure 1: The graph </span><span class="c0">G </span><span class="c8">(a) and one tree decomposi- </span></p><p class="c6"><span class="c5">to define the </span><span class="c0">tree path </span><span class="c5">on the tree decomposition with inner </span><span class="c8">tion </span><span class="c0">T</span><span class="c4">G </span><span class="c8">(b) with </span><span class="c0">tw </span><span class="c5">= 3 </span></p><p class="c6"><span class="c5">and inter edges. </span></p><p class="c18"><span class="c8">Induced subtree</span><span class="c5">. Let </span><span class="c0">G </span><span class="c5">= (</span><span class="c0">V,E</span><span class="c5">) be a graph and </span><span class="c0">T</span><span class="c4">G </span><span class="c5">= (</span><span class="c0">{X</span><span class="c9">i </span><span class="c7">| i &isin; I},T</span><span class="c3">) a tree decomposition of </span><span class="c7">G</span><span class="c3">. Due to the third </span><span class="c5">condition in Definition 1, for any vertex </span><span class="c0">v </span><span class="c5">in </span><span class="c0">V </span><span class="c5">there exists an induced subtree of </span><span class="c0">T</span><span class="c4">G </span><span class="c5">in which every bag contains </span><span class="c0">v</span><span class="c5">. We call it the </span><span class="c0">induced subtree </span><span class="c5">of </span><span class="c0">v </span><span class="c5">and denote it as </span><span class="c0">T</span><span class="c9">v</span><span class="c3">. Further- </span></p><p class="c6"><span class="c5">Definition 5 (Tree path). </span><span class="c0">Let G </span><span class="c5">= (</span><span class="c0">V,E</span><span class="c5">) </span><span class="c0">be a graph and T</span><span class="c4">G </span><span class="c5">= (</span><span class="c0">{X</span><span class="c4">i </span><span class="c0">| i &isin; I},T</span><span class="c5">) </span><span class="c0">a tree decomposition of G. Let u, v &isin; V . Let further {u, i} and {v, j} be tree vertices in T</span><span class="c4">G</span><span class="c0">. A </span><span class="c5">tree path </span><span class="c0">from {u, i} to {v, j} is a sequence of tree vertices connected with either inter or inner edges. </span><span class="c5">more, we denote the root of </span><span class="c0">T</span><span class="c4">v </span><span class="c5">as </span><span class="c0">r</span><span class="c4">v </span><span class="c5">and its corresponding bag of the as </span><span class="c0">X</span><span class="c5">induced </span><span class="c9">r</span><span class="c19">v</span><span class="c5">. For instance, </span><span class="c0">X</span><span class="c2">0</span><span class="c7">,X</span><span class="c2">1 </span><span class="c3">and </span><span class="c5">subtree of vertex 3 </span><span class="c7">X</span><span class="c2">2 </span><span class="c3">constitute the bags </span><span class="c5">in Figure 1(b), because vertex 3 occurs precisely in these three bags. Since </span><span class="c0">X</span><span class="c2">0 </span><span class="c3">is </span><span class="c5">the root of the induced subtree, we have </span><span class="c0">r</span><span class="c2">3 </span><span class="c3">= 0. </span><span class="c1">2.2 Tree Path </span></p><p class="c18"><span class="c5">Let </span><span class="c0">G </span><span class="c5">= (</span><span class="c0">V,E</span><span class="c5">) be a graph, and </span><span class="c0">u, v &isin; V </span><span class="c5">. </span><span class="c0">v </span><span class="c5">is reachable from vertex </span><span class="c0">u</span><span class="c5">, denoted as </span><span class="c0">u &rarr; v</span><span class="c5">, if there is a path start- ing from </span><span class="c0">u </span><span class="c5">and ending at </span><span class="c0">v </span><span class="c5">with the form </span><span class="c0">{u, v</span><span class="c2">1</span><span class="c7">,...,v</span><span class="c9">n</span><span class="c7">,v}</span><span class="c3">, </span><span class="c5">where (</span><span class="c0">u, v</span><span class="c11">1</span><span class="c5">), (</span><span class="c0">v</span><span class="c4">i</span><span class="c0">,v</span><span class="c4">i</span><span class="c11">+1</span><span class="c5">)</span><span class="c2">(1</span><span class="c9">&le;i&le;n&minus;</span><span class="c2">1)</span><span class="c3">, (</span><span class="c7">v</span><span class="c9">n</span><span class="c7">,v</span><span class="c3">) </span><span class="c7">&isin; E</span><span class="c3">. The shortest </span><span class="c5">distance from vertex </span><span class="c0">u </span><span class="c5">to vertex </span><span class="c0">v </span><span class="c5">is denoted as </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">u, v</span><span class="c5">). Note that in this paper, we consider only </span><span class="c0">simple paths</span><span class="c5">. Ob- viously, for undirected graphs, </span><span class="c0">u &rarr; v &hArr; v &rarr; u</span><span class="c5">. </span></p><p class="c18"><span class="c5">Lemma 1. </span><span class="c0">Let G </span><span class="c5">= (</span><span class="c0">V,E</span><span class="c5">) </span><span class="c0">be a graph and T</span><span class="c4">G </span><span class="c5">= (</span><span class="c0">{X</span><span class="c4">i </span><span class="c0">| i &isin; I},T</span><span class="c5">) </span><span class="c0">a tree decomposition of G. Let u, v &isin; V . Let further {u, i} and {v, j} be tree vertices in T</span><span class="c4">G</span><span class="c0">. There is a path from u to v in G if and only if there is a tree path from {u, i} to {v, j}. </span></p><p class="c18"><span class="c5">Proof. The &rdquo;if&rdquo; direction is trivial: given a tree path from </span><span class="c0">{u, i} </span><span class="c5">to </span><span class="c0">{v, j}</span><span class="c5">, we only need to consider the inner edges. Since for each inner edge </span><span class="c0">{u, i},{v, i}</span><span class="c5">, there is an edge (</span><span class="c0">u, v</span><span class="c5">) </span><span class="c0">&isin; E</span><span class="c5">, the path from </span><span class="c0">u </span><span class="c5">to </span><span class="c0">v </span><span class="c5">can be easily constructed. </span></p><p class="c18"><span class="c5">Now we prove the &rdquo;only if&rdquo; direction: assume that there is a path from </span><span class="c0">u </span><span class="c5">to </span><span class="c0">v </span><span class="c5">in </span><span class="c0">G</span><span class="c5">. We prove it by induction on the length of the path. </span></p><p class="c6"><span class="c5">Let us consider the graph vertices in the tree nodes. Since </span></p><p class="c6"><span class="c0">&bull; </span><span class="c5">Basis: if </span><span class="c0">u </span><span class="c5">reaches </span><span class="c0">v </span><span class="c5">with a path of length 1, that a vertex in </span><span class="c0">G </span><span class="c5">may occur in more than one bag of </span><span class="c0">T</span><span class="c4">G</span><span class="c5">, it is identified with </span><span class="c0">{v, i}</span><span class="c5">, where </span><span class="c0">v </span><span class="c5">is the vertex and </span><span class="c0">i </span><span class="c5">the node </span></p><p class="c16"><span class="c5">is, (</span><span class="c0">u, v</span><span class="c5">) </span><span class="c0">&isin; E</span><span class="c5">. Then there exists a node </span><span class="c0">k </span><span class="c5">in the tree decomposition, s.t. </span><span class="c0">u &isin; X</span><span class="c9">k </span><span class="c3">and </span><span class="c7">v &isin; X</span><span class="c9">k</span><span class="c3">. We start from </span><span class="c5">in the tree, meaning that vertex </span><span class="c0">v </span><span class="c5">is located in the bag </span><span class="c0">X</span><span class="c4">i</span><span class="c5">. We denote it as </span><span class="c0">tree vertex</span><span class="c5">. </span></p><p class="c16"><span class="c0">{u, i}</span><span class="c5">, traverse along the induced subtree of </span><span class="c0">u</span><span class="c5">, till we reach </span><span class="c0">{u, k}</span><span class="c5">. Since the induced subtree is connected, Now we define the so-called </span><span class="c0">internal edge </span><span class="c5">in the tree de- </span></p><p class="c6"><span class="c5">the path from </span><span class="c0">{u, i} </span><span class="c5">to </span><span class="c0">{u, k} </span><span class="c5">can be constructed with composition. Recall that the second condition in Definition </span></p><p class="c6"><span class="c5">inter edges. Then we reach from </span><span class="c0">{u, k} </span><span class="c5">to </span><span class="c0">{v, k} </span><span class="c5">with 1 requires that for every edge (</span><span class="c0">u, v</span><span class="c5">) </span><span class="c0">&isin; E</span><span class="c5">, both </span><span class="c0">u </span><span class="c5">and </span><span class="c0">v </span><span class="c5">should </span></p><p class="c6"><span class="c5">an inner edge. Now we traverse from </span><span class="c0">{v, k} </span><span class="c5">to </span><span class="c0">{v, j} </span><span class="c5">occur in some bag of </span><span class="c0">T</span><span class="c4">G</span><span class="c5">. We call these edges </span><span class="c0">inner edges </span><span class="c5">in the tree decomposition. </span></p><p class="c16"><span class="c5">along the induced subtree of </span><span class="c0">v</span><span class="c5">, which can again be constructed with inter edges. The tree path from </span><span class="c0">{u, i} </span><span class="c5">to </span><span class="c0">{v, j} </span><span class="c5">is thus completed. Definition 3 (Inner edge). </span><span class="c0">Let G </span><span class="c5">= (</span><span class="c0">V,E</span><span class="c5">) </span><span class="c0">be a graph and T</span><span class="c9">G </span><span class="c3">= (</span><span class="c7">{X</span><span class="c9">i </span><span class="c7">| i &isin; I},T</span><span class="c3">) </span><span class="c7">a tree decomposition of G. The </span><span class="c5">inner edges </span><span class="c0">of T</span><span class="c4">G </span><span class="c0">are the pairs of tree vertices defined as follows: </span></p><p class="c6"><span class="c0">{</span><span class="c5">(</span><span class="c0">{u, i}, {v, i}</span><span class="c5">) </span><span class="c0">| </span><span class="c5">(</span><span class="c0">u, v</span><span class="c5">) </span><span class="c0">&isin; E,u,v &isin; X</span><span class="c4">i</span><span class="c5">(</span><span class="c0">i &isin; I</span><span class="c5">)</span><span class="c0">} </span></p><p class="c16"><span class="c0">&bull; </span><span class="c5">Induction: assume that the lemma holds with paths whose length is less than or equal to </span><span class="c0">n &minus; </span><span class="c5">1, we prove that it holds for paths with length of </span><span class="c0">n</span><span class="c5">. Assume that there is a path from </span><span class="c0">u </span><span class="c5">to </span><span class="c0">v </span><span class="c5">with length </span><span class="c0">n</span><span class="c5">, where </span><span class="c0">u </span><span class="c5">reaches </span><span class="c0">w </span><span class="c5">with length </span><span class="c0">n &minus; </span><span class="c5">1 and (</span><span class="c0">w, v</span><span class="c5">) </span><span class="c0">&isin; E</span><span class="c5">. From in- Intuitively, the set of inner edges consists of precisely those </span></p><p class="c6"><span class="c5">duction hypothesis, we know that there is a tree path edges in </span><span class="c0">E</span><span class="c5">, with the extra information of the bags in which </span></p><p class="c6"><span class="c5">form </span><span class="c0">{u, i} </span><span class="c5">to </span><span class="c0">{w, l} </span><span class="c5">in the tree decomposition, where </span><span class="c0">l </span><span class="c5">the edges are located. For instance, the inner edges of the </span></p><p class="c6"><span class="c5">is a node in the induced subtree of </span><span class="c0">w</span><span class="c5">. Since (</span><span class="c0">w, v</span><span class="c5">) </span><span class="c0">&isin; E</span><span class="c5">, tree decomposition of the graph in Example 1 are: (</span><span class="c0">{</span><span class="c5">0</span><span class="c0">,</span><span class="c5">2</span><span class="c0">}, {</span><span class="c5">5</span><span class="c0">,</span><span class="c5">2</span><span class="c0">}</span><span class="c5">), </span></p><p class="c6"><span class="c5">there is a node </span><span class="c0">n </span><span class="c5">such that </span><span class="c0">w &isin; X</span><span class="c4">n </span><span class="c5">and </span><span class="c0">v &isin; X</span><span class="c4">n</span><span class="c5">. Thus (</span><span class="c0">{</span><span class="c5">1</span><span class="c0">, </span><span class="c5">3</span><span class="c0">},{</span><span class="c5">2</span><span class="c0">, </span><span class="c5">3</span><span class="c0">}</span><span class="c5">), (</span><span class="c0">{</span><span class="c5">2</span><span class="c0">,</span><span class="c5">1</span><span class="c0">}, {</span><span class="c5">3</span><span class="c0">,</span><span class="c5">1</span><span class="c0">}</span><span class="c5">), (</span><span class="c0">{</span><span class="c5">3</span><span class="c0">,</span><span class="c5">2</span><span class="c0">}, {</span><span class="c5">0</span><span class="c0">,</span><span class="c5">2</span><span class="c0">}</span><span class="c5">), (</span><span class="c0">{</span><span class="c5">4</span><span class="c0">, </span><span class="c5">1</span><span class="c0">},{</span><span class="c5">3</span><span class="c0">, </span><span class="c5">1</span><span class="c0">}</span><span class="c5">), </span></p><p class="c6"><span class="c0">{w, n} </span><span class="c5">can be reached from </span><span class="c0">{w, l} </span><span class="c5">with inter edges. </span></p><p class="c6"><span class="c34">101 </span></p><p class="c23"><span class="c5">Example 2. </span><span class="c0">Consider the graph in Figure 1(a). Vertex </span><span class="c5">4 </span><span class="c0">reaches vertex </span><span class="c5">0 </span><span class="c0">with the path </span><span class="c5">(4</span><span class="c0">,</span><span class="c5">1</span><span class="c0">,</span><span class="c5">2</span><span class="c0">, </span><span class="c5">3</span><span class="c0">,</span><span class="c5">0)</span><span class="c0">. In the tree decomposition in Figure 1(b), there is a tree path from {</span><span class="c5">4</span><span class="c0">,</span><span class="c5">1</span><span class="c0">} to {</span><span class="c5">0</span><span class="c0">,</span><span class="c5">2</span><span class="c0">} as follows: </span><span class="c5">(</span><span class="c0">{</span><span class="c5">4</span><span class="c0">, </span><span class="c5">1</span><span class="c0">}, {</span><span class="c5">4</span><span class="c0">, </span><span class="c5">3</span><span class="c0">}, {</span><span class="c5">1</span><span class="c0">, </span><span class="c5">3</span><span class="c0">}, {</span><span class="c5">2</span><span class="c0">, </span><span class="c5">3</span><span class="c0">}, {</span><span class="c5">2</span><span class="c0">, </span><span class="c5">1</span><span class="c0">}, {</span><span class="c5">3</span><span class="c0">, </span><span class="c5">1</span><span class="c0">}, {</span><span class="c5">3</span><span class="c0">,</span><span class="c5">0</span><span class="c0">}, {</span><span class="c5">3</span><span class="c0">,</span><span class="c5">2</span><span class="c0">}, {</span><span class="c5">0</span><span class="c0">,</span><span class="c5">2</span><span class="c0">}</span><span class="c5">)</span><span class="c0">. </span></p><p class="c73"><span class="c1">2.3 Shortest Path Query Answering on Tree </span><span class="c41">Decomposition </span><span class="c5">With the definition of the tree path, we are able to map every path from </span><span class="c0">u </span><span class="c5">to </span><span class="c0">v </span><span class="c5">in the graph </span><span class="c0">G </span><span class="c5">into a tree path in the corresponding tree decomposition </span><span class="c0">T</span><span class="c9">G</span><span class="c3">. Since all the paths </span><span class="c5">can be traced in the tree decomposition, after inspecting all the corresponding tree nodes, we are able to compute the shortest path from </span><span class="c0">u </span><span class="c5">to </span><span class="c0">v</span><span class="c5">. Our goal is now to restrict the attention of the tree nodes to those that every tree path would pass through. </span></p><p class="c63 c92 c100"><span class="c5">There is a well-known property of trees that for any two nodes </span><span class="c0">i </span><span class="c5">and </span><span class="c0">j </span><span class="c5">in a tree, there exists a unique simple path, denoted as </span><span class="c0">SP</span><span class="c9">i,j</span><span class="c3">, such that every path from </span><span class="c7">i </span><span class="c3">to </span><span class="c7">j </span><span class="c3">contains </span><span class="c5">all the nodes in </span><span class="c0">SP</span><span class="c4">i,j</span><span class="c5">. In the following we show that this property can also be applied to tree paths. </span></p><p class="c10"><span class="c5">Given a tree path </span><span class="c0">P </span><span class="c5">in the tree decomposition, we say </span><span class="c0">P </span><span class="c5">visits a node </span><span class="c0">i </span><span class="c5">, if there is a tree vertex </span><span class="c0">{v, i} </span><span class="c5">in </span><span class="c0">P</span><span class="c5">. </span></p><p class="c82"><span class="c5">Lemma 2. </span><span class="c0">Let {u, i} and {v, j} be two tree vertices, and SP</span><span class="c4">i,j </span><span class="c0">be the simple path between tree nodes i and j. Let P be a tree path from {u, i} to {v, j}. Then P visits every node in SP</span><span class="c4">i,j</span><span class="c0">. </span></p><p class="c48"><span class="c5">Example 3. </span><span class="c0">The tree path from {</span><span class="c5">4</span><span class="c0">, </span><span class="c5">1</span><span class="c0">} to {</span><span class="c5">0</span><span class="c0">, </span><span class="c5">2</span><span class="c0">} shown in Example 2 visits the nodes in a sequence of </span><span class="c5">(1</span><span class="c0">,</span><span class="c5">3</span><span class="c0">,</span><span class="c5">1</span><span class="c0">, </span><span class="c5">0</span><span class="c0">,</span><span class="c5">2)</span><span class="c0">. It contains not only all the nodes in the simple path, but also node </span><span class="c5">3</span><span class="c0">, which is not in the simple path. </span></p><p class="c65"><span class="c5">Theorem 1. </span><span class="c0">Let G </span><span class="c5">= (</span><span class="c0">V,E</span><span class="c5">) </span><span class="c0">be a graph and T</span><span class="c9">G </span><span class="c3">= (</span><span class="c7">{X</span><span class="c9">i </span><span class="c7">| i &isin; </span><span class="c0">I},T</span><span class="c5">) </span><span class="c0">a tree decomposition of G. Let u, v &isin; V , and r</span><span class="c4">u </span><span class="c0">(resp. r</span><span class="c9">v</span><span class="c7">) be the root node of the induced subtree of u (resp. </span><span class="c0">v). Then for every node w in SP</span><span class="c4">r</span><span class="c19">u</span><span class="c4">,r</span><span class="c19">v</span><span class="c0">, there is one vertex t &isin; X</span><span class="c4">w</span><span class="c0">, such that sdist</span><span class="c5">(</span><span class="c0">u, v</span><span class="c5">) = </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">u, t</span><span class="c5">) + </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">t, v</span><span class="c5">)</span><span class="c0">. </span></p><p class="c92 c96"><span class="c5">Proof. Let </span><span class="c0">p </span><span class="c5">be the shortest path from </span><span class="c0">u </span><span class="c5">to </span><span class="c0">v </span><span class="c5">in </span><span class="c0">G </span><span class="c5">that generates </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">u, v</span><span class="c5">). From Lemma 1, we know that there is a corresponding tree path </span><span class="c0">P </span><span class="c5">of </span><span class="c0">p </span><span class="c5">from </span><span class="c0">{u, r</span><span class="c9">u</span><span class="c7">} </span><span class="c3">to </span><span class="c7">{v, r</span><span class="c9">v</span><span class="c7">} </span><span class="c5">in </span><span class="c0">T</span><span class="c4">G</span><span class="c5">. According to Lemma 2, </span><span class="c0">P </span><span class="c5">visits all the nodes in </span><span class="c0">SP</span><span class="c9">r</span><span class="c19">u</span><span class="c9">,r</span><span class="c19">v</span><span class="c5">. Then for every node </span><span class="c0">n </span><span class="c5">in </span><span class="c0">SP</span><span class="c9">r</span><span class="c19">u</span><span class="c9">,r</span><span class="c19">v</span><span class="c5">, there is a vertex </span><span class="c0">{t, n} </span><span class="c5">in </span><span class="c0">P</span><span class="c5">. Therefore, </span><span class="c0">t </span><span class="c5">is in </span><span class="c0">p</span><span class="c5">. Then we have </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">u, v</span><span class="c5">) = </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">u, t</span><span class="c5">) + </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">t, v</span><span class="c5">). </span></p><p class="c92 c99"><span class="c5">Theorem 1 shows that for every path from </span><span class="c0">u </span><span class="c5">to </span><span class="c0">v </span><span class="c5">in </span><span class="c0">G</span><span class="c5">, although the tree path from </span><span class="c0">{u, r</span><span class="c4">u</span><span class="c0">} </span><span class="c5">to </span><span class="c0">{v, r</span><span class="c4">v</span><span class="c0">} </span><span class="c5">may possibly visit any node in the tree, we only need to concentrate on those vertices which occur in the simple path </span><span class="c0">SP</span><span class="c9">r</span><span class="c19">u</span><span class="c9">,r</span><span class="c19">v</span><span class="c5">. More precisely, we can simply take </span><span class="c0">any </span><span class="c5">node </span><span class="c0">w </span><span class="c5">from </span><span class="c0">SP</span><span class="c4">r</span><span class="c19">u</span><span class="c4">,r</span><span class="c19">v</span><span class="c5">, and for each </span><span class="c0">t &isin; X</span><span class="c9">w</span><span class="c3">, compute </span><span class="c7">sdist</span><span class="c3">(</span><span class="c7">u, t</span><span class="c3">) and </span><span class="c7">sdist</span><span class="c3">(</span><span class="c7">t, v</span><span class="c3">) respec- </span><span class="c5">tively. Then, the minimal value of </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">u, t</span><span class="c5">) + </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">t, v</span><span class="c5">) is the shortest distance from </span><span class="c0">u </span><span class="c5">to </span><span class="c0">v</span><span class="c5">. However, this is obviously not a solution, since we have to compute the shortest path for 2</span><span class="c0">c </span><span class="c5">times, where </span><span class="c0">c </span><span class="c5">is the cardinality of the bag </span><span class="c0">X</span><span class="c4">w</span><span class="c5">. </span></p><p class="c15"><span class="c5">Then </span><span class="c0">{w, n} </span><span class="c5">can reach </span><span class="c0">{v, n} </span><span class="c5">with an inner edge. Fi- nally </span><span class="c0">{v, n} </span><span class="c5">can reach </span><span class="c0">{v, j} </span><span class="c5">with a sequence of inter edges. This completes the proof. </span></p><p class="c18 c69"><span class="c5">The following question thus arises: </span><span class="c0">Can we compute the shortest path from u to the vertices (respectively from the vertices to v) in the simple path more efficiently</span><span class="c5">? The an- swer is yes. Intuitively, we can compute the shortest distance from </span><span class="c0">u </span><span class="c5">to the vertices occur in the simple path bag after bag, in a bottom-up manner. Let us assume that the current bag be </span><span class="c0">X</span><span class="c4">c </span><span class="c5">and its parent bag be </span><span class="c0">X</span><span class="c4">p</span><span class="c5">. Assume further that for all the vertices </span><span class="c0">t &isin; X</span><span class="c4">c</span><span class="c5">, we have obtained </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">u, t</span><span class="c5">). Now we start processing </span><span class="c0">X</span><span class="c9">p</span><span class="c3">. For any vertex </span><span class="c7">s &isin; X</span><span class="c9">p </span><span class="c7">\ X</span><span class="c9">c</span><span class="c3">, the </span><span class="c5">following property holds: </span></p><p class="c22"><span class="c0">sdist</span><span class="c5">(</span><span class="c0">u, s</span><span class="c5">) = </span><span class="c0">{min</span><span class="c5">(</span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">u, t</span><span class="c5">) + </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">t, s</span><span class="c5">)) </span><span class="c0">| t &isin; X</span><span class="c4">c </span><span class="c0">&cap; X</span><span class="c4">p</span><span class="c0">} </span></p><p class="c81"><span class="c5">This is because </span><span class="c0">every </span><span class="c5">path from </span><span class="c0">u </span><span class="c5">to </span><span class="c0">s </span><span class="c5">has to pass through one vertex in </span><span class="c0">X</span><span class="c9">c </span><span class="c7">&cap; X</span><span class="c9">p </span><span class="c3">(formal proof given in Theorem 2). </span><span class="c5">Therefore, the shortest path must be among them. </span></p><p class="c21"><span class="c5">Clearly, in order to enable the bottom-up operation, we need to store the shortest distances for each bag in the tree decomposition. That is, in every bag </span><span class="c0">X</span><span class="c5">, for every pair of vertices </span><span class="c0">x, y &isin; X</span><span class="c5">, we pre-compute </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">x, y</span><span class="c5">) and store them locally. In addition to the local shortest distance, we need to store the vertices in </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">x, y</span><span class="c5">), denoted as </span><span class="c0">path</span><span class="c5">(</span><span class="c0">x, y</span><span class="c5">), to trace back the vertices along the shortest path later on. </span></p><p class="c68"><span class="c8">Figure 2: Bottom-up processing on the simple tree path</span><span class="c3">Given the tree decomposition of </span><span class="c7">G </span><span class="c3">and the local shortest </span><span class="c5">distance, as well as </span><span class="c0">u </span><span class="c5">and </span><span class="c0">v</span><span class="c5">, the shortest path query answer- ing is sketched in Theorem 2. See Figure 2 for a graphical illustration. </span></p><p class="c57"><span class="c5">Theorem 2. </span><span class="c0">Let G </span><span class="c5">= (</span><span class="c0">V,E</span><span class="c5">) </span><span class="c0">be a graph and u, v &isin; V . Let tw be the treewidth of G and T</span><span class="c4">G </span><span class="c5">= (</span><span class="c0">{X</span><span class="c4">i </span><span class="c0">| i &isin; I},T</span><span class="c5">) </span><span class="c0">be the corresponding tree decomposition. The shortest distance from u to v can be computed in O</span><span class="c5">(</span><span class="c0">tw</span><span class="c20">2</span><span class="c0">h</span><span class="c5">)</span><span class="c0">, where h is the height of T</span><span class="c9">G</span><span class="c7">. </span></p><p class="c52"><span class="c5">Proof. We show that the bottom-up operation can be executed on </span><span class="c0">T</span><span class="c9">G</span><span class="c3">, so that the shortest distance (as well as the </span><span class="c5">corresponding shortest path) from </span><span class="c0">u </span><span class="c5">to </span><span class="c0">v </span><span class="c5">can be computed. Let us make the following assumptions of </span><span class="c0">T</span><span class="c9">G</span><span class="c3">: </span><span class="c7">T</span><span class="c9">u </span><span class="c3">(resp. </span><span class="c0">T</span><span class="c4">v</span><span class="c5">) is the induced subtree of </span><span class="c0">u </span><span class="c5">(resp. </span><span class="c0">v</span><span class="c5">) where </span><span class="c0">r</span><span class="c4">u </span><span class="c5">(resp. </span><span class="c0">r</span><span class="c4">v</span><span class="c5">) is the root. </span><span class="c0">a </span><span class="c5">is the youngest common ancestor of </span><span class="c0">r</span><span class="c9">u </span><span class="c3">and </span><span class="c0">r</span><span class="c9">v</span><span class="c3">, Assume further that the shortest distance (</span><span class="c7">sdist</span><span class="c3">) and </span><span class="c5">shortest path (</span><span class="c0">path</span><span class="c5">) for the pairs of vertices in every bag in </span><span class="c0">T</span><span class="c9">G </span><span class="c3">are pre-computed. We explain the process only for the </span><span class="c5">side of </span><span class="c0">u</span><span class="c5">, the bottom-up process from the </span><span class="c0">v </span><span class="c5">side is identical. The process starts with the node </span><span class="c0">r</span><span class="c9">u</span><span class="c3">. From the information </span><span class="c5">of shortest distance in the tree node </span><span class="c0">X</span><span class="c4">r</span><span class="c19">u</span><span class="c5">, we can simply obtain </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">u, t</span><span class="c5">) for each </span><span class="c0">t &isin; X</span><span class="c4">r</span><span class="c19">u</span><span class="c5">. </span></p><p class="c47"><span class="c34">102 </span></p><p class="c18"><span class="c5">Next, we consider </span><span class="c0">r</span><span class="c9">u </span><span class="c3">as the child node and process its par- </span><span class="c5">ent node, with the available </span><span class="c0">sdist </span><span class="c5">information. This process is executed till </span><span class="c0">a </span><span class="c5">is reached. </span></p><p class="c18"><span class="c5">We show that at each step of the processing, the shortest distance from </span><span class="c0">u </span><span class="c5">to all the vertices in the current bag can be computed in </span><span class="c0">w</span><span class="c20">2 </span><span class="c5">time, where </span><span class="c0">w </span><span class="c5">is the width of the current bag. Assume </span><span class="c0">p </span><span class="c5">is the current node, </span><span class="c0">c </span><span class="c5">its child node, and we have obtained </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">u, t</span><span class="c5">) for each </span><span class="c0">t &isin; X</span><span class="c4">c</span><span class="c5">. </span></p><p class="c18"><span class="c5">Now we have to compute the shortest distance from </span><span class="c0">u </span><span class="c5">to every vertex in </span><span class="c0">X</span><span class="c4">p</span><span class="c5">. Let </span><span class="c0">z </span><span class="c5">be a vertex in </span><span class="c0">X</span><span class="c4">p</span><span class="c5">. We want to compute </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">u, z</span><span class="c5">). We consider the following two cases: </span></p><p class="c18"><span class="c5">1. </span><span class="c0">z &isin; X</span><span class="c9">p </span><span class="c3">and </span><span class="c7">z &isin; X</span><span class="c9">c</span><span class="c3">. Since at the child node </span><span class="c7">sdist</span><span class="c3">(</span><span class="c7">u, z</span><span class="c3">) </span><span class="c5">is already obtained, the value </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">u, z</span><span class="c5">) remains un- changed. </span></p><p class="c6"><span class="c5">2. </span><span class="c0">z &isin; X</span><span class="c4">p </span><span class="c5">and </span><span class="c0">z /&isin; X</span><span class="c4">c</span><span class="c5">. This is a more complex case. We show that there is a vertex </span><span class="c0">t</span><span class="c5">, where </span><span class="c0">t &isin; X</span><span class="c9">p </span><span class="c3">and </span><span class="c0">t &isin; X</span><span class="c4">c</span><span class="c5">, such that </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">u, z</span><span class="c5">) = </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">u, t</span><span class="c5">)+</span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">t, z</span><span class="c5">). In other words, the shortest path from </span><span class="c0">u </span><span class="c5">to </span><span class="c0">z </span><span class="c5">has to pass through some vertex </span><span class="c0">t </span><span class="c5">which occurs in both </span><span class="c0">X</span><span class="c9">c </span><span class="c5">and </span><span class="c0">X</span><span class="c4">p</span><span class="c5">. Since </span><span class="c0">z </span><span class="c5">does not occur in </span><span class="c0">X</span><span class="c4">c</span><span class="c5">, according to the con- nectedness condition, </span><span class="c0">z </span><span class="c5">does not occur in any bag in the subtree rooted with </span><span class="c0">c</span><span class="c5">. Thus the induced subtrees of </span><span class="c0">u </span><span class="c5">and </span><span class="c0">z </span><span class="c5">do not share any common node in </span><span class="c0">T</span><span class="c4">G</span><span class="c5">. Since </span><span class="c0">u &rarr; z</span><span class="c5">, there is a tree path from </span><span class="c0">{u, r</span><span class="c9">u</span><span class="c7">} </span><span class="c3">to </span><span class="c7">{z, r</span><span class="c9">z</span><span class="c7">}</span><span class="c3">, and </span><span class="c0">c, p &isin; SP</span><span class="c4">r</span><span class="c19">u</span><span class="c4">,r</span><span class="c19">z</span><span class="c5">. The tree path from </span><span class="c0">{u, r</span><span class="c4">u</span><span class="c0">} </span><span class="c5">to </span><span class="c0">{z,r</span><span class="c4">z</span><span class="c0">} </span><span class="c5">must contain an inter edge of the form (</span><span class="c0">{t, c},{t, p}</span><span class="c5">), where </span><span class="c0">t &isin; X</span><span class="c4">p</span><span class="c0">,X</span><span class="c4">c</span><span class="c5">, because this is the only possible edge to traverse from </span><span class="c0">c </span><span class="c5">to </span><span class="c0">p</span><span class="c5">. Therefore, the shortest path from </span><span class="c0">u </span><span class="c5">to </span><span class="c0">z </span><span class="c5">must pass through one vertex </span><span class="c0">t &isin; X</span><span class="c9">p</span><span class="c7">,X</span><span class="c9">c</span><span class="c3">. </span><span class="c5">Given the shortest distance from </span><span class="c0">u </span><span class="c5">to every vertex in </span><span class="c0">X</span><span class="c4">c</span><span class="c5">, we compute the shortest distance from </span><span class="c0">u </span><span class="c5">to the vertices in </span><span class="c0">X</span><span class="c9">p </span><span class="c3">as </span><span class="c5">follows: First for each vertex </span><span class="c0">t &isin; X</span><span class="c9">c </span><span class="c7">&cap;X</span><span class="c9">p</span><span class="c3">, set </span><span class="c7">sdist</span><span class="c3">(</span><span class="c7">u, t</span><span class="c3">) the </span><span class="c5">same value as in </span><span class="c0">X</span><span class="c4">c</span><span class="c5">. Then for each vertex </span><span class="c0">t &isin; X</span><span class="c4">p </span><span class="c0">\ X</span><span class="c4">c</span><span class="c5">, set </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">u, t</span><span class="c5">) = </span><span class="c0">min</span><span class="c5">(</span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">u, s</span><span class="c5">)+</span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">s, t</span><span class="c5">)) where </span><span class="c0">s &isin; X</span><span class="c9">c</span><span class="c7">&cap;X</span><span class="c9">p</span><span class="c3">. </span><span class="c5">Clearly the time consumption is in the worst case </span><span class="c0">O</span><span class="c5">(</span><span class="c0">w</span><span class="c20">2</span><span class="c5">) where </span><span class="c0">w </span><span class="c5">is the width of </span><span class="c0">X</span><span class="c9">p</span><span class="c3">. </span></p><p class="c18"><span class="c5">To sum up, at each step, the time cost of updating the shortest distance is </span><span class="c0">O</span><span class="c5">(</span><span class="c0">tw</span><span class="c20">2</span><span class="c5">), where </span><span class="c0">tw </span><span class="c5">is the treewidth of </span><span class="c0">G</span><span class="c5">. and there are maximally 2</span><span class="c0">h </span><span class="c5">steps where </span><span class="c0">h </span><span class="c5">is the height of the tree decomposition. Hence the overall time cost is </span><span class="c0">O</span><span class="c5">(</span><span class="c0">tw</span><span class="c20">2</span><span class="c0">h</span><span class="c5">). </span></p><p class="c6"><span class="c1">3. ALGORITHMS AND COMPLEXITY </span></p><p class="c6"><span class="c1">RESULTS </span><span class="c5">In this section, we present the detailed algorithms for both the index construction and the shortest path query answer- ing. In Section 3.1 we begin with the introduction of algo- rithmic issues on the tree decomposition from a complexity theory perspective, and then justify our choice of an efficient but suboptimal decomposing algorithm. In Section 3.2 we first analyze the shortest path query answering algorithm proposed in Theorem 2 from the previous section. Then, we point out that the time and space improvement can be made to achieve more efficiency of our algorithm. </span><span class="c1">3.1 Index Construction via Tree </span><span class="c41">Decomposition </span></p><p class="c18"><span class="c5">The index construction algorithm consists of three steps (see Algorithm 1). Step 1 and 2 constitute the major part of the index construction task: decomposing the graph </span><span class="c0">G</span><span class="c5">. </span></p><p class="c18"><span class="c5">Since its introduction by Robertson and Seymour [18], the concepts of tree decomposition has been proved to be of great importance in computational complexity theory. The interested readers may refer to an introductory survey by Bodlaender [4]. The theoretical significance of the tree de- composition based approach lies in the fact that many in- tractable problems can be solved in polynomial time (or even in linear time) for graphs with treewidth bounded by a con- stant. Problems which can be dealt with in this way include many well known NP-complete problems, such as the Inde- pendent Set, the Hamiltonian Circuits, etc. Recent applica- tions of tree decomposition based approaches can be found in Constraint Satisfaction [15] and database design [10]. </span></p><p class="c18"><span class="c5">However, the practical usefulness of tree decomposition based approaches has been limited due to the following two problems: (1) Computing the treewidth of a graph is hard. In the last section, we have always assumed that a tree de- composition is given. In fact, to obtain a tree decomposition with the minimal width (treewidth) is a optimization prob- lem. Determining whether the treewidth of a given graph is at most a given integer </span><span class="c0">w </span><span class="c5">is NP-complete [2]. Although for a fixed </span><span class="c0">w</span><span class="c5">, linear time algorithms exist to solve the deci- sion problem &rdquo;treewidth </span><span class="c0">&le; w</span><span class="c5">&rdquo;, there is a huge hidden con- stant factor, which prevents it from being useful in practice. There exist many heuristics and approximation algorithms for determining the treewidth, unfortunately few of them can deal with graphs containing more than 1000 vertices [17]. (2) The second problem lies in the fact that even if the treewidth can be determined, good performance for solving intractable problems by using the tree decomposition based approaches can only be achieved if the underlying structure has </span><span class="c0">bounded </span><span class="c5">treewidth (i.e. less than 10). Because the time complexity of most of the algorithms is exponential to the treewidth. </span></p><p class="c6"><span class="c5">As far as the efficiency is concerned, we can only search for an approximate solution, which yields a suboptimal treewidth. On the other hand, we can tolerate a treewidth which is not bounded. As we have seen from Theorem 2, the time complexity is in the worst case quadratic of the treewidth (width). We will show later in this section that our query answering algorithm does not depend on the treewidth, but with some parameter which can be enforced to be bounded, due to the nice property of our dedicated decomposing al- gorithm. </span></p><p class="c6"><span class="c5">Inspired by the so-called pre-processing methods from Bod- laender et al. [5], we apply the reduction rules on the graph by reducing stepwise a graph to another one with fewer ver- tices, due to the following simple fact. </span></p><p class="c6"><span class="c5">Definition 6 (Simplicial). </span><span class="c0">A vertex v is simplicial in a graph G if the neighbors of v form a clique in G. </span></p><p class="c6"><span class="c5">Proposition 1. </span><span class="c0">If v is a simplicial vertex in a graph G, </span></p><p class="c6"><span class="c34">103 </span></p><p class="c6"><span class="c8">Algorithm 1 </span><span class="c0">index </span></p><p class="c6"><span class="c8">Input: </span><span class="c0">G </span><span class="c5">= (</span><span class="c0">V,E</span><span class="c5">) </span><span class="c8">Output: </span><span class="c0">T</span><span class="c4">G </span><span class="c5">and local shortest paths. </span></p><p class="c6"><span class="c5">1: </span><span class="c0">graph </span></p><p class="c6"><span class="c0">reduction</span><span class="c5">(</span><span class="c0">k, G</span><span class="c5">); </span><span class="c0">{</span><span class="c5">output the vertex stack </span><span class="c0">S </span><span class="c5">and reduced graph </span><span class="c0">G } </span><span class="c5">2: </span><span class="c0">tree </span></p><p class="c6"><span class="c0">decomposition</span><span class="c5">(</span><span class="c0">S, G, G </span><span class="c5">); </span><span class="c0">{</span><span class="c5">output the tree decom- position </span><span class="c0">T</span><span class="c9">G</span><span class="c7">} </span><span class="c5">3: </span><span class="c0">local </span></p><p class="c6"><span class="c0">paths</span><span class="c5">(</span><span class="c0">G, T</span><span class="c4">G</span><span class="c5">); </span><span class="c0">{</span><span class="c5">compute local shortest paths in </span><span class="c0">T</span><span class="c9">G</span><span class="c7">} </span></p><p class="c6"><span class="c0">shortest </span></p><p class="c6"><span class="c0">construction</span><span class="c5">(</span><span class="c0">G</span><span class="c5">) </span></p><p class="c6"><span class="c0">computing the treewidth of G is equivalent to computing the treewidth of G &minus; v. </span></p><p class="c18"><span class="c5">Proof. Let </span><span class="c0">T</span><span class="c9">G&minus;v </span><span class="c3">be the tree decomposition of </span><span class="c7">G &minus; v</span><span class="c3">. </span><span class="c5">Let further </span><span class="c0">{v</span><span class="c11">1</span><span class="c0">,...,v</span><span class="c9">l</span><span class="c7">} </span><span class="c3">be the neighbors of </span><span class="c7">v</span><span class="c3">. We construct </span><span class="c5">a bag </span><span class="c0">X</span><span class="c9">c </span><span class="c3">= </span><span class="c7">{v, v</span><span class="c2">1</span><span class="c7">,...,v</span><span class="c9">l</span><span class="c7">}</span><span class="c3">. Since </span><span class="c7">{v</span><span class="c2">1</span><span class="c7">,...,v</span><span class="c9">l</span><span class="c7">} </span><span class="c3">form a clique, </span><span class="c5">there exists a bag in </span><span class="c0">T</span><span class="c4">G&minus;v </span><span class="c5">consisting of all the vertices in </span><span class="c0">{v</span><span class="c2">1</span><span class="c7">,...,v</span><span class="c9">l</span><span class="c7">}</span><span class="c3">. We denote it as </span><span class="c7">X</span><span class="c9">p</span><span class="c3">. We can then construct </span><span class="c7">T</span><span class="c9">G </span><span class="c5">by adding </span><span class="c0">X</span><span class="c4">c </span><span class="c5">as a child of </span><span class="c0">X</span><span class="c4">p</span><span class="c5">. It is easy to verify that all the conditions of the tree decomposition are fulfilled. Thus this new tree is also a tree decomposition. </span></p><p class="c18"><span class="c5">Now consider the treewidth of </span><span class="c0">T</span><span class="c4">G</span><span class="c5">. </span><span class="c0">X</span><span class="c4">c </span><span class="c5">has the size of </span><span class="c0">l</span><span class="c5">+1. It is easy to show that the size of </span><span class="c0">X</span><span class="c9">p </span><span class="c3">is equal to or greater </span><span class="c5">than </span><span class="c0">l </span><span class="c5">+ 1, thus by adding the new bag </span><span class="c0">X</span><span class="c4">c </span><span class="c5">the treewidth remains to be the same. </span></p><p class="c18"><span class="c5">Figure 3 shows some special cases. If a vertex </span><span class="c0">v </span><span class="c5">has degree of one (Figure 3(a)), then we can remove </span><span class="c0">v </span><span class="c5">without increas- ing the treewidth. Figure 3(b), 3(c) illustrate the cases of degree 2 and 3 respectively. </span></p><p class="c6"><span class="c5">(a) (b) (c) </span></p><p class="c6"><span class="c8">Figure 3: A graph containing a vertex </span><span class="c0">v </span><span class="c8">with degree 1 (a), 2 (b) and 3 (c) </span></p><p class="c16"><span class="c5">The main idea of our decomposition algorithm is to reduce the graph by removing the vertices one by one from the graph, and at the same time push the removed vertices into a stack, so that later on the tree can be constructed with the information from the stack. Each time a vertex </span><span class="c0">v </span><span class="c5">with a specific degree is identified. We first check whether all its neighbors form a clique, if not, we add the missing edges to construct a clique. Then </span><span class="c0">v </span><span class="c5">together with its neighbors are pushed into the stack, which is followed by the deletion of </span><span class="c0">v </span><span class="c5">and the corresponding edges in the graph. See Algorithm 2. The program begins with removing isolated vertices and vertices with degree 1. Then, the reduction process proceeds by increasing the degree of the vertex. We denote such pro- cedure of removing all the vertices with degree </span><span class="c0">l </span><span class="c5">as </span><span class="c0">degree-l reduction</span><span class="c5">. </span></p><p class="c18"><span class="c5">Example 4. </span><span class="c0">Consider the graph in Example 1. Figure 4 illustrates the reduction process. The process starts with a degree-2 reduction by removing vertex </span><span class="c5">0 </span><span class="c0">and its edges, after adding the edge between </span><span class="c5">3 </span><span class="c0">and </span><span class="c5">5</span><span class="c0">. Vertex </span><span class="c5">0 </span><span class="c0">and its neighbors are then pushed in the stack. Then vertex </span><span class="c5">1 </span><span class="c0">is removed, fol- lowing the same principle as of </span><span class="c5">0</span><span class="c0">. After vertex </span><span class="c5">2 </span><span class="c0">is removed, a single triangle is then left. </span></p><p class="c18"><span class="c5">Algorithm 2 will terminate if one of the following con- ditions is fulfilled. (1) The graph is reduced to an empty set. For instance, if the graph contains only simple cycles, it will be reduced to an empty set after degree-2 reductions. This is usually the case for extremely sparse graphs. (2) For graphs which are not sparse, one has to define a upper </span></p><p class="c18"><span class="c5">bound </span><span class="c0">k </span><span class="c5">for the reduction, so that the program stops after the degree-</span><span class="c0">k </span><span class="c5">reduction. Note that as the degree increases, the effectiveness of the reduction will decrease, because in the worst case, we need to add </span><span class="c0">l</span><span class="c5">(</span><span class="c0">l &minus; </span><span class="c5">1)</span><span class="c0">/</span><span class="c5">2 edges in order to remove </span><span class="c0">l </span><span class="c5">edges. </span></p><p class="c6"><span class="c8">Figure 4: The reduction process on the graph of Example 1 </span></p><p class="c18"><span class="c5">After the reduction process, the tree decomposition can be constructed as follows: (1) At first we collect all the vertices which were not removed by the reduction process and assign this set as the bag of the tree root </span><span class="c0">R</span><span class="c5">. The size of </span><span class="c0">R </span><span class="c5">depends on the structure of the graph (i.e. how many vertices are left after the reduction). For graphs which are not sparse, the bag size of the root is the greatest among all bags in the tree decomposition. (2) The rest of the tree is generated from the information stored in stack </span><span class="c0">S</span><span class="c5">. Let </span><span class="c0">X</span><span class="c4">c </span><span class="c5">be the set of vertices </span><span class="c0">{v, v</span><span class="c11">1</span><span class="c0">,...,v</span><span class="c9">l</span><span class="c7">} </span><span class="c3">which is popped up from the top </span><span class="c5">of </span><span class="c0">S</span><span class="c5">. Here </span><span class="c0">v </span><span class="c5">is the removed vertex and </span><span class="c0">{v</span><span class="c2">1</span><span class="c7">,...,v</span><span class="c9">l</span><span class="c7">} </span><span class="c3">are the </span><span class="c5">neighbors of </span><span class="c0">v </span><span class="c5">which form a clique. After the parent bag </span><span class="c0">X</span><span class="c9">p </span><span class="c3">which contains </span><span class="c7">{v</span><span class="c2">1</span><span class="c7">,...,v</span><span class="c9">l</span><span class="c7">} </span><span class="c3">is located in the tree, </span><span class="c7">X</span><span class="c9">c </span><span class="c3">is </span><span class="c5">added as a child bag of </span><span class="c0">X</span><span class="c4">p</span><span class="c5">. This process proceeds until </span><span class="c0">S </span><span class="c5">is empty. Algorithm 3 illustrates the process. </span></p><p class="c18"><span class="c5">The last step of the index construction is to compute and store the shortest distances and paths for every pair of ver- tices in the bags of the tree decomposition (see Algorithm 4). We apply the standard BFS algorithms. Due to the property of the tree decomposition, there exist redundan- cies. For instance, both node 1 and 3 in Figure 1(b) contain the vertex pair (2</span><span class="c0">,</span><span class="c5">4). Therefore, the same shortest distance </span></p><p class="c6"><span class="c34">104 </span></p><p class="c6"><span class="c8">Algorithm 2 </span><span class="c0">graph </span></p><p class="c6"><span class="c8">Input: </span><span class="c5">graph </span><span class="c0">G</span><span class="c5">, </span><span class="c0">k </span><span class="c5">is the upper bound for the reduction. </span><span class="c8">Output: </span><span class="c5">stack </span><span class="c0">S </span><span class="c5">and the reduced graph </span><span class="c0">G </span></p><p class="c6"><span class="c5">1: initialize stack </span><span class="c0">S</span><span class="c5">; 2: </span><span class="c8">for </span><span class="c0">i </span><span class="c5">= 1 to </span><span class="c0">k </span><span class="c8">do </span><span class="c5">3: </span><span class="c0">remove </span></p><p class="c6"><span class="c0">upto</span><span class="c5">(</span><span class="c0">l</span><span class="c5">) 7: </span><span class="c8">while </span><span class="c5">TRUE </span><span class="c8">do </span><span class="c5">8: </span><span class="c8">if </span><span class="c5">there exists a vertex </span><span class="c0">v </span><span class="c5">with degree less than </span><span class="c0">l </span><span class="c8">then </span><span class="c5">9: </span><span class="c0">{v</span><span class="c11">1</span><span class="c0">,...,v</span><span class="c9">l</span><span class="c7">} </span><span class="c3">= neighbors of </span><span class="c7">v</span><span class="c3">; </span><span class="c5">10: build a clique for </span><span class="c0">{v</span><span class="c2">1</span><span class="c7">,...,v</span><span class="c9">l</span><span class="c7">} </span><span class="c3">in </span><span class="c7">G</span><span class="c3">; </span><span class="c5">11: push </span><span class="c0">v, v</span><span class="c11">1</span><span class="c0">,...,v</span><span class="c9">l </span><span class="c3">into </span><span class="c7">S</span><span class="c3">; </span><span class="c5">12: delete </span><span class="c0">v </span><span class="c5">and all its edges from </span><span class="c0">G</span><span class="c5">; 13: </span><span class="c8">else </span><span class="c5">14: break; 15: </span><span class="c8">end if </span><span class="c5">16: </span><span class="c8">end while </span></p><p class="c6"><span class="c0">upto</span><span class="c5">(</span><span class="c0">i</span><span class="c5">); 4: </span><span class="c8">end for </span><span class="c5">5: </span><span class="c8">return </span><span class="c0">S, G</span><span class="c5">; </span></p><p class="c6"><span class="c5">6: </span><span class="c8">procedure </span><span class="c0">remove </span></p><p class="c6"><span class="c0">reduction</span><span class="c5">(</span><span class="c0">k, G</span><span class="c5">) </span></p><p class="c6 c90"><span class="c8">Algorithm 3 </span><span class="c0">tree </span></p><p class="c56"><span class="c8">Input: </span><span class="c0">S </span><span class="c5">is the stack storing the removed vertices and their neighbors, </span><span class="c0">G </span><span class="c5">is the graph, </span><span class="c0">G </span><span class="c5">is the reduced graph of </span><span class="c0">G</span><span class="c5">. </span><span class="c8">Output: </span><span class="c5">return tree decomposition </span><span class="c0">T</span><span class="c4">G </span></p><p class="c86"><span class="c5">1: construct the root of </span><span class="c0">T</span><span class="c4">G </span><span class="c5">containing all the vertices of </span></p><p class="c24"><span class="c0">G </span><span class="c5">; 2: </span><span class="c8">while </span><span class="c0">S </span><span class="c5">is not empty </span><span class="c8">do </span><span class="c5">3: pop up a bag </span><span class="c0">X</span><span class="c9">c </span><span class="c3">= </span><span class="c7">{v, v</span><span class="c2">1</span><span class="c7">,...,v</span><span class="c9">l</span><span class="c7">} </span><span class="c3">from </span><span class="c7">S</span><span class="c3">; </span><span class="c5">4: find the bag </span><span class="c0">X</span><span class="c4">p </span><span class="c5">containing </span><span class="c0">{v</span><span class="c11">1</span><span class="c0">,...,v</span><span class="c9">l</span><span class="c7">}</span><span class="c3">; </span><span class="c5">5: add </span><span class="c0">X</span><span class="c9">c </span><span class="c3">into </span><span class="c7">T </span><span class="c3">as the child node of </span><span class="c7">X</span><span class="c9">p</span><span class="c3">; </span><span class="c5">6: </span><span class="c8">end while </span></p><p class="c6 c40"><span class="c0">decomposition</span><span class="c5">(</span><span class="c0">S, G, G </span><span class="c5">) </span></p><p class="c18 c87"><span class="c5">Now, we only need to execute a nested loop on </span><span class="c0">X</span><span class="c2">1 </span><span class="c7">&cap; R </span><span class="c3">and </span><span class="c0">X</span><span class="c2">2 </span><span class="c7">&cap; R</span><span class="c3">, to decide the final shortest path. Since both </span><span class="c7">|X</span><span class="c2">1</span><span class="c7">| </span><span class="c5">and </span><span class="c0">|X</span><span class="c11">2</span><span class="c0">| </span><span class="c5">have the upper bound of </span><span class="c0">k</span><span class="c5">, the overall time con- sumption is of </span><span class="c0">O</span><span class="c5">(</span><span class="c0">k</span><span class="c20">2</span><span class="c0">h</span><span class="c5">), thus independent of </span><span class="c0">|R|</span><span class="c5">. </span></p><p class="c18 c87"><span class="c5">Now, we only need to execute a nested loop on </span><span class="c0">X</span><span class="c2">1 </span><span class="c7">&cap; R </span><span class="c3">and </span><span class="c0">X</span><span class="c2">2 </span><span class="c7">&cap; R</span><span class="c3">, to decide the final shortest path. Since both </span><span class="c7">|X</span><span class="c2">1</span><span class="c7">| </span><span class="c5">and </span><span class="c0">|X</span><span class="c11">2</span><span class="c0">| </span><span class="c5">have the upper bound of </span><span class="c0">k</span><span class="c5">, the overall time con- sumption is of </span><span class="c0">O</span><span class="c5">(</span><span class="c0">k</span><span class="c20">2</span><span class="c0">h</span><span class="c5">), thus independent of </span><span class="c0">|R|</span><span class="c5">. </span></p><p class="c30 c63"><span class="c5">The algorithm for the shortest path query answering is presented in Algorithm 5. Comparing with the bottom-up query processing shown in Theorem 2, Algorithm 5 is cus- tomized with respect to our dedicated tree decomposition algorithm, in the sense that the query time complexity is adapted to be related to </span><span class="c0">k</span><span class="c5">, instead of the treewidth. </span></p><p class="c30 c64"><span class="c5">Given the graph </span><span class="c0">G</span><span class="c5">, its tree decomposition </span><span class="c0">T</span><span class="c9">G </span><span class="c3">and the </span><span class="c5">pre-computed local shortest paths in the bags on </span><span class="c0">T</span><span class="c4">G</span><span class="c5">, as well as the vertices </span><span class="c0">u, v</span><span class="c5">, we first locate the root of the induced subtree of </span><span class="c0">u </span><span class="c5">(</span><span class="c0">v</span><span class="c5">), denoted as </span><span class="c0">r</span><span class="c9">u </span><span class="c3">(</span><span class="c7">r</span><span class="c9">v</span><span class="c3">). The algorithm considers </span><span class="c5">special cases, according to the relationship between </span><span class="c0">r</span><span class="c4">u </span><span class="c5">and </span><span class="c0">r</span><span class="c9">v</span><span class="c3">. (1) if </span><span class="c7">r</span><span class="c9">u </span><span class="c3">and </span><span class="c7">r</span><span class="c9">v </span><span class="c3">are located in one bag, then the shortest </span><span class="c5">path can be immediately returned (line 4). (2) Otherwise, we have to locate the youngest common ancestor of </span><span class="c0">r</span><span class="c9">u </span><span class="c3">and </span><span class="c0">r</span><span class="c4">v</span><span class="c5">, denoted as </span><span class="c0">root</span><span class="c5">. Here a special case is either </span><span class="c0">r</span><span class="c4">u </span><span class="c5">or </span><span class="c0">r</span><span class="c4">v </span><span class="c5">is </span><span class="c0">root</span><span class="c5">. If this occurs, the bottom-up operation should be only executed from one side. Note that we stop the processing at the child node of the </span><span class="c0">root </span><span class="c5">node. At each step of the bottom- up processing, we update the shortest distance value, as well as the </span><span class="c0">parent </span><span class="c5">value, for the later backtrace for the shortest path(line 11 and 19). As soon as both the child nodes </span><span class="c0">X</span><span class="c2">1 </span><span class="c5">and </span><span class="c0">X</span><span class="c2">2 </span><span class="c3">are reached, we obtain the common values with the </span><span class="c0">root </span><span class="c5">node by executing the set intersection operation with it (line 25). At last, a nested loop over the bag </span><span class="c0">X</span><span class="c2">1 </span><span class="c3">and </span><span class="c7">X</span><span class="c2">2 </span><span class="c5">is executed, to </span><span class="c0">stitch the threads </span><span class="c5">from both sides. Finally, the shortest path can be traced back using the </span><span class="c0">p </span><span class="c5">set we have stored during the bottom-up processing. </span></p><p class="c6 c25"><span class="c8">Algorithm 4 </span><span class="c0">local </span></p><p class="c77"><span class="c8">Input: </span><span class="c0">G, T</span><span class="c4">G </span><span class="c8">Output: </span><span class="c5">local shortest paths in </span><span class="c0">T</span><span class="c9">G </span></p><p class="c43"><span class="c5">1: </span><span class="c8">for all </span><span class="c5">bag </span><span class="c0">X </span><span class="c5">in the tree decomposition </span><span class="c8">do </span><span class="c5">2: </span><span class="c8">for </span><span class="c5">every vertex pair </span><span class="c0">x, y &isin; X </span><span class="c8">do </span><span class="c5">3: compute </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">x, y</span><span class="c5">) and </span><span class="c0">path</span><span class="c5">(</span><span class="c0">x, y</span><span class="c5">) 4: </span><span class="c8">end for </span><span class="c5">5: </span><span class="c8">end for </span></p><p class="c85"><span class="c5">is stored in two bags. This redundancy can be avoided by storing the shortest distances in a hash table. </span></p><p class="c72"><span class="c1">3.2 Shortest Path Query Answering </span></p><p class="c58"><span class="c5">Recall from Theorem 2 that the time complexity of the bottom-up query answering is </span><span class="c0">O</span><span class="c5">(</span><span class="c0">tw</span><span class="c20">2</span><span class="c0">h</span><span class="c5">). This upper bound is optimal, only if the following two conditions are fulfilled: (1) the treewidth of the underlying graph is bounded (that is, </span><span class="c0">tw</span><span class="c20">2 </span><span class="c0">&#8810; n</span><span class="c5">), and (2) there is an efficient tree decomposition algorithm for it. The first condition has to be fulfilled, since otherwise the linear time BFS algorithm would be more effi- cient. Unfortunately, as we have seen in Section 3.1, given an arbitrary graph, neither of them can be guaranteed. There- fore, we have to inspect the tree decomposition heuristics applied in Section 3.1 for improvements. </span></p><p class="c66"><span class="c39">3.2.1 From Treewidth to </span><span class="c0">|R| </span><span class="c39">and </span><span class="c0">k </span></p><p class="c49"><span class="c5">According to Algorithm 2, a graph </span><span class="c0">G </span><span class="c5">can be decomposed by the </span><span class="c0">degree-l reductions </span><span class="c5">by increasing </span><span class="c0">l </span><span class="c5">from 1 to </span><span class="c0">k</span><span class="c5">. As soon as the </span><span class="c0">degree-k reduction </span><span class="c5">is done, all the vertices which are not yet removed are the elements in </span><span class="c0">R </span><span class="c5">of the tree de- composition. Usually if the graph is not extremely sparse, the relationship </span><span class="c0">k &#8810; |R| </span><span class="c5">holds. In fact, we could even en- force such a relationship by setting </span><span class="c0">k </span><span class="c5">to be small enough in the tree decomposition algorithm. Hence, the resulting tree decomposition has the following properties: (1) the root is of big size (</span><span class="c0">|R|</span><span class="c5">), and (2) the rest of the bags have smaller size (the upper bound is </span><span class="c0">k</span><span class="c5">). </span></p><p class="c46"><span class="c5">If we inspect the bottom-up query processing more care- fully, we could observe that the quadratic time computation over the root can be </span><span class="c0">always </span><span class="c5">be avoided. To see this, let us consider the vertices </span><span class="c0">u </span><span class="c5">and </span><span class="c0">v </span><span class="c5">and the youngest common an- cestor of </span><span class="c0">r</span><span class="c9">u </span><span class="c3">and </span><span class="c7">r</span><span class="c9">v </span><span class="c3">is the root </span><span class="c7">R</span><span class="c3">. Assume that </span><span class="c7">X</span><span class="c2">1 </span><span class="c3">(resp. </span><span class="c0">X</span><span class="c2">2</span><span class="c3">) is the child node of </span><span class="c7">R </span><span class="c3">which locates in the simple path </span><span class="c5">from </span><span class="c0">r</span><span class="c4">u </span><span class="c5">(resp. </span><span class="c0">r</span><span class="c4">v</span><span class="c5">) to </span><span class="c0">R</span><span class="c5">. Consider now that for all </span><span class="c0">x &isin; X</span><span class="c11">1</span><span class="c5">, </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">u, x</span><span class="c5">) (resp. all </span><span class="c0">y &isin; X</span><span class="c2">2</span><span class="c3">, </span><span class="c7">sdist</span><span class="c3">(</span><span class="c7">y,v</span><span class="c3">)) have been com- </span><span class="c5">puted. Clearly, any path from </span><span class="c0">u </span><span class="c5">to </span><span class="c0">v </span><span class="c5">has to pass through a vertex in </span><span class="c0">X</span><span class="c2">1 </span><span class="c3">and </span><span class="c7">X</span><span class="c2">2 </span><span class="c3">respectively. Therefore, at the root </span><span class="c5">node </span><span class="c0">R</span><span class="c5">, the </span><span class="c0">interface </span><span class="c5">from </span><span class="c0">X</span><span class="c11">1 </span><span class="c5">to </span><span class="c0">R </span><span class="c5">has to be </span><span class="c0">X</span><span class="c11">1 </span><span class="c0">&cap; R</span><span class="c5">, and accordingly, the </span><span class="c0">interface </span><span class="c5">from </span><span class="c0">X</span><span class="c11">2 </span><span class="c5">to </span><span class="c0">R </span><span class="c5">has to be </span><span class="c0">X</span><span class="c11">2 </span><span class="c0">&cap; R</span><span class="c5">. </span></p><p class="c6 c89"><span class="c0">shortest </span></p><p class="c6 c27"><span class="c0">paths</span><span class="c5">(</span><span class="c0">G, T</span><span class="c9">G</span><span class="c3">) </span></p><p class="c6 c27"><span class="c0">paths</span><span class="c5">(</span><span class="c0">G, T</span><span class="c9">G</span><span class="c3">) </span></p><p class="c18 c30"><span class="c5">Given the graph </span><span class="c0">G</span><span class="c5">, its tree decomposition </span><span class="c0">T</span><span class="c9">G </span><span class="c3">and the </span><span class="c5">pre-computed local shortest paths in the bags on </span><span class="c0">T</span><span class="c4">G</span><span class="c5">, as well as the vertices </span><span class="c0">u, v</span><span class="c5">, we first locate the root of the induced subtree of </span><span class="c0">u </span><span class="c5">(</span><span class="c0">v</span><span class="c5">), denoted as </span><span class="c0">r</span><span class="c9">u </span><span class="c3">(</span><span class="c7">r</span><span class="c9">v</span><span class="c3">). The algorithm considers </span><span class="c5">special cases, according to the relationship between </span><span class="c0">r</span><span class="c4">u </span><span class="c5">and </span><span class="c0">r</span><span class="c9">v</span><span class="c3">. (1) if </span><span class="c7">r</span><span class="c9">u </span><span class="c3">and </span><span class="c7">r</span><span class="c9">v </span><span class="c3">are located in one bag, then the shortest </span><span class="c5">path can be immediately returned (line 4). (2) Otherwise, we have to locate the youngest common ancestor of </span><span class="c0">r</span><span class="c9">u </span><span class="c3">and </span><span class="c0">r</span><span class="c4">v</span><span class="c5">, denoted as </span><span class="c0">root</span><span class="c5">. Here a special case is either </span><span class="c0">r</span><span class="c4">u </span><span class="c5">or </span><span class="c0">r</span><span class="c4">v </span><span class="c5">is </span><span class="c0">root</span><span class="c5">. If this occurs, the bottom-up operation should be only executed from one side. Note that we stop the processing at the child node of the </span><span class="c0">root </span><span class="c5">node. At each step of the bottom- up processing, we update the shortest distance value, as well as the </span><span class="c0">parent </span><span class="c5">value, for the later backtrace for the shortest path(line 11 and 19). As soon as both the child nodes </span><span class="c0">X</span><span class="c2">1 </span><span class="c5">and </span><span class="c0">X</span><span class="c2">2 </span><span class="c3">are reached, we obtain the common values with the </span><span class="c0">root </span><span class="c5">node by executing the set intersection operation with it (line 25). At last, a nested loop over the bag </span><span class="c0">X</span><span class="c2">1 </span><span class="c3">and </span><span class="c7">X</span><span class="c2">2 </span><span class="c5">is executed, to </span><span class="c0">stitch the threads </span><span class="c5">from both sides. Finally, the shortest path can be traced back using the </span><span class="c0">p </span><span class="c5">set we have stored during the bottom-up processing. </span></p><p class="c18 c30"><span class="c5">Given the graph </span><span class="c0">G</span><span class="c5">, its tree decomposition </span><span class="c0">T</span><span class="c9">G </span><span class="c3">and the </span><span class="c5">pre-computed local shortest paths in the bags on </span><span class="c0">T</span><span class="c4">G</span><span class="c5">, as well as the vertices </span><span class="c0">u, v</span><span class="c5">, we first locate the root of the induced subtree of </span><span class="c0">u </span><span class="c5">(</span><span class="c0">v</span><span class="c5">), denoted as </span><span class="c0">r</span><span class="c9">u </span><span class="c3">(</span><span class="c7">r</span><span class="c9">v</span><span class="c3">). The algorithm considers </span><span class="c5">special cases, according to the relationship between </span><span class="c0">r</span><span class="c4">u </span><span class="c5">and </span><span class="c0">r</span><span class="c9">v</span><span class="c3">. (1) if </span><span class="c7">r</span><span class="c9">u </span><span class="c3">and </span><span class="c7">r</span><span class="c9">v </span><span class="c3">are located in one bag, then the shortest </span><span class="c5">path can be immediately returned (line 4). (2) Otherwise, we have to locate the youngest common ancestor of </span><span class="c0">r</span><span class="c9">u </span><span class="c3">and </span><span class="c0">r</span><span class="c4">v</span><span class="c5">, denoted as </span><span class="c0">root</span><span class="c5">. Here a special case is either </span><span class="c0">r</span><span class="c4">u </span><span class="c5">or </span><span class="c0">r</span><span class="c4">v </span><span class="c5">is </span><span class="c0">root</span><span class="c5">. If this occurs, the bottom-up operation should be only executed from one side. Note that we stop the processing at the child node of the </span><span class="c0">root </span><span class="c5">node. At each step of the bottom- up processing, we update the shortest distance value, as well as the </span><span class="c0">parent </span><span class="c5">value, for the later backtrace for the shortest path(line 11 and 19). As soon as both the child nodes </span><span class="c0">X</span><span class="c2">1 </span><span class="c5">and </span><span class="c0">X</span><span class="c2">2 </span><span class="c3">are reached, we obtain the common values with the </span><span class="c0">root </span><span class="c5">node by executing the set intersection operation with it (line 25). At last, a nested loop over the bag </span><span class="c0">X</span><span class="c2">1 </span><span class="c3">and </span><span class="c7">X</span><span class="c2">2 </span><span class="c5">is executed, to </span><span class="c0">stitch the threads </span><span class="c5">from both sides. Finally, the shortest path can be traced back using the </span><span class="c0">p </span><span class="c5">set we have stored during the bottom-up processing. </span></p><p class="c18 c30"><span class="c5">Given the graph </span><span class="c0">G</span><span class="c5">, its tree decomposition </span><span class="c0">T</span><span class="c9">G </span><span class="c3">and the </span><span class="c5">pre-computed local shortest paths in the bags on </span><span class="c0">T</span><span class="c4">G</span><span class="c5">, as well as the vertices </span><span class="c0">u, v</span><span class="c5">, we first locate the root of the induced subtree of </span><span class="c0">u </span><span class="c5">(</span><span class="c0">v</span><span class="c5">), denoted as </span><span class="c0">r</span><span class="c9">u </span><span class="c3">(</span><span class="c7">r</span><span class="c9">v</span><span class="c3">). The algorithm considers </span><span class="c5">special cases, according to the relationship between </span><span class="c0">r</span><span class="c4">u </span><span class="c5">and </span><span class="c0">r</span><span class="c9">v</span><span class="c3">. (1) if </span><span class="c7">r</span><span class="c9">u </span><span class="c3">and </span><span class="c7">r</span><span class="c9">v </span><span class="c3">are located in one bag, then the shortest </span><span class="c5">path can be immediately returned (line 4). (2) Otherwise, we have to locate the youngest common ancestor of </span><span class="c0">r</span><span class="c9">u </span><span class="c3">and </span><span class="c0">r</span><span class="c4">v</span><span class="c5">, denoted as </span><span class="c0">root</span><span class="c5">. Here a special case is either </span><span class="c0">r</span><span class="c4">u </span><span class="c5">or </span><span class="c0">r</span><span class="c4">v </span><span class="c5">is </span><span class="c0">root</span><span class="c5">. If this occurs, the bottom-up operation should be only executed from one side. Note that we stop the processing at the child node of the </span><span class="c0">root </span><span class="c5">node. At each step of the bottom- up processing, we update the shortest distance value, as well as the </span><span class="c0">parent </span><span class="c5">value, for the later backtrace for the shortest path(line 11 and 19). As soon as both the child nodes </span><span class="c0">X</span><span class="c2">1 </span><span class="c5">and </span><span class="c0">X</span><span class="c2">2 </span><span class="c3">are reached, we obtain the common values with the </span><span class="c0">root </span><span class="c5">node by executing the set intersection operation with it (line 25). At last, a nested loop over the bag </span><span class="c0">X</span><span class="c2">1 </span><span class="c3">and </span><span class="c7">X</span><span class="c2">2 </span><span class="c5">is executed, to </span><span class="c0">stitch the threads </span><span class="c5">from both sides. Finally, the shortest path can be traced back using the </span><span class="c0">p </span><span class="c5">set we have stored during the bottom-up processing. </span></p><p class="c87 c95"><span class="c1">3.3 Complexity </span><span class="c8">Index construction time. </span><span class="c5">For the index construction, we have to (1) generate the tree decomposition, and (2) at each tree node, generate the required shortest paths. For (1), both of the reduction step and the tree construction procedure take time </span><span class="c0">O</span><span class="c5">(</span><span class="c0">n</span><span class="c5">). For (2), we deploy the classic BFS algorithm, which costs in worst case </span><span class="c0">O</span><span class="c5">(</span><span class="c0">n</span><span class="c5">). In fact, we need to run for each vertex in </span><span class="c0">G </span><span class="c5">exactly one BFS procedure. Therefore, the overall index construction time is </span><span class="c0">O</span><span class="c5">(</span><span class="c0">n</span><span class="c20">2</span><span class="c5">). </span><span class="c8">Index size. </span><span class="c5">In each bag </span><span class="c0">X</span><span class="c5">, for each pair of vertices </span><span class="c0">u, v </span><span class="c5">in </span><span class="c0">X</span><span class="c5">, we need to store the vertices along the shortest path between </span><span class="c0">u </span><span class="c5">and </span><span class="c0">v</span><span class="c5">. Thus the index size is </span><span class="c0">l|X|</span><span class="c20">2</span><span class="c5">, where </span><span class="c0">l </span><span class="c5">is the average length of all the local shortest paths. Since the relationship </span><span class="c0">k &#8810; |R| </span><span class="c5">holds, the root size (</span><span class="c0">|R|</span><span class="c5">) is dominant among all the bags. Therefore, the index size is </span><span class="c0">l|R|</span><span class="c20">2</span><span class="c5">. The index size consists of the tree structure, constructed by us- ing the tree decomposition algorithm. However, this space overhead is linear to </span><span class="c0">n</span><span class="c5">, thus can be ignored. </span><span class="c8">Query. </span><span class="c5">The bottom-up query processing for shortest path computation takes time </span><span class="c0">O</span><span class="c5">(</span><span class="c0">k</span><span class="c20">2</span><span class="c0">h</span><span class="c5">), where </span><span class="c0">k </span><span class="c5">is the number of the reductions and </span><span class="c0">h </span><span class="c5">is the height of the tree decomposition. </span></p><p class="c97"><span class="c39">3.3.1 The Trade-off between Time and Space </span></p><p class="c69 c98"><span class="c5">The number of the reductions for the tree decomposition algorithm, </span><span class="c0">k</span><span class="c5">, and the root size </span><span class="c0">|R|</span><span class="c5">, represent the trade-off between the time and space consumptions of the TEDI ap- proach. As analyzed above, the time complexity for the query answering depends on </span><span class="c0">k</span><span class="c5">, whereas the index size is de- cided by </span><span class="c0">|R|</span><span class="c5">. Clearly, regarding to the tree decomposition algorithm, </span><span class="c0">|R| </span><span class="c5">is a monotonically decreasing function of </span><span class="c0">k</span><span class="c5">. Usually, </span><span class="c0">|R| </span><span class="c5">decreases drastically as </span><span class="c0">k </span><span class="c5">is small, e.g. from 1 to </span></p><p class="c74"><span class="c34">105 </span></p><p class="c6"><span class="c8">Algorithm 5 </span><span class="c0">reach </span></p><p class="c6"><span class="c8">Input: </span><span class="c0">T</span><span class="c9">G </span><span class="c3">is the tree decomposition of </span><span class="c7">G </span><span class="c3">and </span><span class="c7">u, v </span><span class="c3">vertices </span><span class="c5">in </span><span class="c0">G</span><span class="c5">. In every bag </span><span class="c0">X </span><span class="c5">of </span><span class="c0">T</span><span class="c9">G</span><span class="c3">, and any pair of </span><span class="c7">x, y &isin; X</span><span class="c3">, </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">x, y</span><span class="c5">) stores the shortest distance, and </span><span class="c0">path</span><span class="c5">(</span><span class="c0">x, y</span><span class="c5">) stores the vertices along the path. </span><span class="c8">Output: </span><span class="c5">the shortest path from </span><span class="c0">u </span><span class="c5">to </span><span class="c0">v</span><span class="c5">. </span></p><p class="c6"><span class="c5">1: </span><span class="c0">r</span><span class="c9">u </span><span class="c3">= root of induced subtree of </span><span class="c7">u</span><span class="c3">; </span><span class="c5">2: </span><span class="c0">r</span><span class="c4">v </span><span class="c5">= root of induced subtree of </span><span class="c0">v</span><span class="c5">; 3: </span><span class="c8">if </span><span class="c5">(</span><span class="c0">r</span><span class="c9">u </span><span class="c3">== </span><span class="c7">r</span><span class="c9">v</span><span class="c3">) </span><span class="c53">then </span><span class="c5">4: </span><span class="c8">return </span><span class="c0">path</span><span class="c5">(</span><span class="c0">u, v</span><span class="c5">); 5: </span><span class="c8">end if </span><span class="c5">6: </span><span class="c0">root </span><span class="c5">= youngest common ancestor of </span><span class="c0">r</span><span class="c9">u </span><span class="c3">and </span><span class="c7">r</span><span class="c9">v</span><span class="c3">; </span><span class="c5">7: </span><span class="c8">if </span><span class="c5">(</span><span class="c0">r</span><span class="c4">u </span><span class="c5">== </span><span class="c0">root</span><span class="c5">) </span><span class="c8">then </span><span class="c5">8: switch </span><span class="c0">u </span><span class="c5">and </span><span class="c0">v</span><span class="c5">; switch </span><span class="c0">r</span><span class="c9">u </span><span class="c3">and </span><span class="c7">r</span><span class="c9">v</span><span class="c3">; </span><span class="c5">9: </span><span class="c8">end if </span><span class="c5">10: </span><span class="c8">for all </span><span class="c0">x &isin; X</span><span class="c4">r</span><span class="c19">u </span><span class="c8">do </span><span class="c5">11: label </span><span class="c0">x </span><span class="c5">with </span><span class="c0">d</span><span class="c9">u</span><span class="c3">(</span><span class="c7">x</span><span class="c3">) = </span><span class="c7">sdist</span><span class="c3">(</span><span class="c7">u, x</span><span class="c3">); </span><span class="c7">p</span><span class="c3">(</span><span class="c7">x</span><span class="c3">) = </span><span class="c7">u</span><span class="c3">; </span><span class="c5">12: </span><span class="c8">end for </span><span class="c5">13: </span><span class="c0">X</span><span class="c2">1 </span><span class="c3">= </span><span class="c7">X</span><span class="c9">r</span><span class="c19">u</span><span class="c5">; 14: </span><span class="c8">while </span><span class="c0">X</span><span class="c11">1</span><span class="c0">.parent </span><span class="c5">= </span><span class="c0">root </span><span class="c8">do </span><span class="c5">15: </span><span class="c0">X</span><span class="c9">p </span><span class="c3">= </span><span class="c7">X</span><span class="c2">1</span><span class="c7">.parent </span><span class="c5">16: </span><span class="c8">for all </span><span class="c0">t &isin; X</span><span class="c9">p </span><span class="c7">\ X</span><span class="c2">1 </span><span class="c53">do </span><span class="c5">17: </span><span class="c8">for all </span><span class="c0">s &isin; X</span><span class="c4">p </span><span class="c0">&cap; X</span><span class="c11">1 </span><span class="c8">do </span><span class="c5">18: </span><span class="c8">if </span><span class="c0">d</span><span class="c9">u</span><span class="c3">(</span><span class="c7">t</span><span class="c3">) </span><span class="c7">&gt; d</span><span class="c9">u</span><span class="c3">(</span><span class="c7">s</span><span class="c3">) + </span><span class="c7">sdist</span><span class="c3">(</span><span class="c7">s, t</span><span class="c3">) </span><span class="c53">then </span><span class="c5">19: </span><span class="c0">d</span><span class="c4">u</span><span class="c5">(</span><span class="c0">t</span><span class="c5">) = </span><span class="c0">d</span><span class="c4">u</span><span class="c5">(</span><span class="c0">s</span><span class="c5">) + </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">s, t</span><span class="c5">); </span><span class="c0">p</span><span class="c5">(</span><span class="c0">t</span><span class="c5">) = </span><span class="c0">s</span><span class="c5">; 20: </span><span class="c8">end if </span><span class="c5">21: </span><span class="c8">end for </span><span class="c5">22: </span><span class="c8">end for </span><span class="c5">23: </span><span class="c0">X</span><span class="c2">1 </span><span class="c3">= </span><span class="c7">X</span><span class="c9">p</span><span class="c3">; </span><span class="c5">24: </span><span class="c8">end while </span><span class="c5">25: </span><span class="c0">X</span><span class="c2">1 </span><span class="c3">= </span><span class="c7">X</span><span class="c2">1 </span><span class="c7">&cap; root</span><span class="c3">; </span><span class="c5">26: </span><span class="c8">if </span><span class="c0">r</span><span class="c4">v </span><span class="c5">is the ancestor of </span><span class="c0">r</span><span class="c4">u </span><span class="c8">then </span><span class="c5">27: </span><span class="c0">X</span><span class="c2">2 </span><span class="c3">= </span><span class="c7">{v}</span><span class="c3">; </span><span class="c7">d</span><span class="c9">v</span><span class="c3">(</span><span class="c7">v</span><span class="c3">) = 0; </span><span class="c5">28: </span><span class="c8">else </span><span class="c5">29: </span><span class="c8">for all </span><span class="c0">x &isin; X</span><span class="c4">r</span><span class="c19">v </span><span class="c8">do </span><span class="c5">30: label </span><span class="c0">x </span><span class="c5">with </span><span class="c0">d</span><span class="c9">v</span><span class="c3">(</span><span class="c7">x</span><span class="c3">) = </span><span class="c7">sdist</span><span class="c3">(</span><span class="c7">v,x</span><span class="c3">); </span><span class="c7">p</span><span class="c3">(</span><span class="c7">x</span><span class="c3">) = </span><span class="c7">v</span><span class="c3">; </span><span class="c5">31: </span><span class="c8">end for </span><span class="c5">32: </span><span class="c0">X</span><span class="c2">2 </span><span class="c3">= </span><span class="c7">X</span><span class="c9">r</span><span class="c19">v</span><span class="c5">; 33: </span><span class="c8">while </span><span class="c0">X</span><span class="c2">2</span><span class="c7">.parent </span><span class="c3">= </span><span class="c7">root </span><span class="c53">do </span><span class="c5">34: </span><span class="c0">X</span><span class="c4">p </span><span class="c5">= </span><span class="c0">X</span><span class="c11">2</span><span class="c0">.parent </span><span class="c5">35: </span><span class="c8">for all </span><span class="c0">t &isin; X</span><span class="c9">p </span><span class="c7">\ X</span><span class="c2">2 </span><span class="c53">do </span><span class="c5">36: </span><span class="c8">for all </span><span class="c0">s &isin; X</span><span class="c4">p </span><span class="c0">&cap; X</span><span class="c11">2 </span><span class="c8">do </span><span class="c5">37: </span><span class="c8">if </span><span class="c0">d</span><span class="c9">v</span><span class="c3">(</span><span class="c7">t</span><span class="c3">) </span><span class="c7">&gt; d</span><span class="c9">v</span><span class="c3">(</span><span class="c7">s</span><span class="c3">) + </span><span class="c7">sdist</span><span class="c3">(</span><span class="c7">s, t</span><span class="c3">) </span><span class="c53">then </span><span class="c5">38: </span><span class="c0">d</span><span class="c4">v</span><span class="c5">(</span><span class="c0">t</span><span class="c5">) = </span><span class="c0">d</span><span class="c4">v</span><span class="c5">(</span><span class="c0">s</span><span class="c5">) + </span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">s, t</span><span class="c5">); </span><span class="c0">p</span><span class="c5">(</span><span class="c0">t</span><span class="c5">) = </span><span class="c0">s</span><span class="c5">; 39: </span><span class="c8">end if </span><span class="c5">40: </span><span class="c8">end for </span><span class="c5">41: </span><span class="c8">end for </span><span class="c5">42: </span><span class="c0">X</span><span class="c2">2 </span><span class="c3">= </span><span class="c7">X</span><span class="c9">p</span><span class="c3">; </span><span class="c5">43: </span><span class="c8">end while </span><span class="c5">44: </span><span class="c0">X</span><span class="c2">2 </span><span class="c3">= </span><span class="c7">X</span><span class="c2">2 </span><span class="c7">&cap; root</span><span class="c3">; </span><span class="c5">45: </span><span class="c8">end if </span><span class="c5">46: </span><span class="c0">mdist </span><span class="c5">= </span><span class="c0">{min</span><span class="c5">(</span><span class="c0">d</span><span class="c4">u</span><span class="c5">(</span><span class="c0">x</span><span class="c5">)+</span><span class="c0">d</span><span class="c4">v</span><span class="c5">(</span><span class="c0">y</span><span class="c5">)+</span><span class="c0">sdist</span><span class="c5">(</span><span class="c0">x, y</span><span class="c5">)) </span><span class="c0">| </span><span class="c5">(</span><span class="c0">x &isin; X</span><span class="c11">1</span><span class="c0">,y &isin; </span></p><p class="c6"><span class="c0">X</span><span class="c2">2</span><span class="c7">}</span><span class="c3">; </span><span class="c5">47: let </span><span class="c0">x &isin; X</span><span class="c11">1</span><span class="c0">,y &isin; X</span><span class="c11">2 </span><span class="c5">be the vertices along the shortest </span></p><p class="c6"><span class="c5">path; 48: </span><span class="c8">while </span><span class="c0">x</span><span class="c5">! = </span><span class="c0">u </span><span class="c8">do </span><span class="c5">49: output </span><span class="c0">path</span><span class="c5">(</span><span class="c0">x, p</span><span class="c5">(</span><span class="c0">x</span><span class="c5">)); </span><span class="c0">x </span><span class="c5">= </span><span class="c0">p</span><span class="c5">(</span><span class="c0">x</span><span class="c5">); 50: </span><span class="c8">end while </span><span class="c5">51: output </span><span class="c0">path</span><span class="c5">(</span><span class="c0">x, y</span><span class="c5">); 52: </span><span class="c8">while </span><span class="c0">y</span><span class="c5">! = </span><span class="c0">v </span><span class="c8">do </span><span class="c5">53: output </span><span class="c0">path</span><span class="c5">(</span><span class="c0">y,p</span><span class="c5">(</span><span class="c0">y</span><span class="c5">)); </span><span class="c0">y </span><span class="c5">= </span><span class="c0">p</span><span class="c5">(</span><span class="c0">y</span><span class="c5">); 54: </span><span class="c8">end while </span></p><p class="c6"><span class="c0">dist</span><span class="c5">(</span><span class="c0">T</span><span class="c4">G</span><span class="c0">, u, v</span><span class="c5">) </span></p><p class="c18"><span class="c5">5. Then, the decreasing of </span><span class="c0">|R| </span><span class="c5">follows diverse trends, which is decided by the characteristics of the underlying graphs. One obvious instance is that for extremely sparse graphs, </span><span class="c0">|R| </span><span class="c5">can be decreased rapidly into zero after 3 or 4 steps of reductions. For instance, the graph &ldquo;Eva&rdquo; in Figure 5 be- longs to this category. However, this correlation can not be solely reflected by the density of the underlying graph. An exact investigation of such a relationship is left as the fu- ture work. Figure 5 depicts the </span><span class="c0">k</span><span class="c5">-</span><span class="c0">|R| </span><span class="c5">relationship for the real datasets we have tested. In this illustration, the Y-axis depicts the value of </span><span class="c0">|R|/n </span><span class="c5">in percentage, namely the pro- portion of the root size with respect to the graph size. Note that due to the wide range of the value on Y-axis, we plot the vertical axis logarithmically. More details of the dataset are given in Section 4. </span></p><p class="c16"><span class="c14">100 </span><span class="c33">Pfei Geom Epa Dutch Erdos PPI Eva Cal Yea Homo Inter </span></p><p class="c6"><span class="c33">10 0 5 10 15 20 25 30 </span></p><p class="c6"><span class="c8">Figure 5: </span><span class="c0">k </span><span class="c8">and </span><span class="c0">|R| </span><span class="c8">relationships for real data </span></p><p class="c6"><span class="c1">4. EXPERIMENTAL RESULTS </span></p><p class="c18"><span class="c5">In this section we evaluate the TEDI approach on real, synthetic, and large datasets respectively, for the shortest path query answering. All tests are run on an Intel(R) Core 2 Duo 2.4 GHz CPU, and 2 GB of main memory. All al- gorithms are implemented in C++ with the Standard Tem- plate Library (STL). </span></p><p class="c6"><span class="c5">We are interested in the following parameters: </span></p><p class="c6"><span class="c0">&bull; </span><span class="c5">Index size, </span></p><p class="c6"><span class="c0">&bull; </span><span class="c5">Index construction time, and </span></p><p class="c6"><span class="c0">&bull; </span><span class="c5">Query time. </span></p><p class="c18"><span class="c5">The index size consists of two parts: (1) the size of the tree decomposition. This includes the tree structure and the vertices stored in the bags of the tree decomposition. (2) the local shortest paths stored in the hash table, which is dominant comparing to part (1). </span></p><p class="c18"><span class="c5">The index construction time consists of two parts as well: (1) time cost for the tree decomposition. (2) the time for the local shortest path generation. Here part (2) is dominant. </span></p><p class="c18"><span class="c5">Besides the standard measurements, we are also interested in the structure of the tree decomposition, which may influ- ence the performance of the algorithm. These are: </span></p><p class="c6"><span class="c0">&bull; </span><span class="c5">the number of tree nodes (#TreeN), </span></p><p class="c6"><span class="c0">&bull; </span><span class="c5">the number of all the vertices stored in the bags (#SumV), </span></p><p class="c6"><span class="c34">106 </span></p><p class="c6"><span class="c14">) %(eziSh parG/eziSt oo</span><span class="c33">Rk </span></p><p class="c6"><span class="c0">&bull; </span><span class="c5">the height of the tree (</span><span class="c0">h</span><span class="c5">), </span></p><p class="c6"><span class="c0">&bull; </span><span class="c5">the number of vertex reductions (</span><span class="c0">k</span><span class="c5">), and </span></p><p class="c6"><span class="c0">&bull; </span><span class="c5">the root size of the tree. (</span><span class="c0">|R|</span><span class="c5">). </span></p><p class="c6"><span class="c5">In our experiments, we compare our approach with the compact BFS trees proposed by Xiao et al. [23], which we denote as SYMM. To the best of our knowledge, SYMM is the state-of-the-art implementation for efficient shortest path query answering with pre-computed index structures. </span><span class="c1">4.1 Real Datasets </span></p><p class="c18"><span class="c5">We test a variety of real graph data including biologi- cal networks (PPI, Yea and Homo), social networks (Pfei, Geom, Erdos, Dutch, and Eva), information networks (Cal and Epa) and technological networks (Inter). All the graph data are provided by the authors of [23]. </span></p><p class="c18"><span class="c5">Some statistics of the graphs w.r.t. the tree decompo- sition algorithm are shown in Table 1. Note that we have chosen the optimal </span><span class="c0">k</span><span class="c5">, in order to achieve the best query time performance. </span></p><p class="c6"><span class="c8">Table 1: Statistics of real graphs and the properties of the index </span></p><p class="c18"><span class="c5">We measure the time and space cost of the index con- struction on the real datasets, and compare our results with SYMM [23]. See Table 2 for details. The index size gener- ated with TEDI has been dramatically reduced comparing with SYMM. In fact, most of the index sizes of TEDI are two orders of magnitude smaller than those generated with SYMM. For the index construction time, improvement can be shown similarly. The index construction time of TEDI on every graph is at least one order of magnitude faster than that with SYMM. </span></p><p class="c18"><span class="c5">The measurement on the index construction time and the index size confirms the complexity analysis in Section 3.3.1. The index construction time is only dependent on the graph size, whereas the index size is decided by the root size </span><span class="c0">|R|</span><span class="c5">. For instance, the graph size of Homo is 3 times small than In- ter, while the root size is two times greater than Inter. This is exactly reflected by the index size and index construction time in Table 2 respectively. </span></p><p class="c18"><span class="c5">We execute the query answering algorithm given in Algo- rithm 5. For each dataset we randomly generate 10000 pairs of vertices and query the shortest paths between each pair of vertices. To make a fair comparison, we have implemented the naive BFS algorithm. This way, we could compare the speedup of our method w.r.t BFS algorithm to the speedup of the SYMM algorithm w.r.t. BFS. The results are shown </span></p><p class="c6"><span class="c5">618 Dutsch </span></p><p class="c6"><span class="c5">Graph </span></p><p class="c6"><span class="c5">60 Gemo </span></p><p class="c6"><span class="c5">516 Homo </span></p><p class="c6"><span class="c5">832 Erdos </span></p><p class="c6"><span class="c5">101 Yeast </span></p><p class="c6"><span class="c5">1244 Inter </span></p><p class="c6"><span class="c5">623 Epa </span></p><p class="c6"><span class="c5">Pfei </span></p><p class="c6"><span class="c5">258 Eva </span></p><p class="c6"><span class="c5">405 PPI </span></p><p class="c6"><span class="c5">75 Cal </span></p><p class="c6"><span class="c5">22442 </span></p><p class="c6"><span class="c5">1738 </span></p><p class="c6"><span class="c5">3621 </span></p><p class="c6"><span class="c5">4253 </span></p><p class="c6"><span class="c5">3621 </span></p><p class="c6"><span class="c5">4475 </span></p><p class="c6"><span class="c5">5925 </span></p><p class="c6"><span class="c5">6927 </span></p><p class="c6"><span class="c5">1458 </span></p><p class="c6"><span class="c5">2284 </span></p><p class="c6"><span class="c5">7020 </span></p><p class="c6"><span class="c0">n </span></p><p class="c6"><span class="c5">#TreeN </span></p><p class="c6"><span class="c5">21757 </span></p><p class="c6"><span class="c5">1680 </span></p><p class="c6"><span class="c5">3000 </span></p><p class="c6"><span class="c5">3637 </span></p><p class="c6"><span class="c5">3442 </span></p><p class="c6"><span class="c5">4457 </span></p><p class="c6"><span class="c5">5095 </span></p><p class="c6"><span class="c5">6690 </span></p><p class="c6"><span class="c5">1359 </span></p><p class="c6"><span class="c5">1770 </span></p><p class="c6"><span class="c5">5778 </span></p><p class="c6"><span class="c5">#SumV </span></p><p class="c6"><span class="c5">11137 </span></p><p class="c6"><span class="c5">18591 </span></p><p class="c6"><span class="c5">18979 </span></p><p class="c6"><span class="c5">24359 </span></p><p class="c6"><span class="c5">67519 </span></p><p class="c6"><span class="c5">3916 </span></p><p class="c6"><span class="c5">9985 </span></p><p class="c6"><span class="c5">8700 </span></p><p class="c6"><span class="c5">9303 </span></p><p class="c6"><span class="c5">3638 </span></p><p class="c6"><span class="c5">6708 </span></p><p class="c6"><span class="c5">16 </span></p><p class="c6"><span class="c5">10 </span></p><p class="c6"><span class="c5">14 </span></p><p class="c6"><span class="c5">11 </span></p><p class="c6"><span class="c5">10 </span></p><p class="c6"><span class="c5">10 </span></p><p class="c6"><span class="c0">h </span></p><p class="c6"><span class="c5">7 </span></p><p class="c6"><span class="c5">9 </span></p><p class="c6"><span class="c5">9 </span></p><p class="c6"><span class="c5">9 </span></p><p class="c6"><span class="c5">6 </span></p><p class="c6"><span class="c5">10 </span></p><p class="c6"><span class="c5">15 </span></p><p class="c6"><span class="c5">13 </span></p><p class="c6"><span class="c0">k </span></p><p class="c6"><span class="c5">6 </span></p><p class="c6"><span class="c5">5 </span></p><p class="c6"><span class="c5">7 </span></p><p class="c6"><span class="c5">5 </span></p><p class="c6"><span class="c5">2 </span></p><p class="c6"><span class="c5">7 </span></p><p class="c6"><span class="c5">7 </span></p><p class="c6"><span class="c5">9 </span></p><p class="c6"><span class="c5">687 </span></p><p class="c6"><span class="c0">|R| </span></p><p class="c6"><span class="c8">Table 4: Statistics of the synthetic graphs and the properties of the index </span></p><p class="c18"><span class="c5">Some statistics of those graphs w.r.t. the tree decomposi- tion algorithm are shown in Table 4. Again, we have chosen the optimal </span><span class="c0">k</span><span class="c5">, in order to achieve the best query time per- formance. The measurement of the index construction time and index size is similar to those of real dataset. </span></p><p class="c18"><span class="c5">The index size and the index construction time are shown in Table 5. Figure 6(a) and 6(b) illustrate the comparison of index construction time and the index size on the synthetic datasets with SYMM. Note that due to the wide range of time and space cost, we plot the vertical axis logarithmically. The results in Figure 6(a) and 6(b) show clearly that on both the index size and the index construction time, TEDI outperforms the approach SYMM with the improvement of more than an order of magnitude. </span></p><p class="c6"><span class="c5">Since SYMM does not present the query time for the syn- thetic data, we can not make a comparison on that. Instead, </span></p><p class="c6"><span class="c34">107 </span></p><p class="c6"><span class="c5">in Table 3. Surprisingly, the speedup for all the datasets, except for one graph, is higher than that of SYMM. </span></p><p class="c6"><span class="c5">In summary, TEDI algorithm is superior to SYMM in </span><span class="c0">all </span><span class="c5">aspects. </span></p><p class="c6"><span class="c8">Table 3: Comparison between TEDI and SYMM on query time over real dataset. </span></p><p class="c6"><span class="c1">4.2 Synthetic Data </span></p><p class="c18"><span class="c5">We have generated synthetic graphs according to the BA model [3], a widely used model to simulate real graphs. To make a fair comparison, we set </span><span class="c0">k </span><span class="c5">= 1</span><span class="c0">.</span><span class="c5">1, so that the average degree of the graph generated is 2</span><span class="c0">k</span><span class="c5">, which is identical to the synthetic datasets in [23]. We vary the graph size from 1000 to 10000 vertices by the step of 1000. </span></p><p class="c6"><span class="c5">39.62 Dutsch </span></p><p class="c6"><span class="c5">Graph </span></p><p class="c6"><span class="c5">25.63 Homo </span></p><p class="c6"><span class="c5">13.04 Gemo </span></p><p class="c6"><span class="c5">59.31 Erdos </span></p><p class="c6"><span class="c5">13.30 Yeast </span></p><p class="c6"><span class="c5">N.a. Inter </span></p><p class="c6"><span class="c5">Graph </span></p><p class="c6"><span class="c5">41.10 Epa </span></p><p class="c6"><span class="c5">57.72 PPI </span></p><p class="c6"><span class="c5">Pfei </span></p><p class="c6"><span class="c5">28.21 Eva </span></p><p class="c6"><span class="c5">20.20 Cal </span></p><p class="c6"><span class="c5">194 1k 2k </span></p><p class="c6"><span class="c5">272 3k </span></p><p class="c6"><span class="c5">361 4k </span></p><p class="c6"><span class="c5">443 5k </span></p><p class="c6"><span class="c5">542 6k </span></p><p class="c6"><span class="c5">612 7k </span></p><p class="c6"><span class="c5">710 8k </span></p><p class="c6"><span class="c5">801 9k </span></p><p class="c6"><span class="c5">913 10k </span></p><p class="c6"><span class="c5">TEDI (ms) </span></p><p class="c6"><span class="c5">10000 </span></p><p class="c6"><span class="c5">1000 </span></p><p class="c6"><span class="c5">2000 </span></p><p class="c6"><span class="c5">3000 </span></p><p class="c6"><span class="c5">4000 </span></p><p class="c6"><span class="c5">5000 </span></p><p class="c6"><span class="c5">6000 </span></p><p class="c6"><span class="c5">7000 </span></p><p class="c6"><span class="c5">8000 </span></p><p class="c6"><span class="c5">9000 </span></p><p class="c6"><span class="c5">0.003420 </span></p><p class="c6"><span class="c5">0.002933 </span></p><p class="c6"><span class="c5">0.002096 </span></p><p class="c6"><span class="c5">0.002655 </span></p><p class="c6"><span class="c5">0.002299 </span></p><p class="c6"><span class="c5">0.003325 </span></p><p class="c6"><span class="c5">0.002037 </span></p><p class="c6"><span class="c5">0.002629 </span></p><p class="c6"><span class="c5">0.002463 </span></p><p class="c6"><span class="c5">0.007666 </span></p><p class="c6"><span class="c5">0.004178 </span></p><p class="c6"><span class="c0">n </span></p><p class="c6"><span class="c5">#TreeN </span></p><p class="c6"><span class="c5">1730 </span></p><p class="c6"><span class="c5">2641 </span></p><p class="c6"><span class="c5">3559 </span></p><p class="c6"><span class="c5">4460 </span></p><p class="c6"><span class="c5">5355 </span></p><p class="c6"><span class="c5">6292 </span></p><p class="c6"><span class="c5">7201 </span></p><p class="c6"><span class="c5">8089 </span></p><p class="c6"><span class="c5">8983 </span></p><p class="c6"><span class="c5">TEDI </span></p><p class="c6"><span class="c5">808 </span></p><p class="c6"><span class="c5">0.052 </span></p><p class="c6"><span class="c5">0.123 </span></p><p class="c6"><span class="c5">0.105 </span></p><p class="c6"><span class="c5">0.097 </span></p><p class="c6"><span class="c5">0.089 </span></p><p class="c6"><span class="c5">0.187 </span></p><p class="c6"><span class="c5">0.146 </span></p><p class="c6"><span class="c5">0.050 </span></p><p class="c6"><span class="c5">0.071 </span></p><p class="c6"><span class="c5">0.226 </span></p><p class="c6"><span class="c5">0.693 </span></p><p class="c6"><span class="c5">BFS </span></p><p class="c6"><span class="c5">#SumV </span></p><p class="c6"><span class="c5">Speedup </span></p><p class="c6"><span class="c5">10131 </span></p><p class="c6"><span class="c5">12758 </span></p><p class="c6"><span class="c5">15371 </span></p><p class="c6"><span class="c5">18626 </span></p><p class="c6"><span class="c5">20790 </span></p><p class="c6"><span class="c5">23497 </span></p><p class="c6"><span class="c5">26224 </span></p><p class="c6"><span class="c5">2131 </span></p><p class="c6"><span class="c5">4786 </span></p><p class="c6"><span class="c5">7362 </span></p><p class="c6"><span class="c5">169.0 </span></p><p class="c6"><span class="c5">15.2 </span></p><p class="c6"><span class="c5">42.4 </span></p><p class="c6"><span class="c5">50.0 </span></p><p class="c6"><span class="c5">37.3 </span></p><p class="c6"><span class="c5">38.7 </span></p><p class="c6"><span class="c5">56.7 </span></p><p class="c6"><span class="c5">71.9 </span></p><p class="c6"><span class="c5">19.2 </span></p><p class="c6"><span class="c5">28.4 </span></p><p class="c6"><span class="c5">29.7 </span></p><p class="c6"><span class="c5">11 </span></p><p class="c6"><span class="c5">10 </span></p><p class="c6"><span class="c5">10 </span></p><p class="c6"><span class="c5">10 </span></p><p class="c6"><span class="c5">10 </span></p><p class="c6"><span class="c5">12 </span></p><p class="c6"><span class="c5">11 </span></p><p class="c6"><span class="c5">12 </span></p><p class="c6"><span class="c5">11 </span></p><p class="c6"><span class="c0">h </span></p><p class="c6"><span class="c5">9 </span></p><p class="c6"><span class="c5">SYMM [23] </span></p><p class="c6"><span class="c0">k </span></p><p class="c6"><span class="c5">3 </span></p><p class="c6"><span class="c5">5 </span></p><p class="c6"><span class="c5">6 </span></p><p class="c6"><span class="c5">7 </span></p><p class="c6"><span class="c5">8 </span></p><p class="c6"><span class="c5">9 </span></p><p class="c6"><span class="c5">9 </span></p><p class="c6"><span class="c5">9 </span></p><p class="c6"><span class="c5">9 </span></p><p class="c6"><span class="c5">9 </span></p><p class="c6"><span class="c5">Speedup </span></p><p class="c6"><span class="c5">1019 </span></p><p class="c6"><span class="c5">N.a. </span></p><p class="c6"><span class="c0">|R| </span></p><p class="c6"><span class="c8">Table 2: Comparison between TEDI and SYMM on index construction of real dataset. </span></p><p class="c6"><span class="c33">Comparison of Index Construction Time (s) </span><span class="c14">100 </span></p><p class="c6"><span class="c33">TEDI </span><span class="c31">SYMM </span></p><p class="c26"><span class="c14">10 1 </span><span class="c33">0.1 1k 2k 3k 4k 5k 6k 7k 8k 9k 10k </span><span class="c5">(a) </span></p><p class="c6"><span class="c33">Comparison of Index Size (MB) </span></p><p class="c6"><span class="c14">100 </span></p><p class="c6"><span class="c33">TEDI </span><span class="c31">SYMM </span></p><p class="c26"><span class="c14">10 1 </span><span class="c33">0.1 1k 2k 3k 4k 5k 6k 7k 8k 9k 10k </span><span class="c5">(b) </span></p><p class="c6"><span class="c8">Figure 6: Comparison of index construction time and size on synthetic data </span></p><p class="c6"><span class="c5">37.14 Dutsch </span></p><p class="c6"><span class="c5">Graph </span></p><p class="c6"><span class="c5">7.578 Homo </span></p><p class="c6"><span class="c5">2.688 Gemo </span></p><p class="c6"><span class="c5">34.094 Erdos </span></p><p class="c6"><span class="c5">1.547 Yeast </span></p><p class="c6"><span class="c5">53.985 Inter </span></p><p class="c6"><span class="c5">14.859 Epa </span></p><p class="c6"><span class="c5">Pfei </span></p><p class="c6"><span class="c5">90.453 PPI </span></p><p class="c6"><span class="c5">13.687 Eva </span></p><p class="c6"><span class="c5">289.532 Cal </span></p><p class="c6"><span class="c5">paths </span></p><p class="c6"><span class="c5">0.025 </span></p><p class="c6"><span class="c5">0.404 </span></p><p class="c6"><span class="c5">0.026 </span></p><p class="c6"><span class="c5">0.516 </span></p><p class="c6"><span class="c5">0.052 </span></p><p class="c6"><span class="c5">1.81 </span></p><p class="c6"><span class="c5">1.63 </span></p><p class="c6"><span class="c5">3.04 </span></p><p class="c6"><span class="c5">1.08 </span></p><p class="c6"><span class="c5">6.88 </span></p><p class="c6"><span class="c5">1.66 </span></p><p class="c6"><span class="c5">0.008 </span></p><p class="c6"><span class="c5">0.020 </span></p><p class="c6"><span class="c5">0.022 </span></p><p class="c6"><span class="c5">0.016 </span></p><p class="c6"><span class="c5">0.018 </span></p><p class="c6"><span class="c5">0.038 </span></p><p class="c6"><span class="c5">0.018 </span></p><p class="c6"><span class="c5">0.008 </span></p><p class="c6"><span class="c5">0.014 </span></p><p class="c6"><span class="c5">0.048 </span></p><p class="c6"><span class="c5">0.136 </span></p><p class="c6"><span class="c5">tree </span></p><p class="c6"><span class="c5">Index Size (MB) </span></p><p class="c6"><span class="c5">TEDI </span></p><p class="c6"><span class="c5">0.033 </span></p><p class="c6"><span class="c5">1.830 </span></p><p class="c6"><span class="c5">1.652 </span></p><p class="c6"><span class="c5">0.420 </span></p><p class="c6"><span class="c5">0.044 </span></p><p class="c6"><span class="c5">3.078 </span></p><p class="c6"><span class="c5">0.534 </span></p><p class="c6"><span class="c5">0.060 </span></p><p class="c6"><span class="c5">1.094 </span></p><p class="c6"><span class="c5">6.928 </span></p><p class="c6"><span class="c5">1.796 </span></p><p class="c6"><span class="c5">SYMM [23] </span></p><p class="c6"><span class="c5">744.07478 </span></p><p class="c6"><span class="c5">44.9907 </span></p><p class="c6"><span class="c5">28.1992 </span></p><p class="c6"><span class="c5">20.8559 </span></p><p class="c6"><span class="c5">32.2695 </span></p><p class="c6"><span class="c5">19.4457 </span></p><p class="c6"><span class="c5">7.9243 </span></p><p class="c6"><span class="c5">5.5447 </span></p><p class="c6"><span class="c5">92.026 </span></p><p class="c6"><span class="c5">21.574 </span></p><p class="c6"><span class="c5">5.954 </span></p><p class="c6"><span class="c8">Table 6: TEDI query time on synthetic datasets </span></p><p class="c6"><span class="c1">4.3 Scalability over Large Datasets </span></p><p class="c18"><span class="c5">To test the scalability of our approach, we conduct the experiments on much larger datasets. We have chosen two datasets. The first one is DBLP dataset. We first gener- </span></p><p class="c6"><span class="c34">108 </span></p><p class="c6"><span class="c8">Table 5: Index Construction of synthetic dataset </span></p><p class="c18"><span class="c5">we report the query time on synthetic graphs with TEDI and compare the results with the BFS algorithms. The results is given in Table 6. Interestingly, the speedup to the naive BFS method increases, as the size of the graph grows. This observation will be confirmed in the next section, namely on very large datasets, the speedup of the query time to BFS can be increased substantially. </span></p><p class="c6"><span class="c5">Graph </span></p><p class="c6"><span class="c5">0.003 </span></p><p class="c6"><span class="c5">0.068 </span></p><p class="c6"><span class="c5">0.056 </span></p><p class="c6"><span class="c5">0.011 </span></p><p class="c6"><span class="c5">0.006 </span></p><p class="c6"><span class="c5">0.145 </span></p><p class="c6"><span class="c5">0.038 </span></p><p class="c6"><span class="c5">0.004 </span></p><p class="c6"><span class="c5">0.019 </span></p><p class="c6"><span class="c5">0.198 </span></p><p class="c6"><span class="c5">0.796 </span></p><p class="c6"><span class="c5">0.091 1k 2k </span></p><p class="c6"><span class="c5">0.227 3k </span></p><p class="c6"><span class="c5">0.409 4k </span></p><p class="c6"><span class="c5">0.663 5k </span></p><p class="c6"><span class="c5">0.993 6k </span></p><p class="c6"><span class="c5">1.456 7k </span></p><p class="c6"><span class="c5">2.134 8k </span></p><p class="c6"><span class="c5">2.491 9k </span></p><p class="c6"><span class="c5">3.252 10k </span></p><p class="c6"><span class="c0">t</span><span class="c4">tree </span></p><p class="c6"><span class="c5">Graph </span></p><p class="c6"><span class="c5">15.858 </span></p><p class="c6"><span class="c5">paths </span></p><p class="c6"><span class="c0">t</span><span class="c9">paths </span></p><p class="c6"><span class="c5">0.099 </span></p><p class="c6"><span class="c5">0.878 </span></p><p class="c6"><span class="c5">0.311 </span></p><p class="c6"><span class="c5">0.239 </span></p><p class="c6"><span class="c5">2.535 </span></p><p class="c6"><span class="c5">0.849 </span></p><p class="c6"><span class="c5">0.130 </span></p><p class="c6"><span class="c5">0.566 </span></p><p class="c6"><span class="c5">7.745 </span></p><p class="c6"><span class="c5">50.0 10k </span></p><p class="c6"><span class="c5">0.27 </span></p><p class="c6"><span class="c5">0.61 </span></p><p class="c6"><span class="c5">1.16 </span></p><p class="c6"><span class="c5">1.76 </span></p><p class="c6"><span class="c5">2.68 </span></p><p class="c6"><span class="c5">10.2 </span></p><p class="c6"><span class="c5">1k </span></p><p class="c6"><span class="c5">17.5 2k </span></p><p class="c6"><span class="c5">25.0 3k </span></p><p class="c6"><span class="c5">29.5 4k </span></p><p class="c6"><span class="c5">31.6 5k </span></p><p class="c6"><span class="c5">39.5 6k </span></p><p class="c6"><span class="c5">40.4 7k </span></p><p class="c6"><span class="c5">43.4 8k </span></p><p class="c6"><span class="c5">47.5 9k </span></p><p class="c6"><span class="c5">0.97 </span></p><p class="c6"><span class="c5">4.0 </span></p><p class="c6"><span class="c5">4.6 </span></p><p class="c6"><span class="c5">6.2 </span></p><p class="c6"><span class="c5">8.2 </span></p><p class="c6"><span class="c5">Index Size (MB) </span></p><p class="c6"><span class="c5">Index Time (s) </span></p><p class="c6"><span class="c5">0.004 </span></p><p class="c6"><span class="c5">0.010 </span></p><p class="c6"><span class="c5">0.014 </span></p><p class="c6"><span class="c5">0.020 </span></p><p class="c6"><span class="c5">0.025 </span></p><p class="c6"><span class="c5">0.030 </span></p><p class="c6"><span class="c5">0.036 </span></p><p class="c6"><span class="c5">0.042 </span></p><p class="c6"><span class="c5">0.047 </span></p><p class="c6"><span class="c5">0.052 </span></p><p class="c6"><span class="c5">TEDI (ms) </span></p><p class="c6"><span class="c5">16.654 </span></p><p class="c6"><span class="c5">tree </span></p><p class="c6"><span class="c5">TEDI </span></p><p class="c6"><span class="c5">0.102 </span></p><p class="c6"><span class="c5">0.946 </span></p><p class="c6"><span class="c5">1.026 </span></p><p class="c6"><span class="c5">0.322 </span></p><p class="c6"><span class="c5">0.245 </span></p><p class="c6"><span class="c5">2.680 </span></p><p class="c6"><span class="c5">0.887 </span></p><p class="c6"><span class="c5">0.134 </span></p><p class="c6"><span class="c5">0.585 </span></p><p class="c6"><span class="c5">7.943 </span></p><p class="c6"><span class="c5">0.001545 </span></p><p class="c6"><span class="c5">0.002073 </span></p><p class="c6"><span class="c5">0.002645 </span></p><p class="c6"><span class="c5">0.003286 </span></p><p class="c6"><span class="c5">0.003674 </span></p><p class="c6"><span class="c5">0.004155 </span></p><p class="c6"><span class="c5">0.004450 </span></p><p class="c6"><span class="c5">0.004754 </span></p><p class="c6"><span class="c5">0.005135 </span></p><p class="c6"><span class="c5">0.005722 </span></p><p class="c6"><span class="c5">10.052 </span></p><p class="c6"><span class="c5">TEDI </span></p><p class="c6"><span class="c5">0.274 </span></p><p class="c6"><span class="c5">0.620 </span></p><p class="c6"><span class="c5">1.174 </span></p><p class="c6"><span class="c5">1.780 </span></p><p class="c6"><span class="c5">2.705 </span></p><p class="c6"><span class="c5">4.030 </span></p><p class="c6"><span class="c5">4.636 </span></p><p class="c6"><span class="c5">6.242 </span></p><p class="c6"><span class="c5">8.247 </span></p><p class="c6"><span class="c5">Query Time </span></p><p class="c6"><span class="c5">SYMM [23] </span></p><p class="c6"><span class="c5">1709.64 </span></p><p class="c6"><span class="c5">0.027 </span></p><p class="c6"><span class="c5">0.050 </span></p><p class="c6"><span class="c5">0.078 </span></p><p class="c6"><span class="c5">0.104 </span></p><p class="c6"><span class="c5">0.145 </span></p><p class="c6"><span class="c5">0.168 </span></p><p class="c6"><span class="c5">0.193 </span></p><p class="c6"><span class="c5">0.226 </span></p><p class="c6"><span class="c5">0.257 </span></p><p class="c6"><span class="c5">0.299 </span></p><p class="c6"><span class="c5">BFS </span></p><p class="c6"><span class="c5">0.003 </span></p><p class="c6"><span class="c5">0.010 </span></p><p class="c6"><span class="c5">0.024 </span></p><p class="c6"><span class="c5">0.038 </span></p><p class="c6"><span class="c5">0.040 </span></p><p class="c6"><span class="c5">0.081 </span></p><p class="c6"><span class="c5">0.092 </span></p><p class="c6"><span class="c5">0.091 </span></p><p class="c6"><span class="c5">0.124 </span></p><p class="c6"><span class="c5">0.167 </span></p><p class="c6"><span class="c0">t</span><span class="c4">tree </span></p><p class="c6"><span class="c5">Index Time (s) </span></p><p class="c6"><span class="c5">Speedup </span></p><p class="c6"><span class="c0">t</span><span class="c9">paths </span></p><p class="c6"><span class="c5">0.088 </span></p><p class="c6"><span class="c5">0.217 </span></p><p class="c6"><span class="c5">0.385 </span></p><p class="c6"><span class="c5">0.625 </span></p><p class="c6"><span class="c5">0.953 </span></p><p class="c6"><span class="c5">1.340 </span></p><p class="c6"><span class="c5">1.942 </span></p><p class="c6"><span class="c5">2.400 </span></p><p class="c6"><span class="c5">3.128 </span></p><p class="c6"><span class="c5">4.274 </span></p><p class="c6"><span class="c5">52.3 </span></p><p class="c6"><span class="c5">TEDI </span></p><p class="c6"><span class="c5">4.441 </span></p><p class="c18"><span class="c5">ate an undirected graph from the DBLP N-triple dump </span><span class="c20">3</span><span class="c5">. The dataset contains all the </span><span class="c35">inproceeding </span><span class="c5">records and all </span><span class="c35">proceedings </span><span class="c5">records, with all their persons, publishers, se- ries and relations between persons and inproceedings. To highlight the purpose of shortest path query answering, we removed elements in each paper that are not interesting to keyword search, such as url, ee, etc. Finally, we get a graph containing 593</span><span class="c0">K </span><span class="c5">vertices. </span></p><p class="c18"><span class="c5">The second large dataset is the road network of the San Francisco Bay area </span><span class="c20">4 </span><span class="c5">denoted as BAY. The graph contains 321</span><span class="c0">K </span><span class="c5">vertices. </span></p><p class="c6"><span class="c14">100 </span><span class="c33">DBLP BAY </span></p><p class="c26"><span class="c14">) %(eziSh parG/eziSt oo</span><span class="c33">R</span><span class="c14">10 1 </span><span class="c33">0.1 0 10 20 30 40 50 60 70 k </span></p><p class="c6"><span class="c8">Figure 7: </span><span class="c0">k </span><span class="c8">and </span><span class="c0">|R| </span><span class="c8">relationships for large data </span></p><p class="c18"><span class="c5">Figure 7 illustrates the relationship of </span><span class="c0">k </span><span class="c5">and </span><span class="c0">|R| </span><span class="c5">w.r.t. the reduction step of the tree decomposition process. Table 7 shows some characteristics of the graphs. The curves in Figure 7 exposes distinct features of the </span><span class="c0">k &minus;|R| </span><span class="c5">relationship on DBLP and BAY. For DBLP, the root size </span><span class="c0">|R| </span><span class="c5">can hardly be reduced after 4000 (approximately 0</span><span class="c0">.</span><span class="c5">67% of the graph size). On the other hand, the root size of BAY remains de- creasing continuously. The results of the tree decomposition reflect these differences. The decomposed tree of BAY has a much smaller root size than that of DBLP (245 vs. 3821). However, the height of BAY is correspondingly greater than DBLP (30 vs. 351). This implies that the BAY dataset requires less space for index structure, but the query time is longer. For DBLP, the query time is much shorter be- cause of the smaller height of the tree, but the price to pay is greater index size. All of these observations are reflected in the Table 8 and 9. </span></p><p class="c6"><span class="c8">Table 7: Statistics of large graphs and the properties of the index </span></p><p class="c6"><span class="c5">The experimental result on large graphs demonstrate clearly that the TEDI approach scales well on large dataset. More- over, the query time speedup is more substantial, in com- parison to the relatively smaller graphs. </span></p><p class="c6"><span class="c5">As far as the index time is concerned, the experimental results are against the complexity analysis of </span><span class="c0">O</span><span class="c5">(</span><span class="c0">n</span><span class="c20">2</span><span class="c5">). The </span></p><p class="c6"><span class="c11">3</span><span class="c17">http://www4.wiwiss.fu-berlin.de/bizer/d2rq/benchmarks </span><span class="c11">4</span><span class="c17">http://www.dis.uniroma1.it/</span><span class="c7">&sim;</span><span class="c17">challenge9/download.shtml </span></p><p class="c6"><span class="c5">Graph </span></p><p class="c6"><span class="c5">3821 DBLP BAY </span></p><p class="c6"><span class="c5">592 983 </span></p><p class="c6"><span class="c5">321 272 </span></p><p class="c6"><span class="c0">n </span></p><p class="c6"><span class="c5">#TreeN </span></p><p class="c6"><span class="c5">589 164 </span></p><p class="c6"><span class="c5">321 028 </span></p><p class="c6"><span class="c5">1 309 710 </span></p><p class="c6"><span class="c5">1 298 993 </span></p><p class="c6"><span class="c5">#SumV </span></p><p class="c6"><span class="c5">351 </span></p><p class="c6"><span class="c5">30 </span></p><p class="c6"><span class="c0">h </span></p><p class="c6"><span class="c5">100 </span></p><p class="c6"><span class="c5">80 </span></p><p class="c6"><span class="c0">k </span></p><p class="c6"><span class="c5">245 </span></p><p class="c6"><span class="c0">|R| </span></p><p class="c6"><span class="c8">Table 9: Comparison of TEDI query time on large datasets to BFS </span></p><p class="c6"><span class="c1">5. RELATED WORK </span></p><p class="c18"><span class="c5">The classic shortest path algorithm deploys Breadth First Search, which can be implemented with a queue [16]. In recent years, many efficient algorithms with preprocessing have been proposed for finding the shortest paths. The graphs under consideration have some special constraints such as edge weights. See [8, 11]. A survey paper on vari- ous versions of algorithms are presented in [9]. All of these methods are based on heuristics designed specifically on the underlying datasets (like GIS data). It is unknown, whether the algorithms can be extended to dealing the other graph datasets. Moreover, one assumption common to all those algorithms is that the whole graph can be stored in main memory. </span></p><p class="c18"><span class="c5">Another related graph query problem &ndash; which is more in- tensively studied in the database community &ndash; is the reach- ability query answering. Many approaches have been pro- posed to first pre-compute the transitive closure, so that the reachability queries can be more efficiently answered com- paring to BFS or DFS. The </span><span class="c0">2-HOP approach </span><span class="c5">[7] proposes selecting a small amount of vertices that can be stored as landmark to facilitate the query answering. However, the time cost for generating such an optimized vertex set is too high to be practical (</span><span class="c0">O</span><span class="c5">(</span><span class="c0">n</span><span class="c20">3</span><span class="c5">)). Some approximation algo- rithms to 2-HOP are proposed [19]. Another category of reachability query answering algorithms is so-called </span><span class="c0">inter- val labeling approach </span><span class="c5">[1, 22, 6, 21, 14]. These methods first extract some tree from the graph, then store the transitive closure of the rest of the vertices. Good performance has been obtained for sparse graphs. Recently, Jin et al. have proposed the 3-HOP algorithm for reachability query an- swering on dense graphs [13]. None of these methods can be extended to cope with the shortest path query answer- ing. Given </span><span class="c0">u, v </span><span class="c5">in a graph, reachability queries require only a boolean answer (yes or no). Therefore, the transitive clo- sure stored in the index can be drastically compressed, as long as the boolean query can be correctly answered. On the other hand, shortest path queries require that the paths to be returned. Therefore, the compression methods with the </span></p><p class="c6"><span class="c34">109 </span></p><p class="c6"><span class="c8">Table 8: Index construction of large dataset. </span></p><p class="c18"><span class="c5">reason for this is that the average shortest path length of BAY graph is much longer than that of DBLP. Therefore, the time cost of the BFS algorithm for BAY is greater than DBLP. </span></p><p class="c6"><span class="c5">Graph </span></p><p class="c6"><span class="c5">2226.4 DBLP BAY </span></p><p class="c6"><span class="c5">Graph </span></p><p class="c6"><span class="c5">590.0 DBLP BAY </span></p><p class="c6"><span class="c5">paths </span></p><p class="c6"><span class="c5">117.2 </span></p><p class="c6"><span class="c5">24.7 </span></p><p class="c6"><span class="c5">Index Size (MB) </span></p><p class="c6"><span class="c5">TEDI (ms) </span></p><p class="c6"><span class="c5">tree </span></p><p class="c6"><span class="c5">2.6 </span></p><p class="c6"><span class="c5">2.6 </span></p><p class="c6"><span class="c5">0.055 </span></p><p class="c6"><span class="c5">0.258 </span></p><p class="c6"><span class="c5">TEDI </span></p><p class="c6"><span class="c5">119.8 </span></p><p class="c6"><span class="c5">27.3 </span></p><p class="c6"><span class="c5">Query Time </span></p><p class="c6"><span class="c5">BFS (ms) </span></p><p class="c6"><span class="c5">102.4 </span></p><p class="c6"><span class="c5">182.2 </span></p><p class="c6"><span class="c0">t</span><span class="c4">tree </span></p><p class="c6"><span class="c5">32.47 </span></p><p class="c6"><span class="c5">20.54 </span></p><p class="c6"><span class="c5">Index Time (s) </span></p><p class="c6"><span class="c5">2124.0 </span></p><p class="c6"><span class="c5">2859.7 </span></p><p class="c6"><span class="c0">t</span><span class="c9">paths </span></p><p class="c6"><span class="c5">Speedup </span></p><p class="c6"><span class="c5">80.0 </span></p><p class="c6"><span class="c5">3041.9 </span></p><p class="c6"><span class="c5">TEDI </span></p><p class="c6 c92"><span class="c5">information loss can not be adapted for answering shortest path queries. </span></p><p class="c80"><span class="c1">6. CONCLUSIONS AND FUTURE WORK </span></p><p class="c58"><span class="c5">In this paper, we introduced an indexing and query an- swering scheme based on the tree decomposition concept for the shortest path query answering. The careful the- oretical analysis has shown that our approach is intuitive and efficient. Through extensive experiments over various datasets, we demonstrate that TEDI achieves the improve- ment of performance by more than an order of magnitude in </span><span class="c0">all </span><span class="c5">aspects including query time, index construction time and index size. Moreover, the algorithm scales well over large datasets. </span></p><p class="c46"><span class="c5">In the future we plan to investigate the following prob- lems: (1) Development more heuristics for the tree decom- position algorithms. (2) The integration of A* heuristics for a more efficient query answering. (3) Maintenance of the index structure. Furthermore, we will consider on-disk al- gorithms for both index construction and query answering. </span></p><p class="c70"><span class="c1">7. REFERENCES </span></p><p class="c28"><span class="c5">[1] R. Agrawal, A. Borgida, and H. V. Jagadish. Efficient </span></p><p class="c32"><span class="c5">management of transitive relationships in large data and knowledge bases. In </span><span class="c0">SIGMOD</span><span class="c5">, 1989. [2] S. Arnborg, D. G. Corneil, and A. Proskurowski. </span></p><p class="c36"><span class="c5">Complexity of finding embeddings in a k-tree. </span><span class="c0">SIAM J. Algebraic Discrete Methods</span><span class="c5">, 8(2):277&ndash;284, 1987. [3] A. L. Barabasi and R. Albert. Emergence of scaling in </span></p><p class="c79"><span class="c5">random networks. </span><span class="c0">Science</span><span class="c5">, 286(5439), October 1999. [4] H. L. Bodlaender. A tourist guide through treewidth. </span></p><p class="c55"><span class="c0">Acta Cybernetica</span><span class="c5">, 11:1&ndash;23, 1993. [5] H. L. Bodlaender, A. M. C. A. Koster, and F. van den </span></p><p class="c60"><span class="c5">Eijkhof. Pre-processing rules for triangulation of probabilistic networks. </span><span class="c0">Computational Intelligence</span><span class="c5">, 21(3):286&ndash;305, 2005. [6] L. Chen, A. Gupta, and M. E. Kurul. Stack-based </span></p><p class="c62"><span class="c5">algorithms for pattern matching on dags. In </span><span class="c0">VLDB</span><span class="c5">, 2005. [7] E. Cohen, E. Halperin, H. Kaplan, and U. Zwick. </span></p><p class="c38"><span class="c5">Reachability and distance queries via 2-hop labels. </span><span class="c0">SIAM J. Comput.</span><span class="c5">, 32(5):1338&ndash;1355, 2003. [8] A. Goldberg and C. Harrelson. Computing the </span></p><p class="c13"><span class="c5">shortest path: A* search meets graph theory. In </span><span class="c0">SODA</span><span class="c5">. SIAM, 2005. </span></p><p class="c6 c71"><span class="c5">[9] A. V. Goldberg. Point-to-point shortest path </span></p><p class="c75"><span class="c5">algorithms with preprocessing. In </span><span class="c0">SOFSEM (1)</span><span class="c5">, 2007. [10] G. Gottlob, R. Pichler, and F. Wei. Tractable </span></p><p class="c45"><span class="c5">database design through bounded treewidth. In </span><span class="c0">PODS</span><span class="c5">, pages 124&ndash;133, 2006. [11] R. Gutman. Reach-based routing: A new approach to shortest path algorithms optimized for road networks. In </span><span class="c0">ALENEX</span><span class="c5">. SIAM, 2004. [12] H. He, H. Wang, J. Yang, and P. S. Yu. Blinks: ranked keyword searches on graphs. In </span><span class="c0">SIGMOD</span><span class="c5">. ACM, 2007. [13] R. Jin, Y. Xiang, N. Ruan, and D. Fuhry. 3-hop: a </span></p><p class="c94"><span class="c5">high-compression indexing scheme for reachability query. In </span><span class="c0">SIGMOD</span><span class="c5">. ACM, 2009. [14] R. Jin, Y. Xiang, N. Ruan, and H. Wang. Efficiently answering reachability queries on very large directed graphs. In </span><span class="c0">SIGMOD</span><span class="c5">, 2008. [15] K. Kask, R. Dechter, J. Larrosa, and A. Dechter. Unifying tree decompositions for reasoning in graphical models. </span><span class="c0">Artif. Intell.</span><span class="c5">, 166(1-2):165&ndash;193, 2005. [16] D. E. Knuth. </span><span class="c0">Art of Computer Programming, Volume </span></p><p class="c50"><span class="c0">1: Fundamental Algorithms (3rd Edition)</span><span class="c5">. 1997. [17] A. Koster, H. L. Bodlaender, and S. P. M. V. Hoesel. Treewidth: Computational experiments. In </span><span class="c0">Electronic Notes in Discrete Mathematics</span><span class="c5">, pages 54&ndash;57. Elsevier Science Publishers, 2001. [18] P. D. Robertson, Neil; Seymour. Graph minors iii: </span></p><p class="c88 c91"><span class="c5">Planar tree-width. </span><span class="c0">Journal of Combinatorial Theory</span><span class="c5">, Series B 36:49&ndash;64, 1984. [19] R. Schenkel, A. Theobald, and G. Weikum. Efficient </span></p><p class="c88 c93"><span class="c5">creation and incremental maintenance of the hopi index for complex xml document collections. In </span><span class="c0">ICDE</span><span class="c5">, pages 360&ndash;371, 2005. [20] T. Tran, H. Wang, S. Rudolph, and P. Cimiano. Top-k </span></p><p class="c87 c88"><span class="c5">exploration of query candidates for efficient keyword search on graph-shaped (rdf) data. In </span><span class="c0">ICDE</span><span class="c5">. IEEE, 2009. [21] S. Trissl and U. Leser. Fast and practical indexing and querying of very large graphs. In </span><span class="c0">SIGMOD</span><span class="c5">, 2007. [22] H. Wang, H. He, J. Yang, P. S. Yu, and J. X. Yu. Dual </span></p><p class="c44"><span class="c5">labeling: Answering graph reachability queries in constant time. In </span><span class="c0">ICDE</span><span class="c5">, 2006. [23] Y. Xiao, W. Wu, J. Pei, W. Wang, and Z. He. </span></p><p class="c54"><span class="c5">Efficiently indexing shortest paths by exploiting symmetry in graphs. In </span><span class="c0">EDBT</span><span class="c5">, 2009. </span></p><p class="c37"><span class="c34">110 </span></p></body></html>