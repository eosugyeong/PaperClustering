<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c103{margin-left:-15.7pt;padding-top:1.9pt;text-indent:25.5pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19pt}.c149{margin-left:28.1pt;padding-top:10.8pt;text-indent:-13.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:90.9pt}.c49{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10.3pt;font-family:"Arial";font-style:normal}.c86{margin-left:-18pt;padding-top:2.2pt;text-indent:27.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18.8pt}.c154{margin-left:-18.7pt;padding-top:2.2pt;text-indent:34.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.6pt}.c169{margin-left:-18.7pt;padding-top:14.2pt;text-indent:29pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.8pt}.c105{margin-left:-16.9pt;padding-top:9.4pt;text-indent:27.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18pt}.c212{margin-left:-17.1pt;padding-top:7.7pt;text-indent:27.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18pt}.c25{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.3pt;font-family:"Arial";font-style:normal}.c24{margin-left:-16.9pt;padding-top:8.2pt;text-indent:27pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18.2pt}.c107{margin-left:-15.7pt;padding-top:2.9pt;text-indent:70.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:18.5pt}.c111{margin-left:-19pt;padding-top:1.9pt;text-indent:28.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.6pt}.c188{margin-left:-19pt;padding-top:17.5pt;text-indent:19.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.8pt}.c124{margin-left:-18.5pt;padding-top:1.2pt;text-indent:59pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:43.6pt}.c27{margin-left:-17.1pt;padding-top:2.2pt;text-indent:27.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.7pt}.c178{margin-left:-18pt;padding-top:2.2pt;text-indent:27.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18.6pt}.c148{margin-left:-19pt;padding-top:10.8pt;text-indent:19.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.8pt}.c14{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10.3pt;font-family:"Courier New";font-style:normal}.c82{margin-left:-16.2pt;padding-top:8.2pt;text-indent:26.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19pt}.c9{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12.1pt;font-family:"Arial";font-style:normal}.c43{margin-left:-18.5pt;padding-top:2.2pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.6pt}.c36{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10.9pt;font-family:"Arial";font-style:normal}.c61{margin-left:-15.7pt;padding-top:2.2pt;text-indent:25.5pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.2pt}.c147{margin-left:-18.7pt;padding-top:1.9pt;text-indent:28.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.6pt}.c16{color:#595959;font-weight:400;text-decoration:none;vertical-align:super;font-size:6.6pt;font-family:"Arial";font-style:normal}.c179{margin-left:-16.8pt;padding-top:1pt;text-indent:72pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-3.4pt}.c8{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:12.1pt;font-family:"Courier New";font-style:normal}.c191{margin-left:-18.5pt;padding-top:1.9pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.4pt}.c13{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c139{margin-left:-18.5pt;padding-top:2.2pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.4pt}.c165{margin-left:-18pt;padding-top:2.2pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18.3pt}.c46{color:#595959;font-weight:400;text-decoration:none;vertical-align:super;font-size:7.9pt;font-family:"Arial";font-style:normal}.c202{margin-left:-17.1pt;padding-top:1.9pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-20.4pt}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:12.1pt;font-family:"Arial";font-style:normal}.c120{margin-left:-17.1pt;padding-top:7.9pt;text-indent:27.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18pt}.c67{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Courier New";font-style:normal}.c39{margin-left:-17.1pt;padding-top:1.9pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.2pt}.c94{margin-left:-16.9pt;padding-top:2.2pt;text-indent:26.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18pt}.c10{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Courier New";font-style:normal}.c31{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7pt;font-family:"Arial";font-style:normal}.c52{margin-left:-16.4pt;padding-top:2.2pt;text-indent:85pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:30.2pt}.c26{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Courier New";font-style:normal}.c109{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:17.2pt;font-family:"Arial";font-style:normal}.c115{margin-left:-16.2pt;padding-top:0.5pt;text-indent:26pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19pt}.c102{margin-left:-14.2pt;padding-top:1.9pt;text-indent:28.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.6pt}.c99{margin-left:-2.4pt;padding-top:5pt;text-indent:19.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:0.4pt}.c38{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:13.3pt;font-family:"Arial";font-style:normal}.c114{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:13.3pt;font-family:"Courier New";font-style:normal}.c56{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:6.8pt;font-family:"Arial";font-style:normal}.c170{margin-left:-6.8pt;padding-top:2.2pt;text-indent:21pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-21.4pt}.c17{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Arial";font-style:normal}.c203{margin-left:-17.5pt;padding-top:1.9pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18.6pt}.c145{margin-left:-17.1pt;padding-top:2.2pt;text-indent:87.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.4pt}.c15{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.3pt;font-family:"Courier New";font-style:normal}.c215{margin-left:-18.5pt;padding-top:8.4pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.2pt}.c57{margin-left:-16.2pt;padding-top:1.9pt;text-indent:26pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-20.6pt}.c11{margin-left:-15.1pt;padding-top:1.9pt;text-indent:41pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:0.9pt}.c171{margin-left:-18.5pt;padding-top:12.7pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-15.9pt}.c40{margin-left:-18.5pt;padding-top:2.2pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.8pt}.c68{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Arial";font-style:normal}.c62{margin-left:-18pt;padding-top:1.9pt;text-indent:27.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-18.8pt}.c127{margin-left:-15.9pt;padding-top:7.4pt;text-indent:26pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-20.4pt}.c125{margin-left:-17.1pt;padding-top:10.8pt;text-indent:17.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.4pt}.c184{margin-left:-18pt;padding-top:1.9pt;text-indent:27.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.6pt}.c95{margin-left:-17.1pt;padding-top:8.2pt;text-indent:27.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.4pt}.c54{margin-left:-18.5pt;padding-top:9.8pt;text-indent:28.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.2pt}.c199{margin-left:-17.1pt;padding-top:1.9pt;text-indent:31.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.4pt}.c108{margin-left:-16.9pt;padding-top:1.9pt;text-indent:27pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18pt}.c100{margin-left:-17.1pt;padding-top:1.9pt;text-indent:27.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.7pt}.c150{margin-left:-17.1pt;padding-top:8.2pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.7pt}.c173{margin-left:-16.9pt;padding-top:2.2pt;text-indent:27pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.8pt}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.2pt;font-family:"Arial";font-style:normal}.c92{color:#595959;font-weight:400;text-decoration:none;vertical-align:sub;font-size:7.9pt;font-family:"Arial";font-style:normal}.c79{margin-left:-14.2pt;padding-top:0.7pt;text-indent:38pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:4.3pt}.c45{margin-left:-17.1pt;padding-top:7.7pt;text-indent:27.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.4pt}.c113{margin-left:-15.1pt;padding-top:1pt;text-indent:38.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:5.9pt}.c64{margin-left:-17.8pt;padding-top:0.7pt;text-indent:27.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18.6pt}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Arial";font-style:normal}.c130{margin-left:-6.8pt;padding-top:2.2pt;text-indent:21.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.8pt}.c19{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Times New Roman";font-style:normal}.c21{margin-left:-18.5pt;padding-top:8.2pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.8pt}.c28{color:#595959;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.7pt;font-family:"Arial";font-style:normal}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10.3pt;font-family:"Arial";font-style:normal}.c91{margin-left:-15.7pt;padding-top:0.5pt;text-indent:25.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-20.4pt}.c106{margin-left:-17.1pt;padding-top:0.2pt;text-indent:27.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.4pt}.c18{margin-left:-16.2pt;padding-top:2.2pt;text-indent:26pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-20.6pt}.c153{margin-left:-18pt;padding-top:2.2pt;text-indent:27.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.1pt}.c97{margin-left:-15.7pt;padding-top:2.2pt;text-indent:25.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-20.6pt}.c41{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Arial";font-style:normal}.c58{margin-left:-18.2pt;padding-top:1.9pt;text-indent:28.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-18.8pt}.c7{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Arial";font-style:normal}.c209{margin-left:-17.1pt;padding-top:1.9pt;text-indent:27.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.2pt}.c163{margin-left:-18pt;padding-top:2.9pt;text-indent:104.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.1pt}.c166{margin-left:-15.7pt;padding-top:1.9pt;text-indent:25.5pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.9pt}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Arial";font-style:normal}.c141{margin-left:-15.7pt;padding-top:8.6pt;text-indent:25.5pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19pt}.c205{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Courier New";font-style:normal}.c34{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.2pt;font-family:"Arial";font-style:normal}.c192{margin-left:-19.2pt;padding-top:8.9pt;text-indent:29pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.6pt}.c89{margin-left:-16.9pt;padding-top:1.9pt;text-indent:27pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19.7pt}.c182{margin-left:-17.1pt;padding-top:0.5pt;text-indent:27.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18pt}.c29{margin-left:-18.7pt;padding-top:2.2pt;text-indent:29pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-18.8pt}.c101{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11.6pt;font-family:"Arial";font-style:normal}.c156{margin-left:-19pt;padding-top:2.4pt;text-indent:37pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.6pt}.c207{margin-left:-16.2pt;padding-top:13.7pt;text-indent:26pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-19pt}.c134{margin-left:-19pt;padding-top:13.9pt;text-indent:19.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.4pt}.c37{margin-left:-18.7pt;padding-top:27.4pt;text-indent:19pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-18.6pt}.c161{margin-left:-19.2pt;padding-top:10.3pt;text-indent:19.7pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.8pt}.c136{margin-left:-17.8pt;padding-top:2.2pt;text-indent:27.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18.8pt}.c20{color:#595959;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:3.9pt;font-family:"Arial";font-style:normal}.c23{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.5pt;font-family:"Arial";font-style:normal}.c87{margin-left:-19pt;padding-top:2.2pt;text-indent:28.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.6pt}.c96{margin-left:-12.3pt;padding-top:1.9pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-19.2pt}.c117{margin-left:-18.5pt;padding-top:2.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.8pt}.c84{margin-left:-23.8pt;padding-top:737.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-24pt}.c123{margin-left:-12pt;padding-top:10.3pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-9.4pt}.c51{margin-left:218.6pt;padding-top:50.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-35.4pt}.c183{margin-left:-18.2pt;padding-top:2.2pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-18.6pt}.c175{margin-left:-17.1pt;padding-top:32.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18pt}.c118{margin-left:-18pt;padding-top:8.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:155.9pt}.c172{margin-left:-14.2pt;padding-top:4.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.2pt}.c44{margin-left:-18.5pt;padding-top:12.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.2pt}.c32{margin-left:218.6pt;padding-top:52.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-35.4pt}.c76{margin-left:-8.6pt;padding-top:0.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:38.3pt}.c75{margin-left:-17.4pt;padding-top:10.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19.4pt}.c70{margin-left:-6.8pt;padding-top:4.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-18pt}.c195{margin-left:-13pt;padding-top:1.9pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-4.3pt}.c50{margin-left:-19pt;padding-top:10.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.6pt}.c187{margin-left:-13pt;padding-top:11.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:6.4pt}.c85{margin-left:-2.6pt;padding-top:3.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:3.3pt}.c138{margin-left:-8.6pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:75.8pt}.c135{margin-left:-18.5pt;padding-top:10.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.8pt}.c33{margin-left:218.6pt;padding-top:50.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-35.4pt}.c164{margin-left:49.6pt;padding-top:3.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:46.1pt}.c168{margin-left:-15.9pt;padding-top:10.1pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-20.4pt}.c78{margin-left:0.5pt;padding-top:1.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:48.9pt}.c162{margin-left:-18.5pt;padding-top:10.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-0.3pt}.c160{margin-left:38.4pt;padding-top:1.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:143.4pt}.c90{margin-left:16.7pt;padding-top:14.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-18.7pt}.c4{margin-left:218.6pt;padding-top:51.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-35.4pt}.c30{margin-left:76.5pt;padding-top:0.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:67.4pt}.c142{margin-left:-18.5pt;padding-top:10.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.2pt}.c185{margin-left:218.6pt;padding-top:53.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-35.4pt}.c206{margin-left:47.2pt;padding-top:8.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:63.6pt}.c214{margin-left:-2.6pt;padding-top:0.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-6.3pt}.c126{margin-left:-19pt;padding-top:10.6pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.6pt}.c176{margin-left:-16.2pt;padding-top:7.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19pt}.c98{margin-left:-16.2pt;padding-top:0.7pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-1.7pt}.c146{margin-left:-16.9pt;padding-top:8.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:111.4pt}.c73{margin-left:-5.8pt;padding-top:2.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:51.6pt}.c122{margin-left:-18pt;padding-top:10.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-18.8pt}.c74{margin-left:18.2pt;padding-top:13.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:20.8pt}.c155{margin-left:-17.3pt;padding-top:5.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-2pt}.c66{margin-left:218.6pt;padding-top:51.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-35.4pt}.c140{margin-left:-16.6pt;padding-top:1.9pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:24.6pt}.c35{margin-left:-17.8pt;padding-top:10.3pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-17.1pt}.c12{margin-left:-16.2pt;padding-top:0.7pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:6pt}.c104{margin-left:-18.7pt;padding-top:13pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.2pt}.c119{margin-left:-7.7pt;padding-top:10.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-18.8pt}.c42{margin-left:-14.2pt;padding-top:2.2pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-16.4pt}.c110{margin-left:-18.7pt;padding-top:9.1pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-18.3pt}.c81{margin-left:-17.5pt;padding-top:12pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.1pt}.c210{margin-left:-8.6pt;padding-top:1.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.6pt}.c158{margin-left:-13pt;padding-top:0.7pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-1.9pt}.c177{margin-left:-2.6pt;padding-top:0.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:6.2pt}.c194{margin-left:-7.7pt;padding-top:4.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:2.1pt}.c143{margin-left:-17.4pt;padding-top:7.7pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:155pt}.c151{margin-left:-8.6pt;padding-top:2.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-1.8pt}.c53{margin-left:-18.5pt;padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.9pt}.c60{margin-left:52.3pt;padding-top:1.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:29.2pt}.c159{margin-left:-15.7pt;padding-top:38.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-19pt}.c132{margin-left:-18.5pt;padding-top:3.1pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.8pt}.c157{margin-left:-17.8pt;padding-top:3.4pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-18.8pt}.c137{margin-left:-15.7pt;padding-top:4.3pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-19pt}.c112{margin-left:-16.6pt;padding-top:1.9pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:9.5pt}.c47{margin-left:-19pt;padding-top:8.2pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-16.2pt}.c204{margin-left:-18.5pt;padding-top:8.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-16.4pt}.c208{margin-left:-6.8pt;padding-top:4.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:1.2pt}.c200{margin-left:-18.5pt;padding-top:11.3pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-17.6pt}.c88{margin-left:-18.5pt;padding-top:14.2pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:142.5pt}.c213{margin-left:-16.9pt;padding-top:0.7pt;padding-bottom:0pt;line-height:1.15;text-align:center;margin-right:-2.4pt}.c197{padding-top:1.9pt;text-indent:35.8pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c133{padding-top:10.3pt;text-indent:16.6pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c116{padding-top:1.9pt;text-indent:26pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c131{padding-top:2.2pt;text-indent:31.3pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c196{padding-top:2.2pt;text-indent:25.5pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c167{padding-top:2.2pt;text-indent:35.8pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c211{padding-top:2.2pt;text-indent:27pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c129{padding-top:1.9pt;text-indent:27pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c186{padding-top:1.9pt;text-indent:25.5pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c59{padding-top:2.2pt;text-indent:26pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c180{padding-top:8.4pt;text-indent:27.2pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c93{padding-top:13.9pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c69{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c48{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c22{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c65{padding-top:9.8pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c63{margin-left:-15.7pt;text-indent:25.5pt;margin-right:-20.2pt}.c128{margin-left:-17.8pt;text-indent:27.9pt;margin-right:-19.4pt}.c181{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c174{margin-left:-15.7pt;margin-right:-20.4pt}.c121{margin-left:-16.9pt;margin-right:-18.2pt}.c193{margin-left:30.2pt;margin-right:31pt}.c80{margin-left:-16.9pt;margin-right:-19.4pt}.c77{margin-left:-16.2pt;margin-right:-19.2pt}.c198{margin-left:-15.7pt;margin-right:-19pt}.c201{margin-left:-17.1pt;margin-right:-19.4pt}.c189{margin-left:-12.3pt;margin-right:-18.2pt}.c55{margin-left:-16.2pt;margin-right:-20.4pt}.c190{margin-left:-15.7pt;margin-right:-18.7pt}.c72{margin-left:68.1pt;margin-right:4.3pt}.c83{margin-left:-75.4pt;margin-right:178.1pt}.c152{margin-left:-12.1pt;margin-right:14.9pt}.c144{margin-left:-16.9pt;margin-right:-18.5pt}.c71{text-indent:26.2pt}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:24pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:14pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c181"><p class="c84"><span class="c19">Series ISSN: 2367-2005 265 </span><span class="c205">10.5441/002/edbt.2018.24 </span></p><p class="c1 c193"><span class="c109">Interactive Rule Refinement for Fraud Detection </span></p><p class="c149"><span class="c13">Tova Milo </span><span class="c41">Tel Aviv University milo@post.tau.ac.il </span></p><p class="c69 c83"><span class="c13">Slava Novgorodov </span><span class="c41">Tel Aviv University slavanov@post.tau.ac.il </span></p><p class="c69 c72"><span class="c13">Wang-Chiew Tan </span><span class="c41">Recruit Institute of Technology wangchiew@recruit.ai </span></p><p class="c69 c72"><span class="c13">Wang-Chiew Tan </span><span class="c41">Recruit Institute of Technology wangchiew@recruit.ai </span></p><p class="c204"><span class="c36">ABSTRACT </span><span class="c7">Credit card frauds are unauthorized transactions that are made or attempted by a person or an organization that is not authorized by the card holders. Fraud with general-purpose cards (credit, debit cards etc.) is a billion dollar industry and companies are therefore investing significant efforts in identifying and preventing them. </span></p><p class="c111"><span class="c7">It is typical to deploy mining and machine learning-based tech- niques to derive rules. However, such rules may not always capture the semantic reasons underlying the frauds that occur. For this reason, credit card companies often employ domain experts to manually specify rules that exploit general or domain knowledge for improving the detection process. Over time, however, as new (fraudulent and legitimate) transactions arrive, these rules need to be updated and refined to capture the evolving (fraud and legiti- mate) activity patterns. The goal of the R</span><span class="c2">UDOLF </span><span class="c7">system described in this paper is to guide and assist domain experts in this challeng- ing task. R</span><span class="c2">UDOLF </span><span class="c7">automatically determines the &ldquo;best&rdquo; adaptation to existing rules to capture all fraudulent transactions and, respec- tively, omit all legitimate transactions. The proposed modifications can then be further refined by users and the process can be re- peated until they are satisfied with the resulting rules. We show that the problem of identifying the best candidate adaptation is NP-hard in general and present PTIME heuristic algorithms for determining the set of rules to adapt. We have implemented our algorithms in R</span><span class="c2">UDOLF </span><span class="c7">and show, through experiments on real-life datasets, the effectiveness and efficiency of our solution. </span></p><p class="c188"><span class="c36">1 INTRODUCTION </span><span class="c7">A credit card fraud is an unauthorized transaction made or at- tempted by an individual or organization who is not authorized by the card holder to use a credit card to perform the electronic pay- ment. Fraud with general-purpose cards (credit, debit cards etc.) is a billion dollar industry. In fact, several independent news articles and studies that were carried out (e.g., [1, 2]) corroborate that there is a consistent, fast-growing, and upward trend on the total global payment-card frauds. Detecting and deterring credit card frauds are therefore of extreme importance to credit card compa- nies. A core part of operations behind every credit card company is to (automatically) detect fraudulent transactions among the new transactions (e.g., [3]) that are received everyday. </span></p><p class="c43"><span class="c7">To this end, models based on data mining and machine-learning techniques (e.g. [4&ndash;6]) have been used. A typical approach is to score each transaction where transactions whose scores are above a threshold are classified as fraudulent. However, the models and scoring system do not always have high precision and re- call. Fraudulent transactions may be missed by the models and, likewise, legitimate transactions may be wrongly identified as fraudulent. The derived threshold also do not provide a semantic explanation of the underlying causes of the frauds. It is for this reason that credit card companies typically rely on rules that are </span></p><p class="c53"><span class="c31">&copy; 2018 Copyright held by the owner/author(s). Published in Proceedings of the 21st International Conference on Extending Database Technology (EDBT), March 26-29, 2018, ISBN 978-3-89318-078-3 on OpenProceedings.org. Distribution of this paper is permitted under the terms of the Creative Commons license CC-by-nc-nd 4.0. </span></p><p class="c1 c121"><span class="c7">carefully specified by domain experts in addition to models for automatically determining fraudulent transactions. </span></p><p class="c108"><span class="c7">Intuitively, a rule describes a set of transactions in the database and the goal is to arrive at a set of rules that, together with the automatically derived scores, captures precisely the fraudulent transactions. The use of rules written by users has the advantage that it allows employing general or domain knowledge to handle rare special cases. </span></p><p class="c89"><span class="c7">Writing rules to capture precisely fraudulent transactions is a challenging task that is exacerbated over time as the types of fraudulent transactions evolve or as new knowledge is learnt. Typ- ically, a set of rules that were curated by users already exists and the rules work well for capturing fraudulent transactions up to a certain day. However, these rules need to be adapted over time to capture new types of frauds that may occur. For example, there may be new reported fraudulent transactions coming from a certain type of store at a certain time that did not occur before and hence, not caught by existing rules. Analogously, there may be some transactions that were identified by the existing rules as fraudulent but later verified by the card holders to be legitimate. Hence, the rules have to be adapted or augmented over time to capture all (but only) fraudulent transactions. In this paper, we present R</span><span class="c2">UDOLF</span><span class="c7">, a system whose goal is to assist users to define and refine rules for fraud detection. </span></p><p class="c80 c211"><span class="c7">Note that our goal resembles in part that of previous works on query/rule refinement, which attempt to automatically identify minimal changes to the query/rule in order to insert or remove certain items from the query result (e.g., [7]). However, a key difference here is that such minimal modifications often do not capture the actual &ldquo;ground truth&rdquo;, namely the nature of ongoing attack, which may not yet be fully reflected in the data. By inter- acting with users to fine-tune rules, important domain knowledge can be effectively imported into the rules to detect the pattern of frauds often even before they are manifested in the transactions themselves. </span></p><p class="c100"><span class="c7">Our goal also resembles previous work on discovering or learn- ing decision rules from streams with concept drifts (e.g. [8, 9]). Like them, R</span><span class="c2">UDOLF </span><span class="c7">strives to discover or adapt rules as new transactions arrive. However, all previous work considered only domains over numerical values and hence do not immediately ap- ply to our setting, which involves both categorical and numerical values. Furthermore, R</span><span class="c2">UDOLF </span><span class="c7">makes crucial use of a hierarchy of higher-level concepts over the domains (numerical or categorical) in the specification of rules. In addition, R</span><span class="c2">UDOLF </span><span class="c7">collaborates with the domain expert to improve upon the quality of the rules used for capturing only fraudulent transactions. The interplay be- tween the domain experts and the use of higher-level concepts, whenever possible, enables the derivation of rules which can be used to explain the true nature ongoing frauds. Our experiments indicate that such interactions can be effective in deriving rules with good prediction quality. An overview example The top of Figure 1 shows a simplified set of rules that is currently used to capture fraudulent transactions up to yesterday. Intuitively, the first two rules capture a suspicion of two attacks on an online store taking place at the first and </span></p><p class="c35"><span class="c7">last few minutes of 6pm, charging amounts over $110. The last rule captures a fraud pattern at Gas station A where false charges of amounts over $40 are made soon after the closing time at 9pm. In practice each rule also includes some threshold condition (not shown) on the score (i.e., the degree of confidence that the transaction is fraudulent) for each transaction, as well as additional conditions on the user/settings/etc. The scores and the additional conditions are omitted so that we can focus our discussions on the semantic aspect of the rules shown in Figure 1. </span></p><p class="c178"><span class="c7">Figure 2 shows an example of a relation which contains a num- ber of transactions made today. The transaction tuples are ordered by the time of the transaction. In the figure, some transactions that were reported as fraudulent are labeled as &ldquo;FRAUD&rdquo;. Similarly, transactions that are reported to be legitimate may be correspond- ingly labeled &ldquo;LEGITIMATE&rdquo; (not shown in the figure). Transac- tions may also be unlabeled. The current set of rules captures only the shaded tuples shown in the transaction relation. Clearly, none of the new fraudulent transactions are captured by the existing rules whereas some unlabeled transactions are captured. </span></p><p class="c58"><span class="c7">R</span><span class="c2">UDOLF </span><span class="c7">first attempts to capture the fraudulent transactions by generalizing the rules, semantically according to a given ontology whenever possible, before it specializes the rules to avoid unnec- essarily capturing legitimate transactions. However, the changes proposed by R</span><span class="c2">UDOLF </span><span class="c7">may not correspond to the best or correct changes. The domain experts can view/accept/reject/modify the suggestions provided by R</span><span class="c2">UDOLF</span><span class="c7">, arriving for instance at the </span><span class="c5">1) Time &isin; [18:05,18:05] &and; Amt &ge; 100 &and; Type = Onl., no CCV. 2) Time &isin; [18:55,19:15] &and; Amt &ge; 100 &and; Type = Onl., no CCV. 3) Time &isin; [20:45,21:15] &and; Amt &ge; 40 &and; Location &le; Gas Station &and; Type &le; Offline. </span></p><p class="c29"><span class="c7">Intuitively, the first two rules above flag online transactions without CCV, charging amounts over $100 in the respective time intervals as fraudulent transactions. The third rule flags offline transactions at the gas stations around closing time of amounts over $40 as fraudulent transactions. Observe that the condition &ldquo;Location &le; &lsquo;Gas Station&rsquo; is a semantic generalization of Gas Stations A and B, which are defined in an ontology to be contained within the category &ldquo;Gas Station&rdquo;. Similarly, &ldquo;Type &le; Offline&rdquo; reflects the semantic category (shown at the bottom of Figure 1) which contains offline transactions with and without PIN. Contributions This paper makes the following contributions. </span></p><p class="c119"><span class="c7">(1) We formulate and present a novel interactive framework for determining the &ldquo;best&rdquo; way to adapt and augment rules so that fraudulent transactions are captured and, at the same time, legitimate transactions are avoided. (2) We establish that the rule refinement problem is NP-hard even under special circumstances: (1) determine the best way to generalize rules to capture new fraudulent transac- tions when there are no new legitimate transactions, and (2) determine the best way to specialize existing rules to avoid capturing new legitimate transactions when there are no new fraudulent transactions. (3) In light of these hardness results, we develop a heuristic algorithm which is able to interactively adapt rules with do- main experts until a desired set of rules is obtained. At each step, the algorithm makes a proposal of the best changes to a rule, and the domain expert can further refine the proposed changes or seek suggestions for other possible changes. Our algorithm represents a departure from prior algorithms on discovering or learning decision rules from streams with concept drifts in that it handles categorical </span></p><p class="c1 c174"><span class="c7">values in addition to numerical values, adapt rules with semantic concepts from available ontologies, and interacts with domain experts. (4) We have implemented our solution in the R</span><span class="c2">UDOLF </span><span class="c7">proto- type system and applied it on real data, demonstrating the effectiveness and efficiency of our approach. We performed experimental evaluations on a real-life dataset of credit card transactions. We show that by interacting with users (even ones with only little knowledge specific to the domain of the datasets), our algorithms consistently outperform alter- native baseline algorithms, yielding more effective rules in shorter time. While most of our exposition on the features of R</span><span class="c2">UDOLF </span><span class="c7">is based on credit card frauds, we emphasize that R</span><span class="c2">UDOLF </span><span class="c7">is a general-purpose system that can be used to interact with users to refine rules. For example, for preventing network attacks, for refining rules for spam detection or for intrusion detection [10]. </span></p><p class="c59 c77"><span class="c7">A first prototype of the system was demonstrated at VLDB&rsquo;16 [11]. The short paper accompanying the demonstration gives only a brief overview of the system architecture whereas the present work provides a comprehensive description of the underlying model and algorithms. </span></p><p class="c77 c116"><span class="c7">The paper is organized as follows. The next two sections define the model and problem statement behind R</span><span class="c2">UDOLF </span><span class="c7">(Section 2 and, respectively, Section 3). The algorithm behind R</span><span class="c2">UDOLF </span><span class="c7">is described in Section 4. We then present our experimental results (Section 5) and related work (Section 6), before we present our conclusions (Section 7). </span></p><p class="c55 c133"><span class="c36">2 PRELIMINARIES </span><span class="c7">Transaction relation A transaction relation is a set of tuples (or transactions). The transaction relation is appended with more transactions over time. We assume that the domain of every at- tribute A has a partial order, which is reflexive, antisymmetric, and transitive, with a greatest element &#8868;</span><span class="c9">A </span><span class="c7">and least element &perp;</span><span class="c9">A</span><span class="c7">. W.l.o.g. we also assume that &perp;</span><span class="c9">A </span><span class="c7">does not appear in any of the tu- ples</span><span class="c3">1</span><span class="c7">. For brevity, when an attribute name is clear from the context we will omit it and simply use the notations &#8868; and &perp;. Attributes that are associated with a partial order but not a total order are called categorical attributes. The elements in such partial order are sometimes referred to as concepts. </span></p><p class="c61"><span class="c7">A transaction may be flagged as fraudulent which means that the transaction was carried out illegally or conversely, a transaction may be flagged as legitimate. Unmarked transactions are called unlabeled transactions. The labeling is assumed to correspond to the (known part of the) ground truth. In addition, each transaction has a </span><span class="c10">score </span><span class="c7">between 0 and 1, that is computed automatically using machine learning techniques, and depicts the estimated probability of each transaction to be fraud. The score may or may not agree with the ground truth and this discrepancy is precisely the reason why rules are employed to refine the fraud detection. </span></p><p class="c127"><span class="c7">Example 2.1. Part of a transaction relation I with schema </span><span class="c10">T(time,amount,type,location,...) </span><span class="c7">is shown in Fig- ure 2. Each tuple records, among others, the time, amount, type of transaction, and location where the purchase was made through some credit card. The scores of the transactions, as computed by a machine learning module, are omitted from the figure. The last column annotates the type of transactions. The part of instance I that is shown contains only fraudulent and unlabeled transactions. </span></p><p class="c176"><span class="c23">1</span><span class="c101">If this is not the case, add a new special element to the domain and set it smaller, in </span><span class="c31">the partial order, than all other elements. </span></p><p class="c51"><span class="c19">266 </span></p><p class="c1"><span class="c5">Existing fraud rules &Phi; from the previous day: 1) Time &isin; [18:00, 18:05] &and; Amt &ge; 110 2) Time &isin; [18:55, 19:00] &and; Amt &ge; 110 3) Time &isin; [21:00, 21:15] &and; Amt &ge; 40 &and; </span></p><p class="c1"><span class="c5">Location&le;&lsquo;Gas Station A&rsquo; </span></p><p class="c1"><span class="c34">All = &#8890;</span><span class="c56">type </span></p><p class="c1"><span class="c34">Online Offline With code No code </span></p><p class="c69"><span class="c34">Online, with CCV </span></p><p class="c1"><span class="c5">Time Amount Transaction Type Location 18:02 107 Online, no CCV Online Store FRAUD 18:03 106 Online, no CCV Online Store FRAUD 18:04 112 Online, with CCV Online Store 19:08 114 Online, no CCV Online Store FRAUD 19:10 117 Online, with CCV Online Store 20:53 46 Offline, without PIN GAS Station B FRAUD 20:54 48 Offline, without PIN GAS Station B FRAUD 20:55 44 Offline, without PIN GAS Station B FRAUD </span></p><p class="c1"><span class="c34">Online, </span></p><p class="c1"><span class="c34">Offline, </span></p><p class="c1"><span class="c34">Offline, </span></p><p class="c1"><span class="c5">20:58 47 Offline, with PIN Supermarket </span><span class="c34">without CCV </span></p><p class="c1"><span class="c34">with PIN </span></p><p class="c1"><span class="c34">without PIN </span></p><p class="c1"><span class="c5">21:01 49 Offline, with PIN GAS Station A </span></p><p class="c1"><span class="c5">: : : : : </span><span class="c34">None = &perp;</span><span class="c56">type </span></p><p class="c1"><span class="c7">Figure 2: A transaction relation containing new Figure 1: Top: An existing set of rules. </span></p><p class="c1"><span class="c7">transactions. Bottom: Partial Order for </span><span class="c10">type </span><span class="c7">values. </span></p><p class="c22"><span class="c7">The type </span><span class="c10">time </span><span class="c7">is discretized to minutes and is associated with a date (not shown). It thus has a partial order (in fact, a total order), given by the &le; relation. The type </span><span class="c10">amount </span><span class="c7">also has a total order with least element </span><span class="c10">0 </span><span class="c7">and greatest element &infin;. The attribute </span><span class="c10">type </span><span class="c7">is a categorical attribute and its partial order is given by the hierarchy shown at the bottom of Figure 1. Some examples of concepts in the hierarchy are &ldquo;Online&rdquo; or &ldquo;Offline, without PIN&rdquo;. The type </span><span class="c10">location </span><span class="c7">is also a categorical attribute and its partial order (not shown) is given by, say, the geographical containment relationship. In particular, &ldquo;Gas Station A&rdquo; and &ldquo;Gas Station B&rdquo; are both concepts that are children of the concept &ldquo;Gas Station&rdquo;. </span></p><p class="c22"><span class="c7">Rules For simplicity and efficiency of execution, we assume rules are typically written over a single relation, which is a universal transaction relation that includes all the necessary attributes (pos- sibly aggregated or derived from many other database relations) for fraud detection. Hence, it is not necessary to consider explicit joins over different relations in the rule language. </span></p><p class="c48"><span class="c7">To highlight the key principles of our approach we consider here a fairly simple rule language that captures a disjunction of conjunctions. For simplicity, our rule language allows only one condition over each attribute. Multiple disjunctive conditions over the same attribute can be expressed in multiple rules. Other exten- sions to the rule language are possible but will not be considered here. Note that the rule language that we consider, albeit simple, forms the core of common rule languages used by actual systems. A rule is a conjunction of one or more conditions over the attributes of the transaction relation. More precisely, a rule is of the form &alpha;</span><span class="c15">1</span><span class="c7">&and;...&and;&alpha;</span><span class="c25">n </span><span class="c7">wheren is the arity of the transaction relation, &alpha;</span><span class="c9">i </span><span class="c17">is a condition is of the form &lsquo;A</span><span class="c9">i </span><span class="c17">op s&rsquo; or &lsquo;A</span><span class="c9">i </span><span class="c17">&isin; [s,e]&rsquo;, A</span><span class="c9">i </span><span class="c17">is the </span><span class="c7">ith attribute of the transaction relation, op &isin; {=, &lt;, &gt;, &le;, &ge;}, and s and e are constants. </span></p><p class="c22"><span class="c7">More formally, if &phi; is a rule that is specified over a transaction relation I, then &phi;(I) denotes the set of all tuples in I that satisfy &phi;. We say that &phi;(I) are the transactions in I that are captured by &phi;. If &Phi; denotes a set of rules over I, then &Phi;(I) = </span><span class="c8">&phi;</span><span class="c9">&isin;&Phi; </span><span class="c7">&phi;(I). In other words, &Phi;(I) denotes the union of results of evaluating every rules in &Phi; over I. Observe that &Phi;(I) &sube; I since every rule selects a subset of transactions from I. For readability, in our examples we show only the non trivial conditions on attributes, namely omit conditions of the form A</span><span class="c9">i </span><span class="c17">&le; &#8868;. </span></p><p class="c22"><span class="c7">Note that, for simplicity, each rule includes only one condition over each attribute, but multiple disjunctive conditions over the same attribute can be expressed using multiple rules. </span></p><p class="c22"><span class="c7">Example 2.2. The top of Figure 1 illustrates a set &Phi; of three simplified rules currently used by the example credit card com- pany to detect fraudulent transactions. The first rule captures all transactions made between 6pm to 6:05pm where the amount in- volved is at least $110. As previously mentioned, in practice each rule also includes some threshold conditions (not shown here) on the score for each transaction, as well as additional conditions on the user/settings/etc. For simplicity we omit the score thresh- olds and the additional conditions and focus in the sequel on the simplified rules in this example. </span></p><p class="c22"><span class="c7">For the new transaction relation shown in Figure 2, this rule captures the 3rd tuple (which is an unlabeled transaction). The 2nd rule captures no tuples, and the 3rd rule captures the 10th unlabeled tuple. Hence, the existing rules &Phi; do not capture any of the fraudulent transactions on the current day. </span></p><p class="c1"><span class="c7">As we shall demonstrate, the rule language that we consider here, even though simple, is able to succinctly capture the fraudu- lent transactions (and avoid legitimate tuples) in our experiments with a real dataset. Other domains rules, e.g. access control for network traffic or spam detection rules can also be expressed in our language. Cost and Benefit of modifications A modification to a rule is a change in a condition of an attribute in the rule. One may also copy an existing rule before modifying the copy, add rule or remove an existing rule. As we will elaborate in subsequent sections, our cost model assumes there is a cost associated with every operation/modification made to a condition in the rule. </span></p><p class="c22"><span class="c7">To compare between possible modifications to rules and deter- mine which modifications are better, we need to know not only the cost of each modification but also the &ldquo;benefit&rdquo; it entails. Intu- itively, the gain from the modifications can be measured in three ways: (1) the increase in the number of fraudulent transactions that are captured by the modified rule, (2) the the decrease in the num- bers of legitimate transactions that are captured by the modified rule, and (3) the decrease in the numbers of captured unlabeled transactions. The assumption underlying (3) is that unlabeled transactions are typically assumed to be correct until explicitly reported/tagged otherwise and the more specific the rules are to fraudulent (and only) fraudulent transactions, the more precise they are in embodying possible domain-specific knowledge about the fraudulent transactions. </span></p><p class="c1"><span class="c7">Observe that if our modifications are ideal, then after the modi- fications, there are more fraudulent transactions captured, and less </span></p><p class="c1"><span class="c19">267 </span></p><p class="c142"><span class="c7">legitimate and unlabeled transactions caught. Subsequently, the overall update cost is defined as the cost of modifications minus their benefit. We give the formal definition in the next section. </span></p><p class="c148"><span class="c36">3 PROBLEM STATEMENT </span><span class="c7">As described, the goal of R</span><span class="c2">UDOLF </span><span class="c7">is to identify minimal modifi- cations to existing rules that would ideally capture all fraudulent transactions, omit all legitimate transactions, and at the same time, minimize the inclusion of unlabeled transactions. The modifi- cations suggested by R</span><span class="c2">UDOLF </span><span class="c7">serve as a starting point for the domain expert who can either accept the proposed modifications or interactively refine them with the help of R</span><span class="c2">UDOLF </span><span class="c7">. Formally, the problem is stated below. </span></p><p class="c47"><span class="c7">Definition 3.1 (General Rule Modification Problem). Let &Phi; be a set of rules on an existing transaction relation I. Let I </span><span class="c3">&prime; </span><span class="c7">denote a new set of transactions over the same schema. Let F,L &sube; I (resp. F </span><span class="c3">&prime;</span><span class="c7">,L</span><span class="c3">&prime; </span><span class="c7">&sube; I </span><span class="c3">&prime;</span><span class="c7">) be two disjoint sets of fraudulent and legitimate transactions in I (resp. I </span><span class="c3">&prime;</span><span class="c7">). Let R = I &minus; (F &cup; L) (resp. R</span><span class="c3">&prime; </span><span class="c7">= I </span><span class="c3">&prime; </span><span class="c7">&minus; (F </span><span class="c3">&prime; </span><span class="c7">&cup; L</span><span class="c3">&prime;</span><span class="c7">)) be the remaining unlabeled transactions in I (resp. I</span><span class="c3">&prime;</span><span class="c7">). The G</span><span class="c2">ENERAL </span><span class="c7">R</span><span class="c2">ULE </span><span class="c7">M</span><span class="c2">ODIFICATION </span><span class="c7">P</span><span class="c2">ROBLEM </span><span class="c7">is to compute a set M of modifications to &Phi; to obtain &Phi;</span><span class="c3">&prime; </span><span class="c7">so that cost(M)&minus;(&alpha; &lowast; &#8710;F + &beta; &lowast; &#8710;L +&gamma; &lowast; &#8710;R) is minimized, where &alpha;, &beta;,&gamma; &ge; </span><span class="c10">0</span><span class="c7">, and </span></p><p class="c85"><span class="c7">&bull; &#8710;F = |(F &cup; F</span><span class="c3">&prime;</span><span class="c7">) &cap; &Phi;</span><span class="c3">&prime;</span><span class="c7">(I &cup; I </span><span class="c3">&prime;</span><span class="c7">)| &minus; |(F &cup; F</span><span class="c3">&prime;</span><span class="c7">) &cap; &Phi;(I &cup; I</span><span class="c3">&prime;</span><span class="c7">)|, </span></p><p class="c214"><span class="c7">&bull; &#8710;L = |(L &cup; L</span><span class="c3">&prime;</span><span class="c7">) &cap; &Phi;(I &cup; I </span><span class="c3">&prime;</span><span class="c7">)| &minus; |(L &cup; L</span><span class="c3">&prime;</span><span class="c7">) &cap; &Phi;(I &cup; I </span><span class="c3">&prime;</span><span class="c7">)|, and </span></p><p class="c177"><span class="c7">&bull; &#8710;R = |(R &cup; R</span><span class="c3">&prime;</span><span class="c7">) &cap; &Phi;(I &cup; I </span><span class="c3">&prime;</span><span class="c7">)| &minus; |(R &cup; R</span><span class="c3">&prime;</span><span class="c7">) &cap; &Phi;(I &cup; I </span><span class="c3">&prime;</span><span class="c7">)|. </span></p><p class="c21"><span class="c7">The term (&alpha; &lowast; &#8710;F + &beta; &lowast; &#8710;L +&gamma; &lowast; &#8710;R) represents the benefit of applying the given modifications to the rules. In our rule language, if a fraudulent transaction is not captured by a set of rules, then at least some condition of a rule needs to be generalized to select that fraudulent transaction. At the same time, making a condition more general may capture also legitimate or unlabeled transac- tions. Conversely, if a legitimate transaction is captured by a set of rules, then at least some condition of a rule needs to be made more restrictive so that the legitimate transaction is excluded. Such modifications carry the risk of omitting some fraudulent trans- actions that should be captured. The coefficients &alpha;, &beta; and &gamma; are non-negative and are typically provided by the user to tune the relative importance of each category (resp. correctly capturing the fraudulent transactions, avoiding misclassifying legitimate trans- actions, and excluding unlabeled transactions) in the calculation of benefit. The overall goal is to identify the modifications having the best cost-benefit balance. </span></p><p class="c43"><span class="c7">Observe that if &alpha;, &beta; and &gamma; are set to large numbers (e.g. greater than the maximal update cost) then the most beneficial modifi- cations are those leading to a &ldquo;perfect&quot; set of rules, namely one that will (1) capture all fraudulent transactions, (2) exclude all legitimate transactions, and at the same time, (3) does not capture any unlabeled transactions. </span></p><p class="c162"><span class="c36">4 THE GENERAL RULE MODIFICATION </span></p><p class="c154"><span class="c36">ALGORITHM </span><span class="c7">The rule modification algorithm (outlined below) first interactively refines the rules to capture fraudulent transactions. The expert can stop the refinement whenever she is satisfied with the rules and believes that the omission of the remaining fraudulent transactions is tolerable. The resulting set of rules may capture some (exist- ing) legitimate tuples. Hence, in the second step, the algorithm continues to interactively refine the rules to avoid the legitimate transactions. Here again the user may stop the algorithm when she believes that the inclusion of the remaining legitimate transactions </span></p><p class="c22 c80"><span class="c7">is acceptable. However, the rules that result after this step may no longer capture some fraudulent transactions that were previ- ously captured. The domain expert can either repeat the process described above to remedy this, or choose to end the rule refine- ment process at this point. In the latter case, the domain expert has a choice to leave the result as-is or allow the algorithm to create transaction-specific rules to capture each of the remaining transactions. </span></p><p class="c70"><span class="c7">(1) Generalize rules to capture fraudulent transactions. See </span></p><p class="c170"><span class="c7">Algo. 1, section 4.1. (2) Specialize rules to avoid legitimate transactions. See Algo. 2, </span></p><p class="c130"><span class="c7">section 4.2. (3) Exit if the domain expert is satisfied. Otherwise, repeat the </span></p><p class="c199"><span class="c7">steps above. Observe that it is essential for the generalization algorithm (Algo. 1) to be applied before the specialization algorithm (Algo. 2) as one can always add rules to capture specific fraudulent transac- tions without accidentally capturing legitimate transactions. On the other hand, one cannot always add/modify rules to avoid specific legitimate transactions without accidentally excluding fraudulent transactions with our current rule language. </span></p><p class="c121 c129"><span class="c7">As we shall show in the next sections, finding an optimal set of changes to the rules is computationally expensive in either case. For this reason, instead of computing an optimal set of modifications to the rules to generalize or special rules to capture fraudulent and, respectively, avoid legitimate tuples, we develop heuristic algorithms to identify the best update candidates in each of the cases. </span></p><p class="c125"><span class="c36">4.1 Rule Generalization Algorithm </span><span class="c7">We first consider how rules can be generalized to capture fraud- ulent transactions when the set I</span><span class="c3">&prime; </span><span class="c7">of new transactions contains only fraudulent transactions. The goal here is to adapt the existing set of rules &Phi; to capture all fraudulent transactions. We call this problem the R</span><span class="c2">ULE </span><span class="c7">G</span><span class="c2">ENERALIZATION </span><span class="c7">P</span><span class="c2">ROBLEM </span></p><p class="c120"><span class="c7">T</span><span class="c2">HEOREM </span><span class="c7">4.1. The R</span><span class="c2">ULE </span><span class="c7">G</span><span class="c2">ENERALIZATION </span><span class="c7">P</span><span class="c2">ROBLEM </span><span class="c7">is NP-hard even if &Phi; is perfect for I, (namely, F &sube; &Phi;(I) and L&cap;&Phi;(I) = R &cap; &Phi;(I) = &empty;). The problem is NP-hard even when I contains only unlabeled transactions and I</span><span class="c3">&prime; </span><span class="c7">consist of only one fraudulent transaction. </span></p><p class="c105"><span class="c7">P</span><span class="c2">ROOF</span><span class="c7">. We prove the two claim simultaneously by reduction from the minimum hitting set problem which is known to be NP-hard. We recall of the Minimum Hitting Set Problem below. </span></p><p class="c150"><span class="c7">Definition 4.2 (Minimum Hitting Set). Consider the pair (U,S) where U is a universe of elements and S is a set of subsets of U. A set H &sube; U is a hitting set of S if H hits every set in S. In other words, H &cap; S</span><span class="c3">&prime; </span><span class="c7">&empty; for every S</span><span class="c3">&prime; </span><span class="c7">&isin; S. A minimum hitting set H is a minimum cardinality hitting set s.t. </span><span class="c10">&forall;</span><span class="c7">e &isin; H, we have H \ {e} is not a hitting set of S. </span></p><p class="c24"><span class="c7">We assume that each rule modification is associated with a unit cost. Given an instance of the hitting set problem, we construct an instance of the R</span><span class="c2">ULE </span><span class="c7">G</span><span class="c2">ENERALIZATION </span><span class="c7">P</span><span class="c2">ROBLEM </span><span class="c7">were there no fraudulent or legitimate transactions in I and I</span><span class="c3">&prime; </span><span class="c7">consist of only one fraudulent transaction, as follows. </span></p><p class="c129 c144"><span class="c7">The transaction relation has |U | columns, one for each element in U. The transaction relation I has a characteristic (unlabeled) tuple for every set s &isin; S. That is, for every set s in S, we construct a characteristic tuple of s in I by placing a </span><span class="c10">0 </span><span class="c7">in position i if x</span><span class="c9">i </span><span class="c17">&isin; s </span><span class="c7">and </span><span class="c10">1 </span><span class="c7">otherwise. Hence there are |S| tuples in the transaction </span></p><p class="c33"><span class="c19">268 </span></p><p class="c110"><span class="c7">relation I and these are unlabeled tuples that we would like to minimize capturing with the rules. There are no existing fraudulent or legitimate tuples in I. The set &Phi; is initially empty. Hence, &Phi;(I) does not capture any transaction (and thus, by definition, is &ldquo;perfect&rdquo; for I). The instance I </span><span class="c3">&prime; </span><span class="c7">consists of a single transaction (1,1,1,...,1), which is the new fraudulent transaction that we wish to capture. </span></p><p class="c86"><span class="c7">As an example, consider the following hitting set where U = {A</span><span class="c15">1</span><span class="c7">,A</span><span class="c15">2</span><span class="c7">,A</span><span class="c15">3</span><span class="c7">,A</span><span class="c15">4</span><span class="c7">,A</span><span class="c15">5</span><span class="c7">} and S = {s</span><span class="c15">1</span><span class="c7">,s</span><span class="c15">2</span><span class="c7">,s</span><span class="c15">3</span><span class="c7">}, where s</span><span class="c15">1 </span><span class="c7">= {A</span><span class="c15">1</span><span class="c7">,A</span><span class="c15">2</span><span class="c7">,A</span><span class="c15">3</span><span class="c7">}, s</span><span class="c8">2 </span><span class="c17">= {A</span><span class="c8">2</span><span class="c17">,A</span><span class="c8">3</span><span class="c17">,A</span><span class="c8">4</span><span class="c17">,A</span><span class="c8">5</span><span class="c17">}, and s</span><span class="c8">3 </span><span class="c17">= {A</span><span class="c8">4</span><span class="c17">,A</span><span class="c8">5</span><span class="c17">}. The transaction rela- </span><span class="c7">tion I &cup; I </span><span class="c3">&prime; </span><span class="c7">(where I </span><span class="c3">&prime; </span><span class="c7">is highlighted in gray) is shown below. The last column annotates the type of tuple (e.g., the last tuple is a fraudulent transaction). </span></p><p class="c157"><span class="c5">A</span><span class="c6">1 </span><span class="c38">A</span><span class="c6">2 </span><span class="c38">A</span><span class="c6">3 </span><span class="c38">A</span><span class="c6">4 </span><span class="c38">A</span><span class="c6">5 </span><span class="c5">0 0 0 1 1 1 0 0 0 0 1 1 1 0 0 1 1 1 1 1 F&rsquo; </span><span class="c7">It is straightforward to verify that the construction of the in- stance of the Rule Modification Problem can be achieved in poly- nomial time in the size of the input of the Hitting Set Problem. We now show that a solution for the Minimum Hitting Set Problem implies a solution for the Rule Modification Problem and vice versa. </span></p><p class="c165"><span class="c7">Let H be the minimum hitting set. For every element x</span><span class="c9">i </span><span class="c17">in H, </span><span class="c7">we add a condition a</span><span class="c25">i </span><span class="c7">= </span><span class="c10">1 </span><span class="c7">to the same rule. (The condition can also be a</span><span class="c9">i </span><span class="c17">&ge; </span><span class="c26">1 </span><span class="c17">or a</span><span class="c9">i </span><span class="c17">&gt; </span><span class="c26">0 </span><span class="c17">but wlog we assume a</span><span class="c9">i </span><span class="c17">= </span><span class="c26">1 </span><span class="c17">is used.) </span><span class="c7">The cost of changing a</span><span class="c9">i </span><span class="c17">= </span><span class="c26">1 </span><span class="c17">is 1. Clearly, we have that &Phi;</span><span class="c25">&prime;</span><span class="c17">(I &cup; I </span><span class="c25">&prime;</span><span class="c17">) </span><span class="c7">contains the fraudulent transaction and since H hits every set s &isin; S, for every s &isin; S, there must be at least an attribute a</span><span class="c9">i </span><span class="c17">in the </span><span class="c7">corresponding tuple of s whose value </span><span class="c10">0 </span><span class="c7">when the condition a</span><span class="c25">i </span><span class="c7">= </span><span class="c10">1 </span><span class="c7">according to the new rule &Phi;</span><span class="c3">&prime;</span><span class="c7">. Hence, it follows that &Phi;</span><span class="c3">&prime;</span><span class="c7">(I &cup;I </span><span class="c3">&prime;</span><span class="c7">) does not contain any tuples in I &cup; I </span><span class="c3">&prime; </span><span class="c7">other than the fraudulent tuple. </span></p><p class="c183"><span class="c7">We show next that the expression cost(M)&minus;(&alpha; &lowast;&#8710;F+ &beta; &lowast;&#8710;L+ &gamma; &lowast; &#8710;R) is the minimum possible, assuming that &alpha; = &beta; = &gamma; &gt; </span><span class="c10">1 </span><span class="c7">(&beta; is actually irrelevant here) and the cost of each modification is </span><span class="c10">1</span><span class="c7">. Suppose there is another set of modifications whose cost is lower than the above. It must be that none of the unlabeled tuples are selected by the modified rules since one can always avoid capturing an unlabeled tuple and lower the cost even further by adding an appropriate condition a</span><span class="c9">i </span><span class="c17">= </span><span class="c26">1</span><span class="c17">. Furthermore, by the </span><span class="c7">same reason, the fraudulent tuple must be selected by the modified rules. Thus, the expression cost(M)&minus;(&alpha; &lowast; &#8710;F + &beta; &lowast; &#8710;L +&gamma; &lowast; &#8710;R) is the minimum possible when the number of a</span><span class="c9">i </span><span class="c17">= </span><span class="c26">1 </span><span class="c17">conditions </span><span class="c7">correspond to the size of a the minimum hitting set. Any smaller value will mean we have a smaller cardinality hitting set which is a contradiction to our assumption that H is a minimum hitting set. For the converse, let M be the set of modifications made to &Phi; such that cost(M)&minus;(&alpha; &lowast;&#8710;F+&beta; &lowast;&#8710;L+&gamma; &lowast;&#8710;R) is minimum. Again, wlog, we may assume that the modifications must be of the form a</span><span class="c9">i </span><span class="c17">= </span><span class="c26">1</span><span class="c17">. </span></p><p class="c64"><span class="c7">Let H = {x</span><span class="c25">i </span><span class="c7">| a</span><span class="c25">i </span><span class="c7">= </span><span class="c10">1 </span><span class="c7">in the modified rule}. We show next that H is a minimum hitting set. First, we show that H is a hitting set. Suppose not, then there is a set s &isin; S such that H &cap;s = &empty;. Let t be the tuple that corresponds to s in the transaction table. This means that &Phi;</span><span class="c3">&prime;</span><span class="c7">(I &cup; I </span><span class="c3">&prime;</span><span class="c7">) contains t, since t contains the value </span><span class="c10">1 </span><span class="c7">in every attribute a</span><span class="c9">i </span><span class="c17">where a</span><span class="c9">i </span><span class="c17">= </span><span class="c26">1 </span><span class="c17">in the modified rule. Pick an element, </span><span class="c7">say x</span><span class="c25">j </span><span class="c7">&isin; s such that x</span><span class="c25">j </span><span class="c7">H. Now if we add the modification a</span><span class="c9">j </span><span class="c17">= </span><span class="c26">1</span><span class="c17">, the change in cost is +1-&gamma;. Since &gamma; &gt; </span><span class="c26">1</span><span class="c17">, we have that the </span><span class="c7">new total cost is lower than the original cost which contradicts the assumption that M is a set of modifications that would give the minimum total cost. </span></p><p class="c22 c63"><span class="c7">Next, we show that H is a minimum hitting set. Suppose not, then there is another hitting set H</span><span class="c3">&prime; </span><span class="c7">where |H</span><span class="c3">&prime;</span><span class="c7">| &lt; |H|. With H </span><span class="c3">&prime;</span><span class="c7">, it is straightforward to construct a set of modifications whose cost is lower than cost(M)&minus;(&alpha; &lowast; &#8710;F + &beta; &lowast; &#8710;L +&gamma; &lowast; &#8710;R). </span></p><p class="c73"><span class="c7">In our running example, a modified rule is </span></p><p class="c137"><span class="c5">A</span><span class="c14">1 </span><span class="c38">&le;&#8868;&and; A</span><span class="c14">2 </span><span class="c38">= </span><span class="c114">1 </span><span class="c38">&and; A</span><span class="c14">3 </span><span class="c38">&le;&#8868;&and; A</span><span class="c14">4 </span><span class="c38">= </span><span class="c114">1 </span><span class="c38">&and; A</span><span class="c14">5 </span><span class="c38">&le; &#8868; </span><span class="c7">since a minimum hitting set is {A</span><span class="c15">2</span><span class="c7">,A</span><span class="c15">4</span><span class="c7">}. </span><span class="c10">D </span></p><p class="c141"><span class="c7">The reduction of the above proof shows that the NP-hardness result may arise because we allow the size of the schema of the transaction relation to vary. We show next that, even if we fix the size of the schema, the NP-hardness result continues to hold. </span></p><p class="c82"><span class="c7">T</span><span class="c2">HEOREM </span><span class="c7">4.3. The R</span><span class="c2">ULE </span><span class="c7">G</span><span class="c2">ENERALIZATION </span><span class="c7">P</span><span class="c2">ROBLEM </span><span class="c7">is NP-hard even if &Phi; is perfect for I and the size of the schema of the transaction relation is fixed. </span></p><p class="c65 c55 c71"><span class="c7">S</span><span class="c2">KETCH</span><span class="c7">. The proof makes use of a reduction from the set cover problem and in the reduction, a single unary transaction relation is used. We build a taxonomy of the elements of a set cover instance according to which element belongs to which set. The relation is initially empty and assume &Phi; is initially empty as well. The cost of adding rule with a condition is 1 and we assume that the cost of adding the condition A &le; &#8868; is very high (i.e., it is prohibited). The new transaction relation I </span><span class="c3">&prime; </span><span class="c7">consists of n new fraudulent transactions, one for each element of the universe in the set cover instance. One can then establish that a set of rules of minimum cost can be derived from a minimum set cover and vice versa. Intuitively, each rule has the form A &le; S</span><span class="c9">i </span><span class="c17">where each </span><span class="c7">S</span><span class="c9">i </span><span class="c17">is part of the solution to the instance of the minimum set cover </span><span class="c7">problem. </span><span class="c10">D </span></p><p class="c55 c65"><span class="c7">The Algorithm In view of the hardness result, we develop a heuristic algorithm (Algo. 1) for determining a best set of general- izations to capture a given set of fraudulent transactions. </span></p><p class="c18"><span class="c7">In the algorithm, we use I to denote both old and new trans- actions. Observe that one reason for the hardness of the rule generalization problem comes from the desire to identify a set of modifications that captures all fraudulent transactions and is globally optimal. Instead, our heuristic works in a greedy manner, gradually covering more and more uncaptured transactions. Rather than treating each transaction individually, we split the fraudulent transactions into smaller groups (clusters) of transactions that are similar to each other, based on a distance function, and treat each cluster individually. We denote the set of clusters by C. Each cluster in C is represented by a representative tuple. Intuitively, a representative tuple of a cluster is a tuple that &ldquo;contains&rdquo; every tuple in that cluster. Hence, if a rule is generalized to capture the representative tuple, then it must also capture every tuple in the associated cluster. The algorithm then identifies for each repre- sentative tuple the (top-k) best rule modifications to capture it. The proposed modifications are verified with the domain expert, who may interactively further adapt them or ask for additional suggestions. Note that the modifications made to the rules by the algorithm may result in capturing some legitimate tuples. We will see how this too may be avoided later. </span></p><p class="c174 c196"><span class="c7">We next describe our algorithm more formally. We first define each of the components, then provide a comprehensive example that illustrates all. Representative tuple of a cluster The representative tuple f of a clusterC is a tuple with the same schema as tuples in C such that for every attribute A, f .A contains t.A for every t &isin; C. If A is an attribute with a total order, then f .A is an interval that contains t.A. </span></p><p class="c4"><span class="c19">269 </span></p><p class="c187"><span class="c7">Algorithm 1: Generalize rules to capture new fraudulent tuples </span></p><p class="c194"><span class="c5">Input: A set &Phi; of rules for a transaction relation I (contains old </span></p><p class="c113"><span class="c5">and new transactions), with F &sube; I and F</span><span class="c49">&prime; </span><span class="c5">&sube; I. Output: A new set &Phi;</span><span class="c49">&prime; </span><span class="c5">of rules that captures F &cup; F </span><span class="c49">&prime;</span><span class="c5">. </span><span class="c0">1 </span><span class="c5">Let C denote the result of clustering tuples in F &cup; F </span><span class="c49">&prime;</span><span class="c5">. </span><span class="c0">2 </span><span class="c5">foreach C &isin; C do </span><span class="c0">3 </span><span class="c5">Let f (C) be the representative tuple of C. </span><span class="c0">4 </span><span class="c5">Let Top-k(f (C)) denote the top-k rules for f (C) based on </span></p><p class="c11"><span class="c5">Equation 2. </span><span class="c0">5 </span><span class="c5">foreach C &isin; C do </span><span class="c0">6 </span><span class="c5">while there does not exist a rule r such that f (C) &isin; r(I) do </span><span class="c0">7 </span><span class="c5">if Top-k(f (C)) is non-empty then </span><span class="c0">8 </span><span class="c5">Remove the next top rule r from Top-k(f (C)). </span><span class="c0">9 </span><span class="c5">Construct the smallest generalization of r to r</span><span class="c49">&prime; </span><span class="c5">so </span></p><p class="c179"><span class="c5">that f (C) &isin; r</span><span class="c49">&prime;</span><span class="c5">(I). </span><span class="c0">10 </span><span class="c5">Ask whether the rule r</span><span class="c49">&prime; </span><span class="c5">is correct. </span><span class="c0">11 </span><span class="c5">if the domain expert agrees with the modified r</span><span class="c49">&prime; </span><span class="c5">then </span><span class="c0">12 </span><span class="c5">Replace r with r</span><span class="c49">&prime; </span><span class="c5">in &Phi;. </span><span class="c0">13 </span><span class="c5">else </span><span class="c0">14 </span><span class="c5">Ask the domain expert which modifications in r</span><span class="c49">&prime; </span></p><p class="c140"><span class="c5">are undesired. </span><span class="c0">15 </span><span class="c5">Revert the modifications to the original </span></p><p class="c112"><span class="c5">conditions of r as indicated by the domain expert. </span><span class="c0">16 </span><span class="c5">Allow the domain expert to make further </span></p><p class="c60"><span class="c5">generalizations to the proposed rule. </span></p><p class="c155"><span class="c0">17 </span><span class="c5">else </span><span class="c0">18 </span><span class="c5">Create a rule that will select exactly f (C) and add it </span></p><p class="c160"><span class="c5">to &Phi;. </span></p><p class="c118"><span class="c0">19 </span><span class="c5">return &Phi; as &Phi;</span><span class="c49">&prime;</span><span class="c5">. </span></p><p class="c37"><span class="c7">If A is a categorical attribute, then f .A is a concept that contains t.A for every t &isin; C. Furthermore, f .A is the smallest interval (resp. concept) that has the above property.</span><span class="c3">2 </span><span class="c7">In other words, f is the &ldquo;smallest&rdquo; such tuple that contains every tuple in C. Intuitively, the clustering step, which generates representative tuples, provides a higher-level semantic abstraction to the fraudulent tuples that are to be captured. Distance of a rule from a representative tuple The notation |f &minus;r| denotes the distance of a rule r from a representative tuple f . Intuitively it reflects how much the conditions in the rule need to be generalized for the rule to capture the representative tuple. It is formally defined as: </span></p><p class="c163"><span class="c7">&Sigma;</span><span class="c3">n</span><span class="c25">i </span><span class="c68">(f .A</span><span class="c25">i </span><span class="c7">&minus;r.A</span><span class="c9">i</span><span class="c17">), (1) </span><span class="c7">where r.A</span><span class="c25">i </span><span class="c7">denotes the interval or concept associated with the condition of attribute A</span><span class="c9">i </span><span class="c17">in the rule r, and n is the arity of the </span><span class="c7">transaction relation. </span></p><p class="c136"><span class="c7">The distance between two attribute intervals is defined as fol- lows. If f .A is the interval [s</span><span class="c8">1</span><span class="c17">,e</span><span class="c8">1</span><span class="c17">] and r.A is the interval [s</span><span class="c8">2</span><span class="c17">,e</span><span class="c8">2</span><span class="c17">], </span><span class="c7">then |[s</span><span class="c8">1</span><span class="c17">,e</span><span class="c8">1</span><span class="c17">]&minus;[s</span><span class="c8">2</span><span class="c17">,e</span><span class="c8">2</span><span class="c17">]| is the sum of sizes of the smallest inter- </span><span class="c7">val(s) needed to extend [s</span><span class="c15">2</span><span class="c7">,e</span><span class="c15">2</span><span class="c7">] so that it contains [s</span><span class="c15">1</span><span class="c7">,e</span><span class="c15">1</span><span class="c7">]. For example, the distance of |[</span><span class="c10">1</span><span class="c7">,</span><span class="c10">5</span><span class="c7">]&minus;[</span><span class="c10">5</span><span class="c7">,</span><span class="c10">100</span><span class="c7">]| is 4, while the distance of |[</span><span class="c10">1</span><span class="c7">, </span><span class="c10">100</span><span class="c7">]&minus;[</span><span class="c10">1</span><span class="c7">, </span><span class="c10">5</span><span class="c7">]| is 95. The distance of |[</span><span class="c10">5</span><span class="c7">,</span><span class="c10">10</span><span class="c7">]&minus;[</span><span class="c10">1</span><span class="c7">,</span><span class="c10">100</span><span class="c7">]| is 0, since [1,100] already covers [5,10]. If an attribute A is categorical, then |f .A&minus;r.A| is the length of the smallest &ldquo;ontological distance&rdquo; that need to be added to r.A so that it contains f .A. For example, |Offline with PIN - Online with CCV| is 1, and |Offline without </span></p><p class="c81"><span class="c23">2</span><span class="c101">If there are multiple such concepts, e.g. in non tree-shaped concept hierarchies, we </span><span class="c31">pick one. </span></p><p class="c1 c55"><span class="c7">PIN - Online with CCV| is 2. By leveraging concepts in the ontol- ogy when available, the resulting rules have a more meaningful interpretation. The overall cost function The overall cost of modifying a rule r to capture a representative tuple f then reflects the amount of modifications that need to be carried (Equation 1) minus the benefit derived from those modifications: </span></p><p class="c90"><span class="c7">&Sigma;</span><span class="c3">n</span><span class="c25">i </span><span class="c68">(f .A</span><span class="c3">i </span><span class="c68">&minus; r.A</span><span class="c3">i</span><span class="c68">)&minus;(&alpha; &lowast; &#8710;F + &beta; &lowast; &#8710;L +&gamma; &lowast; &#8710;R) (2) </span></p><p class="c55 c93"><span class="c7">Putting things together We now have all the ingredients for describing our algorithms. The algorithm proceeds by clustering the transactions into groups and then computes a representative tuple for each cluster. </span><span class="c3">3 </span><span class="c7">For every cluster C, we compute its representative tuple f (C) as well the cost (according to Equation 2) of modifying each of the rules to capture it, and select the k rules with minimal cost. We refer to them as the top-k rules (see Line 4 of Algo. 1). In Line 8, we pick the top rule in top-k(f (C)). If the rule r(I) does not already contain f (C), we will attempt to make the smallest generalization on r to r</span><span class="c3">&prime; </span><span class="c7">so that r </span><span class="c3">&prime;</span><span class="c7">(I) contains f (C). Whenever the interval or concept of an attribute r.A does not contain f .A, we will attempt to modify r.A by computing the smallest extension needed on r.A based on its distance from f .A. We perform this extension on every attribute A of r wherer.A does not contain f .A. This is what we mean by &ldquo;generalize r minimally to r</span><span class="c3">&prime; </span><span class="c7">so that f (C) &isin; r</span><span class="c3">&prime;</span><span class="c7">(I)&rdquo; in line 9. </span></p><p class="c115"><span class="c7">Next, we proceed to verify the new rule r </span><span class="c3">&prime; </span><span class="c7">with our potential modifications with the domain expert. If the domain expert agrees with the proposed modifications (lines 11,12), we will replace r with the new rule r</span><span class="c3">&prime; </span><span class="c7">in &Phi;. Otherwise, we will refine our question to probe the domain expert further on whether or not there are parts of the modifications that are desired even though the entire rule r </span><span class="c3">&prime; </span><span class="c7">is not what the domain expert desires (lines 14,15). We then modify only the desired modifications, if any. The next step allows the domain expert to make further generalizations to the rules. After this, the algorithm proceeds to pick another closest rule to f (C) to attempt to capture f (C). Line 18 captures the case when we ran out of rules to modify. If this happens, we will construct a new rule to cover f by stating the exact conditions that are required. </span></p><p class="c57"><span class="c7">We conclude with a remark regarding the computational com- plexity of the algorithm. All components of the algorithm (i.e., clustering, computation of representative tuples for each cluster and the top-k rules) execute in PTIME in the size of its input. Hence each iteration executes in PTIME in the size of the input. The number of iterations per cluster is dependent on the amount of refinements that the expert makes to the suggested rule modifi- cations (shown in our experiments to be fairly small). </span></p><p class="c207"><span class="c7">Example 4.4. The relation below depicts the representative tuples of the clusters formed from the six fraudulent transactions from Figure 2. The first tuple is the representative tuple of the cluster that consists of the first two tuples in Figure 2. The second (resp. third) tuple below is the representative of the cluster that consists of only the 4th tuple in Figure 2 (resp., 6th, 7th, and 8th tuples). </span></p><p class="c159"><span class="c23">3</span><span class="c101">In our implementation, we use the clustering algorithms of [12], but other clustering </span><span class="c31">algorithms can be similarly be used. </span></p><p class="c32"><span class="c19">270 </span></p><p class="c123"><span class="c5">Representatives of fraudulent transactions in Figure 2: Time Amount Transaction Type Location [18:02,18:03] [106,107] Online, no CCV Online Store [19:08,19:08] [114,114] Online, no CCV Online Store [20:53,20:58] [44,48] Offline, without PIN GAS Station B </span></p><p class="c156"><span class="c5">: : : : </span><span class="c7">Consider a domain expert, Elena, that is working with the system. The first rule in Figure 1 is the closest to the first rep- resentative tuple above. This is because Equation 2 evaluates to (0+4+0+0)-(2+0+0)=2 for the first rule and the first representa- tive tuple, whereas the second and third rule of Figure 1 and the first representative tuple have scores (53+4+0+0)-(2+0-1)=56 and (178+0+0+1)-(6+0-3)=168, respectively, and are thus ranked lower than the first rule. The number &rsquo;1&rsquo; in the last calculation de- notes the ontological distance between &ldquo;Gas Station A&rdquo; and &ldquo;Gas Station B&rdquo;. Since they are both contained under &ldquo;Gas Station&rdquo;, the distance is 1. </span></p><p class="c40"><span class="c7">Algo. 1 will thus propose to modify the condition of the first rule from &ldquo;Amt &ge; 110&rdquo; to &ldquo;Amt &ge; 106&rdquo; to capture the representa- tive tuple. It then proceeds to verify the modification with Elena. Suppose Elena accepts the proposed modification but further gen- eralizes the condition rounding it down to &ldquo;Amt &ge; 100&rdquo; instead. So the new rule 1 is </span></p><p class="c117"><span class="c7">1) Time &isin; [18:00,18:05] &and; Amt &ge; 100. Besides the fact that rounded values may be preferred by do- main experts over more specific values, such rounding may em- body domain-specific knowledge that may possibly lead to the discovery of more fraudulent transactions, particularly from trans- actions that are unlabeled, or the discovery of legitimate transac- tions that should not have been labeled as legitimate. </span></p><p class="c191"><span class="c7">For the second and third cluster, similar interactions occur between R</span><span class="c2">UDOLF </span><span class="c7">and Elena. The new rules that result are: </span></p><p class="c210"><span class="c7">2) Time &isin; [18:55,19:15] &and; Amt &ge; 110. 3) Time &isin; [20:45, 21:15] &and; Amt &ge; 40 &and; Location&le;Gas station&rsquo;. </span></p><p class="c192"><span class="c7">To conclude, observe that Algo. 1 allows Elena to make further generalizations to the rules. Elena rounded the value down from 106 to 100 because her experience tells her that if frauds occur with amount greater than $106, then it is likely to occur a few dollars below $106 as well. Hence, she generalized (i.e., rounded down) the value to $100. In making such generalizations, the fraudulent transactions will continue to be captured. However, the modified rules may now capture (more) non-fraudulent transac- tions. Nonetheless, we still allow such generalizations since these are deliberate changes made by Elena, the domain expert. More typically, however, such &ldquo;rounding generalizations&rdquo; tend to be meaningful generalizations that may lead to the discovery of more fraudulent transactions (i.e., unlabeled transactions that should be classified as fraudulent or legitimate transactions that are mistak- enly labeled as legitimate)</span><span class="c3">4</span><span class="c7">. As we shall show in Example 4.7, Elena can also leverage her experience or domain knowledge to pinpoint the right conditions for avoiding legitimate transactions. </span></p><p class="c151"><span class="c7">We describe next how over-generalization may be treated. </span></p><p class="c200"><span class="c36">4.2 Rule Specialization Algorithm </span><span class="c7">In the previous subsection, we have seen how one generalizes rules to capture fraudulent transactions. We now discuss the opposite case, where we wish to specialize rules instead, in order to exclude legitimate transactions when there no new fraudulent transactions or unlabeled transactions but there are new legitimate transactions. </span></p><p class="c104"><span class="c23">4</span><span class="c101">This is from our conversations with domain experts on credit card fraud detection. </span></p><p class="c22 c201"><span class="c7">We call this special case the R</span><span class="c2">ULE </span><span class="c7">S</span><span class="c2">PECIALIZATION </span><span class="c7">P</span><span class="c2">ROBLEM</span><span class="c7">. Here again we can show hardness results analogous to Theorem 4.1 and 4.3. </span></p><p class="c212"><span class="c7">T</span><span class="c2">HEOREM </span><span class="c7">4.5. The R</span><span class="c2">ULE </span><span class="c7">S</span><span class="c2">PECIALIZATION </span><span class="c7">P</span><span class="c2">ROBLEM </span><span class="c7">is NP-hard even if &Phi; is perfect for I. The problem is NP-hard even when I contains only unlabeled transactions and I</span><span class="c3">&prime; </span><span class="c7">consists of only one legitimate transaction. </span></p><p class="c80 c180"><span class="c7">P</span><span class="c2">ROOF</span><span class="c7">. Given an instance of the hitting set problem, we con- struct an instance of the R</span><span class="c2">ULE </span><span class="c7">S</span><span class="c2">PECIALIZATION </span><span class="c7">P</span><span class="c2">ROBLEM </span><span class="c7">as follows. </span></p><p class="c173"><span class="c7">The transaction relation has |U | columns, one for each element in U. For every set s in S, we construct a characteristic tuple of s by placing a </span><span class="c10">0 </span><span class="c7">in position i if x</span><span class="c9">i </span><span class="c17">&isin; s and </span><span class="c26">1 </span><span class="c17">otherwise. Hence there </span><span class="c7">are |S| tuples in the transaction relation I so far and the fraudulent transactions F = I. The set &Phi; consists of a single rule </span></p><p class="c145"><span class="c7">A</span><span class="c8">1 </span><span class="c17">&le;&#8868;&and; ... &and; A</span><span class="c9">|U | </span><span class="c7">&le; &#8868;, where &#8868; denotes the top element, and hence, &Phi;(I) currently cap- tures all fraudulent transactions F. The new transaction relation I </span><span class="c3">&prime; </span><span class="c7">consists of a single tuple (1,1,1,...,1). This set L</span><span class="c3">&prime; </span><span class="c7">of legitimate transactions is a singleton set consisting of only (1,1,1,...,1). That is, L</span><span class="c3">&prime; </span><span class="c7">= I </span><span class="c3">&prime;</span><span class="c7">. This is the legitimate transaction that we wish to exclude. </span></p><p class="c182"><span class="c7">With F</span><span class="c3">&prime; </span><span class="c7">= L = &empty;, our goal is to specialize the rule in &Phi; to capture exactly the fraudulent tuples F only. Like in the proof of Theorem 4.1, we assume that each modification is associated with a unit cost and &alpha; = &beta; = &gamma; &gt; </span><span class="c10">1</span><span class="c7">. </span></p><p class="c202"><span class="c7">As an example, consider the same hitting set as in the proof of Theorem 4.1, where U = {A</span><span class="c15">1</span><span class="c7">,A</span><span class="c15">2</span><span class="c7">,A</span><span class="c15">3</span><span class="c7">,A</span><span class="c15">4</span><span class="c7">,A</span><span class="c15">5</span><span class="c7">} and S = {s</span><span class="c15">1</span><span class="c7">,s</span><span class="c15">2</span><span class="c7">,s</span><span class="c15">3</span><span class="c7">}, wheres</span><span class="c8">1 </span><span class="c17">= {A</span><span class="c8">1</span><span class="c17">,A</span><span class="c8">2</span><span class="c17">,A</span><span class="c8">3</span><span class="c17">},s</span><span class="c8">2 </span><span class="c17">= {A</span><span class="c8">2</span><span class="c17">,A</span><span class="c8">3</span><span class="c17">,A</span><span class="c8">4</span><span class="c17">,A</span><span class="c8">5</span><span class="c17">}, ands</span><span class="c8">3 </span><span class="c17">= {A</span><span class="c8">4</span><span class="c17">,A</span><span class="c8">5</span><span class="c17">}. </span><span class="c7">The transaction relation I &cup; I </span><span class="c3">&prime; </span><span class="c7">is shown below (where I </span><span class="c3">&prime; </span><span class="c7">is shown in gray). The last column annotates the type of tuple (i.e., F for tuples in F and L&rsquo; for tuples in L</span><span class="c3">&prime;</span><span class="c7">). </span></p><p class="c206"><span class="c5">A</span><span class="c6">1 </span><span class="c38">A</span><span class="c6">2 </span><span class="c38">A</span><span class="c6">3 </span><span class="c38">A</span><span class="c6">4 </span><span class="c38">A</span><span class="c6">5 </span></p><p class="c164"><span class="c5">0 0 0 1 1 F 1 0 0 0 0 F 1 1 1 0 0 F 1 1 1 1 1 L&rsquo; </span></p><p class="c45"><span class="c7">It is straightforward to verify that the reduction to an instance of the R</span><span class="c2">ULE </span><span class="c7">S</span><span class="c2">PECIALIZATION </span><span class="c7">P</span><span class="c2">ROBLEM </span><span class="c7">can be achieved in polynomial time in the size of the input of the Hitting Set Problem. We now show that a solution for the Minimum Hitting Set Problem implies a solution for the R</span><span class="c2">ULE </span><span class="c7">S</span><span class="c2">PECIALIZATION </span><span class="c7">P</span><span class="c2">ROBLEM </span><span class="c7">and vice versa. </span></p><p class="c39"><span class="c7">Let H be a minimum hitting set. For every element x</span><span class="c9">i </span><span class="c17">in H, </span><span class="c7">we duplicate the original rule (except if this is the last element in H) and modify the corresponding condition to a</span><span class="c25">i </span><span class="c7">= </span><span class="c10">0 </span><span class="c7">in the copy of the rule. (The condition can also be a</span><span class="c9">i </span><span class="c17">&le; </span><span class="c26">0 </span><span class="c17">or a</span><span class="c9">i </span><span class="c17">&lt; </span><span class="c26">1 </span><span class="c17">but </span><span class="c7">wlog we assume a</span><span class="c9">i </span><span class="c17">= </span><span class="c26">0 </span><span class="c17">is used.) Recall that the cost of changing </span><span class="c7">a</span><span class="c25">i </span><span class="c7">= </span><span class="c10">0 </span><span class="c7">is 1, and the cost of duplicating a rule is </span><span class="c10">1</span><span class="c7">. Clearly, we have that &Phi;</span><span class="c3">&prime;</span><span class="c7">(I &cup; I </span><span class="c3">&prime;</span><span class="c7">) contains F. Indeed, since H hits every set s &isin; S, there must be an element in s whose corresponding value under an attribute a</span><span class="c9">i </span><span class="c17">is </span><span class="c26">0 </span><span class="c17">when the condition a</span><span class="c9">i </span><span class="c17">= </span><span class="c26">0 </span><span class="c17">according to a new rule </span><span class="c7">in &Phi;</span><span class="c3">&prime;</span><span class="c7">. Hence, it follows that &Phi;</span><span class="c3">&prime;</span><span class="c7">(I &cup; I</span><span class="c3">&prime;</span><span class="c7">) contains F and since each rule in &Phi;</span><span class="c3">&prime; </span><span class="c7">contains a condition of the form a</span><span class="c25">i </span><span class="c7">= </span><span class="c10">0</span><span class="c7">, the legitimate transaction (1,1,1,...1) will not be among &Phi;</span><span class="c3">&prime;</span><span class="c7">(I &cup; I </span><span class="c3">&prime;</span><span class="c7">). </span></p><p class="c94"><span class="c7">We show next that the expression cost(M)&minus;(&alpha;&lowast;&#8710;F+&beta;&lowast;&#8710;L+&gamma; &lowast; &#8710;R) is the minimum possible. Suppose there is another set M</span><span class="c3">&prime; </span><span class="c7">of modifications to &Phi;</span><span class="c3">&prime;&prime; </span><span class="c7">such that cost(M</span><span class="c3">&prime;</span><span class="c7">)&minus;(&alpha; &lowast;&#8710;F+&beta; &lowast;&#8710;L+&gamma; &lowast;&#8710;R) is less than the previous expression. Observe that every rule in &Phi;</span><span class="c3">&prime;&prime; </span><span class="c7">must contain at least a condition that is specific to selecting </span></p><p class="c66"><span class="c19">271 </span></p><p class="c161"><span class="c7">a fraudulent transaction. That is, for every rule, a</span><span class="c25">i </span><span class="c7">= </span><span class="c10">0 </span><span class="c7">for some i since otherwise, the rule is either redundant or the legitimate transaction will be selected. Also, we can assume that every other condition in the rule in &Phi;</span><span class="c3">&prime;&prime; </span><span class="c7">cannot contain a condition that selects 1s (e.g., of the form a</span><span class="c9">i </span><span class="c17">= </span><span class="c26">1</span><span class="c17">). If a rule r contains a condition a</span><span class="c9">i </span><span class="c17">= </span><span class="c26">1</span><span class="c17">, </span><span class="c7">then we can omit this condition and assume it is a</span><span class="c9">i </span><span class="c17">&le; &#8868; instead. </span><span class="c7">The rule with a</span><span class="c25">i </span><span class="c7">&le; &#8868; captures all tuples that are captured by r (and possibly more) and hence, we will continue to capture all fraudulent tuples and continue to exclude the legitimate tuple under this assumption. Similarly, if a rule r contains multiple conditions a</span><span class="c9">i </span><span class="c17">= </span><span class="c26">0</span><span class="c17">s, then we can omit all but one of the a</span><span class="c9">i </span><span class="c17">= </span><span class="c26">0</span><span class="c17">s </span><span class="c7">and assume the rest are a</span><span class="c9">i </span><span class="c17">&le; &#8868;. We can now construct a hitting </span><span class="c7">set from M</span><span class="c3">&prime; </span><span class="c7">that is smaller than H, which is a contradiction. </span></p><p class="c147"><span class="c7">For the converse, let M be the set of modifications made to &Phi; such that F &sube; &Phi;</span><span class="c3">&prime;</span><span class="c7">(I &cup; I </span><span class="c3">&prime;</span><span class="c7">), the legitimate transaction l is such that l &Phi;</span><span class="c3">&prime;</span><span class="c7">(I &cup; I </span><span class="c3">&prime;</span><span class="c7">), and cost(M)&minus;(&alpha; &lowast; &#8710;F + &beta; &lowast; &#8710;L + &gamma; &lowast; &#8710;R) is minimum. As before, observe that each rule must contain at least one modification of the form a</span><span class="c9">i </span><span class="c17">= </span><span class="c26">0 </span><span class="c17">for some i so that l is not </span><span class="c7">selected. Furthermore, it is easy to see that each rule must contain exactly one such condition a</span><span class="c9">i </span><span class="c17">= </span><span class="c26">0 </span><span class="c17">only as additional conditions </span><span class="c7">such as a</span><span class="c9">j </span><span class="c17">= </span><span class="c26">1 </span><span class="c17">or a</span><span class="c9">j </span><span class="c17">= </span><span class="c26">0 </span><span class="c17">are redundant and can only increase the </span><span class="c7">cost.</span><span class="c17">Let H = {x</span><span class="c9">i </span><span class="c17">| a</span><span class="c9">i </span><span class="c17">= </span><span class="c26">0 </span><span class="c17">in any of the modified rules}. We show </span><span class="c7">next that H is a minimum hitting set. First, we show that H is a hitting set. Suppose not, then there is a set s &isin; S such that H &cap;s = &empty;. In other words, for every element x</span><span class="c9">i </span><span class="c17">&isin; s, there does not </span><span class="c7">exist a rule in &Phi;</span><span class="c3">&prime; </span><span class="c7">where a</span><span class="c9">i </span><span class="c17">= </span><span class="c26">0</span><span class="c17">. Let f be the tuple that corresponds </span><span class="c7">to s in the transaction table. This means that f &Phi;</span><span class="c3">&prime;</span><span class="c7">(I &cup; I </span><span class="c3">&prime;</span><span class="c7">), which contradicts our assumption that F &sube; &Phi;</span><span class="c3">&prime;</span><span class="c7">(I &cup; I </span><span class="c3">&prime;</span><span class="c7">). </span></p><p class="c139"><span class="c7">Next, we show that H is a minimum hitting set. Suppose not, then there is another hitting set H</span><span class="c3">&prime; </span><span class="c7">where |H</span><span class="c3">&prime;</span><span class="c7">| &lt; |H|. With H </span><span class="c3">&prime;</span><span class="c7">, it is straightforward to construct a set of modifications whose cost is lower than M&rsquo;s cost. </span></p><p class="c76"><span class="c7">In our running example, &Phi;</span><span class="c3">&prime; </span><span class="c7">contains two rules: </span></p><p class="c74"><span class="c5">A</span><span class="c14">1 </span><span class="c5">&le;&#8868;&and; A</span><span class="c14">2 </span><span class="c5">= </span><span class="c67">0 </span><span class="c5">&and; A</span><span class="c14">3 </span><span class="c5">&le;&#8868;&and; A</span><span class="c14">4 </span><span class="c5">&le;&#8868;&and; A</span><span class="c14">5 </span><span class="c5">&le; &#8868; A</span><span class="c14">1 </span><span class="c38">&le;&#8868;&and; A</span><span class="c14">2 </span><span class="c38">&le;&#8868;&and; A</span><span class="c14">3 </span><span class="c38">&le;&#8868;&and; A</span><span class="c14">4 </span><span class="c38">= </span><span class="c114">0 </span><span class="c38">&and; A</span><span class="c14">5 </span><span class="c38">&le; &#8868; </span></p><p class="c44"><span class="c7">since a minimum hitting set is {A</span><span class="c8">2</span><span class="c17">,A</span><span class="c8">4</span><span class="c17">}. </span><span class="c26">D </span></p><p class="c171"><span class="c7">Similarly, we can show that the NP-hardness continues to hold even if we fix the size of the schema. </span></p><p class="c54"><span class="c7">T</span><span class="c2">HEOREM </span><span class="c7">4.6. The R</span><span class="c2">ULE </span><span class="c7">S</span><span class="c2">PECIALIZATION </span><span class="c7">P</span><span class="c2">ROBLEM </span><span class="c7">is also NP-hard even if &Phi; is perfect for I and the size of the schema of the transaction relation is fixed. </span></p><p class="c169"><span class="c7">S</span><span class="c2">KETCH</span><span class="c7">. The proof of the above result is similar to that of Theorem 4.3. It makes use of a reduction from the set cover problem and in the reduction, a single unary transaction relation is used. We build a taxonomy of the elements of a set cover instance according to which element belongs to which set. The relation initially contains all elements of the universe of the set cover instance and these transactions are all fraudulent. The set &Phi; consists of a single rule A &le; &#8868; which captures all fraudulent transactions. The cost of adding a rule and modifying a condition cost 1 each. The new transaction relation I</span><span class="c3">&prime; </span><span class="c7">consists of a single legitimate tuple whose value does not occur among the existing values. One can then establish that a set of rules of minimum cost can be derived from a minimum set cover and vice versa. Intuitively, each rule has the form A &le; S</span><span class="c9">i </span><span class="c17">where each S</span><span class="c9">i </span><span class="c17">is part of </span><span class="c7">the solution to the instance of the minimum set cover problem. </span><span class="c10">D </span></p><p class="c1 c152"><span class="c7">Algorithm 2: Adapt rules to exclude legitimate tuples </span></p><p class="c208"><span class="c5">Input: A set &Phi; of rules for a transaction relation I (contains old </span></p><p class="c79"><span class="c5">and new transactions) with L &sube; I and L</span><span class="c49">&prime; </span><span class="c5">&sube; I. Output: A new set &Phi;</span><span class="c49">&prime; </span><span class="c5">of rules that excludes L &cup; L</span><span class="c49">&prime;</span><span class="c5">. </span><span class="c0">1 </span><span class="c5">foreach l &isin; (L &cup; L</span><span class="c49">&prime;</span><span class="c5">) do </span><span class="c0">2 </span><span class="c5">Let &Omega;</span><span class="c14">l </span><span class="c5">= {r &isin; &Phi; | l &isin; r(I)}. </span><span class="c0">3 </span><span class="c5">foreach r &isin; &Omega;</span><span class="c14">l </span><span class="c5">do </span><span class="c0">4 </span><span class="c5">repeat </span><span class="c0">5 </span><span class="c5">Let A be an attribute that has not been considered </span></p><p class="c195"><span class="c5">before and where splitting on A to exclude l.A will minimize the cost associated with splitting on A. </span><span class="c0">6 </span><span class="c5">Suppose the existing condition on A is A &isin; [b, e]. </span><span class="c0">7 </span><span class="c5">Split r into r</span><span class="c14">1 </span><span class="c5">and r</span><span class="c14">2 </span><span class="c5">on A as follows: </span><span class="c0">8 </span><span class="c5">Let r</span><span class="c14">1 </span><span class="c5">be a copy of r except that the condition on A </span></p><p class="c158"><span class="c5">is A &isin; [b, prev(r .A)]. </span><span class="c0">9 </span><span class="c5">Let r</span><span class="c14">2 </span><span class="c5">be a copy of r except that the condition on A </span></p><p class="c98"><span class="c5">is A &isin; [succ(r .A), e]. </span><span class="c0">10 </span><span class="c5">Ask the domain expert whether the split into r</span><span class="c14">1 </span><span class="c5">and </span></p><p class="c12"><span class="c5">r</span><span class="c14">2 </span><span class="c38">is correct. </span><span class="c0">11 </span><span class="c5">if the domain expert agrees with the modification </span></p><p class="c107"><span class="c5">then </span><span class="c0">12 </span><span class="c5">Add r</span><span class="c14">1 </span><span class="c5">and r</span><span class="c14">2 </span><span class="c5">to &Phi;. </span><span class="c0">13 </span><span class="c5">Allow the domain expert to make further </span></p><p class="c52"><span class="c5">modifications to the proposed rules. </span><span class="c0">14 </span><span class="c5">Break out of repeat loop. </span><span class="c0">15 </span><span class="c5">until all attributes have been considered; </span><span class="c0">16 </span><span class="c5">Remove r from &Phi;. </span></p><p class="c143"><span class="c0">17 </span><span class="c5">return &Phi; as &Phi;</span><span class="c49">&prime;</span><span class="c5">. </span></p><p class="c175"><span class="c7">The Algorithm In view of the hardness results, we develop a heuristic algorithm (Algo. 2) that greedily determines the best attribute to &ldquo;split&rdquo; to avoid capturing each legitimate tuple. </span></p><p class="c27"><span class="c7">In Algo. 2, we use I to denote both old and new transactions. For each legitimate transaction l in (L &cup; L</span><span class="c3">&prime;</span><span class="c7">), we determine the set &Omega;</span><span class="c9">l </span><span class="c7">of rules that will capture l and modify every rule in &Omega;</span><span class="c9">l </span><span class="c7">to ensure that the modified rules will no longer capture l. For a rule r in &Omega;</span><span class="c9">l</span><span class="c7">, the algorithm proceeds to pick an attribute A where we can split the condition of the attribute to exclude the value l.A. The attribute A that we pick is the one that maximizes the benefit according to the benefit &alpha; &lowast; &#8710;F + &beta; &lowast; &#8710;L + &gamma; &lowast; &#8710;R, assuming a fixed cost of modification where we copy the rule and split on the attribute. If there are multiple attributes with the same maximum benefit, we randomly pick one of them. Observe that the heuristic of greedily selecting an attribute that will maximize benefit may not be globally optimal in the end. In the proof of Theorem 4.5, this greedy heuristic is analogous to the strategy of repeatedly picking the attribute (and splitting on the attribute) that will &ldquo;hit&rdquo; the most sets until all sets are hit. Splitting on attributes Once an attribute is selected, the rule is duplicated into r</span><span class="c8">1 </span><span class="c17">and r</span><span class="c8">2 </span><span class="c17">and the condition on A in both rules is </span><span class="c7">modified to exclude l.A. Observe that since r(I) captures l, we must have that l.A satisfies the rule r&rsquo;s condition on A. In the split, r</span><span class="c8">1</span><span class="c17">&rsquo;s condition on A accept values from b to the element that is the </span><span class="c7">predecessor of l.A, where b denotes the smallest value accepted by the existing condition of r on A. The rule r</span><span class="c8">2 </span><span class="c17">selects only elements </span><span class="c7">from the successor element of l.A to the largest value (i.e., e) accepted by the existing condition of r on A. </span></p><p class="c209"><span class="c7">For domains that are discrete and has a total order, the above procedure, prev(r.A) and succ(r.A) are well-defined. However, when domains are categorical and has only a partial order, the rules will be split according to the partial order. Let O denote the </span></p><p class="c4"><span class="c19">272 </span></p><p class="c50"><span class="c7">set of all concepts (excluding l.A) that are parents of &perp; in the partial order (i.e., the leaf nodes of the partial order excluding &perp;). To exclude l.A, the algorithm considers how to select a minimum set of concepts to &ldquo;cover&rdquo; all concepts in O that excludes l.A at the same time. It can be shown that the problem of computing such a minimum set is analogous to computing a minimum set cover for O. Our procedure adopts the greedy heuristic where we greedily pick a concept in the partial hierarchy that covers the most number of uncovered concepts in O until all nodes in O are covered. For categorical attributes, it may be necessary to duplicate r more than twice, where there is a rule to select each concept in the cover. For example, referring to Figure 1, to exclude &ldquo;Online, with CCV&rdquo;, we may pick &ldquo;Offline&rdquo; and &ldquo;Online, without CCV&rdquo; to cover the remaining concepts that are parents of &ldquo;None&rdquo;. Observe that simi- lar to our algorithm on rule generalization, our rule specialization algorithm also makes use of the ontology whenever available to split the attributes meaningfully. In this case, attributes are split into meaningful concepts in the &ldquo;lower-level&rdquo; according to the ontology. </span></p><p class="c111"><span class="c7">After this, we ask whether the domain expert agrees with the split. If the domain expert agrees, we add both rules r</span><span class="c8">1 </span><span class="c17">and r</span><span class="c8">2 </span><span class="c17">to &Phi;. </span><span class="c7">The domain expert can also add further modifications to the rules (line 13), such as excluding more values than what is suggested by the algorithm, and we break out of the repeat loop. Otherwise, we repeat the loop to attempt to split r on another attribute to avoid capturing l. Note that since l has to be excluded, one of the splits must be deemed correct by the domain expert. After this, we remove r from &Phi; and repeat the same procedure to modify &Phi; to exclude the selection of another legitimate transactions. </span></p><p class="c215"><span class="c7">Example 4.7. We will now illustrate Algo. 2. The legitimate transactions from Figure 2 that are captured by the modified rules of Example 4.4 are shown below for convenience. </span></p><p class="c99"><span class="c5">Time Amount Transaction Type Location l</span><span class="c14">1 </span><span class="c5">18:04 112 Online, with CCV Online Store l</span><span class="c14">2 </span><span class="c5">19:10 117 Online, with CCV Online Store l</span><span class="c14">3 </span><span class="c5">21:01 49 Offline, with PIN GAS Station A </span></p><p class="c124"><span class="c5">: : : : </span><span class="c7">Modified rules &Phi; from Example 4.4: </span></p><p class="c132"><span class="c5">1) Time &isin; [18:00,18:05] &and; Amt &ge; 100. 2) Time &isin; [18:55,19:15] &and; Amt &ge; 110. 3) Time &isin; [20:45, 21:30] &and; Amt &ge; 40 &and; Location&le;Gas station&rsquo;. </span><span class="c7">We would like to adapt the rules to exclude these legitimate transactions (and still continue capture fraudulent transactions). For this example, assume that &alpha; = &beta; = &gamma; = </span><span class="c10">1</span><span class="c7">. </span></p><p class="c87"><span class="c7">The algorithm considers every legitimate transaction. Since l</span><span class="c15">1 </span><span class="c7">is caught by rule (1) above, Algo. 2 proceeds to determine which attribute of the rule to split in order to exclude l</span><span class="c8">1</span><span class="c17">. Splitting on </span><span class="c10">time </span><span class="c7">or </span><span class="c10">amount </span><span class="c7">or </span><span class="c10">type </span><span class="c7">will result in the same maximum benefit: (1*0 (zero unlabeled transactions on either day) + 1*0 (the number of fraudulent transactions that are caught remains unchanged) + 1*1 (one less legitimate transaction that is caught)). Splitting on the attribute </span><span class="c10">location</span><span class="c7">, however, will cause addi- tional fraudulent transactions (i.e., the first two transactions in Figure 2) to be missed and hence has a lower benefit than the rest of the attributes. </span></p><p class="c40"><span class="c7">Suppose the algorithm proposes to split on </span><span class="c10">time </span><span class="c7">(an arbitrary choice among </span><span class="c10">time</span><span class="c7">, </span><span class="c10">amount </span><span class="c7">or </span><span class="c10">type</span><span class="c7">). This will result in two rules that will capture all fraudulent transactions that were previ- ously caught by the rule and exclude l</span><span class="c8">1 </span><span class="c17">at the same time. </span></p><p class="c138"><span class="c5">r</span><span class="c14">11</span><span class="c38">: Time &isin; [18:00,18:03] &and; Amt &ge; 100. </span><span class="c5">r</span><span class="c14">12</span><span class="c38">: Time &isin; [18:05,18:05] &and; Amt &ge; 100. </span></p><p class="c1 c128"><span class="c7">At this point, Elena can accept this proposal or ask for alterna- tives. For the purpose of illustrating our algorithm, suppose Elena asked for an alternative proposed modification. Our algorithm may now propose to split on </span><span class="c10">type </span><span class="c7">instead. Since there is currently no condition on </span><span class="c10">type </span><span class="c7">in the first rule, the condition is implicitly &ldquo;type &le; &#8868;&rdquo;. And because the concepts &ldquo;Offline&rdquo; and &ldquo;Online, with- out CCV&rdquo; cover all possible type values (i.e., values immediately above the &ldquo;None&rdquo; node in Figure 1) except &ldquo;Online,with CCV&rdquo; which we wish to exclude, we have the following two rules: </span><span class="c5">r</span><span class="c14">11</span><span class="c38">: Time &isin; [18:00,18:05] &and; Amt &ge; 100 &and; Type &le; Offline. </span><span class="c5">r</span><span class="c14">12</span><span class="c5">: Time &isin; [18:00,18:05] &and; Amt &ge; 100 &and; Type &le; Onl.,no CCV. </span></p><p class="c106"><span class="c7">Using domain knowledge that only online purchases, especially those without CCVs are of concern, Elena eliminates the rule r</span><span class="c15">11</span><span class="c7">. After this, our algorithm proceeds in a manner that is similar to what was described before to split the second rule of &Phi; to omit l</span><span class="c8">2 </span><span class="c7">(and similarly, the third rule of &Phi; for l</span><span class="c15">3</span><span class="c7">). We omit the details here but show the final rules that are obtained. </span><span class="c5">r</span><span class="c14">22</span><span class="c38">: Time &isin; [18:55,19:15] &and; Amt &ge; 100 &and; Type &le; Onl., no CCV. </span><span class="c5">r</span><span class="c14">31</span><span class="c38">: Time &isin; [20:45,21:15] &and; Amt &ge; 40 &and; Location &le; Gas Station &and; </span></p><p class="c213"><span class="c5">Type &le; Online. r</span><span class="c14">32</span><span class="c38">: Time &isin; [20:45,21:15] &and; Amt &ge; 40 &and; Location &le; Gas Station &and; </span></p><p class="c30"><span class="c5">Type &le; No code. </span></p><p class="c95"><span class="c7">Observe that whenever a condition is generalized (in Algo. 1), more legitimate or unlabeled tuples may be inadvertently captured by the rule. Hence, further refinements may be needed to tune the rules to a desired state. Conversely, if a condition is specialized, some fraudulent tuples may be inadvertently omitted. Hence, fur- ther refinements may be needed to tune the rules to a desired state. As we shall describe next, the rules are interactively refined based on the input of a domain expert such as Elena. In particular, there may be several rounds of refinements through generalizations and specializations before a desired set of rules is obtained. </span></p><p class="c75"><span class="c36">5 IMPLEMENTATION AND EXPERIMENTS </span><span class="c7">R</span><span class="c2">UDOLF </span><span class="c7">is implemented in PHP/JavaScript and uses MySQL as the DB engine. Detailed system architecture described in [11]. Datasets We have access to a real-world datasets of credit card transactions by a financial company XYZ</span><span class="c3">5</span><span class="c7">. Due to the sensitivity of credit card-related information, we used anonymized version of the dataset. The dataset consists of transaction sets of various sizes from 15 financial institutes (FIs) for the first quarter of 2016. Each transaction set varies from 100K to 10M transactions and most of them consists of about 500K transactions. The percentage of fraud- ulent transactions varies between 0.5% to 2.5% between different FIs. The number of missclassified transactions (i.e., fraudulent transactions that are marked as legitimate and vice-versa) varies between 35% and 50%. The transactions contain both numerical (time, amount, number of previous actions, etc.) and also categori- cal (location, client type, etc) data. Along with the transactions, we obtained 15 rules-sets, one for each of the 15 FIs for the same time period from company XYZ. We also obtained the change history and versions of those rules. A small FI typically has about 10 rules while a big FI typically has about 130 rules. Most FIs have about 55 rules on average. Each time the rules are modified, the rules undergo about 10 rounds of modifications on average. The transactions in the data sets are annotated as fraudulent/legitimate, and we take these annotations as the ground truth. Each transac- tion also has a risk score, which is a value between 0 and 1000, that is generated by the company&rsquo;s machine learning algorithm to determine the chance that the transaction is fraudulent. The </span></p><p class="c146"><span class="c23">5</span><span class="c101">Name omitted per company request </span></p><p class="c33"><span class="c19">273 </span></p><p class="c122"><span class="c7">fraudulent transactions can be captured by the set of rules given by the company and allowing the users to refine the rules over time. Another option is to apply a rule that classify all transactions with risk score above a certain threshold as fradulent. Ontology In the experiments for the location attributes we used a geographical ontology (containing different relations, e.g., cap- ital city, located in, region, continent, etc) that was built semi- automatically (using DBPedia [13]) and manually verified by the domain experts. Experiment scenarios The different sizes of transaction sets allowed us to vary our experiments with different dataset sizes (from 100K to 10M, with the average value being 500K). </span></p><p class="c153"><span class="c7">We run each experiment with 8 users (fraud detection experts from company XYZ) and as the variance was less that 2% we present here the average. We also ran our experiments with 10 student volunteers to determine whether the level of expertise affects the results. To simulate the work of a domain expert, we we spilt each dataset into two parts of approximately the same size, before and after a certain point in time. We advanced in time from this point and examined, at different points in time, how the expert adapts the rules in response to transactions arriving up to that point. </span></p><p class="c184"><span class="c7">We compared the performance of R</span><span class="c2">UDOLF </span><span class="c7">to three alternative solutions, to be detailed below. For each of the algorithms and each of the datasets, we varied the number of new transactions arriving between consecutive rounds of rule refinement. The number of new transactions varies from 10% to 20% of the dataset, with the default being 10%, and this corresponds closely to what happens in real-life between rounds of rule refinement. Baseline algorithms We consider the two extreme baselines: A fully-manual setting, where rules are manually refined by experts without the help of the system (the current setting that is used by company XYZ experts in their daily work), and a fully-automatic setting that uses the risk score produced by the ML algorithm and a single rule that selects fraudulent transactions based on their risk scores. Observe that this algorithm essentially generates a single new rule of the form score greater than threshold (rather than refining an existing set of rules). We also compared to the baseline algorithm No Change, which denotes the given rules without any changes. </span></p><p class="c203"><span class="c7">Observe that the fully manual setting is arguably our &ldquo;toughest&rdquo; competitor since the rules are modified by experts and the experts are not limited by any time constraint to refine the rules. </span></p><p class="c62"><span class="c7">In addition to the above, we also consider a variant of R</span><span class="c2">UDOLF</span><span class="c7">, denoted R</span><span class="c2">UDOLF</span><span class="c3">&minus;</span><span class="c7">, that automatically refines the existing set of rules by accepting the modifications proposed by the system without consulting an expert. We also considered R</span><span class="c2">UDOLF </span><span class="c7">-s, which is the system R</span><span class="c2">UDOLF </span><span class="c7">that does not refine categorical attributes (and hence does not use ontologies) of rules. To the best of our knowledge, all existing systems refine only numerical attributes of rules. Hence the performance of R</span><span class="c2">UDOLF </span><span class="c7">-s will allow us to understand how R</span><span class="c2">UDOLF </span><span class="c7">compares with systems that are only restricted to refine numerical attributes. In fact, we discovered that R</span><span class="c2">UDOLF </span><span class="c7">-s gives almost same results as the fully- manual system and also R</span><span class="c2">UDOLF</span><span class="c3">&minus;</span><span class="c7">. Hence, we omit the results of R</span><span class="c2">UDOLF </span><span class="c7">-s completely. Measurements In our experiments, we measured the efficiency of the algorithms in terms of the effectiveness of the derived rules and the amount of time that the domain experts saved as a consequence of using our system. We also measured the running time required by R</span><span class="c2">UDOLF </span><span class="c7">to select the proposed modifications. </span></p><p class="c1 c190"><span class="c7">For our datasets this was always at most one second, and we thus omit the exact measures. </span></p><p class="c18"><span class="c7">To measure the effectiveness of a set of rules derived by any of the methods, we consider its prediction quality, namely how correctly it identifies future frauds. For that, we examine the set of transactions from the given point in time where the rules were derived and until the end of the dataset. For these future trans- actions we count, for each set of rules, the percentage out of all fraudulent (resp. legitimate) transactions that it identifies (resp. wrongly classifies as fraudulent). </span></p><p class="c174 c186"><span class="c7">To understand of how many modifications each method en- tailed, we also computed the cumulative number of rule updates that each method required. We measure this only for R</span><span class="c2">UDOLF</span><span class="c7">, R</span><span class="c2">UDOLF</span><span class="c3">&minus;</span><span class="c7">, and the fully-manual methods, which directly change existing rules. </span></p><p class="c196 c198"><span class="c7">Finally, we measured the time the experts took to refine the rules. </span></p><p class="c168"><span class="c7">Results We first report on our experiments with the domain ex- perts. Our first experiment examines the performance of the algo- rithms as time advances, with all parameters set to their default value. As explained above, at each point in time, (i.e. after a certain percentage of the transactions has been observed), the algorithms are invoked to derive a corresponding updated set of rules. Fig- ure 3(a) shows the (cumulative) number of modifications that R</span><span class="c2">UDOLF</span><span class="c7">, fully-manual and R</span><span class="c2">UDOLF</span><span class="c3">&minus; </span><span class="c7">method performed to the rules. We see that R</span><span class="c2">UDOLF </span><span class="c7">performs less modifications than its competitors. </span></p><p class="c166"><span class="c7">We can see this more clearly in Figure 3(b), which illustrates the prediction quality of the derived sets of rules, in terms of the percentage of misclassified future transactions (lower percentage of error implies better prediction quality). R</span><span class="c2">UDOLF </span><span class="c7">performs the best, providing the best prediction. The fully manual rule derivation provides less accurate predictions, though still better than the two automatic competitors. Among the two, R</span><span class="c2">UDOLF</span><span class="c3">&minus;</span><span class="c7">, that incrementally refines the rules, still performs better than the threshold-based ML approach. </span></p><p class="c91"><span class="c7">We note that the difference in performance between R</span><span class="c2">UDOLF</span><span class="c3">&minus; </span><span class="c7">and R</span><span class="c2">UDOLF </span><span class="c7">demonstrates the importance of incorporating ex- perts and their domain knowledge in the loop. </span></p><p class="c103"><span class="c7">For the experiments above, the rules were periodically refined in hops of 10% of the transactions. For different hops sizes, the results are also similar, except that convergence naturally arrives after fewer (proportionally) iterations for larger hops. </span></p><p class="c55 c59"><span class="c7">Our next experiment examines the performance of the algo- rithms for varying dataset, with almost the same percentage of fraud, but different sizes. The size had no significant effect on the number of rule modifications performed by the algorithms, but the prediction quality slightly improved as more data was avail- able. Figure 3(c) illustrate, for varying dataset sizes, the prediction quality of the rules after the first refinement round, in terms of the percentage of misclassified transaction. Here again, lower percent- age means better quality. As before, R</span><span class="c2">UDOLF </span><span class="c7">yields best results. We can see that the error of all algorithms slightly decreases as the size of the data set grows. The improvement is only small as fraudulent transactions of the existing fraud patterns are dis- tributed throughout the datasets, so the additional data reveals some, but not huge, amount of new information. Similar results were obtained for the following refinements rounds and we thus omit the graphs. </span></p><p class="c97"><span class="c7">Next, we examine the performance of the algorithms for vary- ing percentages of fraudulent transactions. We took 4 different </span></p><p class="c185"><span class="c19">274 </span></p><p class="c1"><span class="c28">70%</span><span class="c46">35</span><span class="c28">Rudolf- Manual Rudolf </span></p><p class="c1"><span class="c28">70%Auto No Change Rudolf- Manual Rudolf </span></p><p class="c1"><span class="c28">Auto No Change Rudolf- Manual Rudolf </span><span class="c46">30</span><span class="c46">25</span><span class="c46">2015105</span><span class="c28">060% 70% 80% 90% 100% </span></p><p class="c1"><span class="c92">50% 60% 70% 80% 90% 100% </span></p><p class="c1"><span class="c92">100 250 500 1000 </span></p><p class="c1"><span class="c5">(a) cumulative # of changes </span></p><p class="c1"><span class="c5">(b) prediction quality </span></p><p class="c1"><span class="c5">(c) varying dataset size </span></p><p class="c1"><span class="c46">252015105</span><span class="c28">00.5% 1.0% 1.5% 2.5% </span></p><p class="c1"><span class="c28">60% </span></p><p class="c1"><span class="c28">60% </span></p><p class="c1"><span class="c28">50% </span></p><p class="c1"><span class="c28">50% </span></p><p class="c1"><span class="c28">40% </span></p><p class="c1"><span class="c28">40% </span><span class="c16">s </span></p><p class="c1"><span class="c16">% % </span></p><p class="c1"><span class="c16">er r goonrrarr</span><span class="c28">30% </span></p><p class="c1"><span class="c28">30% </span></p><p class="c1"><span class="c16">h</span><span class="c20">EE</span><span class="c16">cf o</span><span class="c20"># </span><span class="c28">20% </span></p><p class="c1"><span class="c28">20% </span></p><p class="c1"><span class="c28">10% </span></p><p class="c1"><span class="c28">10% </span></p><p class="c1"><span class="c28">0% </span></p><p class="c1"><span class="c28">0% </span></p><p class="c1"><span class="c20">% of seen transactions </span></p><p class="c1"><span class="c20">% of seen transactions </span></p><p class="c1"><span class="c20">Dataset size (K) </span></p><p class="c1"><span class="c28">3600 </span><span class="c28">Rudolf- Manual Rudolf </span></p><p class="c1"><span class="c28">70%Auto No Change Rudolf- Manual Rudolf </span></p><p class="c1"><span class="c92">0.5% 1.0% 1.5% 2.5% </span></p><p class="c1"><span class="c28">1 2 5 10 50 </span></p><p class="c1"><span class="c5">(d) varying % of fraud - # of changes </span></p><p class="c1"><span class="c5">(e) varying % of fraud - prediction quality </span></p><p class="c1"><span class="c28">Rudolf Manual </span></p><p class="c1"><span class="c5">(f) Time </span></p><p class="c1"><span class="c7">Figure 3: Experimental results </span></p><p class="c22"><span class="c7">customers databases of roughly the same size, but different fraud percentages (0.5% to 2.5%). All other parameters are set to their default values. Figures 3(d) 3(e) show, respectively, the number of rule updates and percentage of error after the first refinement round. We can see that an increased number of fraudulent transac- tion entails more rule modifications to capture them. The classifi- cation error slightly increases with more fraudulent transactions, but here again R</span><span class="c2">UDOLF </span><span class="c7">achieves the lowest error. </span></p><p class="c22"><span class="c7">Finally we note that rule refinement with R</span><span class="c2">UDOLF </span><span class="c7">not only consistently yielded superior fraud prediction, but also reduced the time required from the experts by a factor between 4 to 5. (Around 50 seconds per round for R</span><span class="c2">UDOLF </span><span class="c7">compared to 4-5 minutes with- out). We measured time of our experts performance, depicted in figure 3(f). We asked them to fix up to 50 problematic transactions in both manual and automatic way. Interestingly, no expert fin- ished all 50 fixes in the manual mode (a well-trained expert from company XYZ usually can fix 30-40 transactions per work-day). The fact that R</span><span class="c2">UDOLF </span><span class="c7">leads in performance across all parameters is interesting as the rules derived manually by experts are typically considered as ground truth and yet, R</span><span class="c2">UDOLF </span><span class="c7">is able to do better (i.e., with less changes, and with lower percentage of error) with less data. This was consistent in all the experiments. Furthermore, all users reported that working with R</span><span class="c2">UDOLF </span><span class="c7">was convenient and effective in the sense that the rules/modifications proposed by the system helped them identify and focus on the problematic rules and the needed treatment. To conclude we observed that around 75% of the modifications were condition refinements, 20% rule splits, and 5% rule addition. </span></p><p class="c22"><span class="c7">Interestingly, our experiments with novice users (student vol- unteers) show similar trends. In particular, also for novice users, the rules generated with the assistance of R</span><span class="c2">UDOLF </span><span class="c7">were of best quality and produced much faster than in all alternatives. We omit the graphs for space constraints and only note that as expected, compared to the domain experts, the overall perdition quality, even with R</span><span class="c2">UDOLF </span><span class="c7">, was lower (by about 5%) than for the experts, but still significantly better (by 25%) than what the novice users would have achieved alone. </span></p><p class="c1"><span class="c28">60% </span></p><p class="c1"><span class="c36">6 RELATED WORK </span><span class="c7">The identification of fraudulent transactions is essentially a classifi- cation problem. Classification has been a fundamental problem in machine learning and data management [14, 15], and crowdsourc- ing has recently emerged as a major problem solving paradigm [16]. Many classification works have used crowdsourcing to ob- tain training data for learning [17&ndash;20]. This is complimentary to our work: In R</span><span class="c2">UDOLF </span><span class="c7">the crowd (of experts) is employed to maintain classifications rules, which might have been initially learnt through such training. Besides learning-based models, rules are also used for classification. Most of the previous research in rule-based classifiers focus on how to learn rules from the training data. In contrast, [21] employs both learning and analyst experts that manually create classification rules using regular expressions. In [22] that describes LinkedIn&rsquo;s job title classification system, experts and crowdsourcing are also heavily used. In both cases however the ongoing refinement of rules in a changing environ- ment, which is the focus of R</span><span class="c2">UDOLF</span><span class="c7">, is not considered. </span></p><p class="c22"><span class="c7">In addition to machine learning-based methods, there are mul- tiple fraud-detection techniques that have been considered. For example [4] uses a decision tree, defined recursively for nodes and edges of the tree and using the ratio between number of transac- tions that satisfy some condition to label them accordingly. Other methods, e.g. [5], are based on genetic programming, used to clas- sify transactions into suspicious and non-suspicious ones. Another class of the algorithms for fraud detection is based on clustering techniques. An example is [6] that clusters users based on com- mon behavior and then considers as suspicious the transactions that take the user outside its cluster. Bayesian networks are used both to detect fraud in telecommunications (e.g. [23]) and in the credit card industry (e.g. [24]). Neural networks are also used for fraud detection. For instance [25] presents an online fraud detection system, based on a neural classifier. All these techniques are complimentary to ours and can be used to deriving the initial base-set of rules. </span></p><p class="c22"><span class="c7">Another class of work similar R</span><span class="c2">UDOLF </span><span class="c7">is that of Concept Drifts, which are changes that occur on the distribution of the input that affects the learning system and thus the output. [8] deals with concept drifts by using sliding window that adaptively remembers more or less items from the training set (the closest </span></p><p class="c1"><span class="c19">275 </span></p><p class="c1"><span class="c28">3000 </span></p><p class="c1"><span class="c28">50% </span></p><p class="c1"><span class="c28">2400 40% </span><span class="c16">s </span></p><p class="c1"><span class="c16">% </span></p><p class="c1"><span class="c16">er g</span><span class="c28">1800 </span><span class="c16">onrar</span><span class="c28">30% </span></p><p class="c1"><span class="c16">h</span><span class="c20">E</span><span class="c16">cf o</span><span class="c28">1200 </span><span class="c20"># </span><span class="c28">20% </span></p><p class="c1"><span class="c28">10% </span></p><p class="c1"><span class="c28">600 </span></p><p class="c1"><span class="c28">0% </span></p><p class="c1"><span class="c28">0 </span></p><p class="c1"><span class="c20">% of fraud </span></p><p class="c1"><span class="c20">% of fraud </span></p><p class="c1"><span class="c16">) </span></p><p class="c1"><span class="c16">sdnoces(e mi</span><span class="c20">T# of changes </span></p><p class="c135"><span class="c7">past) according to whether it recognized a concept drift or not. Other system ([9]) is classification system based on decision rules. Even though these systems can compute the nearest neighbors for the closest rules and generalization for numerical values, they do not support generalization and specification on categorical attributes, do not involve a human expert in the loop, and do not allow configuration of weight for different kind of errors (false positives and false negatives). </span></p><p class="c87"><span class="c7">Finally, if we view our transaction relation as the source data- base and the set of fraudulent transactions as our target database, then the work on deriving queries or schema mappings based on source-target databases (e.g., [26&ndash;28]) is also relevant. Simi- larly, techniques for rule mining and, in particular, inductive logic programming (e.g., [29]) can also be used for fraud detection, where the fraudulent transactions can be seen as positive examples and the legitimate transactions can be seen as negative examples. However, the language of schema mappings and inductive logic programming are different from our rule language and more im- portantly, the rules derived cannot be interactively adapted. </span></p><p class="c134"><span class="c36">7 CONCLUSION AND FUTURE WORK </span><span class="c7">We present R</span><span class="c2">UDOLF</span><span class="c7">, a novel system that assists domain experts in defining and adapting rules in dynamic environments. We show that the problem of identifying the best candidate adaptation for a core language is NP-hard and present PTIME heuristic algorithms for determining the set of rules to adapt and working interactively with the domain experts until they are satisfied with the resulting rules. Our experiments with real-world data sets demonstrate the promise that R</span><span class="c2">UDOLF </span><span class="c7">is an effective and efficient tool for rule refinement. </span></p><p class="c43"><span class="c7">One direcvtion for future work is the use of more sophisticated cost model. Instead of associating a cost with every modifica- tion made to a condition in the rule, one can varying the cost depending on the attribute or even rule that is modified and these costs/weights can be learned or adjusted based on user feedback, satisfaction of the suggested modification etc. Similarly, the param- eters &alpha;, &beta; and &gamma; used in our cost formula to weight the importance of misclassifying of fraudulent/legitimate/unlabeled transactions may also be dynamically adapted based on such user feedback. </span></p><p class="c126"><span class="c7">Acknowledgements This work has been partially funded by the European Research Council under the FP7, ERC grant MoDaS, agreement 291071, and by grants from the Blavatnik Cyber Se- curity center and the Israel Innovation Authority. Work was done while Tan was at UCSC. Tan was partially supported by NSF grant IIS-1524382 at UCSC. </span></p><p class="c88"><span class="c36">REFERENCES </span></p><p class="c172"><span class="c7">[1] &ldquo;The us sees more money lost to credit card fraud than the </span></p><p class="c42"><span class="c7">rest of the world combined,&rdquo; http://read.bi/18Gin67. [2] &ldquo;Card fraud worlwide,&rdquo; http://nilsonreport.com/publication_ </span></p><p class="c102"><span class="c7">chart_and_graphs_archive.php?year=2015. [3] &ldquo;How credit card companies spot fraud before you do,&rdquo; http://money.usnews.com/money/personal- finance/articles/2013/07/10/how-credit-card-companies- spot-fraud-before-you-do. [4] A. I. Kokkinaki, &ldquo;On atypical database transactions: Identi- fication of probable frauds using machine learning for user profiling,&rdquo; KDEX, 1997. [5] P. J. Bentley, J. Kim, G.-H. Jung, and J.-U. Choi, &ldquo;Fuzzy </span></p><p class="c78"><span class="c7">darwinian detection of credit card fraud.&rdquo; </span></p><p class="c1 c189"><span class="c7">[6] R. J. Bolton and D. J. Hand, &ldquo;Statistical fraud detection: A </span></p><p class="c96"><span class="c7">review,&rdquo; Statistical Science, vol. 2002, pp. 235&ndash;255, 2002. [7] A. Chapman and H. V. Jagadish, &ldquo;Why not?&rdquo; in SIGMOD, </span></p><p class="c80 c131"><span class="c7">2009, pp. 523&ndash;534. [8] G. Widmer and M. Kubat, &ldquo;Learning in the presence of con- cept drift and hidden contexts,&rdquo; Machine Learning, vol. 23, no. 1, pp. 69&ndash;101, 1996. [9] F. J. Ferrer-Troyano, J. S. Aguilar-Ruiz, and J. C. R. Santos, &ldquo;Data streams classification by incremental rule learning with parameterized generalization.&rdquo; [10] C. Phua, V. C. S. Lee, K. Smith-Miles, and R. W. Gayler, &ldquo;A comprehensive survey of data mining-based fraud detection research,&rdquo; 2010. [11] T. Milo, S. Novgorodov, and W. Tan, &ldquo;Rudolf: Interactive rule refinement system for fraud detection,&rdquo; PVLDB, vol. 9, no. 13, pp. 1465&ndash;1468, 2016. [12] M. Shindler, A. Wong, and A. Meyerson, &ldquo;Fast and accurate k-means for large datasets,&rdquo; in NIPS, 2011, pp. 2375&ndash;2383. [13] &ldquo;DBPedia,&rdquo; http://dbpedia.org. [14] T. M. Mitchell, Machine learning, ser. McGraw Hill series </span></p><p class="c80 c167"><span class="c7">in computer science. McGraw-Hill, 1997. [15] R. Ramakrishnan and J. Gehrke, Database management sys- </span></p><p class="c80 c197"><span class="c7">tems (3rd ed.). McGraw-Hill, 2003. [16] A. Doan, R. Ramakrishnan, and A. Y. Halevy, &ldquo;Crowdsourc- ing systems on the world-wide web,&rdquo; Commun. ACM, vol. 54, no. 4, pp. 86&ndash;96, 2011. [17] S. Vijayanarasimhan and K. Grauman, &ldquo;Large-scale live active learning: Training object detectors with crawled data and crowds,&rdquo; in CVPR, 2011, pp. 1449&ndash;1456. [18] V. Ambati, S. Vogel, and J. G. Carbonell, &ldquo;Active learning and crowd-sourcing for machine translation,&rdquo; in LREC 2010. [19] E. Kamar, S. Hacker, and E. Horvitz, &ldquo;Combining human and machine intelligence in large-scale crowdsourcing,&rdquo; in AAMAS, 2012, pp. 467&ndash;474. [20] D. R. Karger, S. Oh, and D. Shah, &ldquo;Iterative learning for </span></p><p class="c167 c80"><span class="c7">reliable crowdsourcing systems,&rdquo; in NIPS 2011. [21] C. Sun, N. Rampalli, F. Yang, and A. Doan, &ldquo;Chimera: Large- scale classification using machine learning, rules, and crowd- sourcing,&rdquo; PVLDB, vol. 7, no. 13. [22] R. Bekkerman and M. Gavish, &ldquo;High-precision phrase-based document classification on a modern scale,&rdquo; in KDD 2011, 2011, pp. 231&ndash;239. [23] K. J. Ezawa and S. W. Norton, &ldquo;Constructing bayesian net- works to predict uncollectible telecommunications accounts,&rdquo; Intelligent Systems, 1996. [24] S. Maes, K. Tuyls, B. Vanschoenwinkel, and B. Mander- ick, &ldquo;Credit card fraud detection using bayesian and neural networks,&rdquo; in NAISO, 2002. [25] D. J.R., G. F., S. C., and C. C.S., &ldquo;Neural fraud detection in credit card operations,&rdquo; IEEE Trans. on Neural Networks, 1997. [26] A. D. Sarma, A. G. Parameswaran, H. Garcia-Molina, and J. Widom, &ldquo;Synthesizing view definitions from data,&rdquo; in ICDT, 2010. [27] Q. T. Tran, C. Y. Chan, and S. Parthasarathy, &ldquo;Query reverse </span></p><p class="c167 c80"><span class="c7">engineering,&rdquo; VLDB J., vol. 23, no. 5, pp. 721&ndash;746, 2014. [28] B. Alexe, B. ten Cate, P. G. Kolaitis, and W. C. Tan, &ldquo;De- signing and refining schema mappings via data examples,&rdquo; in SIGMOD, 2011, pp. 133&ndash;144. [29] L. Gal&aacute;rraga, C. Teflioudi, K. Hose, and F. M. Suchanek, &ldquo;Fast rule mining in ontological knowledge bases with AMIE+,&rdquo; VLDB J., vol. 24, no. 6, 2015. </span></p><p class="c51"><span class="c19">276 </span></p></body></html>