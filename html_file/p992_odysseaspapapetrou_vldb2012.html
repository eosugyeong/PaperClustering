<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c67{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Courier New";font-style:normal}.c40{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:13.2pt;font-family:"Arial";font-style:normal}.c7{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Arial";font-style:normal}.c47{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7pt;font-family:"Courier New";font-style:normal}.c23{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11.6pt;font-family:"Arial";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.2pt;font-family:"Arial";font-style:normal}.c22{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.3pt;font-family:"Arial";font-style:normal}.c8{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.9pt;font-family:"Courier New";font-style:normal}.c85{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.9pt;font-family:"Arial";font-style:normal}.c20{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.3pt;font-family:"Courier New";font-style:normal}.c61{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Arial";font-style:normal}.c42{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Courier New";font-style:normal}.c59{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:19.9pt;font-family:"Times New Roman";font-style:normal}.c63{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5pt;font-family:"Arial";font-style:normal}.c76{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:16.6pt;font-family:"Arial";font-style:normal}.c37{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:13.3pt;font-family:"Arial";font-style:normal}.c71{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:7.7pt;font-family:"Arial";font-style:normal}.c58{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:7.7pt;font-family:"Arial";font-style:normal}.c41{margin-left:-18.2pt;padding-top:1.4pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-6.8pt}.c46{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Times New Roman";font-style:italic}.c27{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Times New Roman";font-style:italic}.c10{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.8pt;font-family:"Arial";font-style:normal}.c9{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Times New Roman";font-style:normal}.c91{margin-left:-18.2pt;padding-top:7.4pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-6.8pt}.c14{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Times New Roman";font-style:italic}.c32{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.6pt;font-family:"Arial";font-style:normal}.c92{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.2pt;font-family:"Courier New";font-style:normal}.c87{margin-left:-9.2pt;padding-top:1.2pt;text-indent:29.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-15.8pt}.c25{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.2pt;font-family:"Times New Roman";font-style:normal}.c12{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6pt;font-family:"Arial";font-style:normal}.c60{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10.2pt;font-family:"Arial";font-style:normal}.c48{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11.6pt;font-family:"Courier New";font-style:normal}.c82{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:11.6pt;font-family:"Arial";font-style:normal}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:14.9pt;font-family:"Times New Roman";font-style:normal}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:10pt;font-family:"Arial";font-style:normal}.c33{margin-left:-9.2pt;padding-top:1.7pt;text-indent:18.1pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.1pt}.c54{margin-left:-9.2pt;padding-top:3.8pt;text-indent:18.1pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-16.1pt}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Times New Roman";font-style:normal}.c43{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.1pt;font-family:"Arial";font-style:normal}.c11{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Arial";font-style:normal}.c36{margin-left:-18.2pt;padding-top:4.1pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-7pt}.c53{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:7pt;font-family:"Arial";font-style:normal}.c69{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.7pt;font-family:"Arial";font-style:normal}.c34{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:13.3pt;font-family:"Times New Roman";font-style:normal}.c38{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10pt;font-family:"Courier New";font-style:normal}.c49{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7.2pt;font-family:"Arial";font-style:normal}.c45{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8.4pt;font-family:"Arial";font-style:normal}.c52{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:11.6pt;font-family:"Times New Roman";font-style:normal}.c21{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7pt;font-family:"Arial";font-style:normal}.c18{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Arial";font-style:normal}.c50{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:7.2pt;font-family:"Arial";font-style:normal}.c39{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:13.3pt;font-family:"Arial";font-style:normal}.c77{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:6.7pt;font-family:"Arial";font-style:normal}.c13{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Courier New";font-style:normal}.c35{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:8.2pt;font-family:"Arial";font-style:normal}.c88{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:6.1pt;font-family:"Arial";font-style:normal}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:10pt;font-family:"Arial";font-style:normal}.c31{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.6pt;font-family:"Arial";font-style:normal}.c83{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5.3pt;font-family:"Arial";font-style:normal}.c74{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Times New Roman";font-style:italic}.c51{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.6pt;font-family:"Courier New";font-style:normal}.c90{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:17.9pt;font-family:"Arial";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9pt;font-family:"Arial";font-style:normal}.c24{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:14.9pt;font-family:"Times New Roman";font-style:normal}.c15{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:4.9pt;font-family:"Arial";font-style:normal}.c26{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:7pt;font-family:"Times New Roman";font-style:normal}.c16{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c81{color:#000000;font-weight:400;text-decoration:none;vertical-align:sub;font-size:8.2pt;font-family:"Courier New";font-style:normal}.c19{margin-left:-18.2pt;padding-top:1.7pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify;margin-right:-7pt}.c56{color:#000000;font-weight:400;text-decoration:none;vertical-align:super;font-size:15.3pt;font-family:"Arial";font-style:normal}.c64{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:9.2pt;font-family:"Arial";font-style:normal}.c28{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:5pt;font-family:"Courier New";font-style:normal}.c62{margin-left:223.9pt;padding-top:34.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-30.1pt}.c75{margin-left:-18.2pt;padding-top:7.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:113.2pt}.c73{margin-left:-9.2pt;padding-top:11.5pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:105.8pt}.c89{margin-left:226.6pt;padding-top:34.8pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:-27.4pt}.c57{margin-left:-5.3pt;padding-top:8.6pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:5.9pt}.c72{margin-left:-18.2pt;padding-top:7.9pt;padding-bottom:0pt;line-height:1.15;text-align:left;margin-right:85.6pt}.c55{margin-left:-9.2pt;padding-top:1.7pt;padding-bottom:0pt;line-height:1.15;text-align:right;margin-right:-16.6pt}.c86{padding-top:4.1pt;text-indent:18.1pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c65{padding-top:3.8pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c70{padding-top:1.4pt;text-indent:27.4pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c79{padding-top:1.4pt;text-indent:18.1pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c17{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:justify}.c84{padding-top:7.9pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c30{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:center}.c29{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:right}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;text-align:left}.c80{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c68{margin-left:-2.7pt;margin-right:-3.6pt}.c44{margin-left:-18.2pt;margin-right:-7pt}.c66{margin-left:-18.2pt;margin-right:-9.4pt}.c78{margin-left:-9.2pt;margin-right:-16.1pt}.title{padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:24pt;color:#000000;font-weight:700;font-size:24pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:14pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:12pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:11pt;color:#000000;font-weight:700;font-size:11pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:10pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:2pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}</style></head><body class="c80"><p class="c30"><span class="c90">Sketch-based Querying of Distributed Sliding-Window Data Streams </span></p><p class="c30"><span class="c61">Odysseas Papapetrou, Minos Garofalakis, Antonios Deligiannakis </span><span class="c76">Technical University of Crete </span><span class="c5">{</span><span class="c61">papapetrou,minos,adeli</span><span class="c5">}</span><span class="c61">@softnet.tuc.gr </span></p><p class="c2"><span class="c16">ABSTRACT </span></p><p class="c2"><span class="c9">While traditional data-management systems focus on evaluating single, ad- hoc queries over static data sets in a centralized setting, several emerg- ing applications require (possibly, continuous) answers to queries on </span><span class="c46">dy- namic </span><span class="c9">data that is widely </span><span class="c46">distributed </span><span class="c9">and constantly updated. Furthermore, such query answers often need to discount data that is &ldquo;stale&rdquo;, and operate solely on a </span><span class="c46">sliding window </span><span class="c9">of recent data arrivals (e.g., data updates occur- ring over the last </span><span class="c18">24 </span><span class="c9">hours). Such </span><span class="c46">distributed data streaming </span><span class="c9">applications mandate novel algorithmic solutions that are both time- and space-efficient (to manage high-speed data streams), and also communication-efficient (to deal with physical data distribution). In this paper, we consider the prob- lem of complex query answering over distributed, high-dimensional data streams in the sliding-window model. We introduce a novel sketching tech- nique (termed </span><span class="c46">ECM-sketch</span><span class="c9">) that allows effective summarization of stream- ing data over both time-based and count-based sliding windows with prob- abilistic accuracy guarantees. Our sketch structure enables point as well as inner-product queries, and can be employed to address a broad range of problems, such as maintaining frequency statistics, finding heavy hit- ters, and computing quantiles in the sliding-window model. Focusing on distributed environments, we demonstrate how ECM-sketches of individ- ual, local streams can be composed to generate a (low-error) ECM-sketch summary of the order-preserving aggregation of all streams; furthermore, we show how ECM-sketches can be exploited for continuous monitoring of sliding-window queries over distributed streams. Our extensive experi- mental study with two real-life data sets validates our theoretical claims and verifies the effectiveness of our techniques. To the best of our knowledge, ours is the first work to address efficient, guaranteed-error complex query answering over distributed data streams in the sliding-window model. </span><span class="c16">1. INTRODUCTION </span></p><p class="c17"><span class="c4">The ability to process, in real time, continuous high-volume </span><span class="c27">stre- ams </span><span class="c4">of data is a common requirement in many emerging applica- tion environments. Examples of such applications include, sensor networks, financial data trackers, and intrusion-detection systems. As a result, in recent years, we have seen a flurry of activity in the area of </span><span class="c27">data-stream processing</span><span class="c4">. Unlike conventional database query processing that requires several passes over a static, archived data image, data-stream processing algorithms often rely on build- ing concise, approximate (yet, accurate) </span><span class="c27">sketch synopses </span><span class="c4">of the in- </span></p><p class="c17"><span class="c4">put streams in real time (i.e., in one pass over the streaming data). Such sketch structures typically require </span><span class="c27">small space and update time </span><span class="c4">(both significantly sublinear in the size of the data), and can be used to provide </span><span class="c27">approximate query answers </span><span class="c4">with guarantees on the quality of the approximation. These answers can be more than suf- ficient for typical exploratory analysis of massive data, where the goal is to detect interesting statistical behavior and patterns rather than obtain answers that are precise to the last decimal. Large-scale stream processing applications are also inherently </span><span class="c27">distributed</span><span class="c4">, with several remote sites observing their local stream(s) and exchanging information through a communication network. This distribution of the data naturally imposes critical </span><span class="c27">communication-efficiency </span><span class="c4">re- quirements that prohibit na&#305;ve solutions that centralize all the data, due to its massive volume and/or the high cost of communication (e.g., in sensornets). Communication efficiency is particularly im- portant for </span><span class="c27">distributed event-monitoring </span><span class="c4">scenarios (e.g., monitoring sensor or IP networks), where the goal is real-time tracking of dis- tributed measurements and events, rather than one-shot answers to sporadic queries [25]. </span></p><p class="c17"><span class="c4">Several query models for streaming data have been explored over the past decade. Streaming data items naturally carry a notion of &ldquo;time&rdquo;, and, in many applications, it is important to be able to downgrade the importance (or, weight) of older items; for in- stance, in the statistical analysis of trends or patterns in financial data streams, data that is more than a few months old might be considered &ldquo;stale&rdquo; and irrelevant. Various </span><span class="c27">time-decay models </span><span class="c4">for querying streaming data have been proposed in the literature, mostly differentiating on the relation of an item&rsquo;s weight to its age (e.g., ex- ponential or polynomial decay [6]). The</span><span class="c27">sliding-window </span><span class="c4">model [12] is one of the most prominent and intuitive time-decay models that considers only a window of the most recent items seen in the stream thus far (i.e., items outside the window are &ldquo;aged out&rdquo; or given a weight of zero). The window itself can be either </span><span class="c27">time-based </span><span class="c4">(i.e., items seen in the last </span><span class="c5">N </span><span class="c4">time units) or </span><span class="c27">count-based </span><span class="c4">(i.e., the last </span><span class="c5">N </span><span class="c4">items). Several algorithms have been proposed for maintaining different types of statistics over sliding-window data streams while requiring time and space that is significantly sublinear (typically, poly-logarithmic) in the window size </span><span class="c5">N </span><span class="c4">[12, 15, 24, 26]. Still, the bulk of existing work on the sliding-window model has focused on tracking basic counts and other simple aggregates (e.g., sums) over </span></p><p class="c17"><span class="c18">Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies </span></p><p class="c29"><span class="c4">one-dimensional streams in a centralized setting. Some recent work has also considered the case of distributed data, however, no exist- ing techniques can handle flexible, complex aggregate queries over </span><span class="c18">bear this notice and the full citation on the first page. To copy otherwise, to </span></p><p class="c2"><span class="c4">rapid, high-dimensional distributed data streams, e.g., with each </span><span class="c18">republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Articles from this volume were invited to present their results at The 38th International Conference on Very Large Data Bases, </span></p><p class="c2"><span class="c4">dimension corresponding to the frequency of a distinct key in the stream. </span></p><p class="c2"><span class="c18">August 27th - 31st 2012, Istanbul, Turkey. </span></p><p class="c2"><span class="c27">Example: </span><span class="c4">Recent work on effective network-monitoring systems </span><span class="c18">Proceedings of the VLDB Endowment, Vol. 5, No. 10 Copyright 2012 VLDB Endowment 2150-8097/12/06... </span><span class="c67">$ </span><span class="c18">10.00. </span></p><p class="c2"><span class="c4">(e.g., for detecting DDoS attacks or network-wide anomalies in </span></p><p class="c2"><span class="c13">992 </span></p><p class="c17"><span class="c4">large-scale IP networks) has stressed the importance of an efficient </span><span class="c27">distributed-triggering </span><span class="c4">functionality [20, 22, 18, 17]. In their early work, Jain et al. [20] discuss a generic distributed attack-detection scheme relying on the ability to maintain frequency statistics for high-dimensional data over sliding windows. In particular, each node (e.g., a network router implementing Cisco&rsquo;s Netflow proto- col, a wireless access point, or a peer in a P2P network) maintains a sliding-window count of all observed messages for each target IP address. If this count exceeds a pre-determined threshold, which is determined based on the capacity of the target machine (possibly expressing the fair share of each client to the target machine), an event is triggered to a central coordinator as a warning of possible overloading. The coordinator then collects network-wide statistics to monitor overloaded nodes or abnormal behavior. More recent efforts have focused on different variants and extensions of this ba- sic scheme, often requiring more extensive data/statistics collection and more sophisticated analyses [18, 17]. (Note that such data col- lection mechanisms are supported by commercial products, such as the Cisco Netflow Collection Engine solution.) </span></p><p class="c17"><span class="c4">The ability to efficiently summarize high-dimensional data over sliding windows is obviously crucial to such network-monitoring schemes, given the tremendous volume of network-data streams and their massive domain sizes (e.g., </span><span class="c5">2</span><span class="c3">48 </span><span class="c4">for IPv6 addresses). This raises a critical need for synopsis data structures that can compactly capture accurate frequency statistics for a vast domain space over sliding windows. Furthermore, to enable the coordinator to aggre- gate data coming from different nodes (a requirement for detecting DDoS attacks), we need to be able to </span><span class="c27">compose </span><span class="c4">individually con- structed synopses to a single synopsis which can capture the global state of the network and help isolate network-wide abnormalities. Thus, we are faced with the difficult challenge of designing ef- fective, composable synopses that can support potentially complex sliding-window analysis queries over massive, distributed network- data streams. </span></p><p class="c17"><span class="c4">Note that similar requirements are frequently observed in other domains, e.g., for identifying misbehaving nodes in large wireless networks, for training of classifiers with distributed training data that expires over time, and for ranking products in a cloud-based e-shop, based on the number of recent visits of each product. </span></p><p class="c17"><span class="c4">Our Contributions. In this paper, we consider the problem of an- swering potentially complex queries over distributed, high-dimen- sional data streams in the sliding-window model. Our contribu- tions can be summarized as follows. </span></p><p class="c17"><span class="c5">&bull; </span><span class="c4">ECM-Sketches for Sliding-Window Streams. We introduce a novel sketch synopsis (termed </span><span class="c27">ECM-sketch</span><span class="c4">) that allows effective summarization of streaming data over both time-based and count- based sliding windows with probabilistic accuracy guarantees. In a nutshell, our ECM-sketch combines the well-known Count-Min sketch structure [10] for conventional streams with state-of-the-art tools for sliding-window statistics. The end result is a sliding- window sketch synopsis that can provide provable, guaranteed- error performance for point, as well as inner-product, queries, and can be employed to address a broad range of problems, such as maintaining frequency statistics, finding heavy hitters, and com- puting quantiles in the sliding-window model. </span></p><p class="c17"><span class="c5">&bull; </span><span class="c4">Time-based Sliding Windows over Distributed Streams. Fo- cusing on distributed environments, we demonstrate how ECM- sketches summarizing time-based sliding windows of individual, local streams can be composed to generate a guaranteed-error ECM- sketch synopsis of the order-preserving aggregation of all streams. While conventional Count-Min sketches are trivially composable, composing ECM-sketches is more challenging, since it requires </span></p><p class="c17"><span class="c4">the composition of the sliding-window statistics maintained in the sketch. Compared to earlier work on composable, randomized sli- ding-window statistics [27, 15], our sliding window approximation technique is completely deterministic and is much more space ef- ficient (with a linear rather than a quadratic dependence on the ap- proximation error). This increased efficiency comes at the cost of a slight inflation of the worst-case error guarantee due to composi- tion. Furthermore, we demonstrate how our ECM-sketches can be exploited in the context of the geometric framework of Sharfman et al. [25] for continuous monitoring of sliding-window queries over distributed streams. </span></p><p class="c17"><span class="c5">&bull; </span><span class="c4">Experimental Study and Validation. We perform a thorough experimental evaluation of our techniques using two real-life data sets, in both centralized and distributed settings. The results of our study verify the efficiency and effectiveness of our ECM-sketch synopses in a variety of applications, and expose interesting func- tional trade-offs. When compared to algorithms based on random- ized sliding window synopses &ndash; which are the only ones that were considered for composition up to now &ndash; ECM-sketches reduce the memory and computational requirements by at least one order of magnitude with a very small loss in accuracy. Similar savings ap- ply to the network requirements. </span></p><p class="c2"><span class="c16">2. RELATED WORK </span><span class="c4">Centralized and Distributed Data Streams. Most prior work on data-stream processing has focused on developing space-efficient, one-pass algorithms for performing a wide range of </span><span class="c27">centralized, one-shot computations </span><span class="c4">on massive data streams; examples include computing quantiles [16], estimating distinct values [14], count- ing frequent elements (i.e., &ldquo;heavy hitters&rdquo;) [5, 9], and estimating join sizes and stream norms [1, 10]. Out of these efforts, flexi- ble, general-purpose sketch summaries, such as the AMS [1] and the Count-Min [10] sketch have found wide applicability in a broad range of stream-processing scenarios. More recent efforts have also concentrated on </span><span class="c27">distributed-stream </span><span class="c4">processing, proposing commu- nication-efficient streaming tools for handling a number of query tasks, including distributed tracking of simple aggregates [23], quan- tiles [8], and join aggregates [7], as well as monitoring distributed threshold conditions [25]. All the above-referenced works assume a traditional, &ldquo;full-history&rdquo; data stream and do not address the is- sues specific to the sliding-window model. </span></p><p class="c17"><span class="c4">Sliding-Window Stream Queries. As mentioned earlier, the bulk of existing work on the sliding-window model has focused on al- gorithms for maintaining simple statistics, such as basic counts and sums, in space and time that is significantly sub-linear (typically, poly-logarithmic) in the sliding-window size </span><span class="c5">N</span><span class="c4">. </span><span class="c27">Exponential his- tograms </span><span class="c4">[12] are a state-of-the-art deterministic technique for main- taining </span><span class="c5">&#491;</span><span class="c4">-approximate counts and sums over sliding windows, using </span><span class="c5">O( </span><span class="c3">1</span><span class="c12">&#491; </span><span class="c11">log</span><span class="c3">2 </span><span class="c5">N) </span><span class="c4">space. </span><span class="c27">Deterministic waves </span><span class="c4">[15] solve the same ba- sic counting/summation problem with the same space complexity as exponential histograms, but improve the worst-case update time complexity to </span><span class="c5">O(1)</span><span class="c4">; on the other hand, </span><span class="c27">randomized waves </span><span class="c4">[15] rely on randomization through hashing to track </span><span class="c27">duplicate-insensitive </span><span class="c4">counts (i.e., </span><span class="c18">COUNT-DISTINCT </span><span class="c4">aggregates) over sliding windows. While randomized waves can be easily composed (in distributed settings), they also come with an increased space requirement of </span><span class="c5">O( </span><span class="c3">log(1/&delta;) </span></p><p class="c17"><span class="c12">&#491;</span><span class="c20">2 </span><span class="c11">log</span><span class="c3">2 </span><span class="c5">N)</span><span class="c4">, where </span><span class="c5">&delta; </span><span class="c4">is a small probability of failure. Xu et al. [27] describe a randomized, sampling-based synopsis, very similar to randomized waves, for tracking sliding-window counts and sums with out-of-order arrivals (e.g., due to network delays) in a distributed setting. As with randomized waves, their space re- quirements are also quadratic in the inverse approximation error; </span></p><p class="c2"><span class="c13">993 </span></p><p class="c17"><span class="c4">furthermore, their approach requires knowledge of the maximum number of elements in any sliding window (to set up the synopsis data structure), which could be problematic in dynamic, widely- distributed environments. Cormode et al. [11] also propose ran- domized techniques for handling out-of-order arrivals for tracking duplicate-insensitive sliding-window aggregates. To address the high cost associated with randomized data structures, Busch and Tirthapura propose a deterministic structure for handling out-of- order arrivals in sliding windows [3]. Similar to the other deter- ministic structures, this structure also does not allow composition and focuses only on basic counts and sums. Finally, Chan et al. [4] investigate continuous monitoring of exponential-histogram aggre- gates over distributed sliding windows. The main contribution of their work lies in the efficient scheduling of the propagation of the local exponential-histogram summaries to a coordinator, without violating prescribed accuracy guarantees. </span></p><p class="c2"><span class="c4">Going beyond counts, sums, and simple aggregates, there is sur- prisingly little work in the more general problem of maintaining general, frequency-distribution synopses over high-dimensional streaming data in the sliding-window model. Hung and Ting [19] and Dimitropoulos et al. [13] propose synopses based on Count- Min sketches for tracking heavy hitters and frequency counts over sliding windows; still, their techniques rely on keeping simple equi- width counters within the sketch, and, thus, cannot provide any meaningful error guarantees, especially for small query ranges. Sim- ilarly, the hybrid histograms of Qiao et al. [24] combine exponen- tial histograms with simplistic equi-width histograms for answer- ing sliding-window range queries; again, these structures cannot give meaningful bounds on the approximation error and cannot be composed in a distributed setting. </span></p><p class="c2"><span class="c16">3. PRELIMINARIES </span></p><p class="c17"><span class="c4">ECM-sketches combine the functionalities of Count-Min sketches [10] and exponential histograms [12]. We now describe the two structures, focusing on the aspect related to our work. </span></p><p class="c17"><span class="c4">Count-Min Sketches. Count-Min sketches are a widely applied sketching technique for data streams. A Count-Min sketch is com- posed of a set of </span><span class="c5">d </span><span class="c4">hash functions, </span><span class="c5">h</span><span class="c12">1</span><span class="c5">(&middot;)</span><span class="c4">, </span><span class="c5">h</span><span class="c12">2</span><span class="c5">(&middot;)</span><span class="c4">, </span><span class="c5">...</span><span class="c4">, </span><span class="c5">h</span><span class="c0">d</span><span class="c7">(&middot;)</span><span class="c6">, and a 2- </span><span class="c4">dimensional array of counters of width </span><span class="c5">w </span><span class="c4">and depth </span><span class="c5">d</span><span class="c4">. Hash func- tion </span><span class="c5">h</span><span class="c12">j </span><span class="c4">corresponds to row </span><span class="c5">j </span><span class="c4">of the array, mapping stream items to the range of </span><span class="c5">[1 ...w]</span><span class="c4">. Let </span><span class="c5">CM[i, j] </span><span class="c4">denote the counter at position </span><span class="c5">(i, j) </span><span class="c4">in the array. To add an item </span><span class="c5">x </span><span class="c4">of value </span><span class="c5">v</span><span class="c0">x </span><span class="c6">in the Count-Min </span><span class="c4">sketch, we increase the counters located at </span><span class="c5">CM[h</span><span class="c12">j</span><span class="c5">(x),j] </span><span class="c4">by </span><span class="c5">v</span><span class="c12">x</span><span class="c4">, for </span><span class="c5">j &isin; [1 ...d]</span><span class="c4">. A point query for an item </span><span class="c5">q </span><span class="c4">is answered by hash- ing the item in each of the </span><span class="c5">d </span><span class="c4">rows and getting the minimum value of the corresponding cells, i.e., </span><span class="c5">min</span><span class="c3">d</span><span class="c12">j=1 </span><span class="c11">CM[h</span><span class="c12">j</span><span class="c5">(q),j]</span><span class="c4">. Note that hash collisions may cause estimation inaccuracies &ndash; only overesti- mations. By setting </span><span class="c5">d = &lceil;ln(1/&delta;)&rceil; </span><span class="c4">and </span><span class="c5">w = &lceil;e/&#491;&rceil;</span><span class="c4">, where </span><span class="c5">e </span><span class="c4">is the base of the natural logarithm, the structure enables point queries to be answered with an error of less than </span><span class="c5">&#491;||a||</span><span class="c12">1</span><span class="c4">, with a probability of at least </span><span class="c5">1 &minus; &delta;</span><span class="c4">, where </span><span class="c5">||a||</span><span class="c0">1 </span><span class="c6">denotes the number of items seen in the </span><span class="c4">stream. Similar results hold for range and inner product queries. </span></p><p class="c17"><span class="c4">Exponential Histograms. Exponential histograms [12] are a de- terministic structure, proposed to address the basic counting prob- lem, i.e., for counting the number of true bits in the last </span><span class="c5">N </span><span class="c4">stream arrivals. They belong to the family of methods that break the slid- ing window range into smaller windows, called buckets or basic windows, to enable efficient maintenance of the statistics. Each bucket contains the aggregate statistics, i.e., number of arrivals and bucket bounds, for the corresponding sub-range. Buckets that no longer overlap with the sliding window are expired and discarded from the structure. To compute an aggregate over the whole (or </span></p><p class="c2"><span class="c26">Notation Description </span><span class="c21">N </span><span class="c26">Length of the sliding window, in time units or # arrivals </span><span class="c21">h</span><span class="c22">i</span><span class="c48">(</span><span class="c23">&middot;</span><span class="c48">) </span><span class="c52">Hash function </span><span class="c23">i </span><span class="c52">of the Count-Min sketch </span><span class="c21">a</span><span class="c22">r</span><span class="c26">, </span><span class="c21">b</span><span class="c22">r </span><span class="c26">Substream of stream </span><span class="c21">a</span><span class="c26">, </span><span class="c21">b</span><span class="c26">, within the query range </span><span class="c21">r f</span><span class="c22">a</span><span class="c47">(</span><span class="c21">x, r</span><span class="c47">) </span><span class="c26">Frequency of item </span><span class="c21">x </span><span class="c26">in stream </span><span class="c21">a</span><span class="c26">, within the query range </span><span class="c21">r E</span><span class="c22">a</span><span class="c48">(</span><span class="c23">i, j, r</span><span class="c48">) </span><span class="c52">Estimated value of the ECM-sketch counter for stream </span><span class="c23">a </span><span class="c52">in </span></p><p class="c30"><span class="c26">position </span><span class="c47">(</span><span class="c21">i, j</span><span class="c47">) </span><span class="c26">for query range </span><span class="c21">r a</span><span class="c22">r </span><span class="c21">&#8857; b</span><span class="c22">r</span><span class="c21">, </span><span class="c82">&#770;</span><span class="c21">a</span><span class="c22">r </span><span class="c21">&#8857; b</span><span class="c22">r </span><span class="c26">Real and estimated inner product of </span><span class="c21">a</span><span class="c22">r </span><span class="c26">and </span><span class="c21">b</span><span class="c22">r </span><span class="c23">u</span><span class="c48">(</span><span class="c23">N, S</span><span class="c48">) </span><span class="c52">Upper bound of number of arrivals on stream </span><span class="c23">S </span><span class="c52">within the </span></p><p class="c30"><span class="c26">sliding window of length </span><span class="c21">N </span><span class="c4">Table 1: Frequently used notation. </span></p><p class="c17"><span class="c4">a part of) sliding window, the statistics from all buckets overlap- ping with the query range are aggregated. For example, for basic counting, aggregation is a summation of the number of true bits in the buckets. A possible estimation error can be introduced due to the oldest bucket inside the query range, which usually has only a partial overlap with the query. Therefore, the maximum possible estimation error is bounded by the size of the last bucket. </span></p><p class="c17"><span class="c4">To reduce the space requirements, exponential histograms main- tain buckets of exponentially increasing sizes. Bucket boundaries are chosen such that the ratio of the size of each bucket </span><span class="c5">b </span><span class="c4">with the sum of the sizes of all buckets more recent than </span><span class="c5">b </span><span class="c4">is upper bounded. In particular, the following invariant (</span><span class="c27">invariant 1</span><span class="c4">) is maintained for all buckets </span><span class="c5">j</span><span class="c4">: </span><span class="c5">C</span><span class="c12">j</span><span class="c5">/(2(1+</span><span class="c11">&sum;</span><span class="c12">j&minus;1 </span></p><p class="c17"><span class="c12">i=1 </span><span class="c11">C</span><span class="c3">i</span><span class="c11">)) &le; &#491; </span><span class="c24">where </span><span class="c11">&#491; </span><span class="c24">denotes the max- </span><span class="c4">imum acceptable relative error and </span><span class="c5">C</span><span class="c0">j </span><span class="c6">denotes the size of bucket </span><span class="c7">j </span><span class="c4">(number of true bits arrived in the bucket range), with bucket 1 being the most recent bucket. Queries are answered by summing the sizes of all buckets that fully overlap the query range, and half of the size of the oldest bucket, if it partially overlaps the query. The estimation error is solely contained in the oldest bucket, and is therefore bounded by this invariant, resulting to a maximum rela- tive error of </span><span class="c5">&#491;</span><span class="c4">. </span></p><p class="c2"><span class="c16">4. ECM-SKETCHES </span></p><p class="c17"><span class="c4">We now describe ECM-sketches (short for Exponential Count- Min sketches), a composable sketch for maintaining data stream statistics over sliding windows in distributed environments. ECM- sketches combine the functionality of Count-Min sketches and slid- ing windows, and support both time-based and count-based sliding windows under the cash register model. Therefore, they can be used for compactly summarizing high-dimensional streams over sliding windows, i.e., to maintain the observed frequencies of the stream items within the sliding window range. </span></p><p class="c17"><span class="c4">The core of the structure is a modified Count-Min sketch. Count- Min sketches alone cannot handle the sliding window requirement. To address this limitation, ECM-sketches replace the Count-Min counters with sliding window structures. Each counter is main- tained as a sliding window, covering the last </span><span class="c5">N </span><span class="c4">time units, or the last </span><span class="c5">N </span><span class="c4">arrivals, depending on whether we need time-based or count- based sliding windows. </span></p><p class="c17"><span class="c4">As discussed in Section 2, there have been several algorithms proposed for sliding window maintenance. Due to the large ex- pected number of sliding window counters in ECM-sketches, we require an algorithm with a small memory footprint. Randomized sliding window synopses are therefore not a good choice. Instead, we employ exponential histograms [12], a compact and efficient deterministic synopsis. Each of the Count-Min counters is imple- mented as an exponential histogram, configured to provide an </span><span class="c5">&#491; </span><span class="c4">approximation for any query within a sliding window of length </span><span class="c5">N</span><span class="c4">, i.e., the estimation </span><span class="c5">&circ;x </span><span class="c4">of the counter for any query range within the sliding window length is in the range of </span><span class="c5">(1 &plusmn; &#491;)x </span><span class="c4">of the true value </span><span class="c5">x </span><span class="c4">of the counter. We will be discussing our choice for exponential histograms again in more detail in the following section, where we will consider alternative deterministic and randomized algorithms. </span></p><p class="c2"><span class="c13">994 </span></p><p class="c2"><span class="c4">Figure 1: Adding an element to the ECM-sketch. </span></p><p class="c17"><span class="c4">Adding an item </span><span class="c5">x </span><span class="c4">to the structure is similar to the case of the standard Count-Min sketches. The process for time-based sliding windows is depicted in Figure 1. First, the counters </span><span class="c5">CM[h</span><span class="c12">j</span><span class="c5">(x),j]</span><span class="c4">, where </span><span class="c5">j &isin; {1...d}</span><span class="c4">, corresponding to the </span><span class="c5">d </span><span class="c4">hash functions are detected. For each of the counters, we register the arrival of the item at time </span><span class="c5">t</span><span class="c4">, and remove all expired information, i.e., the buckets of the exponential histogram that have no overlap with the sliding window range. The process for count-based sliding windows is similar, but instead of registering each arrival with system time </span><span class="c5">t</span><span class="c4">, we register it with the count of arrivals since the beginning of the stream. </span></p><p class="c2"><span class="c4">The challenges that need to be addressed for the integration of exponential histograms with Count-Min sketches are: (a) to take into account the additional error introduced by the sliding window counters for deriving the accuracy guarantees for ECM-sketches (presented in the remainder of this section), and, (b) to enable com- position of a set of ECM-sketches to a single ECM-sketch repre- senting the order-preserving aggregation of the corresponding indi- vidual streams (Section 5). </span><span class="c16">4.1 Query Answering </span></p><p class="c17"><span class="c4">We now explain how ECM-sketches support point queries, inner product queries, and self-join queries, and we derive probabilistic guarantees for the accuracy of the estimation. Our analysis covers both sliding window models, i.e., time-based and count-based. </span></p><p class="c17"><span class="c4">Point Queries. A point query </span><span class="c5">(x, r) </span><span class="c4">is a combination of an item identifier </span><span class="c5">x</span><span class="c4">, and the query range </span><span class="c5">r </span><span class="c4">defined either as number of time units or number of arrivals. Point queries are executed as follows. The query item is hashed to the </span><span class="c5">d </span><span class="c4">counters </span><span class="c5">CM[h</span><span class="c0">j</span><span class="c7">(x),j] </span><span class="c6">where </span><span class="c5">(j &isin; {1 ...d})</span><span class="c4">, and the estimate of each counter </span><span class="c5">E(h</span><span class="c12">j</span><span class="c5">(x), j, r) </span><span class="c4">for the query range is computed. The estimate value for the frequency of </span><span class="c5">x </span><span class="c4">is </span><span class="c11">&circ;</span><span class="c5">f(x, r) = min</span><span class="c0">j=1...d </span><span class="c7">E(h</span><span class="c0">j</span><span class="c7">(x), j, r)</span><span class="c6">. </span></p><p class="c2"><span class="c4">Let </span><span class="c5">&delta;</span><span class="c0">cm </span><span class="c6">and </span><span class="c7">&#491;</span><span class="c0">cm </span><span class="c6">denote the configuration parameters of the Count- </span><span class="c4">Min sketch, whereas </span><span class="c5">&#491;</span><span class="c12">sw </span><span class="c4">denotes the configuration parameter of the exponential histogram. With </span><span class="c5">||a</span><span class="c0">r</span><span class="c7">||</span><span class="c0">1 </span><span class="c6">we denote the number of </span><span class="c4">arrivals within the query range. The following theorem provides probabilistic guarantees for the approximation quality. T</span><span class="c25">HEOREM </span><span class="c4">1. </span><span class="c18">| </span><span class="c39">&circ;</span><span class="c18">f(x, r)&minus; f(x, r)| &ge; (&#491;</span><span class="c12">sw </span><span class="c18">+ &#491;</span><span class="c12">cm </span><span class="c18">+ &#491;</span><span class="c12">sw</span><span class="c18">&#491;</span><span class="c12">cm</span><span class="c18">)||a</span><span class="c12">r</span><span class="c18">||</span><span class="c0">1 </span><span class="c14">with probability at most </span><span class="c37">&delta; = &delta;</span><span class="c0">cm</span><span class="c14">. </span><span class="c4">P</span><span class="c25">ROOF</span><span class="c4">. Special case of Theorem 3, proved in the appendix. As is typical for small-space sketches, the error guarantees are rel- ative to the stream characteristics, i.e., the L1 norm. For all pairs of </span><span class="c5">&#491;</span><span class="c0">sw </span><span class="c6">and </span><span class="c7">&#491;</span><span class="c0">cm </span><span class="c6">satisfying </span><span class="c37">&#491;</span><span class="c0">sw </span><span class="c37">+ &#491;</span><span class="c0">cm </span><span class="c37">+ &#491;</span><span class="c0">sw</span><span class="c37">&#491;</span><span class="c0">cm </span><span class="c37">= &#491;</span><span class="c6">, the maximum es- </span><span class="c4">timation error will be </span><span class="c5">&#491;||a</span><span class="c12">r</span><span class="c5">||</span><span class="c12">1</span><span class="c4">. (Note that </span><span class="c18">&#491; &asymp; &#491;</span><span class="c12">cm </span><span class="c18">+&#491;</span><span class="c12">sw</span><span class="c4">, since typi- cally </span><span class="c5">&#491;</span><span class="c0">sw</span><span class="c7">,&#491;</span><span class="c0">cm </span><span class="c7">&lt; 0.5</span><span class="c6">, and thus the product </span><span class="c37">&#491;</span><span class="c0">sw</span><span class="c37">&#491;</span><span class="c0">cm </span><span class="c6">is much smaller </span><span class="c4">than the two linear terms.) The optimal pair of </span><span class="c5">&#491;</span><span class="c0">cm </span><span class="c6">and </span><span class="c7">&#491;</span><span class="c0">sw </span><span class="c6">is the </span><span class="c4">one that minimizes memory utilization. The worst-case memory re- quirements of the structure are minimized as follows. The required memory per sliding window counter is </span><span class="c5">O( </span><span class="c3">1</span><span class="c12">&#491;</span><span class="c22">sw </span><span class="c5">log</span><span class="c3">2 </span><span class="c5">Z)</span><span class="c4">, where </span><span class="c5">Z </span><span class="c4">denotes the maximum possible count of each item in the sliding window. Therefore, the maximum required memory is mem </span><span class="c5">= </span></p><p class="c2"><span class="c12">c &#491;</span><span class="c22">sw </span><span class="c5">log</span><span class="c3">2 </span><span class="c5">Z &times; w &times; d</span><span class="c4">, with </span><span class="c5">c </span><span class="c4">denoting a constant, </span><span class="c5">w = &lceil;e/&#491;</span><span class="c0">cm</span><span class="c7">&rceil;</span><span class="c6">, </span><span class="c4">and </span><span class="c5">d = &lceil;ln(1/&delta;</span><span class="c0">cm</span><span class="c7">)&rceil;</span><span class="c6">. By derivation we find that the memory </span><span class="c4">bound is minimized for </span><span class="c5">&#491;</span><span class="c0">sw </span><span class="c7">= &#491;</span><span class="c0">cm </span><span class="c7">= </span><span class="c5">&radic;</span><span class="c7">&#491; + 1 &minus; 1</span><span class="c6">, and becomes </span><span class="c5">O( </span><span class="c3">ln</span><span class="c20">2 </span><span class="c12">Z ln(1/&delta;</span><span class="c22">cm</span><span class="c0">) </span></p><p class="c2"><span class="c12">&#491;</span><span class="c22">sw</span><span class="c0">&#491;</span><span class="c22">cm </span><span class="c5">) = O( </span><span class="c3">ln</span><span class="c20">2 </span><span class="c12">Z ln(1/&delta;</span><span class="c22">cm</span><span class="c0">) </span></p><p class="c2"><span class="c12">&#491; </span><span class="c11">)</span><span class="c24">. </span><span class="c4">Inner Product and Self-Join Queries. Another frequent query type is the cardinality of the inner product. Given two streams </span><span class="c5">a </span></p><p class="c2"><span class="c4">and </span><span class="c5">f</span><span class="c0">b</span><span class="c7">(x)</span><span class="c6">, </span><span class="c5">b</span><span class="c4">, the </span><span class="c6">where </span><span class="c4">inner </span><span class="c7">D </span><span class="c6">denotes </span><span class="c4">product </span><span class="c6">the </span><span class="c4">is defined </span><span class="c6">input domain, </span><span class="c4">as </span><span class="c5">a &#8857; b </span><span class="c6">i.e., </span><span class="c5">= </span><span class="c6">the </span><span class="c11">&sum;</span><span class="c12">x&isin;D </span><span class="c6">distinct </span><span class="c11">f</span><span class="c12">a</span><span class="c5">(x) </span><span class="c6">input </span><span class="c5">&times; </span></p><p class="c29"><span class="c4">elements, and </span><span class="c5">f</span><span class="c0">a</span><span class="c7">(x) </span><span class="c6">(resp. </span><span class="c7">f</span><span class="c0">b</span><span class="c7">(x)</span><span class="c6">) denotes the frequency of element </span><span class="c5">x </span><span class="c4">in stream </span><span class="c5">a </span><span class="c4">(resp. stream </span><span class="c5">b</span><span class="c4">). Self-join queries, also called the second frequency moment queries defined over a Both inner product queries </span><span class="c5">F</span><span class="c12">2</span><span class="c4">, are single stream: and self-join a special </span><span class="c5">F</span><span class="c4">queries </span><span class="c0">2</span><span class="c7">(a) </span><span class="c4">case </span><span class="c7">= </span><span class="c4">are </span><span class="c5">&sum;</span><span class="c4">of very </span><span class="c0">x&isin;D </span><span class="c4">inner </span><span class="c5">(f</span><span class="c4">important product </span><span class="c0">a</span><span class="c7">(x))</span><span class="c12">2</span><span class="c6">. </span></p><p class="c17"><span class="c4">for databases, e.g., for building query execution plans, and they can be efficiently and accurately computed for streams with the cash register and turnstile model. However, similar to point queries, computing these queries over sliding windows is challenging. </span></p><p class="c29"><span class="c4">ECM-sketches can be used to address this type of queries as well. Let </span><span class="c5">a</span><span class="c0">r </span><span class="c6">(resp. </span><span class="c7">b</span><span class="c0">r</span><span class="c6">) denote the substream of stream </span><span class="c7">a </span><span class="c6">(resp. </span><span class="c7">b</span><span class="c6">) within </span><span class="c4">the query range. With </span><span class="c5">CM</span><span class="c0">a </span><span class="c6">we denote the corresponding ECM- </span><span class="c4">sketch for stream </span><span class="c5">a</span><span class="c12">r</span><span class="c4">, and with </span><span class="c5">E</span><span class="c12">a</span><span class="c5">(i, j, r) </span><span class="c4">we denote the estimated value Also, </span><span class="c5">f</span><span class="c4">of </span><span class="c0">a</span><span class="c7">(x, </span><span class="c4">the </span><span class="c7">r) </span><span class="c4">counter </span><span class="c6">and </span><span class="c7">f</span><span class="c5">&circ;</span><span class="c0">a</span><span class="c7">(x, </span><span class="c4">of </span><span class="c5">CM</span><span class="c7">r) </span><span class="c6">denote </span><span class="c0">a </span><span class="c6">in position the real </span><span class="c7">(i, </span><span class="c6">and </span><span class="c7">j)</span><span class="c6">, estimated for query frequency range </span><span class="c7">r</span><span class="c6">. </span></p><p class="c30"><span class="c4">of </span><span class="c5">x </span><span class="c4">in stream </span><span class="c5">a</span><span class="c0">r</span><span class="c6">. </span><span class="c4">The inner as </span><span class="c5">a</span><span class="c0">r </span><span class="c7">&#8857; b</span><span class="c0">r </span><span class="c7">= </span><span class="c4">product </span><span class="c5">&sum;</span><span class="c0">x&isin;D </span><span class="c4">of </span><span class="c5">f</span><span class="c4">two </span><span class="c0">a</span><span class="c7">(x, </span><span class="c4">streams </span><span class="c7">r)f</span><span class="c0">b</span><span class="c7">(x, </span><span class="c5">a </span><span class="c7">r)</span><span class="c6">. </span><span class="c4">and </span><span class="c6">Using </span><span class="c5">b </span><span class="c4">in a </span><span class="c6">the </span><span class="c4">range </span><span class="c6">ECM-sketches </span><span class="c5">r </span><span class="c4">is defined </span></p><p class="c2"><span class="c4">of where theorem </span><span class="c5">a </span><span class="c4">and </span><span class="c5">( a</span><span class="c11">&#770;</span><span class="c4">bounds </span><span class="c0">r </span><span class="c5">b</span><span class="c4">, </span><span class="c7">&#8857; </span><span class="c4">we </span><span class="c7">b</span><span class="c0">r</span><span class="c7">)</span><span class="c4">estimate </span><span class="c0">j </span><span class="c4">the </span><span class="c7">= </span><span class="c4">approximation </span><span class="c5">&sum;</span><span class="c0">wi=1 </span><span class="c4">it as </span><span class="c5">E</span><span class="c4">follows: </span><span class="c0">a</span><span class="c7">(i, j, </span><span class="c4">error </span><span class="c7">r)&times;E</span><span class="c5">a</span><span class="c11">&#770;</span><span class="c0">r </span><span class="c4">of </span><span class="c7">&#8857; </span><span class="c0">b</span><span class="c7">(i, b</span><span class="c4">this </span><span class="c0">r </span><span class="c7">= min</span><span class="c0">j</span><span class="c7">( a</span><span class="c5">&#770;</span><span class="c0">r </span><span class="c7">&#8857; b</span><span class="c0">r</span><span class="c7">)</span><span class="c0">j</span><span class="c6">, </span><span class="c7">j, r)</span><span class="c6">. The following </span></p><p class="c2"><span class="c4">estimation. T</span><span class="c25">HEOREM </span><span class="c4">2. </span><span class="c5">&#491;</span><span class="c12">sw</span><span class="c5">)</span><span class="c3">2</span><span class="c5">)||a</span><span class="c12">r</span><span class="c5">||</span><span class="c12">1</span><span class="c5">||b</span><span class="c12">r</span><span class="c5">||</span><span class="c12">1 </span><span class="c5">| a</span><span class="c11">&#770;</span><span class="c0">r </span><span class="c7">&#8857; b</span><span class="c0">r </span><span class="c7">&minus; a</span><span class="c0">r </span><span class="c7">&#8857; b</span><span class="c0">r</span><span class="c7">| &ge; (&#491;</span><span class="c12">2</span><span class="c0">sw </span><span class="c5">+ 2&#491;</span><span class="c0">sw </span><span class="c7">+ &#491;</span><span class="c0">cm</span><span class="c7">(1 + </span></p><p class="c2"><span class="c27">with probability at most </span><span class="c5">&delta; = &delta;</span><span class="c12">cm</span><span class="c27">. </span><span class="c4">P</span><span class="c25">ROOF</span><span class="c4">. In the appendix. The error is therefore </span><span class="c5">&asymp; (2&#491;</span><span class="c0">sw</span><span class="c7">+&#491;</span><span class="c0">cm</span><span class="c7">)||a</span><span class="c0">r</span><span class="c7">||</span><span class="c0">1</span><span class="c7">||b</span><span class="c0">r</span><span class="c7">||</span><span class="c0">1</span><span class="c6">, since the higher- </span><span class="c4">order components are dominated by </span><span class="c5">&#491;</span><span class="c12">sw </span><span class="c4">and </span><span class="c5">&#491;</span><span class="c12">cm</span><span class="c4">. Similar to the analysis for point queries, we can find the optimal pair of </span><span class="c5">&#491;</span><span class="c0">sw </span><span class="c4">and </span><span class="c5">&#491;</span><span class="c12">cm </span><span class="c4">guaranteeing a maximum error of </span><span class="c5">&#491;||a</span><span class="c12">r</span><span class="c5">||</span><span class="c12">1</span><span class="c5">||b</span><span class="c12">r</span><span class="c5">||</span><span class="c12">1 </span><span class="c4">by us- ing derivation on the total memory requirements: </span><span class="c18">&#491;</span><span class="c12">sw </span><span class="c18">= &minus;1 &minus; </span></p><p class="c30"><span class="c12">3+3&#491; 3 </span><span class="c20">4</span><span class="c28">3 </span><span class="c38">(</span><span class="c12">9+9&#491;+</span><span class="c3">&radic;</span><span class="c12">3</span><span class="c39">&radic;</span><span class="c12">28+57&#491;+30&#491;</span><span class="c20">2</span><span class="c12">+&#491;</span><span class="c20">3</span><span class="c38">) </span><span class="c20">1</span><span class="c28">3 </span><span class="c39">+ </span></p><p class="c29"><span class="c42">(</span><span class="c0">9+9&#491;+</span><span class="c12">&radic;</span><span class="c0">3</span><span class="c18">&radic;</span><span class="c0">28+57&#491;+30&#491;</span><span class="c28">2</span><span class="c0">+&#491;</span><span class="c28">3</span><span class="c38">) </span><span class="c20">1</span><span class="c28">3 </span><span class="c12">3 </span><span class="c20">2</span><span class="c28">3 </span><span class="c4">and </span><span class="c18">&#491;</span><span class="c0">cm </span><span class="c37">= </span><span class="c12">&#491;&minus;&#491;(1+&#491;</span><span class="c20">2</span><span class="c63">sw</span><span class="c3">&minus;2&#491;</span><span class="c22">sw</span><span class="c0">)</span><span class="c28">2 </span><span class="c63">sw </span></p><p class="c2"><span class="c34">. </span></p><p class="c2"><span class="c16">4.2 Extensions </span></p><p class="c2"><span class="c74">4.2.1 Time-based Vs Count-based ECM-Sketches </span></p><p class="c17"><span class="c4">Exponential histograms were originally developed for count-ba- sed sliding windows. They can be easily extended for time-based sliding windows as follows. First, each entry in the data structure is identified using its arrival time, instead of using its position in the stream. To reduce memory, arrival times are stored in wraparound counters of </span><span class="c5">O(log(N)) </span><span class="c4">bits, where </span><span class="c5">N </span><span class="c4">is the length of the sliding window, e.g., in milliseconds. Second, entries expire based on their arrival time, and not on their position in the stream. Finally, we re- quire an upper bound of the number of arrivals within the sliding window time range for each stream </span><span class="c5">S</span><span class="c4">, denoted as </span><span class="c5">u(N,S)</span><span class="c4">. Note that this is required only for computing the maximum memory re- quirements of the structure a priori; it does not have an impact on the actual required memory or quality of ECM-sketches. Further- more, the bound can be very loose without a noticeable change on the estimated space requirements, because space complexity in- creases only logarithmically with </span><span class="c5">u(N,S)</span><span class="c4">. </span></p><p class="c17"><span class="c4">Complexity. We use </span><span class="c5">N </span><span class="c4">to denote the length of the sliding window, either in number of arrivals or in time, depending on the desired sliding window model. With </span><span class="c5">u(N,S) </span><span class="c4">we denote the upper bound of the number of arrivals in stream </span><span class="c5">S </span><span class="c4">within a sliding window of length </span><span class="c5">N</span><span class="c4">. Also, </span><span class="c5">g(N,S) = max(u(N,S),N)</span><span class="c4">. </span></p><p class="c2"><span class="c4">To get an </span><span class="c5">&#491;</span><span class="c12">sw</span><span class="c4">-approximation of the number of one-bits in the sliding window, exponential histograms require </span><span class="c5">O(log(N)+ </span></p><p class="c2"><span class="c13">995 </span></p><p class="c2"><span class="c9">Exponential Memory </span><span class="c18">O </span><span class="c39">( </span><span class="c12">1</span><span class="c0">&#491; </span><span class="c18">ln( </span><span class="c3">1</span><span class="c12">&delta; </span><span class="c39">) ln</span><span class="c3">2</span><span class="c9">Histogram </span><span class="c18">(g(N,S))</span><span class="c39">) </span><span class="c18">O </span><span class="c39">( </span><span class="c12">1</span><span class="c9">Deterministic </span><span class="c0">&#491; </span><span class="c18">ln(</span><span class="c3">1</span><span class="c12">&delta; </span><span class="c39">) ln</span><span class="c3">2</span><span class="c18">(g(N,S))</span><span class="c9">Wave </span><span class="c39">) </span><span class="c9">Randomized Wave </span></p><p class="c2"><span class="c18">O </span><span class="c9">Amort. update </span><span class="c18">O(ln(1/&delta;)) O(ln(1/&delta;)) ( </span><span class="c0">&#491;1</span><span class="c28">2 </span><span class="c39">ln</span><span class="c3">2</span><span class="c18">O(ln(&delta;) ln</span><span class="c3">2</span><span class="c18">(&delta;)) </span></p><p class="c2"><span class="c3">2</span><span class="c18">(u(N,S))</span><span class="c39">) </span></p><p class="c2"><span class="c9">Worst update Query </span><span class="c18">O(ln(1/&delta;) O(ln(1/&delta;) ln(u(N,S))/ln(u(N,S))) </span><span class="c39">&radic;</span><span class="c18">&#491;) O(ln(1/&delta;) O(ln(1/&delta;)) ln(u(N,S))/</span><span class="c39">&radic;</span><span class="c18">&#491;) O(ln</span><span class="c3">2</span><span class="c18">(&delta;) ln(u(N,S))) </span></p><p class="c2"><span class="c18">O(ln</span><span class="c3">2</span><span class="c18">(&delta;)(ln(u(N,S)) + 1/&#491;</span><span class="c3">2</span><span class="c18">)) </span><span class="c4">Table 2: Computational and space complexity of ECM-sketches. Function </span><span class="c5">g(N,S) </span><span class="c4">is used as a shortcut for </span><span class="c5">max(u(N,S),N)</span><span class="c4">. </span></p><p class="c2"><span class="c5">log log(u(N,S))) </span><span class="c4">memory per bucket, to store the bucket size and bucket yielding boundaries. a total memory The number of </span><span class="c5">O(log</span><span class="c4">of </span><span class="c3">2</span><span class="c5">(g(N,S))/&#491;</span><span class="c12">sw</span><span class="c5">)</span><span class="c4">. buckets is </span><span class="c5">O(log(u(N,S))/&#491;</span><span class="c4">With respect </span><span class="c0">sw</span><span class="c7">)</span><span class="c6">, </span></p><p class="c17"><span class="c4">to computational cost, the update cost per element is </span><span class="c5">O(log(u(N,S))) </span><span class="c4">worst-case, and </span><span class="c5">O(1) </span><span class="c4">amortized time. Queries covering the whole sliding window are executed in constant time. For queries with range </span><span class="c5">N</span><span class="c3">&prime; </span><span class="c5">&lt; N</span><span class="c4">, the required time is </span><span class="c5">O(log(u(N,S)/&#491;</span><span class="c0">sw</span><span class="c7">))</span><span class="c6">. The </span><span class="c4">extra time is required for finding the oldest bucket overlapping with the query, assuming sequential access. If the storage model of the buckets supports random access, e.g., a fixed-length array, then this time can be further reduced to </span><span class="c5">O(log(log(u(N,S)/&#491;</span><span class="c12">sw</span><span class="c5">)))</span><span class="c4">, by em- ploying binary search. </span></p><p class="c17"><span class="c4">The space complexity of ECM-sketches is as follows. For the Count-Min array, we require an array of width </span><span class="c5">w = &lceil;e/&#491;</span><span class="c0">cm</span><span class="c7">&rceil; </span><span class="c6">and </span><span class="c4">depth </span><span class="c5">d = &lceil;ln(1/&delta;)&rceil;</span><span class="c4">. Each cell in the array stores an exponential histogram, requiring total memory requirements With respect to the time </span><span class="c5">O(log</span><span class="c4">complexity, are </span><span class="c3">2</span><span class="c5">(g(N,S))/&#491;O( </span><span class="c12">&#491;</span><span class="c22">sw</span><span class="c0">&#491;</span><span class="c3">1 </span></p><p class="c2"><span class="c22">cm </span><span class="c4">adding </span><span class="c0">sw</span><span class="c7">) </span><span class="c5">log</span><span class="c3">2</span><span class="c6">bits. </span><span class="c5">(g(N,S)) </span><span class="c4">an </span><span class="c6">Therefore, the </span></p><p class="c29"><span class="c5">log(1/&delta;))</span><span class="c4">. element requires computing </span><span class="c5">d </span><span class="c4">hash functions, and updating </span><span class="c5">d </span><span class="c4">separate exponential histograms. The amortized complexity for each arrival is there- fore </span><span class="c5">O(d) = O(log(1/&delta;))</span><span class="c4">, whereas the worst-case complexity is </span><span class="c5">O(d log(u(N,S))) = O(log(u(N,S)) log(1/&delta;))</span><span class="c4">. Finally, query execution takes </span><span class="c5">O(log(1/&delta;)) </span><span class="c4">time for a query of range </span><span class="c5">N</span><span class="c3">&prime; </span><span class="c4">equal to </span><span class="c5">N</span><span class="c4">. For </span><span class="c5">N</span><span class="c3">&prime; </span><span class="c5">O(log(1/&delta;) &lt; log(u(N,S))/N</span><span class="c4">, the execution </span><span class="c11">&radic;</span><span class="c5">&#491;) </span><span class="c4">cost is </span><span class="c5">O(dlog(u(N,S))/&#491;</span><span class="c0">sw</span><span class="c7">) = </span><span class="c4">with sequential access to buckets, e.g., using a linked list. With random access support, binary search can ducing be used the query for finding cost to the </span><span class="c5">O(log(1/&delta;) </span><span class="c4">last relevant </span><span class="c5">log(log(u(N,S))/</span><span class="c4">bucket for each </span><span class="c11">&radic;</span><span class="c4">query, </span><span class="c5">&#491;))</span><span class="c4">. </span></p><p class="c2"><span class="c4">re- </span></p><p class="c2"><span class="c74">4.2.2 ECM-Sketches based on Waves </span></p><p class="c17"><span class="c4">The sliding window counters can also be materialized using other sliding window algorithms. In the literature, two such algorithms are particularly well-known: (a) deterministic waves, and, (b) ran- domized waves [15]. We now show how ECM-sketches can in- corporate these algorithms, and discuss the positive and negative aspects of each variant. </span></p><p class="c17"><span class="c4">Deterministic Waves. Deterministic waves [15] have identical memory requirements with exponential histograms, and they out- perform exponential histograms with respect to worst-case com- plexity for updates, requiring always constant time. As such, the space and computational complexity of ECM-sketches based on deterministic waves is the same to the one of sketches based on exponential histograms, with the only difference being the worst- case update complexity, which is </span><span class="c5">O(log(1/&delta;))</span><span class="c4">. </span></p><p class="c17"><span class="c4">A downside of deterministic waves is that they require knowl- edge of the upper bound of the number of arrivals </span><span class="c5">u(N,S) </span><span class="c4">during the initialization of the data structures, to decide on the required number of queues/levels. Any overestimation of </span><span class="c5">u(N,S) </span><span class="c4">is there- fore translated to an increase on the space requirements &ndash; logarith- mic with </span><span class="c5">u(N,S)</span><span class="c4">. It is important to note that this constraint is substantially less limiting compared to the constraints of previous algorithms, e.g., [27], which required an upper bound for the </span><span class="c27">total number of items in all streams</span><span class="c4">, and therefore could not be applied to dynamic networks, with an unknown number of participating nodes and streams. </span></p><p class="c2"><span class="c4">Randomized Waves. Randomized waves [15] provide an </span><span class="c5">(&#491;, &delta;) </span></p><p class="c17"><span class="c4">approximation for the basic counting problem, i.e., </span><span class="c5">Pr[|&circ;x &minus; x| &le; &#491;</span><span class="c0">sw</span><span class="c7">x] &ge; 1 &minus; &delta;</span><span class="c0">sw</span><span class="c6">, where </span><span class="c7">&circ;x </span><span class="c6">and </span><span class="c7">x </span><span class="c6">denote the estimated and real </span><span class="c4">number of true bits in the sliding window range respectively. This structure has substantially higher space complexity compared to the deterministic counterparts &ndash; </span><span class="c5">O(1/&#491;</span><span class="c3">2</span><span class="c12">sw</span><span class="c11">) </span><span class="c24">instead of </span><span class="c11">O(1/&#491;</span><span class="c12">sw</span><span class="c5">)</span><span class="c4">. How- ever, randomized waves are important for distributed applications, as they enable lossless aggregation of individual summaries to a single summary corresponding to the aggregated data. Therefore, we also consider randomized waves for integration with the ECM- sketch. </span></p><p class="c29"><span class="c4">The space complexity of ECM-sketches based on randomized waves sic structures: is derived </span><span class="c5">O </span><span class="c4">by </span><span class="c5">(log(&delta;</span><span class="c4">multiplying </span><span class="c0">cm</span><span class="c7">) log(&delta;</span><span class="c4">the </span><span class="c0">sw</span><span class="c7">) </span><span class="c4">space </span><span class="c7">log</span><span class="c4">complexity </span><span class="c12">2</span><span class="c7">(f(N,S))/(&#491;</span><span class="c4">of the </span><span class="c0">cm</span><span class="c7">&#491;</span><span class="c4">two </span><span class="c12">2</span><span class="c0">sw</span><span class="c4">ba- </span><span class="c5">)</span><span class="c11">)</span><span class="c4">. Inserting a new element requires </span><span class="c5">O(log(&delta;</span><span class="c12">cm</span><span class="c5">) log(&delta;</span><span class="c12">sw</span><span class="c5">)) </span><span class="c4">amortized time, and</span><span class="c5">O(log(&delta;</span><span class="c0">cm</span><span class="c7">) log(&delta;</span><span class="c0">sw</span><span class="c7">) log(f(N,S))) </span><span class="c6">worst-case time. Fi- </span><span class="c4">nally, query execution </span><span class="c5">1/&#491;</span><span class="c3">2</span><span class="c12">sw</span><span class="c11">)) </span><span class="c24">with sequential </span><span class="c5">(log log(f(N,S)) </span><span class="c4">T</span><span class="c25">HEOREM </span><span class="c4">3. takes</span><span class="c5">O(log(&delta;</span><span class="c12">cm</span><span class="c5">) log(&delta;</span><span class="c12">sw</span><span class="c5">) (log(f(N,S))+ + </span><span class="c18">| f(x, </span><span class="c39">&circ;</span><span class="c24">access to buckets and</span><span class="c11">O(log(&delta;</span><span class="c5">log(1/&#491;</span><span class="c3">2</span><span class="c12">sw</span><span class="c11">))) </span><span class="c24">time with random </span><span class="c12">cm</span><span class="c5">) log(&delta;</span><span class="c0">sw</span><span class="c7">) </span></p><p class="c29"><span class="c24">access. </span><span class="c18">r)&minus; f(x, r)| &ge; (&#491;</span><span class="c0">sw </span><span class="c37">+ &#491;</span><span class="c0">cm </span><span class="c37">+ &#491;</span><span class="c0">sw</span><span class="c37">&#491;</span><span class="c0">cm</span><span class="c37">)||a</span><span class="c0">r</span><span class="c37">||</span><span class="c0">1 </span><span class="c27">with probability at most </span><span class="c5">&delta; = &delta;</span><span class="c12">sw </span><span class="c5">+ &delta;</span><span class="c12">cm</span><span class="c27">. </span></p><p class="c2"><span class="c4">P</span><span class="c25">ROOF</span><span class="c4">. In the appendix. By derivation on the total memory usage, we can find the combi- nation </span><span class="c7">&radic;</span><span class="c4">of </span><span class="c5">&#491;</span><span class="c12">sw </span><span class="c4">and </span><span class="c5">&#491;</span><span class="c12">cm </span><span class="c4">that minimizes </span><span class="c11">&radic;</span><span class="c4">the memory bound: </span><span class="c5">&#491;</span><span class="c12">sw </span><span class="c5">= </span><span class="c0">&#491;</span><span class="c28">2</span><span class="c0">+10&#491;+9+&#491;&minus;3 </span><span class="c12">4 </span><span class="c4">complexity </span><span class="c24">and </span><span class="c11">&#491;</span><span class="c3">cm </span><span class="c11">= </span><span class="c4">becomes </span><span class="c18">O </span><span class="c39">(</span><span class="c18">log(&delta;</span><span class="c12">cm</span><span class="c18">) </span><span class="c4">for </span><span class="c5">&delta;</span><span class="c0">cm </span><span class="c7">= &delta;</span><span class="c0">sw </span><span class="c7">= &delta;/2 </span><span class="c6">it becomes </span><span class="c3">3&#491;&minus;</span><span class="c12">&#491;+</span><span class="c11">&radic;</span><span class="c7">O </span><span class="c12">&#491;</span><span class="c18">log(&delta;</span><span class="c12">sw</span><span class="c18">) </span><span class="c12">&#491;</span><span class="c20">22</span><span class="c12">+10&#491;+9+1 </span><span class="c5">(</span><span class="c12">+10&#491;+9+3 </span></p><p class="c29"><span class="c7">log</span><span class="c12">2</span><span class="c7">(&delta;) </span><span class="c18">log</span><span class="c7">log</span><span class="c3">2</span><span class="c24">. </span><span class="c18">(f(N,S))/&#491;</span><span class="c24">The </span><span class="c12">2</span><span class="c7">(f(N,S))/&#491;</span><span class="c24">optimal </span><span class="c3">2</span><span class="c39">)</span><span class="c24">space </span><span class="c4">, and </span><span class="c12">2</span><span class="c11">)</span><span class="c4">. Table 2 summarizes the main results for the combination of ECM- sketches and the three sliding window structures. The results cor- respond to both time-based and count-based sliding windows. </span></p><p class="c17"><span class="c16">5. ORDER-PRESERVING AGGREGATION </span><span class="c4">For many distributed applications, such as the network monitoring application described in the introduction, we require aggregating individual ECM-sketches </span><span class="c5">CM</span><span class="c0">1</span><span class="c6">, </span><span class="c7">CM</span><span class="c0">2</span><span class="c6">, ..., </span><span class="c7">CM</span><span class="c0">n</span><span class="c6">, each one cor- </span><span class="c4">responding to stream </span><span class="c5">S</span><span class="c12">1</span><span class="c4">, </span><span class="c5">S</span><span class="c12">2</span><span class="c4">, ..., </span><span class="c5">S</span><span class="c12">n</span><span class="c4">, to get a single ECM-sketch </span><span class="c5">CM</span><span class="c0">&oplus; </span><span class="c6">that corresponds to the logical stream </span><span class="c7">S</span><span class="c0">&oplus; </span><span class="c7">= S</span><span class="c0">1 </span><span class="c7">&oplus; S</span><span class="c0">2 </span><span class="c7">&oplus; </span><span class="c5">... &oplus; S</span><span class="c0">n</span><span class="c6">. The </span><span class="c7">&oplus; </span><span class="c6">operator is defined as an aggregation that pre- </span><span class="c4">serves the ordering and arrival time of the events. Standard Count- Min sketches allow this aggregation, as long as all sketches are constructed with identical dimensions and hash functions. For this, they rely on the linearity of the Count-Min counters, which are sim- ple integers in the general case. However, this does not trivially hold for ECM-sketches, where the counters are not simple num- bers but complex sliding window structures, since the analysis of exponential histograms (as well as all other deterministic sliding window structures), does not cover linearity. Although random- ized structures cover linearity by default, these are substantially more expensive, and not preferable for ECM-sketches. Therefore, we now consider the order-preserving aggregation of deterministic sliding window structures. Note that this problem is interesting by itself, since these data structures are widely used in the literature for maintaining statistics over sliding windows. We then extend our results to cover aggregation of the ECM-sketches. </span></p><p class="c2"><span class="c13">996 </span></p><p class="c2"><span class="c16">5.1 Aggregation of Exponential Histograms </span></p><p class="c17"><span class="c4">Consider a set of exponential histograms</span><span class="c5">EH</span><span class="c0">1</span><span class="c7">,EH</span><span class="c0">2</span><span class="c7">,...,EH</span><span class="c0">n</span><span class="c6">, </span><span class="c4">summarizing time-based sliding windows. All are configured to cover a sliding window of </span><span class="c5">N </span><span class="c4">time units. The aggregation opera- tion is denoted with </span><span class="c5">&oplus;</span><span class="c4">, i.e., </span><span class="c5">EH</span><span class="c0">&oplus; </span><span class="c7">= EH</span><span class="c0">1 </span><span class="c7">&oplus; EH</span><span class="c0">2 </span><span class="c7">&oplus; ... &oplus; EH</span><span class="c0">n</span><span class="c6">. </span><span class="c4">With </span><span class="c5">EH</span><span class="c3">j</span><span class="c12">i </span><span class="c24">we denote bucket </span><span class="c11">j </span><span class="c24">of </span><span class="c11">EH</span><span class="c3">i</span><span class="c24">, and </span><span class="c11">|EH</span><span class="c3">j</span><span class="c12">i </span><span class="c11">| </span><span class="c24">denotes the </span><span class="c4">bucket size (number of true bits). By convention, buckets are num- bered such that bucket 1 is the most recent. The ending time of the bucket is denoted as </span><span class="c5">e(EH</span><span class="c3">j</span><span class="c12">i </span><span class="c11">)</span><span class="c24">. To ease exposition, we use </span><span class="c11">s(EH</span><span class="c3">j</span><span class="c12">i </span><span class="c11">) </span><span class="c4">to denote the starting time of the bucket, even though this is not explicitly stored in the buckets. By construction, the starting time of a bucket is equal to the ending time of the previous bucket, i.e., </span><span class="c5">s(EH</span><span class="c3">j</span><span class="c12">i </span><span class="c11">) = e(EH</span><span class="c3">j&minus;1 </span></p><p class="c2"><span class="c12">i </span><span class="c11">)</span><span class="c24">. </span><span class="c4">To construct </span><span class="c5">EH</span><span class="c0">&oplus; </span><span class="c6">our methodology considers the individual ex- </span><span class="c4">ponential histograms as logs. The general idea is to reconstruct </span><span class="c5">EH</span><span class="c0">&oplus; </span><span class="c6">by assuming that half of the elements arrive at the start- </span><span class="c4">ing time of each bucket, and the other half at the ending time of the bucket. Precisely, let </span><span class="c5">B </span><span class="c4">denote the list containing all buckets of all sliding windows. We initialize an empty time-based expo- nential histogram with error </span><span class="c5">&#491;</span><span class="c3">&prime;</span><span class="c4">, configured to keep the last </span><span class="c5">N </span><span class="c4">time units, and a maximum of </span><span class="c11">&sum;</span><span class="c12">n</span><span class="c0">i=1 </span><span class="c5">|EH</span><span class="c0">i</span><span class="c7">| </span><span class="c6">elements. For each bucket </span><span class="c5">B[i] &isin; B</span><span class="c4">, we simulate the insertion in </span><span class="c5">EH</span><span class="c0">&oplus; </span><span class="c6">of </span><span class="c7">|B[i]| </span><span class="c6">true bits. Half </span><span class="c4">of the bits are inserted with timestamp </span><span class="c5">s(B[i])</span><span class="c4">, and the other half at time </span><span class="c5">e(B[i])</span><span class="c4">. The insertions are simulated in the order defined by the starting and ending timestamps of the buckets. </span></p><p class="c17"><span class="c4">T</span><span class="c25">HEOREM </span><span class="c4">4. </span><span class="c27">Consider </span><span class="c5">n </span><span class="c27">time-based exponential histograms </span><span class="c5">EH</span><span class="c0">1</span><span class="c14">, </span><span class="c7">EH</span><span class="c0">2</span><span class="c14">, </span><span class="c7">...</span><span class="c14">, </span><span class="c7">EH</span><span class="c0">n</span><span class="c14">, initialized with error parameter </span><span class="c7">&#491;</span><span class="c14">, and cov- </span><span class="c27">ering the same time range. The exponential histogram </span><span class="c5">EH</span><span class="c0">&oplus; </span><span class="c14">ini- </span><span class="c27">tialized with error parameter </span><span class="c5">&#491;</span><span class="c3">&prime;</span><span class="c27">, and constructed with the proposed aggregation algorithm answers any query within its time range for the stream </span><span class="c5">S</span><span class="c12">&oplus; </span><span class="c27">with a maximum relative error of </span><span class="c5">(&#491; + &#491;</span><span class="c3">&prime; </span><span class="c5">+ &#491;&#491;</span><span class="c3">&prime;</span><span class="c5">)</span><span class="c27">. </span></p><p class="c2"><span class="c4">We will now give the intuition of the proof. The formal proof is presented in the appendix. Each exponential histogram </span><span class="c5">EH </span><span class="c4">of stream </span><span class="c5">S </span><span class="c4">configured with error parameter </span><span class="c5">&#491; </span><span class="c4">can be used to recon- struct an approximate stream </span><span class="c5">S</span><span class="c3">&prime;</span><span class="c4">, as follows: For each bucket </span><span class="c5">b </span><span class="c4">in </span><span class="c5">EH</span><span class="c4">, add </span><span class="c5">|b|/2 </span><span class="c4">true bits in time </span><span class="c5">s(b)</span><span class="c4">, and </span><span class="c5">|b|/2 </span><span class="c4">true bits in time </span><span class="c5">e(b)</span><span class="c4">. We argue that answering any query with starting time </span><span class="c5">s</span><span class="c12">q </span><span class="c4">within the range of </span><span class="c5">EH </span><span class="c4">using the reconstructed stream </span><span class="c5">S</span><span class="c3">&prime; </span><span class="c4">will result to a maximum relative error </span><span class="c5">&#491;</span><span class="c4">. Let </span><span class="c5">b</span><span class="c12">j </span><span class="c4">be the bucket s.t. </span><span class="c5">s(b</span><span class="c0">j</span><span class="c7">) &lt; s</span><span class="c0">q </span><span class="c7">&le; e(b</span><span class="c0">j</span><span class="c7">)</span><span class="c6">. Therefore, the accurate answer </span><span class="c7">x </span><span class="c6">of the </span><span class="c4">query for stream </span><span class="c5">S </span><span class="c4">is bounded by </span><span class="c5">x &ge; </span><span class="c11">&sum;</span><span class="c12">j&minus;1 i=1 </span><span class="c11">|b</span><span class="c12">i</span><span class="c5">| + 1 </span><span class="c4">and </span><span class="c5">x &le; </span><span class="c7">&sum;</span><span class="c0">j&minus;1 </span><span class="c12">i=1 </span><span class="c11">|b</span><span class="c12">i</span><span class="c5">| + |b</span><span class="c0">j</span><span class="c7">|</span><span class="c6">. By construction, the reconstructed stream will </span><span class="c4">contain a total of </span><span class="c11">&sum;</span><span class="c12">j&minus;1 </span></p><p class="c17"><span class="c12">i=1 </span><span class="c11">|b</span><span class="c3">i</span><span class="c11">| + |b</span><span class="c3">j</span><span class="c11">|/2 </span><span class="c24">items with timestamp greater </span><span class="c4">than or equal to </span><span class="c5">s</span><span class="c0">q</span><span class="c6">. Therefore, answering the query by counting </span><span class="c4">the number of true bits in the reconstructed stream with times- tamp after </span><span class="c5">s</span><span class="c12">q </span><span class="c4">will have a maximum error of </span><span class="c5">max(h&minus;</span><span class="c11">&sum;</span><span class="c12">j&minus;1 </span></p><p class="c2"><span class="c12">i=0 </span><span class="c11">|b</span><span class="c3">i</span><span class="c11">|+ </span><span class="c5">|b</span><span class="c0">j</span><span class="c7">|/2,</span><span class="c5">&sum;</span><span class="c0">j&minus;1 </span></p><p class="c2"><span class="c12">i=0 </span><span class="c11">|b</span><span class="c12">i</span><span class="c5">| + |b</span><span class="c0">j</span><span class="c7">|/2 &minus; l) = |b</span><span class="c0">j</span><span class="c7">|/2</span><span class="c6">. By invariant 1 of expo- </span><span class="c4">nential histograms, </span><span class="c5">|b</span><span class="c0">j</span><span class="c7">|/2 &le; &#491;(1 + </span><span class="c5">&sum;</span><span class="c0">j&minus;1 </span></p><p class="c17"><span class="c12">i=1 </span><span class="c11">|b</span><span class="c12">i</span><span class="c5">|) &le; &#491;x</span><span class="c4">. Therefore, the maximum difference between the answer estimated by stream </span><span class="c5">S</span><span class="c3">&prime; </span><span class="c4">and the correct answer </span><span class="c5">x </span><span class="c4">will be less than or equal to </span><span class="c5">&#491;x</span><span class="c4">. </span></p><p class="c2"><span class="c4">Our aggregation algorithm is equivalent to reconstructing each stream </span><span class="c5">S</span><span class="c3">&prime;</span><span class="c12">i </span><span class="c24">from exponential histogram </span><span class="c11">EH</span><span class="c3">i</span><span class="c24">, and using these to </span><span class="c4">recreate an exponential histogram </span><span class="c5">EH</span><span class="c0">&oplus;</span><span class="c6">. The reconstruction of </span><span class="c4">stream </span><span class="c5">S</span><span class="c3">&prime; </span><span class="c4">introduces a maximum relative error </span><span class="c5">&#491;</span><span class="c4">, as explained above. Summarizing </span><span class="c5">S</span><span class="c3">&prime; </span><span class="c4">with a new exponential histogram we get an ad- ditional error </span><span class="c5">&#491;</span><span class="c3">&prime;</span><span class="c4">. However, </span><span class="c5">&#491;</span><span class="c3">&prime; </span><span class="c4">is relative on the answer provided by stream </span><span class="c5">S</span><span class="c3">&prime;</span><span class="c4">, and not by </span><span class="c5">S</span><span class="c4">. Therefore, the absolute error due to the exponential histogram summarization will be </span><span class="c5">&#491;</span><span class="c3">&prime;</span><span class="c5">x</span><span class="c3">&prime;</span><span class="c4">, where </span><span class="c5">x</span><span class="c3">&prime; </span><span class="c5">&isin; (1 &plusmn; &#491;)x </span><span class="c4">and </span><span class="c5">x </span><span class="c4">denoting the accurate answer on </span><span class="c5">S</span><span class="c12">i</span><span class="c4">. Sum- ming both errors, we get a total relative error of </span><span class="c5">&#491; + &#491;</span><span class="c3">&prime; </span><span class="c5">+ &#491;&#491;</span><span class="c3">&prime;</span><span class="c4">. </span></p><p class="c2"><span class="c4">For the special case when </span><span class="c5">&#491;</span><span class="c3">&prime; </span><span class="c5">= &#491;</span><span class="c4">, the maximum relative error becomes </span><span class="c5">2&#491;+&#491;</span><span class="c3">2</span><span class="c4">. Concerning space and computational complexity, </span></p><p class="c2"><span class="c5">EH</span><span class="c0">&oplus; </span><span class="c6">behaves as a standard exponential histogram, and therefore </span><span class="c4">has the same complexity as presented in [12]. </span></p><p class="c17"><span class="c4">Multi-level Aggregation. It is frequently desired to aggregate slid- ing windows in more than one levels. For example, consider a hierarchical P2P network, where each peer maintains its own ex- ponential histogram, and pushes it to its parent for aggregation at regular intervals. Since the aggregated exponential histograms have the same properties as the individual exponential histograms (albeit with a higher </span><span class="c5">&#491;</span><span class="c4">), the above analysis also supports iterative aggrega- tion of exponential histograms. </span></p><p class="c17"><span class="c4">There are two types of approximation error that influence the estimation of an aggregated exponential histogram. A possible ap- proximation error, denoted as err</span><span class="c0">1</span><span class="c6">, is introduced due to halving of </span><span class="c4">the size of the last bucket of the aggregated exponential histogram. This error occurs only at query time, and is independent of the num- ber of performed aggregations. Therefore, at a multi-level aggre- gation scenario this error does not need to be propagated at the in- termediary exponential histograms. A second type of error, termed as err</span><span class="c12">2</span><span class="c4">, occurs due to the inclusion (exclusion) of data that arrived before (after) the query starting time in buckets that are accounted (not accounted) in the query result. </span></p><p class="c17"><span class="c4">It turns out that the error err</span><span class="c0">2 </span><span class="c6">is additive at the worst case (in </span><span class="c4">absolute value). For instance, in the lowest level (Level 0) of the hierarchy, aggregating two exponential histograms (all with relative error </span><span class="c5">&#491;</span><span class="c4">), having a true number of bits (in a given query range) equal to </span><span class="c5">i</span><span class="c12">1 </span><span class="c4">and </span><span class="c5">i</span><span class="c12">2</span><span class="c4">, will result at a maximum value for err</span><span class="c12">2 </span><span class="c5">&le; &#491;(i</span><span class="c12">1 </span><span class="c5">+ i</span><span class="c12">2</span><span class="c5">)</span><span class="c4">. In Level 1, in addition to the previous possible errors, </span><span class="c5">&#491;(i</span><span class="c0">1 </span><span class="c7">+ i</span><span class="c0">2</span><span class="c7">) + </span><span class="c5">&#491;(i</span><span class="c12">3 </span><span class="c5">+ i</span><span class="c12">4</span><span class="c5">) </span><span class="c4">stream items may be incorrectly registered at the wrong side of the query start time. A recursive repetition for </span><span class="c5">h </span><span class="c4">levels results to err</span><span class="c0">2 </span><span class="c7">&le; h&#491;i</span><span class="c6">, where </span><span class="c7">i = </span><span class="c5">&sum;</span><span class="c0">j </span><span class="c5">i</span><span class="c0">j</span><span class="c6">. The total absolute error </span><span class="c4">(including err</span><span class="c0">1</span><span class="c6">) then becomes err </span><span class="c7">= </span><span class="c6">err</span><span class="c0">2</span><span class="c7">+</span><span class="c6">err</span><span class="c0">1 </span><span class="c7">&le; h&#491;i+&#491;(i+h&#491;i)</span><span class="c6">, </span><span class="c4">resulting to a maximum relative error of </span><span class="c5">h&#491;(1 + &#491;) + &#491;</span><span class="c4">. </span></p><p class="c29"><span class="c4">In many applications, the number of aggregation levels can be predicted, or even controlled when constructing the network topol- ogy. For example, consider DHT-based or hierarchical P2P topolo- gies, which typically enable a balanced-tree access to the peers of height </span><span class="c5">h = log(N)</span><span class="c4">, where </span><span class="c5">N </span><span class="c4">is the number of nodes. In such sys- tems, initializing the individual exponential histograms with error </span><span class="c7">&radic;</span><span class="c0">1+2h+h</span><span class="c28">2</span><span class="c0">+4h&#491;&minus;1&minus;h </span><span class="c12">2h </span><span class="c24">yields an aggregated exponential histogram </span><span class="c4">of relative error </span><span class="c5">&#491;</span><span class="c4">. Naturally, this causes a slight inflation of the size of the sliding window, by </span><span class="c5">O(log(N))</span><span class="c4">. However, even with this inflation, exponential histograms are &ndash; even for extremely large net- works &ndash; substantially smaller and more efficient than randomized data structures that enable error-free aggregation in the expense of memory proportional to </span><span class="c5">O(1/&#491;</span><span class="c3">2</span><span class="c5">) </span><span class="c4">(see also Section 5.2). </span></p><p class="c17"><span class="c4">Deterministic Waves. The aggregation technique trivially extends for deterministic waves. Recall that each wave is composed of </span><span class="c5">l </span><span class="c4">levels, each covering a different range. To perform the aggregation, we start from the lowest level </span><span class="c5">l &minus; 1</span><span class="c4">, and switch to a higher level every </span><span class="c5">(1/&#491; + 1)/2 </span><span class="c4">bits, i.e., when the first entry in the higher level has arrived before the next entry in the current level. Repeating the calculation of the error bounds for the aggregation of deterministic waves becomes straightforward when we notice that invariant 1 of the exponential histograms is also true for deterministic waves. </span></p><p class="c17"><span class="c4">Count-based Exponential Histograms. Although exponential his- tograms cover both time-based and count-based sliding windows, aggregation of exponential histograms is specific for time-based sliding windows. Count-based sliding windows do not contain suf- ficient information for allowing order-preserving aggregation. Even storing the system-wide time of the buckets would not be sufficient to allow such an aggregation. To illustrate this limitation, consider </span></p><p class="c2"><span class="c13">997 </span></p><p class="c2 c44"><span class="c4">the two count-based exponential histograms depicted in Fig. 2. For each bucket we store the bucket id, the size of the bucket, the bucket completion time and the total number of arrivals until that time. An arrival in count-based sliding windows might be a true or a false bit. An example query can then be: </span><span class="c27">how many true bits arrived in the last 100 system-wide arrivals</span><span class="c4">. If these 100 system-wide arrivals were read between time 19 and 20, then the correct answer would be 1. However, it is also possible that the last 100 system-wide ar- rivals have arrived between time 3 and time 20, in which case the correct answer could be anything between 2 and 9. The information contained in the two exponential histograms is not sufficient to es- timate this type of queries, as it only allows us to preserve the order of the true bits, but looses the order of the false bits, which is also important. Therefore, given only the exponential histograms, it is not possible to aggregate them in a way that preserves the ordering of both true and false bits. Deterministic and randomized waves also have the same limitation when it comes to order-preserving aggregation of count-based sliding windows. </span><span class="c16">5.2 Aggregation of Randomized Waves </span></p><p class="c36"><span class="c4">Randomized waves were proposed in [15] to address the prob- lem of distributed union counting: </span><span class="c27">counting the number of 1&rsquo;s in the position-wise union of </span><span class="c5">t </span><span class="c27">distributed data streams, over a slid- ing window</span><span class="c4">. However, the existing algorithm for utilizing more than one randomized waves does not consider aggregation of sev- eral waves, to generate a single wave. It assumes that the individual randomized waves can be stored and accessed any time, which is inconvenient for large networks. To eliminate this assumption we now propose a slight variation of their algorithm that can produce a single randomized wave out of a set of individual waves, with the same probabilistic accuracy guarantees as the individual waves. </span></p><p class="c44 c70"><span class="c4">Our algorithm simulates the construction of the aggregate ran- domized wave </span><span class="c5">RW</span><span class="c12">&oplus; </span><span class="c4">by using only the information included in the individual randomized waves. Consider a set </span><span class="c5">R </span><span class="c4">of randomized waves </span><span class="c5">RW</span><span class="c12">1</span><span class="c4">, </span><span class="c5">RW</span><span class="c12">2</span><span class="c4">, ..., </span><span class="c5">RW</span><span class="c12">n</span><span class="c4">, configured to store a sliding win- dow of </span><span class="c5">N </span><span class="c4">time units, with error parameters </span><span class="c5">&#491; </span><span class="c4">and </span><span class="c5">&delta;</span><span class="c4">. The aggregate randomized wave </span><span class="c5">RW</span><span class="c0">&oplus; </span><span class="c6">is initialized with the same </span><span class="c7">&#491; </span><span class="c6">and </span><span class="c7">&delta; </span><span class="c6">pa- </span><span class="c4">rameters, for storing a maximum of </span><span class="c11">&sum;</span><span class="c12">n</span><span class="c0">i=1 </span><span class="c5">|RW</span><span class="c12">i</span><span class="c5">| </span><span class="c4">events over </span><span class="c5">N </span><span class="c4">time units. Each level </span><span class="c5">l </span><span class="c4">of </span><span class="c5">RW</span><span class="c0">&oplus; </span><span class="c6">is then constructed by concatenat- </span><span class="c4">ing the corresponding level </span><span class="c5">l </span><span class="c4">from all individual randomized waves, sorting all events based on the timestamp, and keeping the last </span><span class="c5">c/&#491;</span><span class="c3">2 </span><span class="c4">events. Recall that the number of levels of individual randomized waves is determined based on the maximum number of events in the sliding window. Therefore, it may happen that </span><span class="c5">RW</span><span class="c0">&oplus; </span><span class="c6">has more </span><span class="c4">levels than individual randomized waves. To populate the lower levels of </span><span class="c5">RW</span><span class="c0">&oplus;</span><span class="c6">, we rehash the events populating the last level of </span><span class="c4">each individual randomized wave, as proposed in [15] when merg- ing different levels from randomized waves. </span></p><p class="c41"><span class="c4">The process of query execution and the accuracy guarantees re- main the same as for the standard randomized waves. </span><span class="c16">5.3 Composability of ECM-Sketches </span></p><p class="c44 c65"><span class="c4">Consider a set of ECM-sketches </span><span class="c5">CM</span><span class="c0">1</span><span class="c6">, </span><span class="c7">CM</span><span class="c0">2</span><span class="c6">, </span><span class="c7">...</span><span class="c6">, </span><span class="c7">CM</span><span class="c0">n </span><span class="c6">with </span><span class="c4">identical dimensions and hash functions. The ECM-sketch </span><span class="c5">CM</span><span class="c12">&oplus; </span><span class="c4">with each counter set to the sum of all corresponding counters from the individual sketches (as defined by the </span><span class="c5">&oplus; </span><span class="c4">operator), summarizes the information found in the individual sketches: </span></p><p class="c57"><span class="c5">CM</span><span class="c12">&oplus;</span><span class="c5">[j, k] = CM</span><span class="c12">1</span><span class="c5">[j, k] &oplus; CM</span><span class="c12">2</span><span class="c5">[j, k] &oplus; ... &oplus; CM</span><span class="c12">n</span><span class="c5">[j, k] </span></p><p class="c91"><span class="c4">To bound the estimation error, we consider the two sources of error in the aggregated ECM-sketch. The error due to the Count- Min sketch </span><span class="c5">&#491;</span><span class="c12">cm </span><span class="c4">does not change, since it only depends on the di- mensionality of the Count-Min array, which is fixed. However, </span></p><p class="c30 c68"><span class="c18">EH</span><span class="c0">1 </span><span class="c37">EH</span><span class="c0">2 </span><span class="c9">Bucket id 2 1 5 4 3 2 1 Size 1 1 8 4 2 1 1 Completion time 3 20 3 5 10 15 19 </span></p><p class="c87"><span class="c9">Arrivals 500 1000 900 950 980 990 1000 </span><span class="c4">Figure 2: An example why aggregating count-based exponen- tial histograms is not possible. </span></p><p class="c78 c84"><span class="c4">the error due to sliding window estimations at each counter might change with each aggregation. Let </span><span class="c5">&#491;</span><span class="c3">&prime;</span><span class="c12">sw </span><span class="c24">denote the error produced </span><span class="c4">by the aggregation of the corresponding Count-Min counters, as discussed in Sections 5.1 and 5.2. Recall that this error depends on the data structure used for maintaining the sliding window. Simi- lar to the case of individual ECM-sketches, the total error is </span><span class="c5">&#491; = &#491;</span><span class="c0">cm </span><span class="c7">+ &#491;</span><span class="c12">&prime;</span><span class="c0">sw </span><span class="c5">+ &#491;</span><span class="c0">cm</span><span class="c7">&#491;</span><span class="c12">&prime;</span><span class="c0">sw</span><span class="c4">, with probability </span><span class="c5">1 &minus; &delta;</span><span class="c0">sw </span><span class="c7">&minus; &delta;</span><span class="c0">cm</span><span class="c6">. </span><span class="c16">6. OTHER APPLICATIONS </span></p><p class="c78 c86"><span class="c4">In addition to point and inner product queries, ECM-sketches can also address more complex requirements. We now briefly discuss two such cases: (a) finding the frequent items, and, (b) continu- ous monitoring of the value of inner joins or point queries over distributed streams. Additional problems, such as computing quan- tiles or answering range queries over sliding windows, can also be addressed, e.g., by adapting the algorithms proposed for Count-Min sketches [10] to employ ECM-sketches instead. </span><span class="c16">6.1 Finding the Frequent Items </span></p><p class="c54"><span class="c4">Consider a stream </span><span class="c5">S </span><span class="c4">containing items from the universe </span><span class="c5">U</span><span class="c4">. The straightforward solution for finding the frequent items in the slid- ing window is to execute </span><span class="c5">|U| </span><span class="c4">point queries on the ECM-sketch, one for each item in the universe, and retain only the items above the desired frequency threshold. However, this approach carries a com- putational complexity of </span><span class="c5">O(|U|&times;ln(1/&delta;)) </span><span class="c4">for executing all queries and detecting the frequent items, which is clearly prohibitive for streaming algorithms. </span></p><p class="c33"><span class="c4">A more efficient algorithm based on range sums is proposed by Cormode et al. [10], and can be adapted to ECM-sketches for ad- dressing the sliding-window requirements. The algorithm relies on group testing, for progressively reducing the domain of candidate frequent items, until only the truly frequent items remain. The basic idea is to create </span><span class="c5">log(|U|) </span><span class="c4">ECM-sketches, denoted as </span><span class="c5">CM</span><span class="c0">0</span><span class="c6">, </span><span class="c7">CM</span><span class="c0">1</span><span class="c6">, </span><span class="c4">...</span><span class="c5">CM</span><span class="c0">log(|U|)&minus;1</span><span class="c6">, to keep the number of occurrences of ranges of </span><span class="c4">items. The</span><span class="c5">i</span><span class="c4">&rsquo;th ECM sketch is used to maintain the range sum of the necessary dyadic ranges of length </span><span class="c5">2</span><span class="c3">i </span><span class="c4">for covering </span><span class="c5">U</span><span class="c4">. A new arrival </span><span class="c5">x &isin; U </span><span class="c4">is handled by adding </span><span class="c5">&lfloor;x/2</span><span class="c3">i</span><span class="c5">&rfloor; </span><span class="c4">to </span><span class="c5">CM</span><span class="c0">i</span><span class="c6">, for </span><span class="c7">0 &le; i &lt; log(|U|)</span><span class="c6">. </span><span class="c4">To detect the frequent items, we start with </span><span class="c5">CM</span><span class="c0">log(|U|)&minus;1</span><span class="c6">, estimat- </span><span class="c4">ing the number of occurrences of the contained dyadic ranges. If any of the dyadic ranges has an estimated frequency less than the frequency threshold </span><span class="c5">&phi;</span><span class="c4">, the whole dyadic range is ignored, as it can- not contain a frequent item. For all ranges with frequency surpass- ing </span><span class="c5">&phi;</span><span class="c4">, the test continues recursively by breaking the range in two, and using the ECM-sketch of the lower level. </span></p><p class="c33"><span class="c4">There are some interesting variants of the above problem, mostly relating to the way the threshold </span><span class="c5">&phi; </span><span class="c4">is expressed by the user. If </span><span class="c5">&phi; </span><span class="c4">is given as a minimum number of occurrences of each item, then no further computation is needed to determine which dyadic ranges are frequent and which are infrequent. However, it is often useful to express </span><span class="c5">&phi; </span><span class="c4">as the ratio of the number of occurrences of each item to the total number of arrivals within the sliding window. For time- based sliding windows, we can estimate the total number of arrivals by maintaining an additional sliding window, e.g., a deterministic wave, and using its lower bound. A better alternative that does not require additional memory is to use ECM-sketch </span><span class="c5">CM</span><span class="c12">0 </span><span class="c4">to esti- mate the total number of arrivals, by summing all counters in each </span></p><p class="c89"><span class="c13">998 </span></p><p class="c2"><span class="c64">u</span><span class="c60">1 </span></p><p class="c2"><span class="c18">Drift Vector u </span></p><p class="c2"><span class="c64">u </span><span class="c60">4 </span></p><p class="c2"><span class="c18">Global Estimate Vector e </span></p><p class="c2"><span class="c64">v </span><span class="c56">e </span></p><p class="c2"><span class="c18">Global Statistics Vector v </span></p><p class="c2"><span class="c64">u </span><span class="c60">2 </span></p><p class="c2"><span class="c64">u </span></p><p class="c2"><span class="c88">3 </span></p><p class="c17"><span class="c4">Figure 3: Local constraints using the Geometric Approach. Each node constructs a sphere with diameter the drift vector u of the node and the estimate vector e. The global statistics vector v is guaranteed to lie in the convex hull of e, u1, u2, u3, u4. The union of the local spheres covers the convex hull. </span></p><p class="c29"><span class="c4">row, and getting the average value. Although this approach has the same error bounds, in practice it offers better estimation accuracy than maintaining a single additional sliding window, since the er- rors coming from all counters in each row are usually canceled out. This estimation based on ECM-sketches may result to false pos- itives and false negatives. Theorem 5 allows us to bound this error. </span></p><p class="c17"><span class="c4">T</span><span class="c25">HEOREM </span><span class="c4">5. </span><span class="c27">The proposed algorithm uses </span><span class="c5">O((log |U|/&#491;) log(2 log |U|/(&delta;&phi;)) log</span><span class="c3">2</span><span class="c5">(g(N,S))) </span><span class="c27">memory and amortized time </span><span class="c5">O(log(2 log |U|/&delta;) log |U|) </span><span class="c27">per update, for detect- ing every item with frequency at least </span><span class="c5">(&phi;+&#491;)||a||</span><span class="c12">1</span><span class="c27">. With probability </span><span class="c5">1 &minus; &delta;</span><span class="c27">, no item with frequency less than </span><span class="c5">&phi;||a||</span><span class="c0">1 </span><span class="c14">is output. </span></p><p class="c17"><span class="c4">The same algorithm for approximating range sums can also be used for range queries, by noticing that all valid ranges within </span><span class="c5">U </span><span class="c4">can be expressed by a sum of dyadic ranges [10]. The error guarantees in this case are identical to the ones for Count-Min sketches, as described in [10], whereas the memory requirements are </span><span class="c5">O((1/&#491;) log(1/&delta;) log</span><span class="c3">2</span><span class="c5">(g(N,S)) log |U|) </span><span class="c4">bytes, for maintain- ing the </span><span class="c5">log |U| </span><span class="c4">ECM-sketches. </span></p><p class="c2"><span class="c16">6.2 Continuous </span><span class="c59">Threshold Crossing </span></p><p class="c17"><span class="c16">Monitoring of Functions for </span><span class="c4">In many application domains, continuous monitoring of func- tions is required. ECM-sketches can also be used in these scenar- ios to reduce the memory and network requirements. We give the main intuition on how this can be done using self-join queries over sliding windows as an example. </span></p><p class="c17"><span class="c4">We combine ECM-sketches with the geometric method [25]. The geometric method allows the distributed monitoring of complex (non-linear) functions defined over the average of local vectors (termed as </span><span class="c27">local statistics vectors</span><span class="c4">) maintained at sites. The goal is to to drastically reduce the required coordination for monitoring threshold crossing of such complex functions in a distributed net- work. The main idea is to distributively monitor the domain space where the average vector may lie. Each site monitors a portion of the corresponding subset of the domain space, with the corre- sponding monitoring zone often being expressed as a hypersphere. A common reference point of all such hyperspheres is the </span><span class="c27">global estimate vector</span><span class="c4">, which is the average vector computed during the last global communication (often called as a synchronization step) among all sites. Figure 3 depicts this process. </span></p><p class="c2"><span class="c4">In this context, ECM-sketches are used to represent: </span></p><p class="c2"><span class="c5">&bull; </span><span class="c4">The denoted local as statistics </span><span class="c11">&minus;&rarr;</span><span class="c5">sv</span><span class="c0">1</span><span class="c7">(t),</span><span class="c5">&minus;&rarr;</span><span class="c7">sv</span><span class="c4">vectors </span><span class="c0">2</span><span class="c7">(t),...,</span><span class="c4">at each </span><span class="c5">&minus;&rarr;</span><span class="c7">sv</span><span class="c0">n</span><span class="c7">(t)</span><span class="c6">, </span><span class="c4">site. The </span><span class="c6">where </span><span class="c4">ECM-sketches </span><span class="c7">n </span><span class="c6">is the number </span><span class="c4">are </span></p><p class="c2"><span class="c4">of sites. All sketches have an identical configuration. </span></p><p class="c2"><span class="c5">&bull; </span><span class="c4">The global statistics vector. This vector is the current average over all local statistics vectors. The value of this vector is un- </span></p><p class="c2"><span class="c4">known to all sites, unless a synchronization takes place. The global statistics sketch is denoted as </span><span class="c11">&minus;&rarr;</span><span class="c5">sv(t)</span><span class="c4">, and is computed by a linear aggregation of the local statistics sketches. We also use </span><span class="c11">&minus;&rarr;</span><span class="c5">se(t) </span><span class="c4">to denote the global estimate vector, which is the last known value of the global statistics vector. Out of these two ECM-sketches, we can also compute the fol- lowing two vectors, required by the geometric method: </span></p><p class="c17"><span class="c5">&bull; </span><span class="c4">The statistics delta vectors, denoted using </span><span class="c5">&#8710;</span><span class="c11">&minus;&rarr;</span><span class="c5">sv(t)</span><span class="c4">. This vec- tor is equal to the difference between the local statistics vector and the corresponding vector that was transmitted in the last synchronization. </span></p><p class="c29"><span class="c5">&bull; </span><span class="c4">The drift vectors, denoted as </span><span class="c11">&minus;&rarr;</span><span class="c5">su</span><span class="c0">i</span><span class="c7">(t)</span><span class="c6">, where </span><span class="c5">&minus;&rarr;</span><span class="c7">su</span><span class="c0">i</span><span class="c7">(t) = </span><span class="c5">&minus;&rarr;</span><span class="c7">se(t) + </span><span class="c5">&#8710;</span><span class="c11">&minus;&rarr;</span><span class="c5">sv</span><span class="c12">i</span><span class="c5">(t)</span><span class="c4">. The global statistics vector is guaranteed to lie in the convex hull of the drift vectors, while this convex hull is cov- ered by the union of hyperspheres monitored by the sites. Each hypersphere of a site is constructed with diameter the global es- timate vector and the corresponding drift vector of the site [25]. To initialize the monitoring process, all nodes send their local statistics vectors </span><span class="c11">&minus;&rarr;</span><span class="c5">sv</span><span class="c12">1</span><span class="c5">(t),</span><span class="c11">&minus;&rarr;</span><span class="c5">sv</span><span class="c12">2</span><span class="c5">(t),...,</span><span class="c11">&minus;&rarr;</span><span class="c5">sv</span><span class="c12">n</span><span class="c5">(t) </span><span class="c4">to a coordinator. The coordinator aggregates all vectors using the algorithm for order- preserving aggregation of ECM-sketches, and computes a single global statistics vector </span><span class="c11">&minus;&rarr;</span><span class="c5">sv(t)</span><span class="c4">. This global statistics vector is called the global estimate vector, and it is propagated to all network nodes, e.g., by using a hierarchy, or a broadcasting technique. This es- timate vector is used by each participating node to extract a set of Count-Min sketches, one for each query range. Without loss of generality, assume that we have only a single query range, and </span><span class="c7">&minus;&rarr;se(t) </span><span class="c6">denotes the corresponding extracted Count-Min sketch. </span><span class="c4">After each new arrival at time </span><span class="c5">t</span><span class="c3">&prime;</span><span class="c4">, node </span><span class="c5">p</span><span class="c12">i </span><span class="c4">updates its local statis- tics vector </span><span class="c11">&minus;&rarr;</span><span class="c5">sv</span><span class="c0">i</span><span class="c6">, and checks for a local constraint violation. For this </span><span class="c4">check, </span><span class="c5">p</span><span class="c12">i </span><span class="c4">extracts the statistics delta vector </span><span class="c5">&#8710;</span><span class="c11">&minus;&rarr;</span><span class="c5">sv(t</span><span class="c3">&prime;</span><span class="c5">) </span><span class="c4">from </span><span class="c11">&minus;&rarr;</span><span class="c5">sv</span><span class="c12">i</span><span class="c5">(t</span><span class="c3">&prime;</span><span class="c5">) </span><span class="c4">as a Count-Min sketch, by querying each counter of </span><span class="c11">&minus;&rarr;</span><span class="c5">sv</span><span class="c0">i</span><span class="c7">(t</span><span class="c12">&prime;</span><span class="c7">) </span><span class="c6">for its </span><span class="c4">value within the time range </span><span class="c5">(t, t</span><span class="c3">&prime;</span><span class="c5">]</span><span class="c4">. By summing </span><span class="c5">&#8710;</span><span class="c11">&minus;&rarr;</span><span class="c5">sv(t</span><span class="c3">&prime;</span><span class="c5">) </span><span class="c4">with </span><span class="c11">&minus;&rarr;</span><span class="c5">se(t) </span><span class="c4">the node can compute the drift vector </span><span class="c11">&minus;&rarr;</span><span class="c5">su</span><span class="c0">i</span><span class="c7">(t</span><span class="c12">&prime;</span><span class="c7">)</span><span class="c6">, again as a Count- </span><span class="c4">Min sketch, and construct the sphere of the geometric method. The sphere is formed with a center </span><span class="c5">&kappa; = (</span><span class="c11">&minus;&rarr;</span><span class="c5">se(t)+</span><span class="c11">&minus;&rarr;</span><span class="c5">su</span><span class="c12">i</span><span class="c5">(t</span><span class="c3">&prime;</span><span class="c5">))/2</span><span class="c4">, and radius </span><span class="c5">&alpha; = ||(</span><span class="c11">&minus;&rarr;</span><span class="c5">se(t) &minus; </span><span class="c11">&minus;&rarr;</span><span class="c5">su</span><span class="c0">i</span><span class="c7">(t</span><span class="c12">&prime;</span><span class="c7">))||/2</span><span class="c6">. The geometric method guarantees </span><span class="c4">that if the maximum and minimum value of the function within the sphere are at the same side of the threshold, then there can be no threshold crossing caused by this update. For computing the max- imum and minimum value of the function efficiently, we currently have closed form equations for simple functions, like self-joins. Sharfman et al. [25] propose using numerical analysis algorithms, to compute these extrema, e.g., with Matlab. We are still work- ing on this problem, to achieve efficient analytic solutions for more function types. </span></p><p class="c2"><span class="c16">7. EXPERIMENTAL EVALUATION </span></p><p class="c17"><span class="c4">Our experiments focused on evaluating ECM-sketches with re- spect to their scalability, effectiveness, and efficiency, as well as their suitability for distributed setups. The experiments were con- ducted using two frequently used real-life data sets, the world- cup&rsquo;98 [2] (</span><span class="c27">wc&rsquo;98</span><span class="c4">) and the Crawdad SNMP Fall 03/04 data set [21] (</span><span class="c27">snmp</span><span class="c4">). The wc&rsquo;98 data set consists of all HTTP requests that were directed within a period of 92 days to the web-servers host- ing the official world-cup 1998 website. It contains a total of 1.089 billion valid requests, served by 33 server mirrors. Each request was indexed using the web-page url as a key, i.e., the ECM-sketch could be used for estimating the popularity of each web-page. The snmp data set contains a total of 134 million records collected from the wireless network of Dartmouth college during the fall of 2003/2003. For this data set, we have used the (anonymised) </span></p><p class="c2"><span class="c13">999 </span></p><p class="c17 c44"><span class="c4">MAC addresses of the clients as keys for indexing. Therefore, the ECM-sketch enabled estimating the traffic volume generated by each user. </span></p><p class="c19"><span class="c4">We have compared three sketch variants, differentiating on the employed sliding window algorithm: (a) the default variant de- scribed earlier which is based on exponential histograms, denoted as </span><span class="c27">ECM-EH</span><span class="c4">, (b) a variant using deterministic waves (</span><span class="c27">ECM-DW</span><span class="c4">), and, (c) a variant based on randomized waves (</span><span class="c27">ECM-RW</span><span class="c4">). The comparison between the variants was performed to demonstrate the influence of the sliding window algorithm to the performance of ECM-sketches. </span></p><p class="c72"><span class="c16">7.1 Implementation Details </span></p><p class="c65 c66"><span class="c4">ECM-sketches were implemented in Java 1.7 using 32-bit ad- dressing, and executed on a single idle core of an Intel Xeon 1.6 GHz machine. Deterministic and randomized waves were imple- mented as described in [15], including all optimizations. The queues were implemented as fixed-size deques. The waves were initialized using one event per millisecond as an upper bound for the num- ber of arrivals within the sliding window. In practice, it is rarely possible to predict the maximum number of events per sliding win- dow, and therefore conservative estimates, like this one, are often the only option. Concerning exponential histograms, [12] does not provide sufficient details for the implementation of the list of buck- ets. We therefore considered different possibilities for maintaining the buckets, including fixed arrays, deques, doubly-linked lists, and tree lists, and their combinations. The most efficient implementa- tion was a combination of fixed arrays with deques, which enabled random access to buckets and constant-time bucket merges. Specif- ically, the bucket list was divided to different levels </span><span class="c5">L</span><span class="c12">0</span><span class="c5">,L</span><span class="c12">1</span><span class="c5">,...,L</span><span class="c0">l</span><span class="c6">. </span><span class="c4">Each level </span><span class="c5">L</span><span class="c0">i </span><span class="c6">was initialized as a fixed-length deque, for storing </span><span class="c4">only the buckets of size </span><span class="c5">2</span><span class="c3">i</span><span class="c4">. Furthermore, to save memory, all levels were initially set to null, and initialized on request. The space and computational complexity of our implementation is as described in Section 6, for the random-access model. </span></p><p class="c70 c44"><span class="c4">Unless otherwise noted, all ECM-sketches were set to monitor a sliding window of 1 million seconds (11.5 days). Queries were gen- erated with an exponentially increasing range, i.e., query </span><span class="c5">q</span><span class="c0">i </span><span class="c6">covered </span><span class="c4">the range </span><span class="c5">[t&minus;10</span><span class="c3">i</span><span class="c5">,t]</span><span class="c4">, with </span><span class="c5">t </span><span class="c4">denoting the time of the last arrival. For each range, a self-join query, as well as a set of point queries were constructed and executed. For thorough evaluation, we constructed one point query for each distinct item in the query range (i.e., es- timating the popularity of each web-page in the wc&rsquo;98 dataset, or the number of snmp messages generated by each MAC address in the snmp dataset). </span></p><p class="c75"><span class="c16">7.2 Centralized Setup </span></p><p class="c36"><span class="c4">In the centralized scenario, a single node monitors the whole stream and maintains an ECM-sketch, which is subsequently used for answering the queries. We first consider the tradeoff between memory requirements and estimation error. For this, we vary </span><span class="c5">&#491; </span><span class="c4">within the range of </span><span class="c5">[0.05,0.25]</span><span class="c4">, keeping </span><span class="c5">&delta; = 0.1</span><span class="c4">. For each </span><span class="c5">&#491; </span><span class="c4">value, we use the analysis presented in Section 4 to configure the ECM- sketch such that the required memory for the targeted query type is minimized &ndash; hence the difference in the cost of point queries and self-join queries for the same </span><span class="c5">&#491; </span><span class="c4">values. </span></p><p class="c19"><span class="c4">Figures 4(a)-(d) plot the average and maximum observed error in correlation to the required memory for the two data sets. The figures are annotated with indicative </span><span class="c5">&#491; </span><span class="c4">values. The displayed error at the Y axis is relative to the number of events arriving within the query range, i.e., for point queries, err </span><span class="c5">= | </span><span class="c11">&circ;</span><span class="c5">f(x, r)&minus;f(x, r)|/||a</span><span class="c12">r</span><span class="c5">||</span><span class="c12">1 </span><span class="c4">and for self-joins, err </span><span class="c5">= | &#770;a</span><span class="c12">r </span><span class="c5">&#8857; a</span><span class="c12">r </span><span class="c5">&minus; a</span><span class="c12">r </span><span class="c5">&#8857; a</span><span class="c12">r</span><span class="c5">|/(||a</span><span class="c12">r</span><span class="c5">||</span><span class="c12">1</span><span class="c5">)</span><span class="c3">2</span><span class="c4">. Recall that the ECM-RW structure does not allow probabilistic guarantees </span></p><p class="c17 c78"><span class="c4">for self-join queries, and is therefore not considered for this type of queries. Table 3 presents sample update rates for the considered variants, for </span><span class="c5">&#491; = 0.1</span><span class="c4">. </span></p><p class="c55"><span class="c4">Our first observation is that, for all variants, both the average and maximum observed errors are lower than the user-selected value </span><span class="c5">&#491;</span><span class="c4">. However, the memory requirements of ECM-RW are at least an or- der of magnitude higher than the requirements of ECM-sketches based on the two deterministic structures for offering the same ac- curacy guarantees. As an example, for the wc&rsquo;98 experiment with a moderate value of </span><span class="c5">&#491; = 0.1</span><span class="c4">, the cost of maintaining the ECM-RW sketch is already 400 Mbytes, whereas the ECM-sketches based on exponential histograms and deterministic waves require less than a megabyte for satisfying the same guarantees (the simulation of ECM-RW configured with </span><span class="c5">&#491; = 0.05 </span><span class="c4">could not be completed due to insufficient main memory). This happens because the memory requirements of randomized waves grow quadratically with </span><span class="c5">1/&#491;</span><span class="c4">, whereas the two deterministic sliding window algorithms scale lin- early. Note that this negative result applies to all known random- ized sliding window algorithms, e.g., [27, 11], since they all scale quadratically with </span><span class="c5">1/&#491;</span><span class="c4">. As such, ECM-sketches based on determin- istic structures are more applicable for scenarios with non-specia- lized hardware, or hardware with less memory, like sensor net- works and network devices. Comparing the two deterministic meth- ods, we see that ECM-EH sketches are faster and more compact, requiring approximately half the space compared to the ones based on deterministic waves. All results are consistent for both data sets. Summarizing, these results demonstrate that ECM-EH sketches are more efficient and compact compared to the other two variants, and that ECM-RW sketches require at least an order of magnitude more memory to satisfy the accuracy guarantees compared to the two variants based on deterministic sliding window structures. </span></p><p class="c73"><span class="c16">7.3 Distributed Setup </span></p><p class="c54"><span class="c4">The second series of experiments focused on evaluating the ap- plicability of ECM-sketches for distributed setups. For this, we conducted simulations of distributed networks using the real-world distributions obtained from the two data sets. In particular, wc&rsquo;98 contains the server identification for each of the 33 official world- cup servers answering the HTTP requests, whereas the records in the snmp data set contain the identification for each of the 535 mon- itored APs. For our simulations, these servers were organized in an architecture resembling a balanced binary tree of height </span><span class="c5">&lceil;log</span><span class="c0">2</span><span class="c5">(n)&rceil;</span><span class="c4">, where </span><span class="c5">n </span><span class="c4">is the number of servers. All servers resided at the leaf nodes of the tree. Some of these servers were also randomly cho- sen to occupy the internal tree nodes, responsible for aggregation of the ECM-sketches coming from the children nodes. At the end of the aggregation process, the root node of the hierarchy was holding a single ECM-sketch, representing the order-preserving aggrega- tion of the </span><span class="c5">n </span><span class="c4">streams generated in </span><span class="c5">&lceil;log</span><span class="c0">2</span><span class="c5">(n)&rceil; &minus; 1 </span><span class="c4">steps. ECM-DW sketches are not considered in this set of experiments, since they do not offer any advantages compared to ECM-EH sketches. </span></p><p class="c33"><span class="c4">Figures 5(a)-(b) plot the average observed error for point and self-join queries in correlation to the network requirements for the whole aggregation to be completed. The results correspond to </span><span class="c5">&#491; &isin; [0.05,0.25] </span><span class="c4">and </span><span class="c5">&delta; = 0.1</span><span class="c4">. Note that the simulation with ECM-RW sketches did not complete for all </span><span class="c5">&#491; </span><span class="c4">values, due to insuffi- cient memory resources at the machine simulating the </span><span class="c5">n </span><span class="c4">nodes. To illustrate the accuracy loss due to this aggregation, Table 4 presents a comparison between the observed error of the centralized and the distributed ECM-sketches. </span></p><p class="c78 c79"><span class="c4">As expected, the process of iterative aggregations causes an in- crease of the observed error for ECM-EH sketches. This error how- ever is still substantially lower than the upper bound derived by </span></p><p class="c62"><span class="c13">1000 </span></p><p class="c2"><span class="c50">Self-join Point queries: </span><span class="c49">EH: DW: RW: </span><span class="c50">queries: </span><span class="c49">EH: DW: </span><span class="c4">Figure 4: Average and maximum observed error in correlation to memory requirements for a centralized setup: (a)-(b) wc&rsquo;98 data set, (c)-(d) snmp data set. The plots are annotated with indicative </span><span class="c5">&#491; </span><span class="c4">values. </span></p><p class="c2"><span class="c26">ECM-EH ECM-DW ECM-RW wc&rsquo;98 1486314 1167704 177149 snmp 736595 667036 105825 </span></p><p class="c2"><span class="c4">Table 3: Update rate (updates per sec- ond) for the centralized setup (</span><span class="c5">&#491; = 0.1</span><span class="c4">). </span></p><p class="c2"><span class="c26">Point queries ECM-EH Self join ECM-EH Point queries ECM-RW </span><span class="c21">&#491; </span><span class="c26">Data set Centr.:Distr. Ratio Centr.:Distr. Ratio Centr.:Distr. Ratio 0.1 wc&rsquo;98 0.012:0.015 1.234 0.012:0.015 1.231 0.007:N/A N/A 0.2 wc&rsquo;98 0.027:0.031 1.164 0.026:0.029 1.131 0.016:0.016 1.008 0.1 snmp 0.011:0.011 1.042 0.010:0.011 1.021 0.006:0.006 1.031 0.2 snmp 0.025:0.026 1.037 0.025:0.025 1.016 0.014:0.014 0.986 </span></p><p class="c2"><span class="c4">Table 4: Observed error &ndash; loss is due to the iterative aggregation. </span></p><p class="c2"><span class="c32">0.05 0.00 </span></p><p class="c2"><span class="c58">1 10 100 1000 10000 </span></p><p class="c2"><span class="c32">0.05 </span><span class="c51">&epsilon;</span><span class="c32">=0.25 </span></p><p class="c2"><span class="c71">r orred evresb</span><span class="c32">O0.04 0.03 </span></p><p class="c2"><span class="c51">&epsilon;</span><span class="c32">=0.25 </span></p><p class="c2"><span class="c51">&epsilon;</span><span class="c32">=0.25 </span></p><p class="c2"><span class="c71">r orred evresb</span><span class="c32">O0.04 </span></p><p class="c2"><span class="c51">&epsilon;</span><span class="c32">=0.25 </span></p><p class="c2"><span class="c51">&epsilon;</span><span class="c32">=0.25 </span></p><p class="c2"><span class="c51">&epsilon;</span><span class="c32">=0.05 </span></p><p class="c2"><span class="c51">&epsilon;</span><span class="c32">=0.05 </span></p><p class="c29"><span class="c51">&epsilon;</span><span class="c32">=0.05 </span><span class="c58">1 10 100 1000 10000 </span><span class="c32">Transfer volume (Mbytes) </span></p><p class="c2"><span class="c32">0.03 </span></p><p class="c2"><span class="c32">0.02 </span></p><p class="c2"><span class="c32">0.02 </span></p><p class="c2"><span class="c32">0.01 </span></p><p class="c2"><span class="c51">&epsilon;</span><span class="c32">=0.15 </span></p><p class="c2"><span class="c32">0.01 </span></p><p class="c2"><span class="c32">0.00 </span></p><p class="c2"><span class="c32">Transfer volume (Mbytes) </span></p><p class="c2"><span class="c77">Self-join queries: Point queries: </span><span class="c69">EH: RW: EH: </span><span class="c4">Figure 5: Observed error in correlation to the network cost, for varying </span><span class="c5">&#491;</span><span class="c4">: (a) wc&rsquo;98 data set, (b) snmp data set. </span></p><p class="c17"><span class="c4">the analysis. For example, for the case of the wc&rsquo;98 data set with </span><span class="c5">&#491; = 0.1</span><span class="c4">, the error bound is 0.3, whereas the average observed er- ror after aggregation is less than 0.015, i.e., the increase due to the aggregation is less than 1/4 of the experimentally derived error of the centralized sketch. Concerning ECM-RW sketches, there is no systemic variation of the error, since randomized waves enable a lossless aggregation at the expense of a larger memory footprint. However, the network required for performing this aggregation us- ing ECM-RW is higher by at least an order of magnitude compared to the transfer volume for the variant with exponential histograms. This requirement is prohibitive for a large set of application sce- narios, like sensor and mobile networks, where high network usage causes battery drainage. </span></p><p class="c29"><span class="c4">To further explore the influence of the network size on the esti- mation accuracy and network cost, we have also simulated an arti- ficial network of </span><span class="c5">i </span><span class="c4">servers, with </span><span class="c5">i = {1,2,4,...,256}</span><span class="c4">. The nodes were again placed as leaf nodes on a balanced binary tree, and the requests were divided uniformly across them. Figure 6(a) and (c) plot the average observed error in correlation to the network size, for </span><span class="c5">&#491; = &delta; = 0.1</span><span class="c4">. As expected, for ECM-EH sketches, increasing the number of nodes leads to a small increase on the observed esti- mation error. On the other hand, the aggregation process does not affect the accuracy of ECM-RW sketches, due to the lossless aggre- gation of randomized waves. However, the network cost for aggre- gating the sketches based on randomized waves (Figure 6(b) and (d)) is at least an order of magnitude higher compared to ECM-EH. This limits the applicability of ECM-sketches based on randomized waves to cases where a fast, fixed network is available, and makes the ability to merge deterministic sliding windows, e.g., based on exponential histograms, a very important contribution of this work. Summarizing, this set of experiments showed that ECM-sketches based on exponential histograms can be aggregated with very small information loss. Compared to the lossless aggregation of ECM- </span></p><p class="c2"><span class="c15">0.05 </span><span class="c1">0.01 0.1 1 10 100 1000 </span></p><p class="c2"><span class="c15">0.07 </span><span class="c1">0.01 0.1 1 10 100 1000 </span></p><p class="c2"><span class="c15">0.05 </span><span class="c1">0.01 0.1 1 10 100 1000 10000 </span><span class="c15">0.08 </span><span class="c35">r orre</span><span class="c92">&epsilon;</span><span class="c35">=0.25 m umixamd evresb</span><span class="c15">O</span><span class="c8">&epsilon;</span><span class="c15">=0.25 0.04 </span></p><p class="c2"><span class="c8">&epsilon;</span><span class="c15">=0.250.06 </span></p><p class="c2"><span class="c8">&epsilon;</span><span class="c15">=0.25 </span></p><p class="c2"><span class="c15">0.04 </span></p><p class="c2"><span class="c35">r orre</span><span class="c8">&epsilon;</span><span class="c15">=0.25</span><span class="c8">&epsilon;</span><span class="c15">=0.1 </span></p><p class="c2"><span class="c81">&epsilon;</span><span class="c1">=0.05 </span></p><p class="c2"><span class="c8">&epsilon;</span><span class="c15">=0.05 </span></p><p class="c2"><span class="c8">&epsilon;</span><span class="c15">=0.05 </span></p><p class="c2"><span class="c1">0.01 0.1 1 10 100 1000 10000 </span><span class="c15">Memory (Mbytes) </span></p><p class="c2"><span class="c15">0.07 </span></p><p class="c2"><span class="c8">&epsilon;</span><span class="c15">=0.25 </span></p><p class="c2"><span class="c35">r orred evresb</span><span class="c15">O0.03 </span></p><p class="c2"><span class="c15">0.05 </span></p><p class="c2"><span class="c15">0.04 </span></p><p class="c29"><span class="c35">r orred evresb</span><span class="c15">O0.03 </span><span class="c8">&epsilon;</span><span class="c15">=0.25 </span></p><p class="c2"><span class="c8">&epsilon;</span><span class="c15">=0.1 </span></p><p class="c2"><span class="c35">m umixamd evresb</span><span class="c15">O0.06 0.05 </span></p><p class="c2"><span class="c8">&epsilon;</span><span class="c15">=0.25 </span></p><p class="c2"><span class="c8">&epsilon;</span><span class="c15">=0.05 </span></p><p class="c2"><span class="c8">&epsilon;</span><span class="c15">=0.05 </span></p><p class="c2"><span class="c15">0.00 </span></p><p class="c2"><span class="c15">0.00 </span></p><p class="c2"><span class="c15">Memory (Mbytes) </span></p><p class="c2"><span class="c15">Memory (Mbytes) </span></p><p class="c29"><span class="c15">Memory (Mbytes) 0.04 0.02 </span></p><p class="c2"><span class="c15">0.03 </span></p><p class="c2"><span class="c15">0.02 </span></p><p class="c2"><span class="c8">&epsilon;</span><span class="c15">=0.25 </span></p><p class="c2"><span class="c15">0.03 </span></p><p class="c2"><span class="c15">0.01 </span></p><p class="c2"><span class="c15">0.02 </span></p><p class="c2"><span class="c15">0.01 </span></p><p class="c2"><span class="c15">0.01 </span></p><p class="c2"><span class="c15">0.02 </span></p><p class="c2"><span class="c8">&epsilon;</span><span class="c15">=0.05 </span></p><p class="c2"><span class="c15">0.01 </span></p><p class="c2"><span class="c15">0.00 </span></p><p class="c2"><span class="c15">0.00 </span></p><p class="c17"><span class="c4">sketches based on randomized waves, the sketches based on expo- nential histograms are substantially more compact, and are there- fore applicable for a wider range of application scenarios, where network cost and memory is of the essence, such as P2P networks, sensor networks, and communication between network routers. </span></p><p class="c2"><span class="c16">8. CONCLUSIONS </span></p><p class="c17"><span class="c4">In this work we considered the problem of answering complex queries over distributed and high dimensional data streams, in the sliding window model. Our proposal, ECM-sketches, is a com- pact structure combining the state-of-the-art sketching technique for data stream summarization with deterministic sliding window synopses. The structure provides probabilistic accuracy guaran- tees for the quality of the estimation, for point queries and self-join queries, and can enable a broad range of problems, such as finding heavy hitters, computing quantiles, and answering range queries over sliding windows. </span></p><p class="c17"><span class="c4">Focusing on distributed applications, we also showed how a set of ECM-sketches, each one representing an individual stream, can be aggregated to generate a single ECM-sketch that summarizes the stream produced by the order-sensitive aggregation of all indi- vidual streams. Interestingly, this is the first result in the literature enabling such aggregation for sketches that use deterministic slid- ing window synopses, and it is of high importance since determin- istic synopses are generally a factor of </span><span class="c5">O(1/&#491;) </span><span class="c4">more compact than the best-known randomized synopsis for delivering an </span><span class="c5">&#491;</span><span class="c4">-accurate approximation. In the same context, we demonstrated how ECM- sketches can be exploited for detecting frequent items, as well as within the geometric method for answering continuous queries. </span></p><p class="c17"><span class="c4">ECM-sketches were thoroughly evaluated with a set of extensive experiments, using two large real-world datasets, and considering both centralized and distributed setups. The results verified the high performance of the structure. Compared to structures based on randomized sliding window synopses, ECM-sketches improve the memory and computational complexity by at least one order of magnitude. The same magnitude of improvement is observed with respect to the network requirements. </span></p><p class="c2"><span class="c4">Our future work includes further investigation on employing ECM-sketches for the geometric method, for handling additional types of continuous queries over distributed sliding window streams. Acknowledgments. This work was supported by the European </span><span class="c6">Commission under ICT-FP7- LIFT-255951 (Local Inference in Massively Distributed Systems). </span></p><p class="c2"><span class="c13">1001 </span></p><p class="c2"><span class="c53">Self-join Point queries: </span><span class="c21">EH: RW: </span><span class="c53">queries: </span><span class="c21">EH: </span><span class="c4">Figure 6: Observed error and network cost for different network sizes: (a)-(b) wc&rsquo;98, (c)-(d) snmp. </span><span class="c16">9. REFERENCES </span></p><p class="c2"><span class="c9">[1] N. Alon, Y. Matias, and M. Szegedy. The space complexity of </span></p><p class="c2"><span class="c9">approximating the frequency moments. </span><span class="c46">J. Comput. Syst. Sci.</span><span class="c9">, 58(1):137&ndash;147, 1999. [2] M. Arlitt and T. Jin. A workload characterization study of the 1998 </span></p><p class="c30"><span class="c9">world cup web site. </span><span class="c46">Network</span><span class="c9">, 14(3):30 &ndash;37, 2000. [3] C. Busch and S. Tirthapura. A deterministic algorithm for </span></p><p class="c2"><span class="c9">summarizing asynchronous streams over a sliding window. In </span><span class="c46">STACS</span><span class="c9">, pages 465&ndash;476, 2007. [4] H.-L. Chan, T.-W. Lam, L.-K. Lee, and H.-F. Ting. Continuous </span></p><p class="c2"><span class="c9">monitoring of distributed data streams over a time-based sliding window. </span><span class="c46">Algorithmica</span><span class="c9">, 62(3-4):1088&ndash;1111, 2012. [5] M. Charikar, K. Chen, and M. Farach-Colton. Finding frequent items </span></p><p class="c2"><span class="c9">in data streams. In </span><span class="c46">ICALP</span><span class="c9">, pages 693&ndash;703, 2002. [6] E. Cohen and M. J. Strauss. Maintaining time-decaying stream </span></p><p class="c2"><span class="c9">aggregates. </span><span class="c46">J. Algorithms</span><span class="c9">, 59(1):19&ndash;36, 2006. [7] G. Cormode and M. Garofalakis. Approximate continuous querying </span></p><p class="c2"><span class="c9">over distributed streams. </span><span class="c46">ACM Trans. Database Syst.</span><span class="c9">, 33(2), 2008. [8] G. Cormode, M. Garofalakis, S. Muthukrishnan, and R. Rastogi. </span></p><p class="c30"><span class="c9">Holistic aggregates in a networked world: Distributed tracking of approximate quantiles. In </span><span class="c46">SIGMOD</span><span class="c9">, pages 25&ndash;36, 2005. [9] G. Cormode and S. Muthukrishnan. What&rsquo;s hot and what&rsquo;s not: </span></p><p class="c2"><span class="c9">Tracking most frequent items dynamically. In </span><span class="c46">PODS</span><span class="c9">, pages 296&ndash;306, 2003. [10] G. Cormode and S. Muthukrishnan. An improved data stream </span></p><p class="c2"><span class="c9">summary: the count-min sketch and its applications. </span><span class="c46">J. Algorithms</span><span class="c9">, 55(1):58&ndash;75, 2005. [11] G. Cormode, S. Tirthapura, and B. Xu. Time-decaying sketches for </span></p><p class="c2"><span class="c9">robust aggregation of sensor data. </span><span class="c46">SIAM J. Comput.</span><span class="c9">, 39(4):1309&ndash;1339, 2009. [12] M. Datar, A. Gionis, P. Indyk, and R. Motwani. Maintaining stream </span></p><p class="c2"><span class="c9">statistics over sliding windows. </span><span class="c46">SIAM J. Comput.</span><span class="c9">, 31(6):1794&ndash;1813, 2002. [13] X. A. Dimitropoulos, M. P. Stoecklin, P. Hurley, and A. Kind. The </span></p><p class="c2"><span class="c9">eternal sunshine of the sketch data structure. </span><span class="c46">Computer Networks</span><span class="c9">, 52(17):3248&ndash;3257, 2008. [14] P. B. Gibbons. Distinct sampling for highly-accurate answers to </span></p><p class="c2"><span class="c9">distinct values queries and event reports. In </span><span class="c46">VLDB</span><span class="c9">, pages 541&ndash;550, 2001. [15] P. B. Gibbons and S. Tirthapura. Distributed streams algorithms for </span></p><p class="c2"><span class="c9">sliding windows. In </span><span class="c46">SPAA</span><span class="c9">, pages 63&ndash;72, 2002. [16] M. B. Greenwald and S. Khanna. Space-efficient online computation </span></p><p class="c30"><span class="c9">of quantile summaries. In </span><span class="c46">SIGMOD</span><span class="c9">, pages 58&ndash;66, 2001. [17] L. Huang, M. Garofalakis, A. Joseph, and N. Taft. Communication </span></p><p class="c2"><span class="c9">efficient tracking of distributed cumulative triggers. In </span><span class="c46">ICDCS</span><span class="c9">, 2007. [18] L. Huang, X. Nguyen, M. Garofalakis, J. Hellerstein, M. Jordan, </span></p><p class="c30"><span class="c9">A. Joseph, and N. Taft. Communication-efficient online detection of network-wide anomalies. In </span><span class="c46">INFOCOM</span><span class="c9">, pages 134&ndash;142, 2007. [19] R. Y. S. Hung and H.-F. Ting. Finding heavy hitters over the sliding </span></p><p class="c29"><span class="c9">window of a weighted data stream. In </span><span class="c46">LATIN</span><span class="c9">, pages 699&ndash;710, 2008. [20] A. Jain, J. M. Hellerstein, S. Ratnasamy, and D. Wetherall. A wakeup call for internet monitoring systems: The case for distributed triggers. In </span><span class="c46">SIGCOMM Workshop on Hot Topics in Networks (HotNets)</span><span class="c9">, 2004. [21] D. Kotz, T. Henderson, I. Abyzov, and J. Yeo. CRAWDAD trace set </span></p><p class="c2"><span class="c9">dartmouth/campus/snmp (v. 2004-11-09). http://crawdad.cs.dartmouth.edu/dartmouth/campus/snmp. [22] J. Mirkovic, G. Prier, and P. L. Reiher. Attacking DDoS at the source. </span></p><p class="c2"><span class="c9">In </span><span class="c46">ICNP</span><span class="c9">, pages 312&ndash;321, 2002. </span></p><p class="c2"><span class="c9">[23] C. Olston, J. Jiang, and J. Widom. Adaptive filters for continuous </span></p><p class="c2"><span class="c9">queries over distributed data streams. In </span><span class="c46">SIGMOD</span><span class="c9">, pages 563&ndash;574, 2003. [24] L. Qiao, D. Agrawal, and A. El Abbadi. Supporting sliding window queries for continuous data streams. In </span><span class="c46">SSDBM</span><span class="c9">, pages 85&ndash;96, 2003. [25] I. Sharfman, A. Schuster, and D. Keren. A geometric approach to </span></p><p class="c2"><span class="c9">monitoring threshold functions over distributed data streams. In </span><span class="c46">SIGMOD</span><span class="c9">, pages 301&ndash;312, 2006. [26] S. Tirthapura, B. Xu, and C. Busch. Sketching asynchronous streams </span></p><p class="c30"><span class="c9">over a sliding window. In </span><span class="c46">PODC</span><span class="c9">, pages 82&ndash;91, 2006. [27] B. Xu, S. Tirthapura, and C. Busch. Sketching asynchronous data </span></p><p class="c2"><span class="c9">streams over sliding windows. </span><span class="c46">Distributed Computing</span><span class="c9">, 20(5):359&ndash;374, 2008. </span></p><p class="c2"><span class="c16">APPENDIX </span></p><p class="c17"><span class="c4">P</span><span class="c25">ROOF OF </span><span class="c4">T</span><span class="c25">HEOREM </span><span class="c4">2. We consider the estimation derived by any single row </span><span class="c5">j </span><span class="c4">of the ECM-sketch. We first check the case of </span><span class="c5">E(( a</span><span class="c11">&#770;</span><span class="c0">r </span><span class="c7">&#8857; b</span><span class="c0">r</span><span class="c7">)</span><span class="c0">j</span><span class="c7">) &gt; a</span><span class="c0">r </span><span class="c7">&#8857; b</span><span class="c0">r</span><span class="c6">: </span></p><p class="c2"><span class="c5">E(( a</span><span class="c11">&#770;</span><span class="c0">r </span><span class="c7">&#8857; b</span><span class="c0">r</span><span class="c7">)</span><span class="c0">j </span><span class="c7">&minus; a</span><span class="c0">r </span><span class="c7">&#8857; b</span><span class="c0">r</span><span class="c7">) = </span><span class="c5">&sum;</span><span class="c0">x&isin;D </span></p><p class="c2"><span class="c7">f</span><span class="c5">&circ;</span><span class="c0">a</span><span class="c7">(x, r) f</span><span class="c5">&circ;</span><span class="c0">b</span><span class="c7">(x, r)+ </span></p><p class="c2"><span class="c5">&sum; </span></p><p class="c30"><span class="c12">p,q&isin;D,p =q h</span><span class="c22">j</span><span class="c12">(p)=h</span><span class="c22">j</span><span class="c12">(q) </span></p><p class="c2"><span class="c7">f</span><span class="c5">&circ;</span><span class="c0">a</span><span class="c7">(p, r) f</span><span class="c5">&circ;</span><span class="c0">b</span><span class="c7">(q, r) &minus; </span><span class="c5">&sum;</span><span class="c0">x&isin;D </span></p><p class="c2"><span class="c5">f</span><span class="c0">a</span><span class="c7">(x, r)f</span><span class="c0">b</span><span class="c7">(x, r) </span></p><p class="c2"><span class="c5">&le; </span><span class="c11">&sum;</span><span class="c12">x&isin;D </span></p><p class="c2"><span class="c5">f</span><span class="c0">a</span><span class="c7">(x, r)f</span><span class="c0">b</span><span class="c7">(x, r)(1 + &#491;</span><span class="c0">sw</span><span class="c7">)</span><span class="c12">2</span><span class="c7">+ </span></p><p class="c30"><span class="c5">&sum; </span><span class="c11">f</span><span class="c3">a</span><span class="c11">(p, r)f</span><span class="c12">b</span><span class="c5">(q, r)(1 + &#491;</span><span class="c12">sw</span><span class="c5">)</span><span class="c3">2 </span><span class="c5">&minus; </span><span class="c11">&sum;</span><span class="c12">p,q&isin;D,p =q x&isin;D h</span><span class="c22">j</span><span class="c12">(p)=h</span><span class="c22">j</span><span class="c12">(q)</span><span class="c5">f</span><span class="c12">a</span><span class="c5">(x, r)f</span><span class="c0">b</span><span class="c7">(x, r) = </span><span class="c5">(&#491;</span><span class="c3">2</span><span class="c12">sw </span><span class="c11">+ 2&#491;</span><span class="c12">sw</span><span class="c5">)a</span><span class="c0">r </span><span class="c7">&#8857; b</span><span class="c0">r </span><span class="c7">+ </span><span class="c5">&sum; </span></p><p class="c2"><span class="c5">f</span><span class="c0">a</span><span class="c7">(p, r)f</span><span class="c0">b</span><span class="c7">(q, r)(1 + &#491;</span><span class="c0">sw</span><span class="c7">)</span><span class="c12">2 </span><span class="c6">(1) </span><span class="c12">p,q&isin;D,p =q </span><span class="c4">From [10], we know that </span><span class="c12">h</span><span class="c22">j</span><span class="c12">(p)=h</span><span class="c5">E(</span><span class="c11">&sum; </span></p><p class="c2"><span class="c22">j</span><span class="c12">(q) </span></p><p class="c29"><span class="c12">p,q&isin;D,p =q h</span><span class="c22">j</span><span class="c12">(p)=h</span><span class="c22">j</span><span class="c12">(q) </span><span class="c11">f</span><span class="c12">a</span><span class="c5">(p, r)f</span><span class="c0">b</span><span class="c7">(q, r)) &le; </span><span class="c5">&#491;</span><span class="c0">cm</span><span class="c7">||a</span><span class="c0">r</span><span class="c7">||</span><span class="c5">Pr[&forall;j : </span><span class="c0">1</span><span class="c7">||b</span><span class="c11">&sum; </span></p><p class="c2"><span class="c0">r</span><span class="c7">||</span><span class="c5">f</span><span class="c12">a</span><span class="c5">(p, </span><span class="c0">1</span><span class="c7">/e</span><span class="c6">. Furthermore, </span><span class="c5">r)f</span><span class="c12">b</span><span class="c5">(q, r) &ge; </span><span class="c6">by Markov inequality, </span></p><p class="c2"><span class="c5">&#491;</span><span class="c12">cm</span><span class="c5">||a</span><span class="c12">r</span><span class="c5">||</span><span class="c12">1</span><span class="c5">||b</span><span class="c12">r</span><span class="c5">||</span><span class="c12">1</span><span class="c5">/e] &le; e</span><span class="c3">&minus;d </span><span class="c5">&le; &delta; </span><span class="c12">p,q&isin;D,p =q h</span><span class="c22">j</span><span class="c12">(p)=h</span><span class="c22">j</span><span class="c12">(q) </span><span class="c4">Combining this with Eqn. 1, we get that with probability at least </span><span class="c5">1 &minus; &delta;</span><span class="c4">,</span><span class="c40">a&#770;</span><span class="c10">r </span><span class="c40">&#8857; b</span><span class="c10">r </span><span class="c40">&minus; a</span><span class="c10">r </span><span class="c40">&#8857; b</span><span class="c10">r </span><span class="c40">&le; (&#491;</span><span class="c83">2</span><span class="c10">sw </span><span class="c85">+ 2&#491;</span><span class="c10">sw</span><span class="c40">)a</span><span class="c10">r </span><span class="c40">&#8857; b</span><span class="c10">r </span><span class="c40">+ &#491;</span><span class="c10">cm</span><span class="c40">(1 + &#491;</span><span class="c10">sw</span><span class="c40">)</span><span class="c83">2</span><span class="c40">||a</span><span class="c10">r</span><span class="c40">||</span><span class="c10">1</span><span class="c40">||b</span><span class="c10">r</span><span class="c40">||</span><span class="c10">1 </span></p><p class="c2"><span class="c4">Repeating the analysis for the case of </span><span class="c5">E(( a</span><span class="c11">&#770;</span><span class="c0">r </span><span class="c7">&#8857; b</span><span class="c0">r</span><span class="c7">)</span><span class="c0">j</span><span class="c7">) &lt; a</span><span class="c0">r </span><span class="c7">&#8857; b</span><span class="c0">r </span><span class="c4">we get the following probabilistic guarantees: </span></p><p class="c2"><span class="c5">a</span><span class="c0">r </span><span class="c7">&#8857; b</span><span class="c0">r </span><span class="c7">&minus; a</span><span class="c5">&#770;</span><span class="c0">r </span><span class="c7">&#8857; b</span><span class="c0">r </span><span class="c7">&le; (&#491;</span><span class="c12">2</span><span class="c0">sw </span><span class="c5">+ 2&#491;</span><span class="c0">sw</span><span class="c7">)a</span><span class="c0">r </span><span class="c7">&#8857; b</span><span class="c0">r </span><span class="c4">The bounds follow directly by noticing that </span><span class="c5">a</span><span class="c0">r </span><span class="c7">&#8857; b</span><span class="c0">r </span><span class="c7">&le; ||a</span><span class="c0">r</span><span class="c7">||</span><span class="c0">1</span><span class="c7">||b</span><span class="c0">r</span><span class="c7">||</span><span class="c0">1</span><span class="c6">. </span></p><p class="c2"><span class="c4">P</span><span class="c25">ROOF OF </span><span class="c4">T</span><span class="c25">HEOREM </span><span class="c4">3. By the estimation algorithm we know that there exists at least one row </span><span class="c5">j</span><span class="c4">, for which </span></p><p class="c2"><span class="c13">1002 </span></p><p class="c29"><span class="c15">0.020 </span><span class="c35">r orred evresb</span><span class="c15">O0.016 0.012 </span></p><p class="c2"><span class="c15">0.008 </span></p><p class="c2"><span class="c15">0.004 </span></p><p class="c2"><span class="c1">1 2 4 8 16 32 64 128 256 </span></p><p class="c2"><span class="c15">Number of nodes </span></p><p class="c2"><span class="c15">0 </span><span class="c35">1600 ) setybM(e mulovr efsnar</span><span class="c15">T</span><span class="c35">1400 1200 1000 800 600 400 200 </span><span class="c15">1 2 4 8 16 32 64 128 256 Number of nodes </span></p><p class="c29"><span class="c15">0.020 </span><span class="c35">r orred evresb</span><span class="c15">O0.016 0.012 </span></p><p class="c2"><span class="c15">0.008 </span></p><p class="c2"><span class="c15">0.004 </span></p><p class="c2"><span class="c1">1 2 4 8 16 32 64 128 256 </span></p><p class="c2"><span class="c15">Number of nodes </span></p><p class="c2"><span class="c15">0 </span><span class="c35">500 ) setybM(e mulovr efsnar</span><span class="c15">T</span><span class="c35">400 300 200 100 </span><span class="c15">1 2 4 8 16 32 64 128 256 Number of nodes </span></p><p class="c17"><span class="c5">E(h</span><span class="c0">j</span><span class="c7">(x), j, r) = f(x, </span><span class="c5">&circ;</span><span class="c7">r)</span><span class="c6">. Let us focus now on this row. We ini- </span><span class="c4">tially assume that we have an accurate algorithm to maintain the sliding window counters, i.e., errors are only due to hashing colli- sions. With </span><span class="c5">R(h</span><span class="c0">j</span><span class="c7">(x), j, r) </span><span class="c6">we denote the accurate number of bits </span><span class="c4">that were added in the counter </span><span class="c5">(h</span><span class="c12">j</span><span class="c5">(x),j)</span><span class="c4">, within the query range </span><span class="c5">r</span><span class="c4">. Note that, because of hashing collisions, the value of </span><span class="c5">R(h</span><span class="c0">j</span><span class="c7">(x), j, r) </span><span class="c4">might be greater than the real frequency of </span><span class="c5">x</span><span class="c4">, denoted as </span><span class="c5">f(x, r)</span><span class="c4">. In fact, since the counters are assumed to be accurate, the standard analysis introduced for count-min sketches may be applied. There- fore, </span><span class="c5">Pr[R(h</span><span class="c12">j</span><span class="c5">(x), j, r) &minus; f(x, r) &le; &#491;</span><span class="c12">cm</span><span class="c5">||a</span><span class="c12">r</span><span class="c5">||</span><span class="c12">1</span><span class="c5">] &ge; 1 &minus; &delta;</span><span class="c12">cm </span><span class="c5">&rArr; Pr[R(h</span><span class="c0">j</span><span class="c7">(x), j, r) &le; f(x, r) + &#491;</span><span class="c0">cm</span><span class="c7">||a</span><span class="c0">r</span><span class="c7">||</span><span class="c0">1</span><span class="c7">] &ge; 1 &minus; &delta;</span><span class="c0">cm</span><span class="c6">. </span></p><p class="c2"><span class="c4">However, in practice, the sliding window algorithm may intro- duce errors to the computation of </span><span class="c5">R(h</span><span class="c0">j</span><span class="c7">(x), j, r)</span><span class="c6">. Since all consid- </span><span class="c4">ered algorithms are </span><span class="c5">(&#491;, &delta;)</span><span class="c4">-approximate, we know that their estima- tion</span><span class="c5">E(h</span><span class="c12">j</span><span class="c5">(x), j, r) </span><span class="c4">has the following property: </span><span class="c5">Pr[|E(h</span><span class="c12">j</span><span class="c5">(x), j, r)&minus; R(h</span><span class="c0">j</span><span class="c7">(x), j, r) &le; &#491;</span><span class="c0">sw</span><span class="c7">R(h</span><span class="c0">j</span><span class="c7">(x), j, r)] &ge; 1 &minus; &delta;</span><span class="c0">sw</span><span class="c6">. </span></p><p class="c17"><span class="c4">For the case that </span><span class="c5">E(h</span><span class="c12">j</span><span class="c5">(x), j, r) &gt; R(h</span><span class="c12">j</span><span class="c5">(x), j, r)</span><span class="c4">, we have </span><span class="c5">Pr[E(h</span><span class="c0">j</span><span class="c7">(x), j, r) &le; (1 + &#491;</span><span class="c0">sw</span><span class="c7">)R(h</span><span class="c0">j</span><span class="c7">(x), j, r)] &ge; 1 &minus; &delta;</span><span class="c0">sw</span><span class="c6">. Con- </span><span class="c4">sidering the two results together, we get: </span></p><p class="c2"><span class="c5">Pr[E(h</span><span class="c0">j</span><span class="c7">(x), j, r) &le; (1 + &#491;</span><span class="c0">sw</span><span class="c7">)R(h</span><span class="c0">j</span><span class="c7">(x), j, r)] &ge; 1 &minus; &delta;</span><span class="c0">sw </span><span class="c7">&rArr; </span><span class="c5">Pr[E(h</span><span class="c0">j</span><span class="c7">(x), j, r) &le; (1 + &#491;</span><span class="c0">sw</span><span class="c7">)(f(x, r) + &#491;</span><span class="c0">cm</span><span class="c7">||a</span><span class="c0">r</span><span class="c7">||</span><span class="c0">1</span><span class="c7">)] </span></p><p class="c2"><span class="c5">&ge; 1 &minus; &delta;</span><span class="c0">sw </span><span class="c7">&minus; &delta;</span><span class="c0">cm </span><span class="c7">&rArr; </span><span class="c5">Pr[ f(x, </span><span class="c11">&circ;</span><span class="c5">r) &minus; f(x, r) &le; &#491;</span><span class="c0">sw</span><span class="c7">f(x, r) + &#491;</span><span class="c0">cm</span><span class="c7">||a</span><span class="c0">r</span><span class="c7">||</span><span class="c0">1</span><span class="c7">+ </span></p><p class="c2"><span class="c5">&#491;</span><span class="c0">cm</span><span class="c7">&#491;</span><span class="c0">sw</span><span class="c7">||a</span><span class="c0">r</span><span class="c7">||</span><span class="c0">1</span><span class="c7">] &ge; 1 &minus; &delta; </span></p><p class="c2"><span class="c4">Note that </span><span class="c5">&#491;</span><span class="c0">sw</span><span class="c7">f(x, r) + &#491;</span><span class="c0">cm</span><span class="c7">||a</span><span class="c0">r</span><span class="c7">||</span><span class="c0">1 </span><span class="c7">+ &#491;</span><span class="c0">cm</span><span class="c7">&#491;</span><span class="c0">sw</span><span class="c7">||a</span><span class="c0">r</span><span class="c7">||</span><span class="c0">1 </span><span class="c7">&le; (&#491;</span><span class="c0">sw </span><span class="c7">+ </span><span class="c5">&#491;</span><span class="c0">cm </span><span class="c7">+ &#491;</span><span class="c0">cm</span><span class="c7">&#491;</span><span class="c0">sw</span><span class="c7">)||a</span><span class="c0">r</span><span class="c7">||</span><span class="c0">1</span><span class="c6">. Therefore, </span><span class="c45">Pr[ f(x, </span><span class="c43">&circ;</span><span class="c45">r) &minus; f(x, r) &le; (&#491;</span><span class="c31">sw </span><span class="c45">+ &#491;</span><span class="c31">cm </span><span class="c45">+ &#491;</span><span class="c31">cm</span><span class="c45">&#491;</span><span class="c31">sw</span><span class="c45">)||a</span><span class="c31">r</span><span class="c45">||</span><span class="c31">1</span><span class="c45">] &ge; 1 &minus; &delta; </span><span class="c4">(2) </span></p><p class="c2"><span class="c4">With a similar analysis, the case of </span><span class="c5">E(h</span><span class="c0">j</span><span class="c7">(x), j, r) &lt; </span><span class="c5">R(h</span><span class="c12">j</span><span class="c5">(x), j, r) </span><span class="c4">gives a much tighter constraint: </span></p><p class="c2"><span class="c5">Pr[f(x, r) &minus; f(x, </span><span class="c11">&circ;</span><span class="c5">r) &le; &#491;</span><span class="c12">sw</span><span class="c5">f(x, r)] &ge; 1 &minus; &delta;</span><span class="c12">sw </span><span class="c4">(3) </span></p><p class="c17"><span class="c4">Note that the events considered by equations 2 and 3 are mutu- ally exclusive. The proof is completed by taking the minimum of </span><span class="c5">Pr[f(x, r) &minus; f(x, </span><span class="c11">&circ;</span><span class="c5">r) &le; &#491;</span><span class="c0">sw</span><span class="c7">f(x, r)] </span><span class="c6">and </span><span class="c7">Pr[ f(x, </span><span class="c5">&circ;</span><span class="c7">r) &minus; f(x, r) &le; </span><span class="c5">(&#491;</span><span class="c12">sw </span><span class="c5">+ &#491;</span><span class="c12">cm </span><span class="c5">+ &#491;</span><span class="c12">cm</span><span class="c5">&#491;</span><span class="c12">sw</span><span class="c5">)||a</span><span class="c12">r</span><span class="c5">||</span><span class="c12">1</span><span class="c5">]</span><span class="c4">. </span></p><p class="c29"><span class="c4">P</span><span class="c25">ROOF OF </span><span class="c4">T</span><span class="c25">HEOREM </span><span class="c4">4. We argue that </span><span class="c5">EH</span><span class="c12">&oplus; </span><span class="c4">approximates the ex- ponential histogram of the logical stream, with a maximum relative error of </span><span class="c5">(1 + &#491;)&#491;</span><span class="c3">&prime; </span><span class="c5">+ &#491;</span><span class="c4">, where </span><span class="c5">&#491; </span><span class="c4">is the error parameter of the initial exponential histograms. Consider a query for the last </span><span class="c5">q </span><span class="c4">time units. With </span><span class="c5">s</span><span class="c0">q </span><span class="c7">= t &minus; q </span><span class="c6">we denote the query starting time. Let </span><span class="c7">Q </span><span class="c6">denote </span><span class="c4">the index of the bucket </span><span class="c5">s(EH</span><span class="c4">and estimated </span><span class="c12">&oplus;</span><span class="c3">Q</span><span class="c11">) &le; s</span><span class="c3">q </span><span class="c4">number </span><span class="c11">&le; e(EH</span><span class="c4">of of true </span><span class="c12">&oplus;</span><span class="c5">EH</span><span class="c12">&oplus; </span><span class="c3">Q</span><span class="c11">)</span><span class="c24">. </span><span class="c4">bits </span><span class="c24">With </span><span class="c4">which in </span><span class="c11">i </span><span class="c4">the </span><span class="c24">and </span><span class="c4">contains query </span><span class="c11">&circ;</span><span class="c5">i </span><span class="c4">we range. denote </span><span class="c5">s</span><span class="c12">q </span><span class="c4">in its According the range, accurate i.e., </span></p><p class="c29"><span class="c4">to the in timation the estimation stream may will be algorithm, influenced be</span><span class="c11">&circ;</span><span class="c5">i = 1/2|EH</span><span class="c4">the by estimation two </span><span class="c12">&oplus;</span><span class="c3">Q</span><span class="c11">|+</span><span class="c4">types </span><span class="c11">&sum;</span><span class="c4">for </span><span class="c12">1&le;Y </span><span class="c4">of the approximation </span><span class="c12">&lt;Q </span><span class="c4">number </span><span class="c11">|EH</span><span class="c12">&oplus;</span><span class="c3">Y</span><span class="c4">of </span><span class="c11">|</span><span class="c24">. </span><span class="c4">true bits </span><span class="c24">This es- </span><span class="c4">errors: (a) a possible approximation error of </span><span class="c6">with the query range, denoted as err</span><span class="c0">1</span><span class="c6">, </span><span class="c4">the </span><span class="c6">and, </span><span class="c4">overlap </span><span class="c6">(b) a possible </span><span class="c4">of bucket </span><span class="c6">approxi- </span><span class="c5">EH</span><span class="c12">&oplus; </span><span class="c3">Q</span><span class="c4">mation error of </span><span class="c5">i</span><span class="c4">, denoted as err</span><span class="c12">2</span><span class="c4">, because of the inclusion of data that arrived before </span><span class="c5">s</span><span class="c0">q </span><span class="c6">in buckets </span><span class="c7">Y &le; Q</span><span class="c6">, or data that arrived after </span><span class="c5">s</span><span class="c12">q </span><span class="c4">in buckets </span><span class="c5">Y &gt; Q</span><span class="c4">. Let us now look into these two errors in more details. </span></p><p class="c2"><span class="c4">With respect to err</span><span class="c0">2</span><span class="c6">, recall that the contents of individual buckets </span><span class="c4">are inserted to </span><span class="c5">EH</span><span class="c12">&oplus; </span><span class="c4">using the starting time and the ending time of </span></p><p class="c2"><span class="c5">|EH</span><span class="c12">z</span><span class="c3">b</span><span class="c11">|) &le; &#491;i</span><span class="c12">z </span></p><p class="c2"><span class="c4">The following lemma extends this result to all exponential his- tograms constituting </span><span class="c5">EH</span><span class="c0">&oplus;</span><span class="c6">, for computing the total value of err</span><span class="c0">2</span><span class="c6">: </span></p><p class="c29"><span class="c4">L</span><span class="c25">EMMA </span><span class="c4">2. </span><span class="c27">Consider the exponential histogram </span><span class="c5">EH</span><span class="c0">&oplus;</span><span class="c14">, con- </span><span class="c27">structed by aggregating exponential histograms </span><span class="c5">EH</span><span class="c12">1</span><span class="c27">, </span><span class="c5">EH</span><span class="c0">n</span><span class="c14">. The maximum value of err</span><span class="c0">2 </span><span class="c14">is </span><span class="c7">&#491;i</span><span class="c14">, with </span><span class="c7">i = </span><span class="c27">noting the number of true bits that arrived in all streams </span><span class="c5">&sum;</span><span class="c0">nx=1 </span><span class="c5">EH</span><span class="c12">2</span><span class="c27">, during </span><span class="c5">i</span><span class="c0">x </span><span class="c5">...</span><span class="c27">, </span><span class="c14">de- </span><span class="c27">or after </span><span class="c5">s</span><span class="c0">q</span><span class="c14">. </span></p><p class="c2"><span class="c4">P</span><span class="c25">ROOF</span><span class="c4">. Let err</span><span class="c0">2</span><span class="c7">(x) </span><span class="c6">denote the number </span><span class="c4">stream </span><span class="c5">x </span><span class="c4">with respect to </span><span class="c5">s</span><span class="c12">q</span><span class="c4">. Furthermore, </span><span class="c5">j</span><span class="c12">x </span><span class="c5">s</span><span class="c0">q</span><span class="c7">}</span><span class="c6">.of </span><span class="c5">= </span><span class="c6">out-of-order bits </span><span class="c5">max{b|e(EH</span><span class="c12">x</span><span class="c3">b</span><span class="c11">) </span><span class="c6">of </span><span class="c11">&ge; </span></p><p class="c2"><span class="c6">Notice that err</span><span class="c0">2</span><span class="c7">(x) </span><span class="c6">is upper-bounded </span><span class="c4">aggregation algorithm, err</span><span class="c0">2 </span><span class="c7">= </span><span class="c4">is </span><span class="c5">&#491;</span><span class="c11">&sum;</span><span class="c4">the </span><span class="c12">n</span><span class="c0">x=1 </span><span class="c4">same </span><span class="c5">i</span><span class="c12">x </span><span class="c5">&le; </span><span class="c4">across </span><span class="c5">&#491;i</span><span class="c4">. </span></p><p class="c29"><span class="c4">all EH, we </span><span class="c5">&sum;</span><span class="c4">have: </span><span class="c0">nx=1 </span><span class="c4">errerr</span><span class="c6">by </span><span class="c0">2</span><span class="c7">(x)</span><span class="c6">. </span><span class="c0">2 </span><span class="c6">Lemma </span><span class="c7">= </span><span class="c6">1. Due to the </span><span class="c5">&sum;</span><span class="c6">Observing </span><span class="c0">nx=1 </span><span class="c4">err</span><span class="c0">2</span><span class="c7">(x) </span><span class="c6">that </span><span class="c7">&le; &#491; </span></p><p class="c29"><span class="c4">Underestimation or overestimation of the overlap may also hap- pen because time (err</span><span class="c12">1</span><span class="c4">). of As the shown halving in [12], of the this size process of bucket may </span><span class="c5">EH</span><span class="c4">introduce </span><span class="c12">&oplus; </span><span class="c3">Q</span><span class="c24">during </span><span class="c4">a </span><span class="c24">query </span><span class="c4">max- imum relative error of </span><span class="c5">&#491;r</span><span class="c4">, where </span><span class="c5">r </span><span class="c4">is the sum of the sizes of all buckets in </span><span class="c5">EH</span><span class="c12">&oplus; </span><span class="c4">with an index lower than </span><span class="c5">Q </span><span class="c4">(i.e., with a starting time at least equal to </span><span class="c5">s</span><span class="c0">q</span><span class="c6">). Recall that </span><span class="c7">r </span><span class="c6">may also include bits that ar- </span><span class="c4">rived before </span><span class="c5">s</span><span class="c0">q</span><span class="c6">, which can however be upper bounded by Lemma 2. </span><span class="c4">Therefore, err</span><span class="c0">1 </span><span class="c4">Summing </span><span class="c5">&#491;</span><span class="c3">&prime; </span><span class="c5">+ </span><span class="c4">the maximum underestimation </span><span class="c7">= &#491;</span><span class="c12">&prime;</span><span class="c7">r &le; &#491;</span><span class="c12">&prime;</span><span class="c7">(i + &#491;i) = &#491;</span><span class="c12">&prime;</span><span class="c7">i + &#491;&#491;</span><span class="c12">&prime;</span><span class="c7">i</span><span class="c6">, </span><span class="c5">&#491;&#491;</span><span class="c3">&prime;</span><span class="c5">)</span><span class="c4">. or </span><span class="c6">with </span><span class="c7">i </span><span class="c4">err</span><span class="c12">1 </span><span class="c4">and err</span><span class="c12">2</span><span class="c4">, we get a maximum Theorem 4 follows directly. </span></p><p class="c2"><span class="c4">overestimation </span><span class="c7">= </span><span class="c4">relative </span><span class="c5">&sum;</span><span class="c0">nx=1 </span><span class="c5">i</span><span class="c4">error </span><span class="c0">x</span><span class="c6">. </span></p><p class="c2"><span class="c4">error is </span></p><p class="c2"><span class="c4">of </span><span class="c5">(&#491;+ </span></p><p class="c2"><span class="c13">1003 </span></p><p class="c17"><span class="c4">the buckets. Therefore, it may happen that some bits arrive before </span><span class="c5">s</span><span class="c0">q </span><span class="c6">but are inserted to </span><span class="c7">EH</span><span class="c0">&oplus; </span><span class="c6">with a timestamp after </span><span class="c7">s</span><span class="c0">q</span><span class="c6">, creating </span><span class="c4">&lsquo;false positives&rsquo;. The opposite is also possible. These bits are called out-of-order </span><span class="c6">lead to underestimation </span><span class="c4">bits with respect </span><span class="c6">or overestimation </span><span class="c4">to </span><span class="c5">s</span><span class="c0">q</span><span class="c6">. Clearly, of the out-of-order query answer. bits may The </span><span class="c4">following lemma allows us to upper bound the number of out-of- order bits, and thereby control the maximum error err</span><span class="c12">2</span><span class="c4">. </span></p><p class="c17"><span class="c4">L</span><span class="c25">EMMA </span><span class="c4">1. </span><span class="c27">Consider an (individual) exponential histogram </span><span class="c5">EH</span><span class="c0">z </span><span class="c14">of stream </span><span class="c7">Z</span><span class="c14">, configured with error parameter </span><span class="c7">&#491;</span><span class="c14">. The out- </span><span class="c27">of-order bits with respect to the query starting time </span><span class="c5">s</span><span class="c12">q </span><span class="c27">that </span><span class="c5">EH</span><span class="c12">z </span><span class="c27">can generate are at most </span><span class="c5">&#491;i</span><span class="c0">z</span><span class="c14">, with </span><span class="c7">i</span><span class="c0">z </span><span class="c14">denoting the number of true </span><span class="c27">bits arriving after </span><span class="c5">s</span><span class="c0">q </span><span class="c14">in </span><span class="c7">Z</span><span class="c14">. </span></p><p class="c2"><span class="c4">P</span><span class="c25">ROOF</span><span class="c4">. Due to the non-decreasing nature of bucket timestamps, there can be only one bucket with time greater than or equal to </span><span class="c5">s</span><span class="c0">q</span><span class="c6">. </span><span class="c7">&sum;</span><span class="c12">j&minus;1</span><span class="c0">b=1 </span></p><p class="c2"><span class="c4">a </span><span class="c6">Let </span><span class="c4">start time less </span><span class="c6">this bucket be </span><span class="c4">than </span><span class="c7">EH</span><span class="c0">z</span><span class="c12">j</span><span class="c5">s</span><span class="c4">. </span><span class="c0">q </span><span class="c4">All </span><span class="c6">and </span><span class="c4">other </span><span class="c6">end </span></p><p class="c17"><span class="c4">buckets have both starting and ending time at the same side of </span><span class="c5">s</span><span class="c12">q</span><span class="c4">, and therefore their contents are always inserted with a timestamp at the correct side of </span><span class="c5">s</span><span class="c12">q </span><span class="c4">and Since the ending time of do not </span><span class="c5">EH</span><span class="c12">z </span><span class="c3">j</span><span class="c4">create out-of-order bits. </span></p><p class="c17"><span class="c24">is at or after </span><span class="c11">s</span><span class="c12">q</span><span class="c4">, its most recent true bit has arrived at or after </span><span class="c5">s</span><span class="c0">q</span><span class="c6">, and should be included in the </span><span class="c4">query </span><span class="c5">s</span><span class="c0">q </span><span class="c4">half </span><span class="c6">in </span><span class="c4">of </span><span class="c6">stream </span><span class="c4">range. the bits Therefore, </span><span class="c7">Z </span><span class="c4">of </span><span class="c6">is </span><span class="c5">EH</span><span class="c7">i</span><span class="c0">z </span><span class="c12">z </span><span class="c3">j</span><span class="c7">&ge; </span><span class="c24">are </span><span class="c4">the </span><span class="c7">1 </span><span class="c24">inserted </span><span class="c4">number </span><span class="c7">+ </span><span class="c5">&sum;</span><span class="c0">j&minus;1 </span></p><p class="c2"><span class="c12">b=1 </span><span class="c24">using </span><span class="c4">of </span><span class="c11">|EH</span><span class="c4">true </span><span class="c24">the </span><span class="c12">z</span><span class="c3">b</span><span class="c4">bits </span><span class="c11">|</span><span class="c24">. ending Furthermore, </span><span class="c4">arriving </span><span class="c24">time </span><span class="c4">at </span><span class="c24">and </span><span class="c4">or </span><span class="c24">since </span><span class="c4">after </span></p><p class="c17"><span class="c24">half </span><span class="c4">using the starting time of the bucket, the maximum number of out- of-order bits is </span><span class="c5">|EH</span><span class="c12">z</span><span class="c3">j</span><span class="c11">|/2</span><span class="c24">. By construction (invariant 1): </span></p><p class="c2"><span class="c5">|EH</span><span class="c12">z</span><span class="c3">j</span><span class="c11">| </span></p><p class="c2"><span class="c5">2(1 + </span></p><p class="c2"><span class="c5">|EH</span><span class="c12">z</span><span class="c3">b</span><span class="c11">|) </span></p><p class="c2"><span class="c5">&le; &#491; &rArr; </span><span class="c11">|EH</span><span class="c12">z</span><span class="c3">j</span><span class="c11">| </span></p><p class="c2"><span class="c5">2 </span><span class="c11">&le; &#491;(1+</span><span class="c5">&sum;</span><span class="c3">j&minus;1</span><span class="c0">b=1 </span></p></body></html>